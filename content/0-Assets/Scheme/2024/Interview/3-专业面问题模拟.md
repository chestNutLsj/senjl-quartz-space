---
publish: "true"
tags:
  - Interview
date: 2024-03-01
---
## 基本信息

1. 你的GPA 有点低，为什么？
> 1) 感谢老师的提问，在大学期间没有取得高分的成绩，是我的失职( 虚心承认 )。
> 2) 出现这个问题的原因，主要有三个因素：一方面初入大学时，有些不太适应大学的学习习惯和思维方式，导致大一时绩点比较低；另一方面我在本科时的学习思路是广泛地涉猎计算机应用的各个领域，从前端开发到后端开发，再到网络和机器学习，所以成绩上只是稍有进步；到了后来就是备战考研，对绩点的把握也有些疏忽，最终导致GPA 较低。 (反思问题)
> 3) 如今我已经深深意识到了自己身上所存在的学习问题，通过备战考研期间的学习，我也坚定了我的学习方向，因此如果我有幸被各位导师认可，那么我将全身心地投入到学习和研究中，不辜负老师的期望。( 提出期望 )

2. 你的数学成绩非常低，是学不会吗？
> 1) 数学成绩较低是我的劣势，我在数学考试方面的解题能力确实有些薄弱。
> 2) 但是我在数学方面的学习能力，还是能够满足机器学习中的数学公式推导，以及进一步的计算、解决遇到的问题。并且我会更进一步地深入学习线性代数、概率论等与机器学习息息相关的基础数学，进一步提高自己的数学能力，以满足科研的需要。

3. 你的专业课成绩也不理想，没有过百，为什么？
> 1) 专业课成绩较低的原因主要是在于，去年我了解到清华计算机本科的计算机组成原理、操作系统等课程都转向RISC-V 架构和rCore，因此我花费了大量时间在学习这些新的知识，但是最后考试时一道都没有考。
> 2) 另外一方面是考试时有一些知识记得不太牢固，导致计算时出现错误，丢了几个大分题。但是简答类问题我扣分很少，所以计算机基础知识还是掌握的比较牢固。

## 专业技能知识

1. 能否谈谈你本科专业课程如信息物理系统、应用密码学与物联网安全方面的知识如何应用于未来的研究？
> 信息物理系统是集成传感、计算、通信和控制方面的先进技术，以创建复杂的系统，使人、机器、物体、环境和信息能够动态地高效交互。所以在这个系统中，可以应用人工智能的模型进行更高效、高精度、高适应性地处理，比如对于不同传感器传输的异构数据流，或者可能存在的监听、伪造等恶意数据流，可以使用如随机森林，构建多棵决策树对流量的特征进行提取和学习，最终通过投票机制获取更加准确的结果。
> 
> 应用密码学和物联网安全，也可以与AI 结合。比如
> - 同态加密是一种允许在加密数据上直接进行计算并得到加密结果的技术，计算结果解密后与原始数据进行同样计算的结果相同。在深度学习中，同态加密可以用来保护数据的隐私，使得模型的训练和推断可以在加密数据上进行，从而不暴露敏感信息。

2. PAC 学习、VC-Dimension、非线性特征转换、正则化这四个理论请简要描述你的理解。
> - PAC 学习模型描述了在给定一定数量的样本和一定概率下，一个算法能否在限定错误范围内准确地学习某个函数。如果一个模型是 PAC 可学习的，那么就意味着我们可以以高概率（Probably）保证该模型在未见过的数据上的表现与在训练数据上的表现近似正确（Approximately Correct）。PAC 学习提供了评估学习算法泛化能力的理论基础。
> - VC 维是由 Vapnik 和 Chervonenkis 提出的一个衡量分类模型复杂度的概念。它定义为模型能够完全分隔的最大数据集的大小。直观地说，一个模型的 VC 维越大，意味着它的表示能力越强，但也可能越容易过拟合。VC 维为理解和评估模型的泛化能力提供了数学工具，是 PAC 学习理论的核心组成部分。
> - 非线性特征转换是指将数据从原始特征空间映射到一个新的特征空间，以使得在新空间中，数据的某些性质（如可分性）得到改善。这种转换通常涉及应用一个或多个非线性函数，目的是揭示数据的内在结构，从而提高机器学习模型的性能。非线性特征转换是解决非线性问题的常用手段，特别是在深度学习中，通过多层非线性变换构建复杂的模型来学习数据的高级特征。
> - 正则化是一种用于减少模型过拟合的技术，通过在模型训练的损失函数中加入一个额外的惩罚项来实现。这个惩罚项通常与模型的复杂度相关，比如模型参数的大小（L1 正则化）或参数的平方和（L2 正则化）。通过限制模型的复杂度，正则化有助于提高模型的泛化能力。在实践中，正则化是提升模型性能的关键技术之一，尤其在处理高维数据或小数据集时尤为重要。

3. LogReg、SVM、GBDT 这些模型如何优化？
> - LogReg 通常使用梯度下降（Gradient Descent，GD）或其变体（如随机梯度下降（Stochastic Gradient Descent，SGD）、小批量梯度下降（Mini-batch Gradient Descent））进行优化。优化的目标是最小化对数损失函数（Logistic Loss），该过程涉及计算损失函数相对于模型参数的梯度，并使用这些梯度来更新参数。
> - SVM 的优化目标是最大化分类间隔，通常通过求解一个凸二次规划（Quadratic Programming，QP）问题来实现。对于线性SVM，可以使用梯度下降法或更专门的优化算法，如序列最小优化（Sequential Minimal Optimization，SMO）算法。
> - GBDT 通过迭代添加弱学习器（通常是决策树）来最小化损失函数。每一轮迭代中，都会添加一个新的树，专注于之前所有树预测的残差。GBDT 优化的关键在于使用梯度下降算法在函数空间而不是参数空间上进行迭代，以此来减少模型的损失。
> 	- **迭代式**：GBDT 的优化本质上是迭代过程，每一步都在尝试减少模型在训练集上的损失。
> 	- 围绕如何更有效地构建树和减少残差进行优化，包括学习率的选择、树的深度、剪枝策略等。

5. 能否详细说明在 Transformer 模型方面的研究？
> [[#Transformer]]

6. 你对 LLM 在NLP 领域的影响、应用有什么看法？
> LLM 为NLP 的研究带来许多新的变化：
> - **预训练与微调范式**：LLMs的成功证明了预训练加微调（pre-training and fine-tuning）范式的有效性。通过在大规模数据集上预训练一个通用模型，然后在特定任务上进行微调，可以显著提高多种NLP任务的性能。
> - **零样本和少样本学习**：LLMs展示了在没有或只有少量标注数据情况下进行有效学习的能力，这对于标注数据稀缺的任务尤其有价值。
> - **多模态学习能力**：一些LLMs开始融合文本与图像（如DALL·E）、音频等多种数据类型，推动了多模态学习的发展。
> - **知识获取和推理**：LLMs通过从预训练数据中学习，可以存储大量的世界知识，并在一定程度上进行推理，这为构建知识密集型应用提供了新的可能性。
> 
> 也带来许多挑战：
> - **模型可解释性**：随着LLMs变得越来越复杂，增强模型的可解释性和透明度变得尤为重要，以确保其决策过程可以被理解和信任。
> - **伦理和偏见**：LLMs在处理文本时可能会复制或放大数据中的偏见和不公正现象。因此，研究如何减少这些偏见，并确保模型的公平性和伦理性，是一个紧迫的问题。

7. 你说你对 LLM 的结构有系统性认识，请简要讲解一下。
> ![[LLM-Survey#主流架构]]

8. 你如何理解LLM 的可解释性？
> 对于两种不同的训练范式，有不同的可解释性的理解。
> 1. 对fine-tuning 范式，有局部解释和全局解释，前者专注对LM 在特定问题上预测的理解，后者则是宏观的全局表现情况。
> 	- 在局部解释中，explanation 的作用是澄清模型生成特定分类或标记预测的过程。这一类解释有四个主流方法来生成，即特征归因方法、基于注意力的解释、基于样本的解释和自然语言的解释
> 		- feature attribution methods：旨在测量每个输入特征（例如，单词、短语和文本跨度）与模型预测的相关性。给定由 n 个单词特征{x1，x2，…，xn}组成的输入文本 x，微调的语言模型 f 生成输出 f（x）。归因方法将相关性得分 R（xi）分配给输入词特征 xi 以反映其对模型预测 f（x）的贡献。遵循该策略的方法主要可分为四类：基于扰动的方法、基于梯度的方法、代理模型和基于分解的方法。
> 
>2. 对于prompt 范式

9. LLM 的两种训练范式是什么，分别简要解释一下：
> 1. Fine-Tuning Paradigm
> 	- LM 先在大规模的未标记数据上进行预训练，然后在从特定下游任务中收集的有标签数据集上进行微调
> 	- 可以在LM 的最终encoder 层上添加全连接层简单地实现对特定任务的微调
> 	- 这种范式对中等规模的LM 非常有效，指的是在 1b 参数左右的，比如BERT、RoBERT 等模型
> 	- 这种范式专注两个关键问题：理解自监督的预训练方法是如何使得模型获得对语言的基础理解（如语法、情感、上下文关联等）；以及分析微调过程是如何使得预训练模型能有效解决下游问题的能力
> 
>2. Prompt Paradigm
>	- 提示词范式包含使用自然语言短句让LM 填空、零样本或少样本地学习
>	- 使用提示词范式训练的模型还可以进一步分类：
>		1. 基础模型：通过提示词可以实现极少样本地学习，如GPT-3 等LLM 模型。对这些base model 的解释旨在理解模型如何从预训练中的知识通过提示词响应出来；
>		2. 辅助模型：base model 有两个关键限制，一方面不能跟随用户的指示，这是因为与训练数据很少有“指示-响应”的例子，另一方面它们可能会生成有偏差甚至有害的内容。为了解决这样的问题，base model 需要进一步地在有监督的微调中训练，以实现人类水平的能力，这样的关键是将模型的响应向人类的反馈和偏好进行对齐。这一过程最经典的方法是通过“提示词-指示微调”的解释对、以及从人类反馈中强化学习的算法RHLF。如GPT-3.5 和GPT-4 等LLM。

10. DCTCP 的拥塞控制机制是什么？
> - DCTCP利用ECN作为拥塞的显式信号。在传统的TCP中，拥塞控制主要依赖于丢包作为信号，这种方法在数据中心环境中可能导致不必要的时延和吞吐量下降。ECN允许网络设备在接近拥塞时标记数据包，而不是直接丢弃它们。接收方收到标记的数据包后，通过确认应答（ACK）将拥塞信号反馈给发送方。
> - RED（早期随机检测）队列，通过持续监控队列长度来提前检测网络拥塞的迹象。当队列长度超过某个阈值时，即使网络还未完全拥塞，RED也会开始标记（或丢弃）传入的数据包，以此来减轻未来的拥塞。通过随机选择数据包进行标记，RED避免了同步效应（即多个流同时增减其窗口大小），这有助于网络流量的平滑。
> - DCTCP根据ECN标记的比例来调整窗口大小。如果只有少数包被标记为拥塞，窗口缩小得就少，反之则更多。这种方法允许DCTCP更细致地控制窗口大小，以适应网络条件的变化。
> - **对短流的快速响应**：由于DCTCP对网络拥塞的反应更为细腻，它能够在不引起大量丢包的情况下，迅速适应网络状况的变化，从而减少短流的总体延迟。
> - **高突发容忍度**：通过允许一定程度的网络拥塞而不是立即减少窗口，DCTCP能够更好地应对流量突发，减少不必要的窗口缩减，从而提高网络的吞吐量。
> - **提高长流的带宽利用**：长流可以根据ECN标记逐渐调整其发送速率，以最大化利用可用带宽，同时避免过度拥塞网络。

11. 你对机器学习方法在网络控制和优化中应用的理解是什么？
> SDN引入的控制平面和数据平面的分离，使得控制程序能够在更高层面地掌握网络中的拓扑图形、流量情况等信息，使得更合理地对资源进行分配。这也非常适合机器学习方法的应用，比如
> - 通过有监督或半监督地学习，通过已知的网络状态和预期的输出（如流量分配、路径选择等）来训练模型，使其在遇到新的网络状况时能够预测最优的路由策略。网络流量的变化有强烈的时序特征，因此可以尝试LSTM 来预测网络流量的变化；
> - 通过无监督地聚类学习，可以对网络中的异常行为、流量聚类等进行学习，从而支持网络安全和流量管理；
> - 通过强化学习，最大化累计奖励的策略，SDN 可以通过不断试错来学习最优的路由决策。不过我对强化学习的了解比较薄弱，这个需要在日后的学习中加强。

## 项目经历

1. 你的毕业设计过程中遇到了什么困难？是怎样克服的？
> 在我的毕业设计中，我使用 GBDT 和 CNN 模型创建了一个恶意软件检测器，分别在 EMBER 和 VirusShare 数据集上进行了训练。主要障碍是访问全面的恶意软件数据集以及从 PE 文件中提取特征的技术挑战。通过利用网络安全社区内的资源，我发现了 GBDT 训练的 EMBER 数据集，以及 CNN 构建了一种评估整个 EXE 文件的方法，该方法使用 PyTorch 实现。

2. Transformer 模型如何应用于恶意软件检测？
> 我在学习、了解到Transformer 的自注意力机制在序列学习中的优势后，意识到将Transformer 也应用到恶意软件检测中也值得一试。我在阅读相关论文，如Self-Attention for Dynamic Malware Analysis 后，分析了文章的思路：Nebula 引入自注意力机制，更好地捕捉全局的信息和关联，结合来自动态日志报告的异构信息，比传统的关注程序对API 调用的机器学习模型如CNN、LSTM 等，对恶意活动的检测和分类能力更强。
> 
> Nebula 的可解释性也比过去的大力出奇迹的深层网络更优秀，利用集成梯度和注意力激活等方法，能够突出显示模型关注的关键特征，帮助研究者理解模型的决策过程。

3. NS-3 中不是已经有预先构建好的 DCTCP？你做出了什么改进？
> 主要是对拥塞状态的检测和控制进行改进，例如DCTCP 原论文中提出的状态检测和更新公式，是指数加权移动平均，$\alpha\leftarrow(1-g)\times\alpha+g\times F$ ，其中 $\alpha$ 表示对拥塞状态的监测和更新，$g$ 是加权因子，$F$ 是新的观测值和输入。通过对过去状态和当前观测的加权，实现状态的更新。而我们通过动态地调整权重，以及更合理地对当前状态引入非线性的更新方式，在对即时流量的响应性能上取得了更进一步地改善。

5. 你在微调ChatGLM 的过程中积累了什么经验？
> 由于设备问题，我主要的微调经验是在学习别人的微调方法、经验和教训。比如基于ChatGLM-6B 模型对汽车工业故障模式关系抽取并构建知识图谱的任务，可以采用参数冻结、p-tuning、Lora 方法：
> - 参数冻结，对原始模型部分参数进行冻结操作，仅训练部分参数，以达到在单卡或不进行TP或PP操作，就可以对大模型进行训练
> - p-tuning 方法，对大模型的Embedding加入新的参数，又可以分为prefix-tuning 和prompt-tuning，分别是在每个transformer 层添加参数和输入时添加参数
> - Lora 方法，通过添加低秩约束来近 似每层的更新矩阵，以减少适配下游任务的可训练参数

6. LightGBM 和GBDT 的关系是什么？
> LightGBM（Light Gradient Boosting Machine）是微软开发的一个开源梯度提升框架，引入了两个关键技术来提高计算效率和减少内存消耗，分别是基于梯度的单边采样和互斥特征捆绑。LightGBM支持并行和GPU加速，使其能够处理大规模数据集。
> 
> 而GBDT 是一种广泛使用的机器学习算法，它通过迭代地训练决策树来最小化损失函数，每一棵新的树都在尝试纠正前面所有树的预测残差。GBDT广泛应用于分类和回归任务。y

### Transformer

1. Transformer 模型的主要组成部分是什么？
> **Encoder-Decoder 架构**，其中 Encoder 层采用堆叠的多头自注意层对输入序列进行编码，以生成潜在表示，而 Decoder 层对这些潜在表示进行交叉注意并自回归地生成目标序列。

2. 描述 Transformer 中的自注意力机制如何工作。
> 1. **查询（Query）、键（Key）、值（Value）**：自注意力机制通过这三个组成部分来操作输入。每个输入元素（例如，一个单词或字符的嵌入表示）都被转换成查询、键和值三个向量。这种转换通常通过乘以训练中学习的权重矩阵来实现。  
> 2. **注意力得分计算**：自注意力层计算输入中每一对元素之间的注意力得分，这个得分表示一个元素应该给予另一个元素多少“注意力”。得分通常通过查询向量与键向量的点积来计算，然后通过softmax函数进行归一化，以得到每个元素对其他元素的注意力权重。
> 3. **加权值的求和**：一旦计算出注意力权重，模型就会使用这些权重对值向量进行加权求和，生成每个位置的输出。这确保了输出包含了关注的上下文信息，即使是来自输入序列远处的部分。
> 4. **多头注意力**：在实际应用中，Transformer模型采用多头自注意力机制，即并行执行多组自注意力计算，每组使用不同的权重矩阵。这样做可以让模型在不同的表示子空间捕获信息，从而捕获输入序列的不同方面和特征。最后，这些不同头的输出会被合并并线性变换以产生最终输出。
> 5. **Encoder-Decoder注意力**：在Decoder层，除了多头自注意力，还采用了Encoder-Decoder注意力机制。这里，Decoder的查询向量会与Encoder的输出（作为键和值）进行交互，使得Decoder能够根据Encoder的输出生成目标序列。这种机制使Decoder能够在生成每个新元素时考虑整个输入序列的上下文。
> ![[cnn-rnn-self-attention.svg]]

3. Transformer 模型如何解决长距离依赖问题？
> 1. **自注意力机制**：最核心的是，Transformer ==通过自注意力机制直接计算序列中任意两个位置之间的依赖关系==。不同于传统的序列处理模型（如 RNN 或 LSTM），它不需要逐步遍历序列，而是可以==并行处理所有位置的信息==。这使得模型能够直接“看到”序列中相隔很远的部分，从而有效捕捉长距离依赖。  
> 2. **位置编码**：Transformer模型没有内置的机制来理解序列中的位置信息，因此通过引入位置编码来补充这一点。==位置编码向每个输入元素的表示中添加了关于其位置的信息，确保即使在处理序列的不同部分时，模型也能考虑到元素的顺序==。位置编码可以是基于正弦和余弦函数的固定模式，也可以是可学习的参数。这样，模型就能够利用元素之间的相对或绝对位置信息，从而有助于解决长距离依赖问题。
> 3. **层归一化和残差连接（Add & Norm）**：虽然层归一化和残差连接本身不直接解决长距离依赖问题，但它们对于构建深层模型是非常重要的。残差连接帮助避免了在深层网络中常见的梯度消失或爆炸问题，使得训练深层的 Transformer 模型成为可能。通过保持梯度的稳定，模型可以更好地学习处理长距离依赖的能力。层归一化也有助于加速训练过程并提高模型的稳定性。

4. 在 Transformer 模型中，位置编码的作用是什么？
> - **位置编码的目的**：Transformer模型由于其==自注意力机制的并行处理特性，缺乏对输入序列中元素位置的直接感知能力==。位置编码的引入，旨在补充这种位置信息，使模型能够利用序列中的顺序信息进行有效的学习和推理。
> - **位置编码的实现方式**：位置编码通常通过向每个输入元素的嵌入向量添加额外的位置信息来实现。这可以通过使用一组预定义的正弦和余弦函数生成的向量来完成，其中每个函数的波长在各个维度上按几何级数递增。这种设计允许模型捕捉到不同频率的位置信息，从而可以处理不同长度的序列。此外，也有研究探索了可学习的位置编码，即通过训练过程优化位置编码向量，以更好地适应特定的任务。
> - **绝对位置编码与相对位置编码**：你提到的正弦和余弦函数通常用于生成绝对位置编码，它为序列中的每个位置分配一个唯一的编码。除此之外，还有相对位置编码的概念，它旨在捕捉序列中元素之间的相对距离，而不是它们的绝对位置。相对位置编码对于某些任务可能更为有效，因为它们允许模型更灵活地处理位置关系，特别是在处理具有复杂结构或层次性的语言数据时。
> - **位置编码的作用**：通过注入位置信息，位置编码使得Transformer模型能够理解单词顺序和句子结构，这对于大多数自然语言处理任务至关重要。位置信息的加入使模型不仅能够基于输入元素的内容进行推理，还能考虑到它们在序列中的位置关系，从而提高了处理诸如语言理解和文本生成等任务的能力。

5. Transformer 中的多头注意力机制有什么优势？
> - **提高模型的灵活性和复杂性**：==多头注意力通过对查询（Q）、键（K）和值（V）的多组独立的线性投影，允许模型在不同的表示子空间中学习信息==。这种设计增加了模型的复杂性和灵活性，使得模型能够在多个维度上捕捉序列的特征，从而更好地理解输入数据的多样性。
> - **增强表示能力**：每个注意力头专注于序列的不同特征或模式，例如某些头可能捕捉句法依赖关系，而其他头可能关注词汇共现信息。这种多角度的理解加强了模型对输入序列的全面认识，提高了表示的丰富性和准确性。
> - **并行处理能力**：==多头注意力机制的并行性不仅提高了模型训练和推理的效率，也使得模型能够同时考虑到输入序列的多个方面==。这一特性对于处理复杂的自然语言处理任务尤其重要，因为语言数据通常包含丰富的语义和结构信息。
> - **提高泛化能力**：通过学习输入序列的不同表示，多头注意力机制有助于模型在面对新颖或未见过的数据时表现出更好的泛化能力。这是因为模型不仅依赖于某一种特定的信息或模式，而是能够从多个维度理解输入数据。
> 
> 在回答关于多头注意力机制的优势时，强调这一机制如何通过并行化的方式增加模型的表示能力、灵活性以及对输入数据的全面理解是非常有帮助的。此外，指出这种机制如何促进模型的学习效率和泛化能力，也会使你的回答更加全面和深入。

### 注意力机制

### 6. 什么是注意力机制，它在 NLP 中如何应用？

> 注意力机制的关键要素是Query、Key和Value，通过对环境中的非随意线索和随意线索，结合主体的需求（Query）实现K-V之间的配对，从而引导出最匹配的结果。
> 
> 注意力机制在 NLP 中的应用有这些领域：
> - **机器翻译**：注意力机制最初在NLP领域获得显著成功的应用之一就是机器翻译，特别是在序列到序列（Seq2Seq）模型中。通过对输入序列（源语言）和输出序列（目标语言）之间的依赖关系进行建模，注意力机制可以帮助模型更准确地选择翻译时应关注的词汇，从而提高翻译质量。
> - **文本摘要**：在自动文本摘要任务中，注意力机制允许模型识别原文中最重要的信息片段，然后生成包含这些关键信息的摘要。这种方法可以应用于抽取式摘要（直接从原文挑选句子或短语）和生成式摘要（重新表述原文的关键内容）。
> - **情感分析**：在情感分析任务中，注意力机制能够帮助模型集中于那些情感表达最明显的词汇或短语，从而更准确地判断整体文本的情感倾向，无论是正面、负面还是中性。
> - **问答系统**：注意力机制在问答系统中的应用允许模型集中于与问题最相关的文本段落或句子，从而提取或生成正确的答案。
> - **命名实体识别（NER）**：在命名实体识别任务中，注意力机制可以帮助模型专注于可能表示人名、地点、组织等实体的词汇，提高实体识别的准确率。
> - **语言模型和文本生成**：在生成任务中，如自动写作或对话系统，注意力机制使模型能够基于之前的文本上下文生成连贯且相关的文本，通过专注于特定的上下文信息来增强生成内容的相关性和一致性。

### 7. 注意力机制的三个主要组成部分是什么？

> QKV

### 8. 解释 Scaled Dot-Product Attention 是如何计算的。

> - **计算流程详述**：首先，缩放点积注意力通过计算查询（Query）和键（Key）之间的点积来得到原始的注意力得分。这一步确实需要 Query 和 Key 具有相同的维度。然后，为了控制注意力得分的范围，将这些得分除以键向量维度的平方根（$\sqrt{d_k}$），其中 $d_k$ 是 Key 向量的维度。这一缩放操作有助于防止在计算 softmax 时遇到的梯度消失或爆炸问题。
> - **方差调整的原因**：==点积结果在维度较高时会变得特别大，这会导致 softmax 函数的输出极端化==，即接近 0 或 1，这使得梯度很难在反向传播中有效传递。通过除以 $\sqrt{d_k}$ ，可以缩放得分到一个更合理的范围，使得 softmax 函数的梯度更加平滑。
> - **Softmax 激活**：缩放后的得分通过 softmax 函数进行归一化，得到最终的注意力权重。这一步确保了所有的权重加起来等于 1，从而可以将权重应用到值（Value）上，计算加权和，得到最终的注意力输出。
> - **加权和计算**：最后，将注意力权重应用于值（Value）向量上，通过加权求和得到最终的输出。这一输出综合了根据 Query 与 Key 的相似度分配的权重信息，使得模型能够聚焦于与当前查询最相关的信息。

### 9. 注意力权重是如何学习的？

> 通过反向传播和梯度下降算法优化模型的参数，间接地学习到这些权重。
> - **初始化**：在训练开始时，模型中的所有权重（包括用于生成Query、Key和Value的权重矩阵）通常是随机初始化的。这意味着最初的注意力权重也是随机的，模型在开始训练时并不知道哪些输入部分是重要的。
> - **前向传播**：在模型的前向传播阶段，根据当前的权重，通过计算Query和Key的点积（或缩放点积）来得到原始的注意力得分。然后，这些得分通过softmax函数进行归一化，产生最终的注意力权重。这些权重随后用于加权Value，以生成输出。
> - **损失计算**：模型输出与真实输出之间的差异通过损失函数计算出来。这个损失表示了模型当前性能的一个量度，目标是通过训练过程减小这个损失。
> - **反向传播**：通过反向传播算法，计算损失函数相对于模型参数（包括注意力机制中的参数）的梯度。这个过程会计算出每个参数对最终损失的影响程度，包括那些影响Query、Key生成的参数，从而间接影响注意力权重的计算。
> - **参数更新**：根据计算得到的梯度，使用梯度下降（或其他优化算法）更新模型的参数，包括那些影响注意力权重的参数。这一步的目的是调整模型的参数（从而调整注意力权重），以减小损失函数的值。
> - **迭代学习**：这个过程在训练数据上重复进行，每次迭代都会更新模型的参数，使得模型逐渐学会如何分配注意力权重，以便更加有效地处理输入数据。

### 10. 软注意力和硬注意力有什么区别？

> 软注意力（Soft Attention）和硬注意力（Hard Attention）是注意力机制的两种不同形式，它们在处理机制和计算方式上有着本质的区别。以下是这两种注意力机制的主要特点和区别：
> 
> ***软注意力***（Soft Attention）
> - *可微性*：软注意力机制是==完全可微==的，这意味着可以通过标准的反向传播算法来训练模型，不需要任何特殊的优化技巧或近似方法。
> - *概率分布*：在软注意力机制中，注意力权重通常被建模为对所有输入元素的一个概率分布。每个元素都会被赋予一个权重，这个权重指示了该元素对于生成输出的重要性。
> - *计算效率*：虽然软注意力需要对所有输入元素进行加权求和，这可能会增加计算负担，但它允许模型并行处理，从而在实践中仍然非常高效。
> - *应用范例*：软注意力被广泛应用于各种 NLP 任务中，如机器翻译、文本摘要、情感分析等，因为它能够提供平滑的梯度信息，有助于模型学习。习。
> 
> ***硬注意力***（Hard Attention）
> - *非可微性*：硬注意力机制通常是==非可微的==，这意味着不能直接通过传统的反向传播算法来训练。硬注意力通常需要使用强化学习或变分推断等特殊的优化技术。
> - *选择性关注*：硬注意力机制在==每一步只关注输入序列的一个子集==（通常是一个元素）。这种选择性关注的方式意味着模型必须决定最重要的信息位于何处，而不是同时考虑所有输入。
> - *计算开销*：由于硬注意力只处理序列的一个子集，因此在某些情况下可能比软注意力更节省计算资源。然而，==优化过程可能更复杂==，需要采用特殊的训练方法。
> - *应用范例*：硬注意力在需要模型做出显式选择的任务中较为常见，如视觉对象检测或某些类型的图像到文本的任务。

## 大型语言模型（LLM）

### 11. LLM 在处理自然语言任务时有哪些主要优势？

> - **广泛的知识覆盖和理解能力**：LLM 通过在大规模数据集上预训练，能够学习到广泛的知识和语言模式。这种广泛的知识基础使得 LLM 在处理各种自然语言处理任务时，==即使在没有特定任务训练的情况下，也能展现出惊人的理解和生成能力==。（涌现能力）
> - **强大的泛化能力**：LLM 能够在看到有限或未见过的例子时进行泛化，这是因为它们在预训练过程中学习到的丰富语言结构和知识。==这种泛化能力使得 LLM 在面对新任务或数据时能够快速适应==，甚至在没有大量标注数据的情况下也能表现出色。
> - **灵活的任务适应性**：==通过上下文学习（ICL）和思维链（CoT）等技术，LLM能够在给定特定上下文的情况下，理解任务需求并生成相应的输出==。这种灵活性使得LLM在多任务学习、零样本学习或少样本学习中表现出色。
> - **减少需求的数据标注**：由于 LLM 的预训练包含了丰富的世界知识和语言理解能力，它们在特定任务上的微调或应用时，往往不需要大量的标注数据。这对于数据获取成本高昂或难以获得大量标注数据的任务来说，是一个显著的优势。
> - **多模态能力**：随着LLM技术的发展，一些模型开始融合文本以外的信息，如图像、音频等，展现出多模态理解和生成的能力。这增加了LLM的应用范围，使其能够在更广泛的场景中发挥作用，如图像描述、多模态对话系统等。

### 12. 什么是预训练和微调过程，在 LLM 中它们如何应用？

> ***预训练***（Pre-training）
> - *目的*：预训练阶段的主要目的是让模型在大规模的数据集上学习语言的广泛知识、语法结构、上下文关系等。这一阶段不专注于任何特定的下游任务，而是==旨在让模型掌握尽可能多的语言理解和生成的通用能力==。
> - **方法**：在预训练阶段，模型通常通过自监督学习任务进行训练，例如掩码语言模型（MLM）任务（如BERT使用的）或自回归语言模型任务（如GPT系列使用的）等。
> 
> ***微调***（Fine-tuning）
> - *目的*：微调阶段的目的是==调整预训练好的模型，使其更好地适应特定的下游任务，如文本分类、情感分析、问答系统等==。  
> - *指令微调*（Prompt Tuning）：这里的“指令微调”==指使用特定的指令或提示（prompts）来引导模型在特定任务上的表现==。这种方法依赖于预训练模型的强大通用能力，通过设计合适的任务描述和示例（即 prompt engineering），使模型能够在不同情境下表现出期望的行为。。
> - *对齐微调*（Alignment Tuning）：对齐微调，涉及到使用诸如强化学习从人类偏好（RLHF）等方法来调整模型的输出，确保它们符合人类的伦理标准和价值观。这一步骤对于确保 LLM 的安全性和对社会负责任的使用至关重要。
> 
> ***补充说明***
> - *微调过程的广义解释*：微调不仅仅局限于上述两种形式，它==通常还包括在特定的下游任务数据集上继续训练模型，以适应该任务的特定需求==。这可能包括调整模型的所有参数或只是部分参数（如适应性微调或参数高效微调技术）。 
> - *实践中的应用*：在实践中，微调过程允许研究者和开发者利用预训练模型的强大基础能力，同时通过相对较少的数据量和计算资源，使模型优化以解决特定的任务或符合特定的行为准则。

### 13. 描述一下 GPT 和 BERT 的主要区别。

> GPT（Generative Pre-trained Transformer）和 BERT（Bidirectional Encoder Representations from Transformers）是两种流行的大型预训练语言模型，它们在设计、预训练任务、以及应用方式上有着显著的区别。下面是它们主要区别的详细介绍：
> 
> ***预训练任务和目标***
> - *GPT*：采用自回归（autoregressive）的训练方式，模型==在预训练阶段学习预测给定文本上下文中的下一个词==。这种方式使得 GPT 非常擅长生成连贯的文本序列。（单向）
> - *BERT*：采用自编码（autoencoding）的训练方式，通过掩码语言模型（Masked Language Model, MLM）任务学习预测被随机掩盖的词语。BERT ==同时考虑掩盖词语的左右两侧上下文==，使其特别擅长理解句子内部的双向关系。（双向）
> 
> ***模型架构***
> - *GPT*：仅使用 Transformer 的解码器（decoder）部分进行模型构建，强调顺序信息的处理和生成能力。
> - *BERT*：使用 Transformer 的编码器（encoder）部分构建模型，强调对上下文信息的深层次理解。
> 
> ***应用场景***
> - *GPT*：由于其自回归特性，GPT 特别适合于文本生成任务，如文本续写、文章生成、对话系统等。
> - *BERT*：由于其能够理解句子中的双向关系，BERT 在文本理解任务上表现出色，如文本分类、命名实体识别、问答系统等。
> 
> ***输入和输出处理***
> - *GPT*：在处理输入时，GPT 通常采用单向的上下文流动，即模型在生成每个词时仅考虑之前的词。
> - *BERT*：处理输入时能够考虑到整个句子的上下文信息，即在预测每个掩码词时模型考虑到句子中的所有其他词。
> 
> ***微调***（Fine-tuning）
> - 尽管两者都可以在特定任务上进行微调以提高性能，但由于 BERT 的双向上下文理解能力，它在需要深层语义理解的任务上更加灵活。

### 14. 大型语言模型是如何处理语言的多样性和复杂性的？

> 大型语言模型（LLM）处理语言的多样性和复杂性主要依赖于其设计和训练过程中的几个关键方面。这些方面包括==模型的架构、预训练任务、数据集的多样性以及微调过程==。下面详细介绍这些方面是如何帮助 LLM 处理语言的多样性和复杂性的：
> 
> ***模型架构***：LLM 通常基于 Transformer 架构，这种架构特别适合处理序列数据，如文本。Transformer 利用自注意力机制（Self-Attention）能够捕捉序列内任意两点之间的关系，无论它们的距离有多远。这使得 LLM 能够理解长距离依赖关系，从而处理复杂的句子结构和语义。
> 
> ***预训练任务***：通过设计不同的预训练任务，如掩码语言模型（MLM）和下一句预测，LLM 能够学习语言的广泛特性，包括词汇、语法、语义等。这些任务要求模型预测文本中的缺失部分或判断句子之间的逻辑关系，迫使模型学习到语言的深层次结构和含义。
> 
> ***数据集的多样性***：LLM 的训练涉及大规模和多样化的文本数据集，这些数据集覆盖了多种语言、领域、风格和语境。通过在这样丰富的数据集上进行预训练，模型能够学习到语言的多样性和复杂性，包括不同文化和社会群体的表达方式。
> 
> ***微调过程***：在特定任务上的微调使得 LLM 能够根据特定的应用需求调整其行为。通过在任务相关的数据集上进一步训练，LLM 能够优化其对该任务特定语言用法和复杂性的处理能力。

### 15. 语言模型的参数规模为什么对性能很重要？

> ***增强的理解能力***：随着模型规模的增加，==模型能够学习和存储更多的知识和语言模式==。这使得大型语言模型（LLM）能够更好地理解复杂的语言结构和语义，包括长距离依赖、隐含的语义关系等。较大的模型有更多的参数来捕捉这些细微的语言特性，从而提高理解文本的能力。
> 
> ***更好的泛化能力***：大规模的模型通常==在更广泛的数据集上进行预训练，因此能够接触到更多样化的语言用法和场景==。这不仅增加了模型的知识库，还提高了模型对未见数据的泛化能力。模型规模越大，其学习到的特征越丰富，越能够在不同的任务和数据集上表现出色。
> 
> ***涌现能力***：模型规模的增加被发现与涌现能力（即模型展现出预训练期间未直接学习到的新能力）之间有着紧密的联系。特别是在数十亿或数万亿参数级别的LLM中，这种能力变得尤为显著。大模型能够在没有明确训练的情况下，通过内部组合已有知识和模式来解决新问题，如通过逻辑推理、摘要、生成等。
> 
> ***复杂任务的适应性***：较大的模型由于其深厚的知识基础和复杂的表示能力，==能够更好地适应复杂的自然语言处理任务==。这些模型可以更准确地执行多步骤推理、处理复杂的问答任务、生成高质量的文本等，而较小的模型可能难以捕捉到任务所需的全部细节和复杂性。
> 
> ***降低额外代价***：当模型规模不足以处理特定任务时，可能需要通过额外的数据收集、特定任务的训练或复杂的模型架构改进等手段来补偿。这些方法通常需要额外的时间、计算资源和人力成本。相比之下，增加模型规模本身就是提高模型性能的一种直接且有效的方式，尽管也伴随着计算资源和能耗的增加。

### 16. LLM 为什么大多是 Decoder-only 架构？

> 大型语言模型（LLM）采用 Decoder-only 架构，如 GPT 系列，主要是因为这种架构特别适合生成任务，同时也具有处理广泛自然语言处理（NLP）任务的灵活性。以下是采用 Decoder-only 架构的几个主要优势以及学术界的理解：
> 
> ***适用于自回归语言生成***：Decoder-only 架构==天生适合于自回归语言生成任务，即在给定前文的情况下逐词生成文本==。这种架构通过预测下一个词的方式训练，能够生成连贯且语法正确的文本。这对于聊天机器人、文本续写、创意写作等应用至关重要。
> 
> ***简化的模型设计***：相比于 Encoder-Decoder 架构，Decoder-only 架构简化了模型的设计。在 Decoder-only 模型中，不需要设计两个不同的组件（即编码器和解码器）来分别处理输入和生成输出，从而简化了训练流程。==这种简化同时减少了模型的复杂性和潜在的错误来源==。
> 
> ***灵活的上下文处理能力***：Decoder-only 架构能够处理可变长度的输入序列，并在生成过程中考虑整个上下文。这使得模型在执行任务时能够灵活地利用所有可用的信息，从而提高了处理复杂对话和文本生成任务的能力。
> 
> ***高效的学习能力***：学术界认为，由于 Decoder-only 架构==在训练时能够直接关注生成任务，这使得模型能够更高效地学习语言生成的规律==。这种架构的模型通常在大规模数据集上进行预训练，能够从各种文本中学习语言的使用方式和知识，进而提高模型在各种 NLP 任务上的表现。
> 
> ***适应性和泛化能力***：Decoder-only 模型由于其预训练-微调（pretrain-finetune）范式，显示出在多种 NLP 任务上的适应性和泛化能力。==即使是设计用来生成文本的模型，也可以通过适当的训练和提示（prompting）技巧，被应用于分类、问答和摘要等非生成型任务==。
> 
> 学术界普遍认为，虽然 Decoder-only 架构有其优势，但最适合的架构还是取决于特定的应用场景和任务需求。Decoder-only、Encoder-only（如 BERT），以及 Encoder-Decoder（如 T5）架构各有千秋，适用于不同类型的 NLP 任务。选择哪种架构应基于任务的具体需求，如对生成能力、上下文理解能力或两者的需求。

## 自然语言处理（NLP）

### 27. NLP 中的分词（Tokenization）是什么，为什么重要？

> - 分词（Tokenization）的定义：分词是自然语言处理（NLP）中的一项基础任务，它涉及==将文本分解成更小的单元==（通常是词、子词或字符）。这些小单元称为“tokens”，它们是模型处理和理解文本的基本元素。
> - 为什么分词重要？
> 	1. **处理和理解的基础**：分词是将自然语言转化为机器学习模型可以理解的格式的第一步。==不同的词或子词作为模型的输入特征，使模型能够识别和处理文本中的信息==。（便于后续的 word embedding）
> 	2. **减少模型复杂性**：通过将文本分解为更小的单元，分词有助于减少模型需要处理的数据的维度和复杂性。这对于提高模型的训练效率和性能至关重要。
> 	3. **支持语言的多样性**：==不同语言有不同的语法和结构规则，分词能够适应这些规则==，为特定语言或方言提供定制化的处理。例如，中文和日文之间的分词策略会有显著差异，因为它们的书写系统和语法结构不同。
> 	4. **提高信息捕获能力**：良好的分词策略能够更准确地捕获文本中的语义信息，==如通过识别短语或专有名词作为单个token，而不是将它们分解成独立的词==。这有助于改善模型对文本含义的理解。
> 	5. **适应先进的模型架构**：在使用预训练语言模型（如BERT、GPT）时，分词尤其重要。这些模型通常依赖于特定的分词算法（如Byte Pair Encoding，BPE）来处理大规模词汇表外的词汇，通过这种方式使模型能够处理未见过的词汇或新词。

### 28. 描述词嵌入（Word Embedding）如何工作，以及为什么它比传统的词袋模型（Bag of Words）更有效。

> 词嵌入（Word Embedding）是一种==将词语表示为高维空间中的向量的技术，这些向量能够捕捉到词语之间的语义和语法关系==。与传统的词袋模型（Bag of Words, BoW）相比，词嵌入提供了一种更丰富、更有效的方式来表示文本数据。以下是关于词嵌入工作原理和其相对于词袋模型优势的详细解释：
> 
> ***词嵌入的工作原理***
> 1. **向量空间模型**：在词嵌入模型中，每个词被映射到高维空间中的一个点，即一个向量。这个向量由训练过程中学习到的数值组成，能够表示该词的语义和语法属性。
> 2. **上下文学习**：==词嵌入通过学习词语的上下文来捕捉其意义==，通常是利用大规模文本数据进行无监督学习。例如，使用Word2Vec、GloVe等算法，模型通过预测词语周围的上下文（或相反）来调整词向量，从而使得在语义或语法上相似的词语在向量空间中彼此接近。
> 3. **维度压缩**：与词袋模型的高维稀疏表示不同，词嵌入提供了一种低维（通常是几百到几千维）且密集的词向量表示。这种压缩的表示形式不仅减少了数据的稀疏性，还使得模型能够更有效地处理文本数据。
> 
> ***词嵌入相对于词袋模型的优势***
> 1. **捕捉语义关系**：词嵌入能够捕捉到词语之间的细微语义差异，如同义词、反义词等，而词袋模型则将文本简化为词频的集合，无法表示词语之间的这种关系。
> 2. **解决数据稀疏问题**：词袋模型中，每个文档表示为一个长向量，其中大部分元素为零，这导致数据高度稀疏。词嵌入通过提供密集的向量表示，有效地解决了这一问题。
> 3. **降低维度和计算成本**：词嵌入生成的低维向量减少了模型的计算负担，同时保留了丰富的语义信息。这使得基于词嵌入的模型在计算效率和性能上优于基于高维稀疏向量的词袋模型。
> 4. **泛化能力**：词嵌入可以通过向量的相似性来推断未见词或罕见词的语义，从而提高模型对新词的泛化能力。而在词袋模型中，未见词或罕见词往往被忽略或难以处理。

### 29. 什么是序列到序列（Seq2Seq）模型，它在哪些 NLP 任务中特别有用？

> 序列到序列（Seq2Seq）模型是一种==特别设计来处理序列输入转换为序列输出的任务的深度学习模型架构==。它通常由两部分组成：一个编码器（Encoder）和一个解码器（Decoder）。编码器负责读取并理解输入序列，将其转换成一个固定长度的内部表示（通常是向量形式）；解码器则负责将这个内部表示转换成目标序列。以下是Seq2Seq模型在NLP任务中的应用、优势和局限性的详细解释。
> 
> ***Seq2Seq模型的应用***
> 
> Seq2Seq模型在许多NLP任务中都非常有用，特别是那些输入和输出都是序列的任务，包括但不限于：
> - **机器翻译**：将一种语言的文本翻译成另一种语言。
> - **文本摘要**：从一篇长文本中生成短小精炼的摘要。
> - **对话系统**：生成对用户输入的自然语言回复。
> - **语音识别**：将语音转录成文字。
> - **文本到语音（TTS）**：将文本转换成语音输出。
> 
> ***Seq2Seq模型的优势***
> 
> 1. **灵活性**：Seq2Seq 模型能够处理可变长度的输入和输出序列，使其适用于广泛的 NLP 任务。
> 2. **上下文理解**：通过编码整个输入序列到一个固定长度的向量，模型能够捕捉长距离依赖关系，从而更好地理解上下文信息。
> 3. **端到端训练**：Seq2Seq模型可以端到端地训练，不需要人工设计特征，这简化了模型的开发和训练过程。
> 
> ***Seq2Seq模型的局限性***
>
> 1. **固定长度的内部表示**：编码器将整个输入序列压缩到一个固定长度的向量中，可能会导致信息损失，尤其是在处理非常长的序列时。
> 2. **训练难度**：Seq2Seq模型的训练可能比较困难，尤其是解码器部分，因为错误会随着序列的生成而累积。
> 3. **资源消耗**：由于模型需要处理整个序列，Seq2Seq模型可能需要大量的计算资源和内存，尤其是在处理长序列时。
> 
> 为了克服一些局限性，研究者们提出了多种改进方法，如使用注意力机制（Attention）来允许模型在每一步解码时都能够“查看”输入序列中的所有部分，而不是仅依赖于固定长度的内部表示。这显著提高了模型在机器翻译等任务中的性能。此外，Transformer模型的提出进一步推动了Seq2Seq架构的发展，它通过自注意力机制有效地处理了长距离依赖问题，并在多个NLP任务中取得了突破性的成果。

### 30. 解释什么是情感分析，以及它是如何实现的。

> 情感分析（Sentiment Analysis），也称为情绪分析，是自然语言处理（NLP）中的一个领域，它涉及到识别和分类文本中的主观信息，特别是关于个人情绪或态度的信息。情感分析的目的是确定一段给定文本（如一句话、一个段落或一个文档）所表达的情绪倾向，通常是正面、负面或中性。
> 
> ***情感分析的实现方法***
> 
> 情感分析的实现通常可以分为基于规则的方法、机器学习方法和深度学习方法。
> 1. **基于规则的方法**：
> 	- 这种方法依赖于一组预定义的规则或情感词典（即包含词语及其情感倾向的列表）。
> 	- 文本中的词语和短语会根据这些规则或词典被标记为正面、负面或中性。
> 	- 可能还会考虑否定词、程度副词等来调整情感分数。
> 	- 优点是透明度高，容易理解；缺点是缺乏灵活性，难以适应语言的变化和复杂性。
> 2. **机器学习方法**：
> 	- 利用特征工程从文本中提取特征（如词袋、TF-IDF 等），然后使用传统机器学习分类器（如逻辑回归、SVM 等）进行情感分类。
> 	- 这些方法通常需要大量的标注数据来训练模型。
> 	- 优点是能自动学习特征，适应性强；缺点是需要大量的标注数据，且特征工程可能比较复杂。
> 3. **深度学习方法**：
> 	- 使用词嵌入和神经网络（如卷积神经网络 CNN、循环神经网络 RNN、长短期记忆网络 LSTM 或 Transformer）直接从文本数据中学习情感倾向。
> 	- 这种方法能够捕捉文本中的深层次语义和上下文信息，对复杂的情感表达有更好的识别能力。
> 	- 优点是能够自动从原始文本中学习到复杂的特征，无需繁琐的特征工程；缺点是需要大量的计算资源和大规模的训练数据。
> 
> ***应用场景***
> 
> 情感分析在许多领域都有广泛的应用，包括：
> - **社交媒体监测**：分析用户在社交媒体上的情绪变化，了解公众对某个事件或产品的态度。
> - **品牌监测**：帮助企业了解消费者对品牌或产品的看法，指导市场策略。
> - **市场研究**：分析客户反馈，改进产品或服务。
> - **政治分析**：评估公众对政治事件或政策的情绪反应。

## 未来研究

1. 对网络协议、安全与机器学习融合的研究方向有哪些具体的研究计划或想法？
2. 在LLM领域，您最感兴趣的研究点是什么？
3. 您计划如何深入学习并实践LLM在特定任务上的性能提升？
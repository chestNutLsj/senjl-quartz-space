# Overview of Data Class Builders

Consider a simple class to represent a geographic coordinate pair, as shown in [Example 5-1](#coord_class_ex).

##### Example 5-1. _class/coordinates.py_

```
class
```

That `Coordinate` class does the job of holding latitude and longitude attributes. Writing the `__init__` boilerplate becomes old real fast, especially if your class has more than a couple of attributes: each of them is mentioned three times! And that boilerplate doesn’t buy us basic features we’d expect from a Python object:

```
>>> 
```

[![^1]

`__repr__` inherited from `object` is not very helpful.

[![^2]

Meaningless `==`; the `__eq__` method inherited from `object` compares object IDs.

[![^3]

Comparing two coordinates requires explicit comparison of each attribute.

The data class builders covered in this chapter provide the necessary `__init__`, `__repr__`, and `__eq__` methods automatically, as well as other useful features.

###### Note

None of the class builders discussed here depend on inheritance to do their work. Both `collections.namedtuple` and `typing.NamedTuple` build classes that are `tuple` subclasses. `@dataclass` is a class decorator that does not affect the class hierarchy in any way. Each of them uses different metaprogramming techniques to inject methods and data attributes into the class under construction.

Here is a `Coordinate` class built with `namedtuple`—a factory function that builds a subclass of `tuple` with the name and fields you specify:

```
>>> 
```

[![^1]

Useful `__repr__`.

[![^2]

Meaningful `__eq__`.

The newer `typing.NamedTuple` provides the same functionality, adding a type annotation to each field:

```
>>> 
```

###### Tip

A typed named tuple can also be constructed with the fields given as keyword arguments, like this:

Coordinate = typing.NamedTuple('Coordinate', lat=float, lon=float)

This is more readable, and also lets you provide the mapping of fields and types as `**fields_and_types`.

Since Python 3.6, `typing.NamedTuple` can also be used in a `class` statement, with type annotations written as described in [PEP 526—Syntax for Variable Annotations](https://fpy.li/pep526). This is much more readable, and makes it easy to override methods or add new ones. [Example 5-2](#coord_tuple_ex) is the same `Coordinate` class, with a pair of `float` attributes and a custom `__str__` to display a coordinate formatted like 55.8°N, 37.6°E.

##### Example 5-2. _typing_namedtuple/coordinates.py_

```
from
```

###### Warning

Although `NamedTuple` appears in the `class` statement as a superclass, it’s actually not. `typing.NamedTuple` uses the advanced functionality of a metaclass[^2] to customize the creation of the user’s class. Check this out:

```
>>> 
```

In the `__init__` method generated by `typing.NamedTuple`, the fields appear as parameters in the same order they appear in the `class` statement.

Like `typing.NamedTuple`, the `dataclass` decorator supports [PEP 526](https://fpy.li/pep526) syntax to declare instance attributes. The decorator reads the variable annotations and automatically generates methods for your class. For comparison, check out the equivalent `Coordinate` class written with the help of the `dataclass` decorator, as shown in [Example 5-3](#coord_dataclas_ex).

##### Example 5-3. _dataclass/coordinates.py_

```
from
```

Note that the body of the classes in [Example 5-2](#coord_tuple_ex) and [Example 5-3](#coord_dataclas_ex) are identical—the difference is in the `class` statement itself. The `@dataclass` decorator does not depend on inheritance or a metaclass, so it should not interfere with your own use of these mechanisms.[^3] is a subclass of `object`.
## Don’t Make the Iterable an Iterator for Itself

A common cause of errors in building iterables and iterators is to confuse the two. To be clear: iterables have an `__iter__` method that instantiates a new iterator every time. Iterators implement a `__next__` method that returns individual items, and an `__iter__` method that returns `self`.

Therefore, iterators are also iterable, but iterables are not iterators.

It may be tempting to implement `__next__` in addition to `__iter__` in the `Sentence` class, making each `Sentence` instance at the same time an iterable and iterator over itself. But this is rarely a good idea. It’s also a common antipattern, according to Alex Martelli who has a lot of experience reviewing Python code at Google.

The “Applicability” section about the Iterator design pattern in the _Design Patterns_ book says:

> Use the Iterator pattern
> 
> - to access an aggregate object’s contents without exposing its internal representation.
>     
> - to support multiple traversals of aggregate objects.
>     
> - to provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration).
>     

To “support multiple traversals,” it must be possible to obtain multiple independent iterators from the same iterable instance, and each iterator must keep its own internal state, so a proper implementation of the pattern requires each call to `iter(my_iterable)` to create a new, independent, iterator. That is why we need the `SentenceIterator` class in this example.

Now that the classic Iterator pattern is properly demonstrated, we can let it go. Python incorporated the `yield` keyword from Barbara Liskov’s [CLU language](https://fpy.li/17-7), so we don’t need to “generate by hand” the code to implement iterators.

The next sections present more idiomatic versions of `Sentence`.
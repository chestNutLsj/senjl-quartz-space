## Generic Type Hints for Classic Coroutines

Back in [“Contravariant types”](ch15.html#contravariant_types_sec), I mentioned `typing.Generator` as one of the few standard library types with a contravariant type parameter. Now that we’ve studied classic coroutines, we are ready to make sense of this generic type.

Here is how `typing.Generator` was [declared](https://fpy.li/17-25) in the _typing.py_ module of Python 3.6:[^16]

```
T_co
```

That generic type declaration means that a `Generator` type hint requires those three type parameters we’ve seen before:

```
my_coro
```

From the type variables in the formal parameters, we see that `YieldType` and `ReturnType` are covariant, but `SendType` is contravariant. To understand why, consider that `YieldType` and `ReturnType` are “output” types. Both describe data that comes out of the coroutine object—i.e., the generator object when used as a coroutine object.

It makes sense that these are covariant, because any code expecting a coroutine that yields floats can use a coroutine that yields integers. That’s why `Generator` is covariant on its `YieldType` parameter. The same reasoning applies to the `ReturnType` parameter—also covariant.

Using the notation introduced in [“Covariant types”](ch15.html#covariant_types_sec), the covariance of the first and third parameters is expressed by the `:>` symbols pointing in the same direction:

                       float :> int
Generator[float, Any, float] :> Generator[int, Any, int]

`YieldType` and `ReturnType` are examples of the first rule of [“Variance rules of thumb”](ch15.html#variance_rules_sec):

> 1. If a formal type parameter defines a type for data that comes out of the object, it can be covariant.
>     

On the other hand, `SendType` is an “input” parameter: it is the type of the `value` argument for the `.send(value)` method of the coroutine object. Client code that needs to send floats to a coroutine cannot use a coroutine with `int` as the `SendType` because `float` is not a subtype of `int`. In other words, `float` is not _consistent-with_ `int`. But the client can use a coroutine with `complex` as the `SendType`, because `float` is a subtype of `complex`, therefore `float` is _consistent-with_ `complex`.

The `:>` notation makes the contravariance of the second parameter visible:

                     float :> int
Generator[Any, float, Any] <: Generator[Any, int, Any]

This is an example of the second Variance Rule of Thumb:

> 2. If a formal type parameter defines a type for data that goes into the object after its initial construction, it can be contravariant.
>     

This merry discussion of variance completes the longest chapter in the book.
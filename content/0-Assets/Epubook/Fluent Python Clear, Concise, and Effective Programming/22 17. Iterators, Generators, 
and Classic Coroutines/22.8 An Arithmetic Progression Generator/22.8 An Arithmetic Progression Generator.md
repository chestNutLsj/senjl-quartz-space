# An Arithmetic Progression Generator

The classic Iterator pattern is all about traversal: navigating some data structure. But a standard interface based on a method to fetch the next item in a series is also useful when the items are produced on the fly, instead of retrieved from a collection. For example, the `range` built-in generates a bounded arithmetic progression (AP) of integers. What if you need to generate an AP of numbers of any type, not only integers?

[Example 17-11](#ap_class_demo) shows a few console tests of an `ArithmeticProgression` class we will see in a moment. The signature of the constructor in [Example 17-11](#ap_class_demo) is `ArithmeticProgression(begin, step[, end])`. The complete signature of the `range` built-in is `range(start, stop[, step])`. I chose to implement a different signature because the `step` is mandatory but `end` is optional in an arithmetic progression. I also changed the argument names from `start/stop` to `begin/end` to make it clear that I opted for a different signature. In each test in [Example 17-11](#ap_class_demo), I call `list()` on the result to inspect the generated values.

##### Example 17-11. Demonstration of an `ArithmeticProgression` class

    `>>>` `ap` `=` `ArithmeticProgression``(``0``,` `1``,` `3``)`
    `>>>` `list``(``ap``)`
    `[``0``,` `1``,` `2``]`
    `>>>` `ap` `=` `ArithmeticProgression``(``1``,` `.``5``,` `3``)`
    `>>>` `list``(``ap``)`
    `[``1.0``,` `1.5``,` `2.0``,` `2.5``]`
    `>>>` `ap` `=` `ArithmeticProgression``(``0``,` `1``/``3``,` `1``)`
    `>>>` `list``(``ap``)`
    `[``0.0``,` `0.3333333333333333``,` `0.6666666666666666``]`
    `>>>` `from` `fractions` `import` `Fraction`
    `>>>` `ap` `=` `ArithmeticProgression``(``0``,` `Fraction``(``1``,` `3``),` `1``)`
    `>>>` `list``(``ap``)`
    `[``Fraction``(``0``,` `1``),` `Fraction``(``1``,` `3``),` `Fraction``(``2``,` `3``)]`
    `>>>` `from` `decimal` `import` `Decimal`
    `>>>` `ap` `=` `ArithmeticProgression``(``0``,` `Decimal``(``'.1'``),` `.``3``)`
    `>>>` `list``(``ap``)`
    `[``Decimal``(``'0'``),` `Decimal``(``'0.1'``),` `Decimal``(``'0.2'``)]`

Note that the type of the numbers in the resulting arithmetic progression follows the type of `begin + step`, according to the numeric coercion rules of Python arithmetic. In [Example 17-11](#ap_class_demo), you see lists of `int`, `float`, `Fraction`, and `Decimal` numbers. [Example 17-12](#ex_ap_class) lists the implementation of the `ArithmeticProgression` class.

##### Example 17-12. The `ArithmeticProgression` class

```
class
```

[![^1]

`__init__` requires two arguments: `begin` and `step`; `end` is optional, if it’s `None`, the series will be unbounded.

[![^2]

Get the type of adding `self.begin` and `self.step`. For example, if one is `int` and the other is `float`, `result_type` will be `float`.

[![^3]

This line makes a `result` with the same numeric value of `self.begin`, but coerced to the type of the subsequent additions.[^7]

[![^4]

For readability, the `forever` flag will be `True` if the `self.end` attribute is `None`, resulting in an unbounded series.

[![^5]

This loop runs `forever` or until the result matches or exceeds `self.end`. When this loop exits, so does the function.

[![^6]

The current `result` is produced.

[![^7]

The next potential result is calculated. It may never be yielded, because the `while` loop may terminate.

In the last line of [Example 17-12](#ex_ap_class), instead of adding `self.step` to the previous `result` each time around the loop, I opted to ignore the previous `result` and each new `result` by adding `self.begin` to `self.step` multiplied by `index`. This avoids the cumulative effect of floating-point errors after successive additions. These simple experiments make the difference clear:

```
>>> 
```

The `ArithmeticProgression` class from [Example 17-12](#ex_ap_class) works as intended, and is a another example of using a generator function to implement the `__iter__` special method. However, if the whole point of a class is to build a generator by implementing `__iter__`, we can replace the class with a generator function. A generator function is, after all, a generator factory.

[Example 17-13](#ex_ap_genfunc1) shows a generator function called `aritprog_gen` that does the same job as `ArithmeticProgression` but with less code. The tests in [Example 17-11](#ap_class_demo) all pass if you just call `aritprog_gen` instead of `ArithmeticProgression`.[^8]

##### Example 17-13. The `aritprog_gen` generator function

```
def
```

[Example 17-13](#ex_ap_genfunc1) is elegant, but always remember: there are plenty of ready-to-use generators in the standard library, and the next section will show a shorter implementation using the `itertools` module.
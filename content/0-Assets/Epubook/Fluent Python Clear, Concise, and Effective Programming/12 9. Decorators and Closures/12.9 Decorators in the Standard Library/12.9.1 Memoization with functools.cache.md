## Memoization with functools.cache

The `functools.cache` decorator implements _memoization_:[^5] an optimization technique that works by saving the results of previous invocations of an expensive function, avoiding repeat computations on previously used arguments.

###### Tip

`functools.cache` was added in Python 3.9. If you need to run these examples in Python 3.8, replace `@cache` with `@lru_cache`. For prior versions of Python, you must invoke the decorator, writing `@lru_cache()`, as explained in [“Using lru_cache”](#lru_cache_sec).

A good demonstration is to apply `@cache` to the painfully slow recursive function to generate the _n_th number in the Fibonacci sequence, as shown in [Example 9-17](#ex_fibo_demo).

##### Example 9-17. The very costly recursive way to compute the nth number in the Fibonacci series

```
from
```

Here is the result of running _fibo_demo.py_. Except for the last line, all output is generated by the `clock` decorator:

$ python3 fibo_demo.py
[0.00000042s] fibonacci(0) -> 0
[0.00000049s] fibonacci(1) -> 1
[0.00006115s] fibonacci(2) -> 1
[0.00000031s] fibonacci(1) -> 1
[0.00000035s] fibonacci(0) -> 0
[0.00000030s] fibonacci(1) -> 1
[0.00001084s] fibonacci(2) -> 1
[0.00002074s] fibonacci(3) -> 2
[0.00009189s] fibonacci(4) -> 3
[0.00000029s] fibonacci(1) -> 1
[0.00000027s] fibonacci(0) -> 0
[0.00000029s] fibonacci(1) -> 1
[0.00000959s] fibonacci(2) -> 1
[0.00001905s] fibonacci(3) -> 2
[0.00000026s] fibonacci(0) -> 0
[0.00000029s] fibonacci(1) -> 1
[0.00000997s] fibonacci(2) -> 1
[0.00000028s] fibonacci(1) -> 1
[0.00000030s] fibonacci(0) -> 0
[0.00000031s] fibonacci(1) -> 1
[0.00001019s] fibonacci(2) -> 1
[0.00001967s] fibonacci(3) -> 2
[0.00003876s] fibonacci(4) -> 3
[0.00006670s] fibonacci(5) -> 5
[0.00016852s] fibonacci(6) -> 8
8

The waste is obvious: `fibonacci(1)` is called eight times, `fibonacci(2)` five times, etc. But adding just two lines to use `cache`, performance is much improved. See [Example 9-18](#fibo_demo_cache_ex).

##### Example 9-18. Faster implementation using caching

```
import
```

[![^1]

This line works with Python 3.9 or later. See [“Using lru_cache”](#lru_cache_sec) for alternatives supporting earlier versions of Python.

[![^2]

This is an example of stacked decorators: `@cache` is applied on the function returned by `@clock`.

# Stacked Decorators

To make sense of stacked decorators, recall that the `@` is syntax sugar for applying the decorator function to the function below it. If there’s more than one decorator, they behave like nested function calls. This:

```
@alpha
```

is the same as this:

```
my_fn
```

In other words, the `beta` decorator is applied first, and the function it returns is then passed to `alpha`.

Using `cache` in [Example 9-18](#fibo_demo_cache_ex), the `fibonacci` function is called only once for each value of `n`:

$ python3 fibo_demo_lru.py
[0.00000043s] fibonacci(0) -> 0
[0.00000054s] fibonacci(1) -> 1
[0.00006179s] fibonacci(2) -> 1
[0.00000070s] fibonacci(3) -> 2
[0.00007366s] fibonacci(4) -> 3
[0.00000057s] fibonacci(5) -> 5
[0.00008479s] fibonacci(6) -> 8
8

In another test, to compute `fibonacci(30)`, [Example 9-18](#fibo_demo_cache_ex) made the 31 calls needed in 0.00017s (total time), while the uncached [Example 9-17](#ex_fibo_demo) took 12.09s on an Intel Core i7 notebook, because it called `fibonacci(1)` 832,040 times, in a total of 2,692,537 calls.

All the arguments taken by the decorated function must be _hashable_, because the underlying `lru_cache` uses a `dict` to store the results, and the keys are made from the positional and keyword arguments used in the calls.

Besides making silly recursive algorithms viable, `@cache` really shines in applications that need to fetch information from remote APIs.

###### Warning

`functools.cache` can consume all available memory if there is a very large number of cache entries. I consider it more suitable for use in short-lived command-line scripts. In long-running processes, I recommend using `functools.lru_cache` with a suitable `maxsize` parameter, as explained in the next section.
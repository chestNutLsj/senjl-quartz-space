### 7.5.2　分解各个数位并压栈

数位的分解还是得靠做除法。源程序第44 行用于把除数10 传送到寄存器BX。

以往分解寄存器AX 中的数时，固定是分解5 次，得到5 个数位。但这也存在一个缺点，如果AX 中的数很小时，在屏幕上显示的数左边都是“0”，这当然是很别扭的。为此，本章的源程序做了改善，每次除法结束后，都做一次判断，如果商为0 的话，分解过程可以提前结束。

但是，由于每次得到的数位是压入栈的，将来还要反序从栈中弹出，为此，必须记住实际上到底有多少个数位。源程序第45 行，将寄存器CX 清零，并在后面的代码中用于累计有多少个数位。

源程序第47～53 行也是一个循环体，每执行一次，分解出一个数位。每次分解时，CX 加一，表明数位又多了一个，这是源程序第47 行所做的事。

源程序第48、49 行，将DX 清零，并和AX 一起形成32 位的被除数。

分解出的数位将来要显示在屏幕上，为了方便，源程序第50 行，直接将AL 中的商“加上”0x30，以得到该数字所对应的ASCII 码。

注意上一段话中的引号。这并不是真正的加法，or 并不是相加的指令，但由于此处的特殊情况，使得or 指令的执行结果和相加是一样的。

与xor 一样，or 也是逻辑运算指令。不同之处在于，or 执行的是逻辑“或”。数字逻辑中的“或”用于表示两个命题并列的情况。如果0 代表假，1 代表真，那么：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00202.jpeg)

在处理器内部，or 指令的目的操作数可以是8 位或者16 位的通用寄存器，或者包含8/16位实际操作数的内存单元，源操作数可以是与目的操作数数据宽度相同的通用寄存器、内存单元或者立即数。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00203.jpeg)

和其他指令一样，or 指令不允许目的操作数和源操作数都是内存单元的情况。当or 指令执行时，两个操作数相对应的比特之间分别进行各自的逻辑“或”运算，结果位于目的操作数中。举个例子，以下指令执行后，寄存器AL 中的内容是0xff。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00204.jpeg)

再来看源程序第50 行，因为每次是除以10，所以在寄存器DL 中得到的余数，其高4 位必定为0。又由于0x30 的低4 位是0，高4 位是3，所以，DL 中的内容和0x30 执行逻辑“或”后，相当于是将DL 中的内容和0x30 相加。这是用逻辑“或”指令做加法的一个特例。

or 指令对标志寄存器的影响是：OF 和CF 位被清零，SF、ZF、PF 位的状态依计算结果而定，AF 位的状态未定义。

与or 相对应的是逻辑与“and”。如果0 代表假，1 代表真，那么

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00205.jpeg)

相应地，处理器设计了and 指令。在16 位处理器上，and 指令的两个操作数都应当是字节或者字。其中，目的操作数可以是通用寄存器和内存单元；源操作数可以是通用寄存器、内存单元或者立即数，但不允许两个操作数同时为内存单元，而且它们在数据宽度上应当一致。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00206.jpeg)

注意，“label_a”是一个标号，下同。

当这些指令执行时，两个操作数对应的各个比特位分别进行逻辑“与”，结果保存在目的操作数中。因此，下面的这些指令执行后，寄存器AX 中的结果是二进制数1000000000000100，即0x8004：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00207.jpeg)

and 指令执行后，OF 和CF 位被清零，SF、ZF、PF 位的状态依计算结果而定，AF 位的状态未定义。各个数位的ASCII 码是压入栈中的。源程序第51 行，push 指令的作用是将寄存器DX 的内容压入栈中。在16 位的处理器上，push 指令的操作数可以是16 位的寄存器或者内存单元。例如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00208.jpeg)

你可能觉得奇怪，push 指令只接受16 位的操作数，为什么要对内存操作数使用关键字“word”。事实上，8086 处理器只能压入一个字；但其后的32 位和64 位处理器允许压入字、双字或者四字，因此，关键字是必不可少的。

就8086 处理器来说，因为压入栈的内容必须是字，所以，下面的指令都是非法的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00209.jpeg)

处理器在执行push 指令时，首先将栈指针寄存器SP 的内容减去操作数的字长（以字节为单位的长度，在16 位处理器上是2），然后，把要压入栈的数据存放到逻辑地址SS:SP 所指向的内存位置（和其他段的读写一样，把栈段寄存器SS 的内容左移4 位，加上栈指针寄存器SP 提供的偏移地址）。

如图7-3 所示，代码段和栈段是同一个段，所以段寄存器CS 和SS 的内容都是0x0000。而且，栈指针寄存器SP 的内容在源程序第42 行被置为0。所以，当push 指令第一次执行时，SP 的内容减2，即0x0000－0x0002＝0xFFFE，借位被忽略。于是，被压入栈的数据，在内存中的位置实际上是0x0000:0xFFFE。push 指令的操作数是字，而且Intel 处理器是使用低端字节序的，故低字节在低地址部分，高字节在高地址部分，正好占据了栈段的最高两个字节位置。

这只是第一次压栈操作时的情况。以后每次压栈时，SP 都要依次减2。很明显，不同于代码段，代码段在处理器上执行时，是由低地址端向高地址端推进的，而压栈操作则正好相反，是从高地址端向低地址端推进的。

push 指令不影响任何标志位。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00210.jpeg)

图7-3　第一次执行压栈操作时的内存状态

源程序第52、53 行，判断本次除法结束后，商是否为0。如果不为零，则再循环一次；如果为零，则表明不需要再继续分解了。
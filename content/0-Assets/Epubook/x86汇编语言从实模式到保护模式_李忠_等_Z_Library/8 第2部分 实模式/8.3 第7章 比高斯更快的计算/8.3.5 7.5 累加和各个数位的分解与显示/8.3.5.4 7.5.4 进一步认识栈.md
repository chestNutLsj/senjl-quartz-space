### 7.5.4　进一步认识栈

学习栈的知识，最好是先有一些感性认识，本章就是这么做的。现在，感性认识已经有了，剩下的，就是总结一下，做几点说明。

第一，push 指令的操作数可以是16 位寄存器或者16 位内存单元，push 指令执行后，压入栈中的仅仅是该寄存器或者内存单元里的数值，与该寄存器或内存单元不再相干。如果不理解这一点，就容易错误地以为压入了某个寄存器的值，比如AX 之后，将来还要再弹回AX 才行，这是不对的。所以，下面的指令是合法而且正确的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00212.jpeg)

这两条指令的意思是，将代码段寄存器的内容压栈，并弹出到数据段寄存器DS。如此一来，代码段和数据段将属于同一个内存段。实际上，这两条指令的执行结果，和以下指令的执行结果相同：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00213.jpeg)

第二，栈在本质上也只是普通的内存区域，之所以要用push 和pop 指令来访问，是因为你把它看成栈而已。实际上，如果你把它看成是普通的数据段而忘掉它是一个栈，那么它将不再神秘。

引入栈和push、pop 指令只是为了方便程序开发。临时保存一个数值到栈中，使用push 指令是最简洁、最省事的，但如果你不怕麻烦，可以不使用它。所以，下面的代码可以用来取代push ax 指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00214.jpeg)

同样，pop ax 指令的执行结果和下面的代码相同：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00215.jpeg)

你可能还有另一种想法，即，我连栈段都不用，SP 也省了，我自己把临时数据都保存在数据段中。好吧，如果是这样的话，你必须在数据段中开辟一些空间，并亲自维护一个指针来跟踪这些数据的存入和取出。当程序变得越来越复杂时，这些维护工作同样让你焦头烂额。

因此，显而易见的是，push 和pop 指令更方便，毕竟与栈访问有关的一切都是由处理器自动维护的。而且，总有一天你会发现，有些工作不使用栈来进行的话，是非常困难的。

第三，要注意保持栈平衡。如果在做某件事的时候要使用栈，那么，栈指针寄存器SP 在做这件事之前的值，应当和这件事做完后的值相同。就是说，push 指令和pop 指令的数量应当是相同的。栈是反复使用的内存区域，如果使用不当，将会出现问题，下面就是一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00216.jpeg)

以上的循环是干什么用的，做什么事情，这个不重要。因为每次循环时，都要用到寄存器AX 和BX 的原始内容，所以，循环体的开头要压栈保存它们，在循环体的末尾要出栈恢复它们。但是你看到了，由于一时疏忽，只压入了寄存器AX，而在出栈时，却多弹了一个数值到BX 中。在这种情况下，栈是不平衡的，程序的运行结果当然也不会正确。

第四，在编写程序前，必须充分估计所需要的栈空间，以防止破坏有用的数据。特别是在栈段和其他段属于同一个段的时候。如图7-3 所示，栈段和代码段属于同一个内存段，段地址都是0x0000，段的长度都是64KB。主引导程序的长度是512（0x200）字节，从偏移地址0x7c00 延伸到0x7e00。栈是向下增长的，它们之间有0xffff－0x7e00＋1＝0x8200 字节的空档。通常来说，我们的程序是安全的，因为不可能压入这么多的数据。但是，不能掉以轻心，栈定义得过小，而且程序编写不当，导致栈破坏了有用数据的情况也时有发生。

第五，尽管不能完全阻止程序中的错误，但是，通过将栈定义到一个单独的64KB 段，可以使错误仅局限于栈，而不破坏其他段的有用数据。假如栈的段地址是0x0000，大小是64KB，那么，无论SP 怎样变化，压栈和出栈操作始终会在该段内进行，而不会影响到其他无关的内存区域。这样，无论任何时候，即使是push 指令位于一个无限循环中，栈指针寄存器SP 的内容也永远只会在0x0000～0xFFFF 之间来回滚动，不会影响到其他内存段。

检测点7.1

1． 以下指令执行后，寄存器AX 中的内容是多少？

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00217.jpeg)

2． 下面的说法中哪些是正确的？

A．8086 处理器执行压栈操作时，是先将SP 的内容减2，再访问栈段。

B．8086 处理器执行出栈操作时，是先将SP 的内容加2，再访问栈段。

C．如果SP 的内容为0xFFFC，则执行push ax 后，SP 的内容变为0xFFFA。

3． 在空白处补充指令或指令的操作数，使得程序可以把栈段当成数据段访问，并在寄存器DX 中得到AX 的压栈值。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00218.jpeg)
### 7.5.1　栈和栈段的初始化

得到了累加和之后，下面的工作是将它的各个数位分解出来，并准备在屏幕上显示，好让我们知道这个数到底是多少。

和前两章不同，分解出来的各个数位并不保存在数据段中，而保存在一个叫做栈的地方。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00200.jpeg)

图7-1　一个说明栈工作原理的类比

栈（Stack）是一种特殊的数据存储结构，数据的存取只能从一端进行。这样，最先进去的数据只能最后出来，最后进去的数据倒是最先出来，这称为后进先出（Last In First Out，LIFO）。如图7-1 所示，可以把栈看成一个一端开口的塑料瓶，1 号球最先放进去，3 号球最后放进去，只能在3 号球和2 号球分别取出后，才能把1 号球取出来。

听起来像是在讲如何往盒子里放东西，或者从盒子里取东西。实际上，我们还是在讲内存，只不过是另一种特殊的读写方式而已。

和代码段、数据段和附加段一样，栈也被定义成一个内存段，叫栈段（Stack Segment），由段寄存器SS 指向。

针对栈的操作有两种，分别是将数据推进栈（push）和从栈中弹出数据（pop）。简单地说，就是压栈和出栈。压栈和出栈只能在一端进行，所以需要用栈指针寄存器SP （Stack Pointer）来指示下一个数据应当压入栈内的什么位置，或者数据从哪里出栈。

定义栈需要两个连续的步骤，即初始化段寄存器SS 和栈指针SP 的内容。源程序第40～42 行用于将栈段的段地址设置为0x0000，栈指针的内容设置为0x0000。

到目前为止，我们已经定义了3 个段，图7-2 是当前的内存布局。总的内存容量是1MB，物理地址的范围是0x00000～0xFFFFF，其中，假定数据段的长度是64KB（实际上它的长度无关紧要）， 占据了物理地址0x07C00 ～ 0x17BFF ， 对应的逻辑地址范围是0x07C0:0x0000 ～ 0x07C0:0xFFFF；代码段和栈段是同一个段，占据着物理地址0x00000～0x0FFFF，对应的逻辑地址范围是0x0000:0x0000～0x0000:0xFFFF。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00201.jpeg)

图7-2　本章程序的内存布局

虽然代码段和栈段在本质上指向同一块内存区域，但是不要担心，主引导程序只占据着中间的一小部分，我们有办法让它们互不干扰。
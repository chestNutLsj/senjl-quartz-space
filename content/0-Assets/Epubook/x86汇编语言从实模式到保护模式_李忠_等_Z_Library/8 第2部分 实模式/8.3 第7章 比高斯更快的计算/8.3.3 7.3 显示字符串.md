   

## 7.3　显示字符串

源程序第8 行，声明并初始化了一串字符（字符串），它的最终用途是要显示在屏幕上。我们可以直接用单引号把一串字符围起来：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00199.jpeg)

NASM 支持这样的做法，同前一章相比，以这种方法声明字符串显得更方便、更直接。在编译阶段，编译器将把它们拆开，以形成一个个单独的字节。

为了跳过没有指令的数据区，源程序第6 行是jmp near start 指令。

源程序第11～15 行用于初始化数据段寄存器DS 和附加段寄存器ES。

源程序第18～28 行同样用于显示字符串，但采用了不同的方法，首先是用索引寄存器SI 指向DS 段内待显示字符串的首地址，即标号“message”所代表的汇编地址。然后，再用另一个索引寄存器DI 指向ES 段内的偏移地址0 处，ES 是指向0xB800 段的。

字符串的显示需要依赖循环。本次采用的是循环指令loop。loop 指令的工作又依赖于CX 寄存器，所以，源程序第20 行，用于在编译阶段计算一个循环次数，该循环次数等于字符串的长度（字符个数）。

循环体是从源程序第22 行开始的。首先从数据段中，逻辑地址为DS:SI 的地方取得第一个字符，将其传送到逻辑地址ES:DI，后者指向显示缓冲区。

紧接着，源程序第24 行，将DI 的内容加一，以指向该字符在显示缓冲区内的属性字节；第25 行，在该位置写入属性值0x07，即黑底白字。

源程序第26、27 行，分别将寄存器SI 和DI 的内容加一，以指向源位置和目标位置的下一个单元。

源程序第28 行，执行循环。loop 指令在执行时先将CX 的内容减一，然后，处理器根据CX是否为零来决定是否开始下一轮循环。当CX 为0 的时候，说明所有的字符已经显示完毕。
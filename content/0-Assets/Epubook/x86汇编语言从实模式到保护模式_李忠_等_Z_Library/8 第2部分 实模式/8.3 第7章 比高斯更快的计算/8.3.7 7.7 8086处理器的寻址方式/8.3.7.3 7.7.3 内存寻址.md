### 7.7.3　内存寻址

寄存器寻址的操作数位于寄存器中，立即寻址的操作数位于指令中，是指令的一部分。传统上，这是两种速度较快的寻址方式。但是，它们也有局限性。一方面，我们不可能总是知道要操作的数是多少，因此也就不可能总是在指令中使用立即数；另一方面，寄存器的数量有限，不可能总指望在寄存器之间来回倒腾。

考虑到内存容量巨大，所以，在指令中使用内存地址，来操作内存中的数据，是最理想不过了。正是因为内存访问如此重要，处理器才拥有好几种内存寻址方式。

我们知道，8086 处理器访问内存时，采用的是段地址左移4 位，然后加上偏移地址，来形成20位物理地址的模式，段地址由4 个段寄存器之一来提供，偏移地址要由指令来提供。

因此，所谓的内存寻址，实际上就是寻找偏移地址，这称为有效地址（Effective Address，EA）。换句话说，就是如何在指令中提供偏移地址，供处理器访问内存时使用。

1．直接寻址

使用该寻址方式的操作数是一个偏移地址，而且给出了该偏移地址的具体数值。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00225.jpeg)

但凡是表示内存地址的，都必须用中括号括起来。

以上，在第一条指令中，源操作数使用的是直接寻址方式，当这条指令执行时，处理器将数据段寄存器DS 的内容左移4 位，加上这里的0x5c0f，形成20 位物理地址。接着，从该物理地址处取得一个字，传送到寄存器AX 中。

在第二条指令中，目的操作数采用的是直接寻址方式。当这条指令执行时，处理器用同样的方法，访问由段寄存器DS 指向的数据段，并把指令中的立即数加到该段中偏移地址为0x0230 的字单元里。

尽管在第三条指令中，目的操作数使用了标号和段超越前缀，但它依然属于直接寻址方式。原因很简单，标号是数值的等价形式，在指令编译阶段，会被转换成数值；而段超越前缀仅仅用来改变默认的数据段。

2．基址寻址

很多时候，我们会有一大堆的数据要处理，而且它们通常都是挨在一起，顺序存放的。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00226.jpeg)

假如要将这些数据统统加一，那么，使用直接寻址的指令序列肯定是这样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00227.jpeg)

这样做好吗？当然，程序本身是没有问题的。但是，考虑到它的效率和代码的简洁性，特别是这些工作用循环来完成会更好，可以使用基址寻址。所谓基址寻址，就是在指令的地址部分使用基址寄存器BX 或者BP 来提供偏移地址。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00228.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00229.jpeg)

以上，第一条指令中的目的操作数采用了基址寻址。在指令执行时，处理器将数据段寄存器DS 的内容左移4 位，加上基址寄存器BX 中的内容，形成20 位的物理地址。然后，把寄存器DX中的内容传送到该地址处的字单元里。

第二条指令中的目的操作数也采用的是基址寻址。指令执行时，将数据段寄存器DS 的内容左移4 位，加上寄存器BX 中的内容，形成20 位的物理地址。然后，将指令中的立即数0x55 加到该地址处的字节单元里。

使用基址寻址可以使代码变得简洁高效。比如，可以用以下的代码来处理上面的批量加一任务：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00230.jpeg)

基址寻址的寄存器也可以是BP。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00231.jpeg)

这条指令的源操作数采用了基址寻址方式。但是，与前面的指令相比，它稍微有些特殊。原因在于，它采用是基址寄存器BP，在形成20 位的物理地址时，默认的段寄存器是SS。也就是说，它经常用于访问栈。这条指令执行时，处理器将栈段寄存器SS 的内容左移4 位，加上寄存器BP 的内容，形成20 位的物理地址，并将该地址处的一个字传送到寄存器AX 中。

我们知道，栈是后进先出的数据结构，访问栈的一般方法是使用push 和pop 指令。比如我们用以下的指令压入两个数据：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00232.jpeg)

很显然，如果要用pop 指令弹出数据，就必须先弹出0x7000，才能弹出0x5000，除非你改变了栈指针SP 的内容，否则这个顺序是不可能改变的。

但是，有时候我们希望，而且必须得越过这种限制，去访问栈中的内容，还不能破坏栈的状态，特别是栈指针寄存器SP 的内容，使得push 和pop 操作能正常进行。一个典型的例子是高级语言里的函数调用，所有的参数都位于栈中。为了能访问到那些被压在栈底的参数，这时，BP 就能派上用场：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00233.jpeg)

以上，在压入0x5000 之后，立即将栈指针SP 保存到BP。后面，尽管栈顶的数据0x7000 没有出栈，但依然可以用BP 取出压在栈下面的0x5000。如此一来，正常的push 和pop 操作照样进行，同时，还能访问到栈中的参数。

基址寻址允许在基址寄存器的基础上使用一个偏移量。有时候，这使得它更加灵活。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00234.jpeg)

处理器在执行时，将段寄存器SS 的内容左移4 位，加上BP 的内容，再减去偏移量2 以形成物理地址。这样一来，在保持基址寄存器BP 内容不变的情况下，就可以访问栈中的任何元素。这里，偏移量仅用于在指令执行时形成有效地址，不会改变寄存器BP 的原有内容。

这种增加偏移量的做法也适用于基址寄存器BX。以下代码是前面那个批量加一任务的新版本：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00235.jpeg)

以上代码和前一个版本相比，没有太大变化，区别仅仅在于，BX 现在是从0 开始递增的，inc 指令操作数的偏移地址由BX 和标号buffer 所代表的值相加得到。相加操作在指令执行时进行，仅用于形成有效偏移地址，不会影响到BX 寄存器的内容。

3．变址寻址

变址寻址类似于基址寻址，唯一不同之处在于这种寻址方式使用的是变址寄存器（或称索引寄存器）SI 和DI。例如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00236.jpeg)

和基址寻址一样，当带有这种操作数的指令执行时，除非使用了段超越前缀，处理器会访问由段寄存器DS 指向的数据段，偏移地址由寄存器SI 或者DI 提供。

同样地，变址寻址方式也允许带一个偏移量：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00237.jpeg)

以上第二条指令中，尽管使用的是标号，但本质上属于一个编译阶段确定的数值。

4．基址变址寻址

让处理器支持多种寻址方式会增加硬件上的复杂性，但可以增强它的数据处理能力，这么做是值得的。说到数据处理，下面是一个稍微复杂一些的任务：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00238.jpeg)

以上声明了标号“string”并初始化了26 个字节的数据。现在，你的任务是，将这26 字节的数据在原地反向排列。

这个问题不难，所以你可能很快想到使用栈，先将这26 个数据压栈，再反向出栈，因为栈是后进先出的，正好符合要求。代码是这样的（代码段、栈段初始化的代码统统省略）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00239.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00240.jpeg)

这的确是个好办法。不过，8086 处理器也支持一种基址加变址的寻址方式，简称基址变址寻址，可能用起来更方便。

使用基址变址的操作数可以使用一个基址寄存器（BX 或者BP），外加一个变址寄存器（SI 或者DI）。它的基本形式是这样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00241.jpeg)

以上，第一条指令的源操作数采用了基址变址寻址。当处理器执行这条指令时，把数据段寄存器DS 的内容左移4 位，加上基址寄存器BX 的内容，再加上变址寄存器SI 的内容，共同形成20 位的物理地址。然后，从该地址处取得一个字，传送到寄存器AX 中。

第二条指令与第一条指令类似，只不过是加法指令，它的目的操作数采用了基址变址寻址，源操作数采用的是立即寻址。这条指令执行时，处理器访问由段寄存器DS 指向的数据段，加上由BX 和DI 相加形成的偏移地址，共同形成20 位的物理地址，然后将立即数0x3000 加到该地址处的字单元里。

采用基址变址寻址方式的排序代码如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00242.jpeg)

和前面使用栈的代码相比，指令的数量没有明显减少，这说明任务还不够复杂，也许只能这么解释了。但是，它同样很方便，很有效，不是吗？

同样地，基址变址寻址允许在基址寄存器和变址寄存器的基础上带一个偏移量。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00243.jpeg)
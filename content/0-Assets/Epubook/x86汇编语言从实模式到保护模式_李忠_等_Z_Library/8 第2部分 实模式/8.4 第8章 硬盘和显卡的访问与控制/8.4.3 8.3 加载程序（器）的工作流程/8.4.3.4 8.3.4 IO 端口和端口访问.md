### 8.3.4　I/O 端口和端口访问

外围设备和处理器之间的通信是通过相应的I/O 接口进行的。当然，这么说太过于笼统，所以必须具体到细节上来讲这件事。

具体地说，处理器是通过端口（Port）来和外围设备打交道的。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处仅仅在于，这些叫做端口的寄存器位于I/O 接口电路中。

端口是处理器和外围设备通过I/O 接口交流的窗口，每一个I/O 接口都可能拥有好几个端口，分别用于不同的目的。比如，连接硬盘的PATA/SATA 接口就有几个端口，分别是命令端口（当向该端口写入0x20 时，表明是从硬盘读数据；写入0x30 时，表明是向硬盘写数据）、状态端口（处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误）、参数端口（处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号）和数据端口（通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据）。

端口只不过是位于I/O 接口上的寄存器，所以，每个端口有自己的数据宽度。在早期的系统中，端口可以是8 位的，也可以是16 位的，现在有些端口会是32 位的。到底是8 位还是16 位，这是设备和I/O 接口制造者的自由。比如，PATA/STAT 接口中的数据端口就是16 位的，这有助于加快数据传输速率，提高传输效率。

端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的。比如，0x00000～0xE0000 是真实的物理内存地址，而0xE0001～0xFFFFF 是从很多I/O 接口那里映射过来的，当访问这部分地址时，实际上是在访问I/O 接口。

而在另一些计算机系统中，端口是独立编址的，不和内存发生关系。如图8-10 所示，在这种计算机中，处理器的地址线既连接内存，也连接每一个I/O 接口。但是，处理器还有一个特殊的引脚M/IO#，在这里，“#”表示低电平有效。也就是说，当处理器访问内存时，它会让M/IO#引脚呈高电平，这里，和内存相关的电路就会打开；相反，如果处理器访问I/O 端口，那么M/IO#引脚呈低平，内存电路被禁止。与此同时，处理器发出的地址和M/IO#信号一起用于打个某个I/O 接口，如果该I/O 接口分配的端口号与处理器地址相吻合的话。

Intel 处理器，早期是独立编址的，现在既有内存映射的，也有独立编址的。在本章中，我们只讲独立编址的端口。

所有端口都是统一编号的，比如0x0001、0x0002、0x0003、…。每个I/O 接口电路都分配了若干个端口，比如，I/O 接口A 有3 个端口，端口号分别是0x0021～0x0023；I/O 接口B 需要5 个端口，端口号分别是0x0303～0x0307。

一个现实的例子是个人计算机中的PATA/SATA 接口（图8-9），每个PATA 和SATA 接口分配了8个端口。但是，ICH 芯片内部通常集成了两个PATA/SATA 接口，分别是主硬盘接口和副硬盘接口。这样一来，主硬盘接口分配的端口号是0x1f0～0x1f7，副硬盘接口分配的端口号是0x170～0x177。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00268.jpeg)

图8-10　端口的访问和M/IO#引脚

在Intel 的系统中，只允许65536（十进制数）个端口存在，端口号从0 到65535（0x0000～0xffff）。因为是独立编址，所以，端口的访问不能使用类似于mov 这样的指令，取而代之的是in 和out 指令。

in 指令是从端口读，它的一般形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00269.jpeg)

或者

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00270.jpeg)

这就是说，in 指令的目的操作数必须是寄存器AL 或者AX，当访问8 位的端口时，使用寄存器AL；访问16 位的端口时，使用AX。in 指令的源操作数应当是寄存器DX。

in al,dx 的机器指令码是0xEC，in ax,dx 的机器指令码是0xED，都是一字节的。之所以如此简短，是因为in 指令不允许使用别的通用寄存器，也不允许使用内存单元作为操作数。

也许是为了方便，in 指令还有两字节的形式。此时，前一字节是操作码0xE4 或者0xE5，分别用于指示8 位或者16 位端口访问；后一字节是立即数，指示端口号。

因此，机器指令 E4 F0 就相当于汇编语言指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00271.jpeg)

而机器指令E5 03 就相当于汇编语言指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00272.jpeg)

很显然，因为这种指令形式的操作数部分只允许一字节，故只能访问0～255（0x00～0xff）号端口，不允许访问大于255 的端口号。所以，下面的汇编语言指令就是非法的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00273.jpeg)

in 指令不影响任何标志位。

相应地，如果要通过端口向外围设备发送数据，则必须通过out 指令。

out 指令正好和in 指令相反，目的操作数可以是8 位立即数或者寄存器DX，源操作数必须是寄存器AL 或者AX。下面是一些例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00274.jpeg)

和in 指令一样，out 指令不影响任何标志位。
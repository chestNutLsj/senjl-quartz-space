### 8.3.6　过程调用

读写硬盘是经常要做的事，尤其对于操作系统来说。即使是在本章的程序中，也多次发生。如果每次读写硬盘都按上面的5 个步骤写一堆代码，程序势必很大，也会令人烦恼。

好在处理器支持一种叫过程调用的指令执行机制。过程（Procedure）又叫例程，或者子程序、子过程、子例程（Sub-routine），不管怎么称呼，实质都一样，都是一段普通的代码。处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。

如图8-13 所示，这是过程和过程调用的示意图。下面结合本章代码清单来具体说明。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00285.jpeg)

图8-13　过程和过程调用示意图

在8.3.1 节里，我们已经定义了常量app_lba_start，它代表的值是100，也就是用户程序在硬盘上的起始逻辑扇区号。现在，代码清单8-1 的第24～27 行用于从硬盘上读取这个扇区的内容。这很好理解，因为不知道用户程序到底有多大，到底占用了多少个扇区，所以，可以先读它的第一个扇区。该扇区包含了用户程序的头部，而用户程序头部又包含了该程序的大小、入口点和段重定位表。所以，通过分析头部，就知道接着还要再读多少个扇区才能完全加载用户程序。

因为要多次读取硬盘，而每次的步骤又都差不多，所以，我们精心设计了一段通用的代码，它从代码清单8-1 的第79 行开始，一直到第131 行结束，这就是我们所说的过程。

要调用过程，需要该过程的地址。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。所以，代码清单8-1 第79 行是一个标号“read_hard_disk_0”，意思是读（第一个硬盘控制器的）主盘，当然，什么意思并不重要。

编写过程的好处是只用编写一次，以后只需要“调用”即可。所以，代码的灵活性和通用性尤其重要。具体到这里，就是每次读硬盘时的起始逻辑扇区号和数据保存位置都不相同，这就涉及所谓的参数传递。

参数传递最简单的办法是通过寄存器。在这里，主程序把起始逻辑扇区号的高16 位存放在寄存器DI 中（只有低12 位是有效的，高4 位必须保证为“0”），低16 位存放在寄存器SI 中（没办法，16 位的处理器无法直接处理28 位的数据）；并约定将读出来的数据存放到由段寄存器DS 指向的数据段中，起始偏移地址在寄存器BX 中。

在调用过程前，程序会用到一些寄存器，在过程返回之后，可能还要继续使用。为了不失连续性，在过程的开头，应当将本过程要用到（内容肯定会被破坏）的寄存器临时压栈，并在返回到调用点之前出栈恢复。代码清单8-1 的第82～85 行，用于将过程中用到的寄存器入栈保存。

后面的指令都很好理解，第87～89 行，是向0x1f2 端口写入要读取的扇区数。显而易见，每次读的扇区数是1 个。

第91～101 行，用于向硬盘接口写入起始逻辑扇区号的低24 位。低16 位在寄存器SI 中，高12 位在寄存器DI 中，需要不停地倒换到寄存器AL 中，以方便端口写入。

第105 行，程序执行到这里时，寄存器AH 的低4 位是起始逻辑扇区号的27～24 位，高4 位是全“0”；寄存器AL 中是0xe0。执行or 指令后，将会在寄存器AL 中得到它们的组合值，高4位是0xe，低4 位是逻辑扇区号的27～24 位。

第118～124 行，用于反复从硬盘接口那里取得512 字节的数据，并传送到段寄存器DS 所指向的数据区中。每传送一个字，BX 的值就增2，以指向下一个偏移位置。

第126～129 行，用于把调用过程前各个寄存器的内容从栈中恢复。

最后，因为处理器是没有大脑的，所以需要一个明确的指令ret 促使它离开过程，从哪里来回哪里去，这条指令稍后就会讲到。

有关过程的情况就是这些，下面回到前面，看看过程调用是如何发生的。

代码清单8-1 第24、25 行，用于指定用户程序在硬盘上的起始逻辑扇区号。我们定义的过程要求用DI:SI 来提供这个扇区号，既然它是常数100，很小的数值，可以直接传送到寄存器SI，并将DI 清零即可。

第26 行用于指定存放数据的内存地址。前面几条指令已经将段寄存器DS 设置好了，现在只需要将寄存器BX 清零，以指向该段内偏移地址为0 的地方，这就是当前指令要做的事。

一切都准备好了，第27 行，开始调用过程read_hard_disk_0。以后，我们将把过程所在的标号做为过程的名字，即过程名。

调用过程的指令是“call”。8086 处理器支持四种调用方式。

第一种是16 位相对近调用。近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。

16 位相对近调用是三字节指令，操作码为0xE8，后跟16 位的操作数，因为是相对调用，故该操作数是当前call 指令相对于目标过程的偏移量。计算过程如下：用目标过程的汇编地址减去当前call 指令的汇编地址，再减去当前call 指令以字节为单位的长度（3），保留16 位的结果。举个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00286.jpeg)

近调用的特征是在指令中使用关键字“near”。“proc_1”是程序中的一个标号。在编译阶段，编译器用标号proc_1 处的汇编地址减去本指令的汇编地址，再减去3，作为机器指令的操作数。

关键字“near”不是必需的，如果call 指令中没有提供任何关键字，则编译器认为该指令是近调用。因此，上面的指令与这条指令等效：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00287.jpeg)

因为16 位相对近调用的操作数是两个汇编地址相减的相对量，所以，如果被调用过程在当前指令的前方，也就是说，论汇编地址，它比call 指令的要大，那么该相对量是一个正数；反之，就是一个负数。所以，它的机器指令操作数是一个16 位的有符号数。换句话说，被调用过程的首地址必须位于距离当前call 指令－32768～32767 字节的地方。

在指令执行阶段，处理器看到操作码0xE8，就知道它应当调用一个过程。于是，它用指令指针寄存器IP 的当前内容加上指令中的操作数，再加上3，得到一个新的偏移地址。接着，将IP 的原有内容压入栈。最后，用刚才计算出的偏移地址取代IP 原有的内容。这直接导致处理器的执行流转移到目标位置处。

再看一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00288.jpeg)

很多人认为0x0500 会原封不动地出现在该指令编译后的机器码中，我相信这只是他们一时糊涂。在call 指令后跟一个标号，和跟一个数值没有什么不同。标号是数值的等价形式，是代表标号处的汇编地址。在指令编译阶段，它首先会被转化成数值。

所以，你在call 指令后跟一个数值，只是帮了编译器的忙，帮它省了一个转化步骤，它依然会用这个数值减去当前指令的汇编地址，来得到一个偏移量。

第二种是16 位间接绝对近调用。这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。不过，这个偏移地址不是直接出现在指令中，而是由16 位的通用寄存器或者16 位的内存单元间接给出。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00289.jpeg)

以上，第一条指令的机器码为FF D1，被调用过程的偏移地址位于寄存器CX 内，在指令执行的时候由处理器从该寄存器取得，并直接取代指令指针寄存器IP 原有的内容。

第二条指令的机器码为FF 16 00 30。当这条指令执行时，处理器访问数据段（使用段寄存器DS），从偏移地址0x3000 处取得一个字，作为目标过程的真实偏移地址，并用它取代指令指针寄存器IP 原有的内容。

后面两条指令没什么好说的，只是寻址方式不同而已。

间接绝对近调用指令在执行时，处理器首先按以上的方法计算被调用过程的偏移地址，然后将指令指针寄存器IP 的当前值压栈，最后用计算出来的偏移地址取代寄存器IP 原有的内容。

由于间接绝对近调用的机器指令操作数是16 位的绝对地址，因此，它可以调用当前代码段任何位置处的过程。

第三种是16 位直接绝对远调用。这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用（far call）。很容易想到，远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。

“16 位”是针对偏移地址来说的，而不是限定段地址，尽管段地址事实上也是16 位的；“直接”的意思是，段地址和偏移地址直接在call 指令中给出了。当然，这里的地址也是绝对地址。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00290.jpeg)

这条指令编译后的机器码为9A 30 00 00 20，0x9A 是操作码，后面跟着的两个字分别是偏移地址和段地址，按规定，偏移地址在前，段地址在后。

处理器在执行时，首先将代码段寄存器CS 的当前内容压栈，接着再把指令指针寄存器IP 的当前内容压栈。紧接着，用指令中给出的段地址代替CS 原有的内容，用指令中给出的偏移地址代替IP 原有的内容。这直接导致处理器从新的位置开始执行。

处理器是没有脑子的。如果被调用过程位于当前代码段内，而你又用这种指令格式来调用它，那么，处理器也会不折不扣地从当前代码段“转移”到当前代码段。

第四种是16 位间接绝对远调用。这也属于段间调用，被调用过程位于另一个代码段内，而且，被调用过程所在的段地址和偏移地址是间接给出的。还有，这里的“16 位”同样是用来限定偏移地址的。下面是这种调用方式的几个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00291.jpeg)

间接远调用必须使用关键字“far”，这一点务必牢记。

因为是远调用，也就是段间调用，所以，必须给出被调用过程的段地址和偏移地址。但是，段地址和偏移地址在内存中的其他位置，指令中仅仅给出的是该位置的偏移地址，需要处理器在执行指令的时候自行按图索骥，找到它们。

以上，前两条指令是等效的，不同之处仅仅在于，第一条指令直接给出的是数值，而第二条指令用的是标号。但这无关紧要，在编译后，标号也会变成数值。

为了进一步说清间接远调用是怎么发生的，下面是一个实例。

假如在数据段内声明了标号proc_1 并初始化了两个字：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00292.jpeg)

这两个字分别是某个过程的段地址和偏移地址。按处理器的要求，偏移地址在前，段地址在后。也就是说，0x0102 是偏移地址； 0x2000 是段地址。

那么，为了调用该过程，可以在代码段内使用这条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00293.jpeg)

当这条指令执行时，处理器访问由段寄存器DS 指向的数据段，从指令中指定的偏移地址（由标号proc_1 提供）处取得两个字（分别是段地址0x2000 和偏移地址0x0102）；接着，将代码段寄存器CS 和指令指针寄存器IP 的当前内容分别压栈；最后，用刚才取得的段地址和偏移地址分别取代CS 和IP 的原值。

至于后面的两条指令call far [bx]和call far [bx+si]，仅仅是寻址方式上有所区别，指令执行过程大体上是一样的。

接着回到代码清单8-1 第27 行，很明显，

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00294.jpeg)

就是我们刚刚讲的16 位相对近调用，编译后的机器指令操作数是一个相对偏移量。由于这是段内调用，处理器执行这条指令时，用指令指针寄存器IP 的内容加上指令中的偏移量，以及当前指令的长度，算出被调用过程的绝对偏移地址。接着，将IP 的现行值压栈。最后，用刚刚计算出的偏移地址替代IP 的当前内容。

过程read_hard_disk_0 的功能和工作流程前面已经讲过了，不再赘述。这里只关心一个最重要的问题，那就是过程返回。

“过程”就是例行公事，可以随时根据需要调用，但过程执行完了呢，还得返回到调用点继续执行下一条指令，这称为过程返回（Procedure Return）。

处理器是个大笨蛋，你不提醒它，它就一直稀里糊涂地闷头工作。幸好，处理器的发明者们设计了返回指令ret 和retf。

ret 和retf 经常用做call 和call far 的配对指令。ret 是近返回指令，当它执行时，处理器只做一件事，那就是从栈中弹出一个字到指令指针寄存器IP 中。

retf 是远返回指令（return far），它的工作稍微复杂一点点。当它执行时，处理器分别从栈中弹出两个字到指令指针寄存器IP 和代码段寄存器CS 中。

如图8-14 所示，在call read_hard_disk_0 执行前，栈指针位于箭头①所指示的位置；call 指令执行后，由于压入了IP 的内容，故栈指针移动到箭头②所指示的位置处；进入过程后，出于保护现场的目的，压入了4 个通用寄存器AX、BX、CX、DX，此时，栈指针继续向低地址方向推进到箭头③所指示的位置。

在过程的最后，是恢复现场，连续反序弹出4 个通用寄存器的内容。此时，栈指针又回到刚进入过程内部时的位置，即箭头②处。最后，ret 指令执行时，由于处理器自动弹出一个字到IP，故，过程返回后的瞬间，栈指针仍旧回到过程调用前，即箭头①所指示的位置。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00295.jpeg)

图8-14　过程调用前后的栈变化

需要说明的是，尽管call 指令通常需要ret/retf 和它配对，遥相呼应，但ret/retf 指令却并不依赖于call 指令，这一点你马上就会看到。

call 指令在执行过程调用时不影响任何标志位，ret/retf 指令对标志位也没有任何影响。

检测点8.2

按题目的要求写出相应的指令：

1． 调用当前段内标号label_proc 处的过程；

2． 调用当前段内的过程，过程的偏移地址在寄存器BX 中；

3． 调用当前段内的过程，过程的偏移地址保存在当前数据段内由寄存器BX 所指向的内存单元中；

4． 调用过程，过程的段地址为0xf000，偏移地址为0x0002；

5． 调用过程，过程的段地址和偏移地址存放在当前数据段内偏移地址为0x80 的地方，低字是过程的偏移地址，高字为过程的段地址；

6． 调用过程，过程的段地址和偏移地址存放在当前数据段内，低字为过程的偏移地址，高字为过程的段地址，这两个字在当前数据段内的偏移地址可以用BX+DI+0x08 得到。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00296.jpeg)

图8-15　用户程序头部结构示意图
### 8.3.7　加载用户程序

第一次读硬盘将得到用户程序最开始的512 字节，这512 字节包括最开始的用户程序头部，以及一部分实际的指令和数据。

为了将用户程序全部读入内存，需要知道它的大小，然后再进一步转换成它所用的扇区数。如图8-15 所示，用户程序最开始的双字，就是整个程序的大小。

为此，代码清单8-1 第30、31 行，分别将该数值的高16 位和低16 位传送到寄存器DX 和AX。第32 行，因为每扇区有512 字节，故将512 传送到BX 寄存器，并在第33 行用它来做除法运算。

在凑巧的情况下，用户程序的大小正好是512 的整数倍，做完除法后，在寄存器AX 中是用户程序实际占用的扇区数。但是，绝大多数情况下，这个除法会有余数。有余数意味着，最后一个扇区因为没有填满而落下了，没有纳入总扇区数。

关于这个问题，我们稍微解释一下。硬盘的读写是以扇区为单位的，如果要写入513 字节，那么，它将只能填满一个扇区，还剩一字节。硬盘不管这些，它每次总是说：“来，给我512 字节！”为此，软件的责任是，保证给硬盘的是512 字节，如果不够，凑也要凑够。因此，513 字节会占用两个扇区，第二个扇区只有一字节是有用的，其他511 字节都是用来填充的。至于某个扇区里，哪些数据是有用的，哪些是填充的，不是硬盘的责任，是软件的责任。就像本章的用户程序一样，通过构造一个头部，自行来跟踪自己的大小。

所以，代码清单8-1 第34 行，判断是否除尽。如果没有除尽，则转移到后面的代码，去读剩余的扇区；如果除尽了，则总扇区数减一。

为什么？为什么除不尽不管，除尽了还要减一？因为刚才已经预读了一个扇区。

注意，用户程序的长度有可能小于512 字节，或者恰好等于512 字节。在这两种情况下，当程序执行到第38 行时，寄存器AX 中的内容必然为零。所以，第38 行是算术比较指令cmp，第39 行是条件转移指令，当寄存器AX 中的内容为零时，就意味着用户程序已经全部读取，不再继续读了，毕竟用户程序只占用一个扇区，而刚才也已经读过了。

用户程序被加载的位置是由DS 和ES 所指向的逻辑段。一个逻辑段最大也才64KB，当用户程序特别大的时候，根本容纳不下。想想看，段内偏移地址从0x0000 开始，一直延伸到最大值0xffff。再大的话，又绕回到0x0000，以至于把最开始加载的内容给覆盖掉了。

其实，要解决这个问题最好的办法是，每次往内存中加载一个扇区前，都重新在前面的数据尾部构造一个新的逻辑段，并把要读取的数据加载到这个新段内。如此一来，因为每个段的大小是512 字节，即，十六进制的0x200，右移4 位（相当于除以16 或者0x10）后是0x20，这就是各个段地址之间的差值。每次构造新段时，只需要在前面段地址的基础上增加0x20 即可得到新段的段地址。

这种做法好有一比，尺子很短，树很高，想只量一次是不可能的，于是只好分几次量，每量一次，将尺子往下挪一挪。

段地址的改变是临时的，毕竟只是为了读取硬盘，所以，代码清单8-1 第42 行，将当前数据段寄存器DS 的内容压栈保存。

第44 行，将用户程序剩余的扇区数传送到寄存器CX，供后面的loop 指令使用，因为我们准备采用循环的办法来读完用户程序。

第46～48 行，将当前数据段寄存器DS 的内容在原来的基础上增加0x20，以构造出下一个逻辑段，为从硬盘上读取下一个512 字节的数据做准备。

第50 行，将寄存器BX 清零。BX 被用做数据传输时的段内偏移，而且每次传输都是在一个新的段内进行，故偏移地址在每次传输前都应当是零。

第51 行，每次读硬盘前，将寄存器SI 的内容加一，以指向下一个逻辑扇区。

第52～53 行，调用读硬盘的过程read_hard_disk_0，并开始下一轮循环，直到所有的扇区都读完（寄存器CX 的内容为0）。
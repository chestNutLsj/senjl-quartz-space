### 8.3.10　8086 处理器的无条件转移指令

1．相对短转移

相对短转移的操作码为0xEB，操作数是相对于目标位置的偏移量，仅1 字节，是个有符号数。由于这个原因，该指令属于段内转移指令，而且只允许转移到距离当前指令-128～127 字节的地方。相对短转移指令必须使用关键字“short”。例如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00306.jpeg)

在源程序编译阶段，编译器会检查标号infinite 所代表的值，如果数值超过了一字节所能允许的数值范围，则无法通过编译。否则，编译器用目标位置的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（2），保留1 字节的结果，作为机器指令的操作数。

相对短转移指令的汇编语言操作数只能是标号和数值。下面是直接使用数值的情况：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00307.jpeg)

但数值和标号是等价的。在编译阶段，都被用来计算一个8 位的偏移量。

在指令执行时，处理器把指令中的操作数加上2，再加到指令指针寄存器IP 上，这会导致指令的执行流程转向目标地址处。

2．16 位相对近转移

和相对短转移不同，16 位相对近转移指令的转移范围稍大一些。它的机器指令操作码为0xE9，而且，该指令的长度为3 字节，操作码0xE9 后面还有一个16 位（2 字节）的操作数。

因为是近转移，故其属于段内转移。“相对”的意思同样是指它的操作数是一个相对量，是相对于目标位置处的偏移量。在源程序编译阶段，编译器用目标位置的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3），保留16 位的结果，作为机器指令的操作数。由于这是一个16 位的有符号数，故可以转移到距离当前指令-32768～32767 字节的地方。

16 位相对近转移指令应当使用关键字“near”，比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00308.jpeg)

在早先的NASM 版本中，关键字near 是可以省略的。若没有指定short 或者near，那么，编译器自动默认是“near”的。但是最近的版本改变了这一规则。如果没有指定关键字short 或者near，那么，如果目标位置距离当前指令-128～127 字节，则自动采用short；否则，采用near。

3．16 位间接绝对近转移

这种转移方式也是近转移，即只在段内转移。但是，转移到的目标偏移地址不是在指令中直接给出的，而是用一个16 位的通用寄存器或者内存地址来间接给出的。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00309.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00310.jpeg)

指令中的关键字“near”可以省略，间接绝对近转移原本就是near 的。以上两条指令执行时，处理器将用寄存器BX 或者CX 的内容来取代指令指针寄存器IP 的当前内容。

以上是目标偏移地址位于通用寄存器的情况。当然，该偏移地址也可位于内存中，而且这是最常见的情况。假如在某程序的数据段中声明了标号jump_dest 并初始化了一个字：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00311.jpeg)

而且假定我们已经知道它是转移目标的起始偏移地址，那么，在该程序的代码段内，就可以使用以下的16 位间接绝对近转移指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00312.jpeg)

当这条指令执行时，处理器访问由段寄存器DS 指向的数据段，从指令中指定的偏移地址处取得一个字（在这里是0xc000），并用该字取代指令指针寄存器IP 的当前内容。

当然，既然是间接地寻找目标位置的偏移地址，其他寻址方式也是可以的。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00313.jpeg)

注意，jmp bx 和jmp [bx]是完全不同的，不要犯迷糊。前者，要转移的绝对偏移地址位于寄存器BX 中；后者，偏移地址位于由BX 所指向的内存字单元中。

4．16 位直接绝对远转移

很早以前，我们曾经见过这样的指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00314.jpeg)

在这里，0x0000 和0x7c00 分别是段地址和偏移地址，符合“段地址：偏移地址”的表达习惯。在编译之后，其机器指令为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00315.jpeg)

0xEA 是操作码，后面是操作数。注意，字的存放是按照低端字节序的。而且，在编译之后，偏移地址在前，段地址在后。执行这条指令后，处理器用指令中给出的段地址代替段寄存器CS 的原有内容，用给出的偏移地址代替IP 寄存器的原有内容，从而跳转到另一个不同的代码段中，即执行一个段间转移。

像这种直接在指令中给出段地址和偏移地址的转移指令，就是直接绝对远转移指令。“16 位”仅仅用来限定偏移地址部分，指偏移地址是16 位的。

5．16 位间接绝对远转移（jmp far）

远转移的目标地址可以通过访问内存来间接得到，这叫间接远转移，但是要使用关键字“far”。假如在某程序的数据段内声明了标号jump_far，并在其后初始化了两个字：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00316.jpeg)

这不是两个普通的数值，它们分别是某个程序片断的偏移地址和段地址。为了转移到该程序片断上执行，可以在使用下面的转移指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00317.jpeg)

关键字“far”的作用是告诉编译器，该指令应当编译成一个远转移。处理器执行这条指令后，访问段寄存器DS 所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS 和指令指针寄存器IP 的内容。

其实，最好的例子还是本章代码清单8-1 的第76 行：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00318.jpeg)

16 位间接绝对远转移指令的操作数可以是任何一种内存寻址方式。除了上面的例子外，下面再给出几个：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00319.jpeg)

最后，“16 位”的意思是，要转移到的目标位置的偏移地址是16 位的。

检测点8.3

1． 以下指令执行后，寄存器AX 中的内容是多少？

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00320.jpeg)

2．按题目的要求写出相应的指令：

a．无条件转移到当前段内标号label_proc 处；

b．无条件转移到当前段内的另一个位置，偏移地址在寄存器BX 中；

c．无条件转移到当前段内的另一个位置，偏移地址保存在当前附加段内由寄存器BX 所指向的内存单元中；

d．无条件转移，段地址为0xf000，偏移地址为0x0002；

e．无条件转移，段地址和偏移地址存放在当前数据段内偏移地址为0x80 的地方，低字是目标处的偏移地址，高字为目标处段地址；

f．无条件转移，段地址和偏移地址存放在当前附加段内，低字为目标的偏移地址，高字为目标的段地址，这两个字在当前附加段内的偏移地址可以用BX+DI+0x08 得到。
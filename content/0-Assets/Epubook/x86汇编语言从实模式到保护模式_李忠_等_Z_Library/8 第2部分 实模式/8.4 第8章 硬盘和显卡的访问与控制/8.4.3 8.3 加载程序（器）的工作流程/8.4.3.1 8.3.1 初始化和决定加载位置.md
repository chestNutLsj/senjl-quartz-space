### 8.3.1　初始化和决定加载位置

从大的方面来说，加载器要加载一个用户程序，并使之开始执行，需要决定两件事。第一，看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序；第二，用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。如果你连它在哪里都不知道，怎么找得到它呢！

现在，让我们把目光转移到代码清单8-1，来看看加载器都做了哪些工作。

代码清单8-1 第6 行，加载器程序的一开始声明了一个常数（const）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00258.jpeg)

常数是用伪指令equ 声明的，它的意思是“等于”。本语句的意思是，用标号app_lba_start 来代表数值100，今后，当我们要用到100 的时候，不这样写：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00259.jpeg)

而是这样写：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00260.jpeg)

你可能会说，这样不是更麻烦吗？

不会的，实际上这很方便。用某些教材上的话说，程序中不该使用“不可思议的数”。想想看，如果在程序中的多个地方直接使用数值100，那么，以后要修改它们，把它们改成500，还得找到所有使用这个数值的位置，一一修改，万一漏掉一个呢？如果使用常量app_lba_start，则只需要重新把这个常数的声明语句改成下面的形式，并重新编译即可。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00261.jpeg)

图8-7　可用于加载用户程序的空间范围

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00262.jpeg)

常数的意思是在程序运行期间不变的数。和其他伪指令db、dw、dd 不同，用equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。它仅仅代表一个数值，就这么简单。

加载用户程序需要确定一个内存物理地址，这是在代码清单8-1 第151 行用伪指令dd 声明的，并初始化为0x10000 的。和前面一样，是用32 位的单元来容纳一个20 位的地址：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00263.jpeg)

尽管我们用了一个好看的数0x10000，但你完全可以把用户程序加载到其他地方，只要它是空闲的。比如，可以将这个数值改成0x12340，唯一的要求是该地址的最低4 位必须是0，换句话说，加载的起始地址必须是16 字节对齐的，这样将来才能形成一个有效的段地址。

如图8-7 所示，物理地址0x0FFFF 以下，是加载器及其栈的势力范围；物理地址A0000 以上，是BIOS 和外围设备的势力范围，有很多传统的老式设备将自己的存储器和只读存储器映射到这个空间。

如此一来，可用的空间就位于0x10000～9FFFF，差不多500 多KB。事实上，如果将低端的内存空间合理安排一下，还可以腾出更多空间，但是没有必要，我们用不了多少。
### 8.3.2　准备加载用户程序

和以往不同，我们将主引导扇区程序定义成一个段。代码清单8-1 第9 行：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00264.jpeg)

整个程序只定义了这一个段，所以它略显多余。之所以这么说，是因为，即使你不定义这个段，编译器也会自动把整个程序看成一个段。

但是，因为该定义中有“vstart=0x7c00”子句，所以，它就不那么多余了。一旦有了该子句，段内所有元素的汇编地址都将从0x7c00 开始计算。否则，因为主引导程序的实际加载地址是0x0000:0x7c00，当我们引用一个标号时，还得手工加上那个落差0x7c00。

代码清单8-1 第12～14 行，用于初始化栈段寄存器SS 和栈指针SP。之后，栈的段地址是0x0000，段的长度是64KB，栈指针将在段内0xFFFF 和0x0000 之间变化。

代码清单8-1 第16、17 行，用于取得一个地址，用户程序将要从这个地址处开始加载。

该地址实际上是保存在标号phy_base 处的一个双字单元里。这是一个32 位的数，在16 位的处理器上，只能用两个寄存器存放。如图8-8 所示，32 位数内存中的存放是按低端序列的，高16位处在phy_base＋0x02 处，可以放在寄存器DX 中；低16 位处在phy_base 处，可以用寄存器AX存放。

这两条指令中都使用了段超越前缀“cs:”。这是允许的，意味着在访问内存单元时，使用CS的内容作为段基址。之所以没有使用DS 和ES，是因为它们另有安排。

另外注意，因为段寄存器CS 的内容是0x0000，而且主引导扇区是位于0x0000:0x7c00 处的，所以，理论上指令中的偏移地址应当是0x7c00＋phy_base。不过，因为我们定义段mbr 的时候，使用了“vstart=0x7c00”子句，故段内所有汇编地址都是在0x7c00 的基础上增加的，就不用再加上这个0x7c00 了，直接是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00265.jpeg)

图8-8　获取用于加载用户程序的物理地址

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00266.jpeg)

紧接着，代码清单8-1 第18～21 行，用于将该物理地址变成16 位的段地址，并传送到DS 和ES 寄存器。因为该物理地址是16 字节对齐的，直接右移4 位即可。实际上，右移4 位相当于除以16（0x10），所以程序中的做法将这个32 位物理地址（DX:AX）除以16（在寄存器BX 中），寄存器AX 中的商就是得到的段地址（在本程序中是0x1000）。
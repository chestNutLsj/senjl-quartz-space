### 8.3.8　用户程序重定位

用户程序在编写的时候是分段的。因此，加载器下一步的工作是计算和确定每个段的段地址。

如图8-16 所示，用户程序定义了6 个段，在编译阶段，编译器为每个段计算了一个汇编地址。第一个段header 位于整个程序的开头，所以其汇编地址为0。从第二个段开始，每个段的汇编地址都是其相对于整个程序开头的偏移量，以字节为单位。因为我们不知道各个段的汇编地址到底是多少，故用字母来表示。这样，第二个段code_1 的汇编地址是v，第三个段code_2 的汇编地址是w，……，最后一个段stack 的汇编地址是z。

现在，用户程序已经全部加载到内存里了，而且是从物理地址phy_base 开始的。如此一来，每个段在内存中的物理地址都是基于phy_base 的，第一个段header 在内存中的起始物理地址是phy_base（phy_base+0），第二个段在内存中的起始物理地址是phy_base+v，……，最后一个段stack 则是phy_base+z。

用于加载用户程序的物理地址phy_base 是16 字节对齐的，而用户程序中，每个段的汇编地址也是16 字节对齐的。因此，每个段在内存中的起始地址也是16 字节对齐的，将它们分别右移4位，就是它们各自的逻辑段地址。

为此，代码清单8-1 第55 行，从栈中恢复数据段寄存器DS 的内容，使其指向用户程序被加载的起始位置，也就是用户程序头部。

第58～62 行用于重定位用户程序入口点的代码段。请参考图8-15，用户程序头部内，偏移为0x06 处的双字，存放的是入口点代码段的汇编地址。加载器首先将高字和低字分别传送到寄存器DX 和AX，然后调用过程calc_segment_base 来计算该代码段在内存中的段地址。

过程calc_segment_base（计算段基址）是在代码清单8-1 的第134 行定义的。它接受一个32位的汇编地址（位于寄存器DX:AX 中），并在计算完成后向主程序返回一个16 位的逻辑段地址（位于寄存器AX 中）。

因为计算过程中要破坏寄存器DX 的内容，因此，第137 行用于将其压栈保存。

在16 位的处理器上，每次只能进行16 位数的运算。第139 行，先将用户程序在内存中物理起始地址的低16 位加到寄存器AX 中。该指令的地址部分使用了段超越前缀“cs:”，而且也没有加上0x7c00。原因前面已经解释过了，在本程序中，数据段和代码段是分离的，而且当前代码段的定义部分使用了“vstart=0x7c00”子句。

然后，第140 行，再将该起始地址的高16 位加到寄存器DX 中。adc 是带进位加法，它将目的操作数和源操作数相加，然后再加上标志寄存器CF 位的值（0 或者1）。这样，分两步就可以完成32 位数的加法运算。

现在，我们已经在DX:AX 中得到了入口点代码段的起始物理地址，只需要将这个32 位数右移4 位即可得到逻辑段地址。麻烦在于它们分别在两个寄存器中，如何移动？

答案是分别移动，然后拼接。代码清单8-1 第141 行，使用逻辑右移指令shr（SHift logical Right）将寄存器AX 中的内容右移4 位。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00297.jpeg)

图8-16　段的偏移地址和它在内存中的物理地址

如图8-17 所示，逻辑右移指令执行时，会将操作数连续地向右移动指定的次数，每移动一次，“挤”出来的比特被移到标志寄存器的CF 位，左边空出来的位置用比特“0”填充。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00298.jpeg)

图8-17　逻辑右移示意图

shr 指令的目的操作数可以是8 位或16 位的通用寄存器或者内存单元，源操作数可以是数字1、8 位立即数或者寄存器CL。我们已经介绍过寻址方式，往后，我们要用新的方法来表示指令的格式。就当前指令来说，该指令的格式为：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00299.jpeg)

以上，第一种指令格式的意思是，目的操作数可以是8 位寄存器，或者8 位的内存单元；源操作数是1。对于内存地址的情况，可以使用任何一种我们讲过的内存寻址方式。举三个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00300.jpeg)

第二种指令格式和第一种相似，只是目的操作数的长度不一样。注意，源操作数为1 的逻辑右移指令是特殊设计的优化指令，比如以上的shr ax,1，它的机器码是D1 E8；而类似的指令shr ax,5 则拥有完全不同的机器码C1 E8 05。

第三种指令格式的意思是，目的操作数可以是8 位寄存器，或者8 位的内存单元；源操作数是8 位立即数。下面是两个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00301.jpeg)

第四种指令格式和第二种类似，只是数据宽度不同。

第五种指令格式的目的操作数可以是8 位的寄存器，或者8 位的内存单元；源操作数在寄存器CL 中。如果shr 指令的源操作数是寄存器，则只能使用CL。和一般的指令不同，寄存器CL 只用来提供移动次数，而不用于限定和暗示目的操作数的字长。因此，对于目的操作数是内存地址的情况，必须用关键字byte 或者word 等来加以限定。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00302.jpeg)

最后一种指令格式适用于目的操作数的长度为字的情况。

注意，和8086 处理器不同，80286 之后的IA-32 处理器在执行本指令时，会先将源操作数的高3 位清零。也就是说，最大的移位次数是31。

shr 的配对指令是逻辑左移指令shl（SHift logical Left），它的指令格式和shr 相同，只不过它是向左移动。

尽管DX:AX 中是32 位的用户程序起始物理内存地址，理论上，它只有20 位是有效的，低16位在寄存器AX 中，高4 位在寄存器DX 的低4 位。寄存器AX 经右移后，高4 位已经空出，只要将DX 的最低4 位挪到这里，就可以得到我们所需要的逻辑段地址。为此，可以使用以下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00303.jpeg)

很显然，代码清单8-1 并不是这么做的，为的是演示另一个不同的指令ror（第142 行），也就是循环右移（ROtate Right）。如图8-18 所示，循环右移指令执行时，每右移一次，移出的比特既送到标志寄存器的CF 位，也送进左边空出的位。

ror 的配对指令是循环左移指令rol（ROtate Left）。ror、rol、shl、shr 的指令格式都是相同的。

因为是循环移位，移位后，寄存器DX 的低12 位是我们不需要的。所以，代码清单8-1 的第143 行，用and 指令将其清零。

第144 行，正式将寄存器AX 和DX 的内容合并，这就是我们要的段地址。

过程的最后，第146～148 行，恢复寄存器DX 的原始内容，并返回到调用程序那里。

现在，回到代码清单8-1 的第62 行，那条指令的功能是将刚刚计算出来的逻辑段地址回写到原处，仅覆盖低16 位，高16 位不用理会。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00304.jpeg)

图8-18　循环右移示意图

现在仅仅是处理了入口点代码段的重定位，下面开始正式处理用户程序的所有段，它们位于用户程序头部的段重定位表中。

重定位表的表项数存放在用户程序头部偏移0x0a 处，如图8-5 所示。代码清单8-1 第65 行，用于将它从该内存地址处传送到寄存器CX，供后面的循环指令使用。

段重定位表的首地址存放在用户程序头部偏移0x0c 处，因此，第66 行，将0x0c 传送到基址寄存器BX 中。以后，每次只要将BX 的内容加上4，就指向下一个重定位表项。

第68～74 行是循环体，每次循环开始后，BX 总是指向需要重定位的段的汇编地址，而且都是双字，需要分别传送到寄存器DX 和AX。然后调用过程calc_segment_base 计算相应的逻辑段地址，并覆盖到原来的位置（低字），最后将基址寄存器的内容加上4 ，以指向下一个表项。当寄存器CX 的内容为0 时，循环结束，所有的段都处理完毕。
### 8.4.1　初始化段寄存器和栈切换

现在轮到用户程序在处理器上执行了。

用户程序的入口点在代码清单8-2 的第135 行。因为加载器已经完成了重定位工作，所以用户程序的头等大事是初始化处理器的各个段寄存器DS、ES、SS，以便访问专属于自己的数据。段寄存器CS 就不用初始化了，那是加载器负责做的事。要不然用户程序怎么可能执行呢。

在刚刚进入用户程序时，段寄存器DS 和ES 依然指向段header，而栈段寄存器SS 依然指向加载器的栈空间。代码清单8-2 的第137、138 行，用于从头部取得用户程序自己的栈段的段地址，并传送到段寄存器SS 中。

第139 行，将标号stack_end 所代表的数值传送到栈指针寄存器SP。该标号是在第205 行声明的，在它的前面，是伪指令resb，用来保留256 字节的栈空间。

伪指令resb（REServe Byte）的意思是从当前位置开始，保留指定数量的字节，但不初始化它们的值。在源程序编译时，编译器会保留一段内存区域，用来存放编译后的内容。当它看到这条伪指令时，它仅仅是跳过指定数量的字节，而不管里面的原始内容是什么。内存是反复使用的，谁也无法知道以前的使用者在这里留下了什么。也就是说，跳过的这段空间，每个字节的值是不确定的。

因此，

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00321.jpeg)

将在编译后的内容中保留256 字节。resb 不是唯一用来声明未初始化数据的指令。以下是另外一些：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00322.jpeg)

栈段stack 的定义中有“vstart=0”子句，保留的256 字节，其汇编地址分别是0～255。所以，标号stack_end 处的汇编地址实际上是256。也就是说，代码清单8-2 的第139 行和以下指令等价：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00323.jpeg)

栈切换完毕之后，第141、142 行，从用户程序头部取得数据段data_1 的段地址，传送到段寄存器DS 中。从此，DS 不再指向段header，不能再用它访问用户程序头部了。

据此也可以看出，各个段寄存器的初始化顺序很重要。如果先初始化数据段和附加段，那么，段header 中的数据将无法访问。
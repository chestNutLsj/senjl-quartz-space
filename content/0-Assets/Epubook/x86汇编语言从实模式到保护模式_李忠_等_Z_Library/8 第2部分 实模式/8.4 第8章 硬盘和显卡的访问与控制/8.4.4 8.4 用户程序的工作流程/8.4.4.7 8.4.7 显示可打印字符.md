### 8.4.7　显示可打印字符

下面开始正常显示可打印字符。

第81、82 行，将附加段寄存器ES 设置为指向显存。注意，在过程开始处，已经将ES 的内容压栈保存了，这里可以随意使用该寄存器。

标准模式下，屏幕上可以同时显示2000 个字符。光标占用一个字符的位置，但整个屏幕只有一个，只能出现在2000 个字符位置中的一个上。典型地，程序员要用光标位置来记载和跟踪下一个字符应当显示在什么位置。光标用来指示字符位置，而一个字符在显存中对应两个字节。如此一来，可以将光标位置乘以2，来得到该位置（字符）在显存中的偏移地址。

第83 行，将寄存器BX 的内容逻辑左移1 次，这相当于将其乘以2。毕竟只是乘以2，而且BX 中的数值不大，这样做，比使用乘法指令mul 来得方便。

第84 行，用BX 的内容作为偏移地址，来访问段寄存器ES 所指向的显存，来写入要显示的字符。你可能觉得奇怪，为什么后面没有写显示属性字节。原因很简单，在写入其他内容之前，显存里全是黑底白字的空白字符，所以不需要重写黑底白字的属性。过程put_char 是以黑底白字来显示字符的。

第87、88 行，将寄存器BX 的内容除以2，恢复它的光标位置身份。接着，将其增加1（在数值上，将光标推进到下一个位置，毕竟还没开始设置光标呢）。指令shr 是已经讲过的逻辑右移指令，相当于除以2。

不管是换行，还是正常显示字符后推进光标，都会使寄存器BX 的内容超过1999。下面，就来判断这个情况，并决定是否滚动屏幕内容。
### 8.4.6　处理回车和换行字符

过程put_char 仅接受一个寄存器参数CL，用于提供要显示的ASCII 码。常规字符和回车、换行符将不同对待，为此，需要首先别出它们。

代码清单8-2 第65、66 行，先判断是不是回车符0x0d。如果是的话，继续往下执行，如果不是，则转移到标号.put_0a 处执行。

先来看看如果是0x0d 的情况。

如果是回车符0x0d，那么，应将光标移动到当前行的行首。每行有80 个字符，那么，用当前光标位置除以80，余数不要，就可以得到当前行的行号。接着，再乘以80，就是当前行行首的光标数值。

很好，代码清单8-2 第67～69 行，用寄存器AX 中的光标位置除以寄存器BL 中的80，在AL 中得到的是当前行的行号。

接着，第70、71 行，将寄存器AL 中的内容乘以寄存器BL 中的80，会在寄存器AX 中得到当前行行首的光标值。该值依然传送到寄存器BX 中保存。

和div 指令相反，mul 是乘法指令，格式如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00326.jpeg)

以上，“r”表示通用寄存器，“m”表示内存单元。就是说，mul 指令可以用8 位的通用寄存器或者内存单元中的数和寄存器AL 中的内容相乘，结果是16 位，在AX 寄存器中；也可以用16位的通用寄存器或者内存单元中的数和寄存器AX 中的内容相乘，结果是32 位，高16 位和低16位分别在DX 和AX 中。

举几个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00327.jpeg)

mul 指令执行后，要是结果的高一半为全0，则OF 和CF 清零，否则置1。对SF、ZF、AF 和PF 标志的影响未定义。

第72 行，转移到标号.set_cursor 处设置光标在屏幕上的位置。

如果要显示的字符不是0x0d，那么，它有可能是0x0a，或者是正常的可打印字符。这里的“打印”，可以理解为在屏幕上打印。

为此，第75～77 行，先判断是不是0x0a，如果不是，那就转移到标号.put_other 处，去正常显示可打印字符。如果是，那么，换行的意图是向下挪一行，只需要将寄存器BX 的内容增加80，即可得到新的光标位置数据。但是，不像回车，如果光标原先就在屏幕最后一行，那么，换行之后，会怎样呢？所以，第78 行，立即转移到标号.roll_screen 处执行。在那里，将根据情况决定是否需要滚屏。
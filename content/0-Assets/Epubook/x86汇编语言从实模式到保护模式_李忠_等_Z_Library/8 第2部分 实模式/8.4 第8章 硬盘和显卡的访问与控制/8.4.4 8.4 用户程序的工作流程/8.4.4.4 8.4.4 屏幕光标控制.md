### 8.4.4　屏幕光标控制

过程put_char 用于显示一个字符。但它与常规方法的不同之处在于，它能判断回车和换行，还能在超过屏幕上最后一行的时候上滚内容，就是我们经常说的卷屏或者滚屏。除此之外，它还使用了光标跟随技术。

光标（Cursor）是在屏幕上有规律地闪动的一条小橫线，通常用于指示下一个要显示的字符位置，这对很多年龄比较大的人来说很熟悉（前提是他们以前也用过计算机）。在那个时代，还没有基于图形显示技术的Windows，所有的软件都在文本模式下工作，而基于硬件的光标只在文本模式下才会出现。

计算机技术发展得很快，很多硬件都已经或者即将淘汰，但显卡是个例外。即使是现在，多年前形成的VGA 显示标准在每块显卡中都完好地保留下来了，包括对光标的支持。原因很简单，在显卡中集成一块支持128 个ASCII 代码的字符发生器非常方便，在程序中显示一个字符也只要给出它的ASCII 码。显示图形的代价太大，在计算机加电启动的时候，以及其他一些根本没必要、也没条件使用图形模式的场合，这是最好的选择。

光标在屏幕上的位置保存在显卡内部的两个光标寄存器中，每个寄存器是8 位的，合起来形成一个16 位的数值。比如，0 表示光标在屏幕上第0 行第0 列，80 表示它在第1 行第0 列，因为标准VGA 文本模式是25 行，每行80 个字符。这样算来，当光标在屏幕右下角时，该值为25× 80－1=1999。

光标寄存器是可读可写的。你可以从中读出光标的位置，也可以通过它设置光标的位置。能够通过写入一个数值来设定光标的位置，这不是恩赐，而是责任，因为显卡从来不自动移动光标位置，这个任务是你的。现在你总算明白为什么它是可写的了吧？
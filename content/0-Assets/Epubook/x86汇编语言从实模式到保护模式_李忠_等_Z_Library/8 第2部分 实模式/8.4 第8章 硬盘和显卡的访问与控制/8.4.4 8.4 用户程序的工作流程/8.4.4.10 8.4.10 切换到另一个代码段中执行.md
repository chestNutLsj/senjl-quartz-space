### 8.4.10　切换到另一个代码段中执行

在一个程序中，对段的数量没有限制。可以有多个代码段和多个数据段，甚至可以有多个栈段。在用户程序工作时，可以从一个代码段转到另一个代码段中执行，也可以根据需要，访问不同的数据段。

我们知道，ret 和retf 指令分别用于近返回和远返回。人类最大的问题就是思维有定势，有时候不够开阔。尽管说是“返回”，但最重要的还是弄清它的原理和本质，才能灵活运用。

返回指令的动作是从栈中弹出内容到指令指针寄存器IP，如果是远返回的话，还要接着弹出内容到代码段寄存器CS。假如在此之前，栈顶的内容并非是用于返回的偏移地址和段地址，那么处理器当时就会傻了。

还是回到正题上来。假如要想切换到另一个代码段中执行，可以使用远调用指令（call far）或者远转移指令（jmp far），这是最正常不过的途径了。

问题在于，为了实现段间控制转移，必须事先开辟两个连续的内存单元，存放另一个代码段的入口点偏移地址和段地址，代价似乎有点高，这么做好像不太值得。

为了省事，可以使用指令retf 来模拟段间返回，以实现段间转移。代码清单8-2 第147 行，先在栈中压入代码段code_2 的段地址；接着，第148、149 行，压入偏移地址，该偏移地址就是标号begin 在编译阶段的汇编地址。8086 处理器不能在栈中压入立即数，所以只能通过寄存器AX来间接做这件事，现在的处理器都支持压入立即数：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00328.jpeg)

当然，这是后话。

第151 行，当处理器执行指令retf 时，这个被蒙在鼓里的家伙从栈中将偏移地址和段地址分别弹出到代码段寄存器CS 和指令指针寄存器IP，于是控制立即转移到段code_2 中，从标号begin处开始执行。

这段代码很好地证明了，尽管call 和call far 指令分别依赖于ret 和retf 指令，但后者却并不依赖于前者。它们经常在一起，但并不是夫妻。
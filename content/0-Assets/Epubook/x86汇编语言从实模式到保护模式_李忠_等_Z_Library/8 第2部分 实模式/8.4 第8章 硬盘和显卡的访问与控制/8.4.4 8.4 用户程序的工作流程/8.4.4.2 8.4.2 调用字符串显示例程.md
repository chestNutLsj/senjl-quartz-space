### 8.4.2　调用字符串显示例程

紧接着，用户程序要在屏幕上显示东西了。

要显示的内容位于段data_1 中，该段当前正由段寄存器DS 指向。代码清单8-2 第175 行，声明了标号msg0 并初始化了一大堆字符。当然，因为字符太多，行太长，而我们还想能大致“看”到显示效果，所以分成了多行来初始化。

为太长的行使用续行符“\”当然是一个好主意，不过我们现在的做法是将太长的行分成几段，分别用伪指令db 来初始化。在编译之后，它们仍然是紧挨在一起的，可以用唯一的标号msg0 来引用。

在屏幕上显示字符，所做的仅仅是填充显存，只要所填充的内容不超过一屏所能显示的字符数，其他的事不需要你操心。当字符在一行上显示不下时，显示系统会自动移到下一行接着显示，这也和你无关。

不过，有时候我们希望有自行换行的能力，而不管那一行是否已经到头（屏幕最右边）。这么做的目的通常是用来格式化文本段落。

再来回顾一下ASCII 码。在128 个ASCII 代码中，大部分是可显示和打印的字符，还有一部分用于控制显示和打印那些字符的设备。比如0x0d 是回车，0x0a 是换行。

回车和换行的概念最早起源于老式打字机。那种打字机上有滚筒，用于使纸张上下卷动，每敲击一个按键，字车往右移动一格，位于下一个可打印的位置。在这种古老而不失先进性的设备上，将字车推到最左边，也就是一行的开始，叫做回车（Carriage Return）；而拧一下滚筒，将纸上卷一行，叫做换行（Line Feed）。如果既回车，又换行，那么，字车将位于下一行的行首。这个过程通常叫做回车换行（CRLF）。

在刚刚有了电子计算机的时候，因为它又大又贵，只能通过远程终端来分享它的计算能力。这时候，用的是电传打字机，不需要人工操作即可显示和打印字符。当然，根据需要随时回车换行还是需要的。怎么办？那就是用ASCII 码中的控制字符来命令电传打字机来做这件事。不知怎么回事，回车分配的ASCII 码是0x0d，换行分配的则是0x0a。奇怪吗？没什么好奇怪的。

在个人计算机时代，为了在屏幕上显示字符，ASCII 码也被引入显示系统。不过，当我们向显存里写入0x0d 和0x0a 时，并不起任何作用，也没有任何效果，没有任何硬件对解释它们的意义负责。不过无所谓，对回车换行代码的解释可以由我们自己负责，现在所要做的，就是在字符串中，需要回车换行的地方按照老传统插入这两个代码。

正是由于以上的原因，在代码清单8-2 的第175～191 行，凡是需要回车换行的地方，都使用了0x0d 和0x0a。而且，在第191 行，也就是所有要显示内容最后，是数值0，用来标志字符串的结束，这样的字符串称为是0 终止的字符串，在高级语言里经常使用。

段data_1 的定义中包括“vstart=0”子句，故标号msg0 的汇编地址是从该段的起始处（0）开始计算的。代码清单8-2 的第144、145 行，将该字符串的偏移地址传送到基址寄存器BX，并调用过程put_string。
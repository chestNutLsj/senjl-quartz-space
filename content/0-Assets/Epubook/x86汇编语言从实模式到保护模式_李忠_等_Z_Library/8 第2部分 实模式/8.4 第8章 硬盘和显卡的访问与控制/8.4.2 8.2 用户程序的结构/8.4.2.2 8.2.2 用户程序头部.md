### 8.2.2　用户程序头部

在上面，我们已经知道如何在用户程序中分段，也知道各种段定义子句对段的起始汇编地址和段内汇编地址的影响。现在，让我们结合本章中的实例来进一步加深认识。

浏览一下本章代码清单8-2，你会发现，本章的用户程序实际上定义了7 个段，分别是第7行定义的段header、第27 行定义的段code_1、第163 行定义的段code_2、第173 行定义的段data_1、第194 行定义的段data_2、第201 行定义的段stack 和第208 行定义的段trail。

一般来说，加载器和用户程序是在不同的时间、不同的地方，由不同的人或公司开发的。这就意味着，它们彼此并不了解对方的结构和功能。事实上，也不需要了解。

如图8-5 所示，它们彼此看对方都是一个黑盒子，并不了解对方是怎么编写的，是做什么的。但是，也不能完全是黑的，加载器必须了解一些必要的信息，虽然不是很多，但足以知道如何加载用户程序。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00253.jpeg)

图8-5　加载器与用户程序之间的协议部分示意图

这就涉及加载器的编写者，以及用户程序的编写者，他们之间是怎么协商的。他们之间必须有一个协议，或者说协定，比如说，在用户程序内部的某个固定位置，包含一些基本的结构信息，每个用户程序都必须把自己的情况放在这里，而加载器也固定在这个位置读取。经验表明，把这个约定的地点放在用户程序的开头，对双方，特别是对加载器来说比较方便，这就是用户程序头部。

头部需要在源程序以一个段的形式出现。这就是代码清单8-2 的第7 行：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00254.jpeg)

而且，因为它是“头部”，所以，该段当然必须是第一个被定义的段，且总是位于整个源程序的开头。

用户程序头部起码要包含以下信息。

① 用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区（在本书中，所有程序在硬盘上所占用的逻辑扇区都是连续的）。

代码清单8-2 中第8 行，伪指令dd 用于声明和初始化一个双字，即一个32 位的数据。用户程序可能很大，16 位的长度不足以表示65535 以上的数值。

程序的长度取自程序中的一个标号“program_end”，这是允许的。在编译阶段，编译器将该标号所代表的汇编地址填写在这里。该标号位于整个源程序的最后，从属于段“trail”。由于该段并没有vstart 子句，所以，标号“program_end”所代表的汇编地址是从整个程序的开头计算的。换句话说，program_end 所代表的汇编地址，在数值上等于整个程序的长度。

双字在内存中的存放也是按低端序的。如图8-6 所示，低字保存在低地址，高字保存在高地址。同时，每个字又按低端字节序，低字节在低地址，高字节在高地址。

② 应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位置。因此，必须在头部给出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点（Entry Point）。

理想情况下，当用户程序开始运行时，执行的第一条指令是其代码段内的第一条指令。换句话说，入口点位于其代码段内偏移地址为0 的地方。但是，情况并非总是如此。尤其是，很多程序并非只有一个代码段，比如本章源代码清单8-2 就包含了两个代码段。所以，需要在用户程序头部明确给出用户程序在刚开始运行时，第一条指令的位置，也就是第一条指令在用户程序代码段内的偏移地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00255.jpeg)

图8-6　双字数据在内存中的布局

代码清单8-2 第11、12 行，依次声明并初始化了入口点的偏移地址和段地址。偏移地址取自代码段code_1 中的标号“start”，段地址是用表达式section.code_1.start 得到的。

代码段code_1 是在代码清单8-2 的第27 行定义的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00256.jpeg)

显而易见的是，因为段定义中包含了“vstart=0”子句，故标号start 所代表的汇编地址是相对于当前代码段code_1 的起始位置，从0 开始计算的。

入口点的段地址是用伪指令dd 声明的，并初始化为汇编地址section.code_1.start，这是一个32 位的地址。不过，它仅仅是编译阶段确定的汇编地址，在用户程序加载到内存后，需要根据加载的实际位置重新计算（浮动）。

尽管在16 位的环境中，一个段最长为64KB，但它却可以起始于任何20 位的物理地址处。你不可能用16 位的单元保存20 位的地址，所以，只能保存为32 位的形式。

③ 段重定位表。用户程序可能包含不止一个段，比较大的程序可能会包含多个代码段和多个数据段。这些段如何使用，是用户程序自己的事，但前提是程序加载到内存后，每个段的地址必须重新确定一下。

段的重定位是加载器的工作，它需要知道每个段在用户程序内的位置，即它们分别位于用户程序内的多少字节处。为此，需要在用户程序头部建立一张段重定位表。

用户程序可以定义的段在数量上是不确定的，因此，段重定位表的大小，或者说表项数是不确定的。为此，代码清单8-2 第14 行，声明并初始化了段重定位表的项目数。因为段重定位表位于两个标号header_end 和code_1_segment 之间，而且每个表项占用4 字节，故实际的表项数为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00257.jpeg)

这个值是在程序编译阶段计算的，先用两个标号所代表的汇编地址相减，再除以每个表项的长度4。

紧接着表项数的，是实际的段重定位表，每个表项用伪指令dd 声明并初始化为1 个双字。代码清单8-2 一共定义了5 个段，所以这里有5 个表项，依次计算段开始汇编地址的表达式并进行初始化。
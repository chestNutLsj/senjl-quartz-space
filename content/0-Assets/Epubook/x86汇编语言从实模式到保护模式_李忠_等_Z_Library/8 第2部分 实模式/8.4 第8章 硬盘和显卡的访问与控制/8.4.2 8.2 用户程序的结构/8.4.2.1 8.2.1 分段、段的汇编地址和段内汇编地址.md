### 8.2.1　分段、段的汇编地址和段内汇编地址

处理器的工作模式是将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址：偏移地址”的方式进行。相对应地，一个规范的程序，应当包括代码段、数据段、附加段和栈段。这样一来，段的划分和段与段之间的界限在程序加载到内存之前就已经准备好了。

和我们以前编写的源程序不同，代码清单8-2 很长。当然，真正的不同之处在于，代码和数据是以段的形式组织的。当然，因为清单很长，看起来并不是非常明显。为了清楚起见，图8-1给出了整个源程序的组织结构。

NASM 编译器使用汇编指令“SECTION”或者“SEGMENT”来定义段。它的一般格式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00245.jpeg)

或者

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00246.jpeg)

每个段都要求给出名字，这就是段名称，它主要用来引用一个段，可以是任意名字，只要它们彼此之间不会重复和混淆。

NASM 编译器不关心段的用途，可能也根本不知道段的用途，不知道它是数据段，还是代码段，或是栈段。事实上，这都不重要，段只用来分隔程序中的不同内容。

不过，话又说回来了，作为程序员，每个段的用途，你自己是清楚的。所以，为每个段起一个直观好记的名字，那是应该的。如图8-1 所示，第一个段的名字是“header”，表明它是整个程序的开头部分；第二个段的名字是“code”，表明这是代码段；第三个段的名字是“data”，表明这是数据段。

比较重要的是，一旦定义段，那么，后面的内容就都属于该段，除非又出现了另一个段的定义。另外，如图8-2 所示，有时候，程序并不以段定义语句开始。在这种情况下，这些内容默认地自成一个段。最为典型的情况是，整个程序中都没有段定义语句。这时，整个程序自成一个段。

NASM 对段的数量没有限制。一些大的程序，可能拥有不止一个代码段和数据段。

Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的。这句话的意思是，必须是16 的倍数，或者说该物理地址必须能被16 整除。

相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION 的汇编地址对齐方式。比如说，“align=16”就表示段是16 字节对齐的，“align=32”就表示段是32 字节对齐的。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00247.jpeg)

图8-1　用户程序的一般结构

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00248.jpeg)

图8-2　程序并非以段定义开始的情况

在源程序编译阶段，编译器将根据align 子句确定段的起始汇编地址。如图8-3 所示，这里定义了三个段，分别是data1、data2 和data3，每个段里只有一个字节的数据，分别是0x55、 0xaa 和0x99。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00249.jpeg)

图8-3　align 子句对段的影响（编译之前的源代码）

理论上，如果不考虑段的对齐方式，那么段data1 的汇编地址是0，段data2 的汇编地址是1，段data3 的汇编地址是2。

但是，在这里，每个段的定义中都包含了要求16 字节对齐的子句，情况便不同了。如图8-4所示，这是编译后的结果，因为在段data1 之前没有任何内容，故段data1 的起始汇编地址是0（在图中是0x00000000），而且地址0 本身就是16 字节对齐的，符合align 子句的要求。

段的汇编地址其实就是段内第一个元素（数据、指令）的汇编地址。因此，在段data1 中声明和初始化的0x55 位于汇编地址0x00000000 处。

段data2 也要求是16 字节对齐的。问题是，从汇编地址0x00000001 开始，只有0x00000010（十进制的16）才能被16 整除。于是，编译器将0x00000010 作为段data2 的汇编地址，并在两个段之间填充15 字节的0x00（段data1 只有1 字节的长度）。

段data3 的处理与前面两个段相同。因为段data2 只有1 字节，故也需要在它们之间填充15字节。这样，段data3 的汇编地址就是0x00000020（十进制的32）。段data3 也只有1 字节（0x99），所以，汇编地址0x00000020 处是0x99，这也是编译结果中的最后一字节。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00250.jpeg)

图8-4　align 子句对段的影响（编译之后的二进制文件）

正如我们刚刚讨论过的，每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得该段的汇编地址，NASM 编译器提供了以下的表达式，可以用在你的程序中：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00251.jpeg)

如图8-1 所示，段“header”相对于整个程序开头的汇编地址是section.header.start，段“code”相对于整个程序开头的汇编地址是section.code.start。在这个例子中，因为段“header”是在程序的一开始定义的，它的前面没有其他内容，故section.header.start=0。

如图8-1 所示，段定义语句还可以包含“vstart=”子句。尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的。

这就很麻烦（有时候也很有用）。因此，vstart 可以解决这个问题。如图8-1 所示，“putch”是段code 中的一个标号，原则上，该标号代表的汇编地址应该从程序开头计算。但是，因为段code的定义中有“vstart=0”子句，所以，标号“putch”的汇编地址要从它所在段的开头计算，而且从0 开始计算。

如图8-1 所示，同样的情形也出现在段data 中。段data 的定义中也有“vstart=0”子句，因此，当我们在段code 中引用段data 中的标号“string”时（mov ax,string），尽管在图中没有标明，标号“string”所代表的汇编地址是相对于其所在段data 的。也就是说，传送到寄存器AX 中的数值是标号string 相对于段data 起始处的长度。

但是，图中最后一个段trail 的定义中没有包含“vstart=0”子句。那就对不起了，该段内有一个标号“program_end”，它的汇编地址就要从整个程序开头计算。因为它是整个程序中的最后一行，从这个意义上来说，它所代表的汇编地址就是整个程序的大小（以字节计）。

检测点8.1

对于以下程序片断，假如section.data1.start=0x60，则：

1．section.data2.start=（ ）

2．section.data3.start=（ ）

3．执行mov ax,lba 指令后，寄存器AX 中的内容是多少？

4．执行mov ax,lbc 指令后，寄存器AX 中的内容是多少？

5．执行mov ax,lbd 指令后，寄存器AX 中的内容是多少？

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00252.jpeg)
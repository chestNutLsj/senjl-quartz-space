   

# 第8章　硬盘和显卡的访问与控制

总是把目光放在一个小小的主引导扇区上，这没什么意思。现在，是我们离开它，向自由天地迈进的时候了。但是，应该迈向哪里呢？

主引导扇区是处理器迈向广阔天地的第一块跳板。离开主引导扇区之后，前方通常就是操作系统的森林，也就是我们经常听说的DOS、Windows、Linux、UNIX 等。

操作系统也是由一大堆指令组成的，之所以将其比作“森林”，是因为它包含了更多的指令，也许是几万条、几十万条，甚至几千万条的指令。相比之下，我们在前面编写的那些指令代码则相形见绌了。

和主引导扇区程序一样，操作系统也位于硬盘上。操作系统是需要安装到硬盘上的，这个安装过程不但要把操作系统的指令和数据写入硬盘，通常还要更新主引导扇区的内容，好让这块跳板直接连着操作系统。不像我们，一直用主引导扇区来显示字符和做加法。

操作系统通常肩负着处理器管理、内存分配、程序加载、进程（即已经位于内存中的程序）调度、外围设备（显卡、硬盘、声卡等）的控制和管理等任务。举个例子来说，你每天都要使用的Windows，它可以让你看到计算机内都有几块硬盘，都安装了哪些程序（通过图标来显示），并允许你双击图标运行这些程序，这都是托了操作系统（Windows）的福。要不然的话，这都是不可能的事。

凭个人之力，写一个非常完善的操作系统，这几乎是不可能的事。但是，写个小程序，模拟一下它的某个功能，还是可以的。我们知道，编译好的程序通常都存放在像硬盘这样的载体上，需要加载到内存之后才能执行。这个过程并不简单，首先要读取硬盘，然后决定把它加载到内存的什么位置。最重要的是，程序通常是分段的，载入内存之后，还要重新计算段地址，这叫做段的重定位。

程序可以有千千万万个，但加载过程却是固定的。在本章，我们把主引导扇区改造成一个程序加载器，或者说是一个加载程序，它的功能是加载用户程序，并执行该程序（将处理器的控制权交给该程序）。总的说来，本章的目标是：

1． 模拟操作系统加载应用程序的过程，演示段的重定位方法，最终使你彻底理解8086 处理器的分段内存管理机制。

2． 学习x86 处理器过程调用的程序执行机制。

3． 以读硬盘扇区和控制屏幕光标为实例，了解x86 处理器访问外围硬件设备的方法。

4． 总结JMP 和CALL 指令的全部格式。

5． 认识更多的x86 处理器指令，如in、out、shl、shr、rol、ror、jmp、call、ret 等。
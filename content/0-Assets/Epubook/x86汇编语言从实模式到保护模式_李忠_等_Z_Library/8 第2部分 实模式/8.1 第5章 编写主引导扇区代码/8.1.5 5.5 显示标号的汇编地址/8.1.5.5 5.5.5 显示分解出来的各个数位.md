### 5.5.5　显示分解出来的各个数位

经过5 次除法操作，可以将寄存器AX 中的数分解成单独的数位，下面的任务是将这些数位显示出来，方法是从DS 指向的数据段依次取出这些数位，并写入ES 指向的附加段（显示缓冲区）。

因为在分解并保存各个数位的时候，顺序是“个、十、百、千、万”位，当在屏幕上显示时，却要反过来，先显示万位，再显示千位，等等，因为屏幕显示是从左往右进行的。所以，源程序第70 行，先从数据段中，偏移地址为number+0x04 处取得万位上的数字，传送到AL 寄存器。当然，因为程序是加载到0x0000:0x7C00 处的，所以正确的偏移地址是0x7C00+number+0x04。

然后，源程序第71 行，将AL 中的内容加上0x30，以得到与该数字对应的ASCII 代码。在这里，add 是加法指令，用于将一个数与另一个数相加。

add 指令需要两个操作数，目的操作数可以是8 位或者16 位的通用寄存器，或者指向8 位或者16 位实际操作数的内存地址；源操作数可以是相同数据宽度的8 位或者16 位通用寄存器、指向8 位或者16 位实际操作数的内存地址，或者立即数，但不允许两个操作数同时为内存单元。相加后，结果保存在目的操作数中。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00101.jpeg)

源程序第72 行，将要显示的ASCII 代码传送到显示缓冲区偏移地址为0x1A 的位置，该位置紧接着前面的字符串“Label offset:”。显示缓冲区是由段寄存器ES 指向的，因此使用了段超越前缀。

源程序第73 行，将该字符的显示属性写入下一个内存位置0x1B。属性值0x04 的意思是黑底红字，无闪烁，无加亮。

从源程序的第75 行开始，到第93 行，用于显示其他4 个数位。

源程序第95、96 行，用于以黑底白字显示字符“D”，意思是所显示的数字是十进制的。

检测点5.3

1． INTEL x86 处理器访问内存时，是按低端字节序进行的。那么，以下程序片断执行后，寄存器AX 中的内容是多少？

　　mov word [data],0x2008

　　xor byte [data],0x05

　　add word [data],0x0101

　　mov ax,[data]

data db 0,0

2． 对于以上程序片断，如果标号data 在编译时的汇编地址是0x0030，那么，当该程序加载到内存后，该程序片断所在段的段地址为0x9020 时，该标号处的段内偏移地址和物理内存地址各是多少？

3． 对于以下指令的写法，说出哪些是正确的，哪些是错误的，错误的原因是什么。

A.mov ax,[data1]　　　　B.div [data1]　　　　 　C.xor ax,dx

D.div byte [data2]　　　　E.xor al,[data3]　　　　　F.add [data4],0x05

G.xor 0xff,0x55　　　　　H.add 0x06,al　　　　 　I.div 0xf0

J.add ax,cl

4． 如果寄存器AX、BX 和DX 的内容分别为0xA000、0x9000 和0x0001，那么，执行div bh 后，这三个寄存器的内容各是多少？执行div bx 后呢？
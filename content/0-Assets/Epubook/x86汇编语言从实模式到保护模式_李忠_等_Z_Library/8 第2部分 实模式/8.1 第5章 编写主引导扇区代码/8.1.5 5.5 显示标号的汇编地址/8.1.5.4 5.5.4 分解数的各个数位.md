### 5.5.4　分解数的各个数位

源程序第41、42 行，是把代码段寄存器CS 的内容传送到通用寄存器CX，然后再从CX 传送到数据段寄存器DS。在此之后，数据段和代码段都指向同一个段。之所以这么做，是因为我们刚才声明的数据是和指令代码混在一起的，可以认为是位于代码段中。尽管在指令中访问这些数据可以使用段超越前缀“CS:”，但习惯上，通过数据段来访问它们更自然一些。

前面已经说过，要分解一个数的各个数位，需要做除法。8086 处理器提供了除法指令div，它可以做两种类型的除法。

第一种类型是用16 位的二进制数除以8 位的二进制数。在这种情况下，被除数必须在寄存器AX 中，必须事先传送到AX 寄存器里。除数可以由8 位的通用寄存器或者内存单元提供。指令执行后，商在寄存器AL 中，余数在寄存器AH 中。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00089.jpeg)

前一条指令中，寄存器CL 用来提供8 位的除数。假如AX 中的内容是0x0005，CL 中的内容是0x02，指令执行后，CL 中的内容不变，AL 中的商是0x02，AH 中的余数是0x01。

后一条指令中，除数位于数据段内偏移地址为0x0023 的内存单元里。这条指令执行时，处理器将数据段寄存器DS 的内容左移4 位，加上偏移地址0x0023 以形成物理地址。然后，处理器再次访问内存，从那个物理地址处取得一个字节，作为除数同寄存器AX 做一次除法。

任何时候，只要是在指令中涉及内存地址的，都允许使用段超越前缀。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00090.jpeg)

话又说回来了，在一个源程序中，通常不可能知道汇编地址的具体数值，只能使用标号。所以，指令中的地址部分更常见的形式是使用标号。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00091.jpeg)

上面的程序很有意思，首先，声明了标号dividnd 并初始化了一个字0x3f0 作为被除数；然后，又声明了标号divisor 并初始化一个字节0x3f 作为除数。

在后面的mov 和div 指令中，是用标号dividnd 和divisor 来代替被除数和除数的汇编地址。在编译阶段，编译器用具体的数值取代括号中的标号dividnd 和divisor。现在，假设dividnd 和divisor 所代表的汇编地址分别是0xf000 和0xf002，那么，在编译阶段，编译器在生成这两条指令的机器码之前，会先将它们转换成以下的形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00092.jpeg)

当第一条指令执行时，处理器用0xf000 作为偏移地址，去访问数据段（段地址在段寄存器DS 中），来取得内存中的一个字0x3F0，并把它传送到寄存器AX 中。

当第二条指令执行时，处理器采用同样的方法取得内存中的一个字节0x3F，用它来和寄存器AX 中的内容做除法。当然，除法指令div 的功能你是知道的。

说了这么多，其实是在强调标号和汇编地址的对应关系，以及如何在指令中使用符号化的偏移地址。

第二种类型是用32 位的二进制数除以16 位的二进制数。在这种情况下，因为16 位的处理器无法直接提供32 位的被除数，故要求被除数的高16 位在DX 中，低16 位在AX 中。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00093.jpeg)

图5-6　用DX:AX 分解32 位二进制数示意图

这里有一个例子，如图5-6 所示，假如被除数是十进制数2218367590，那么，它对应着一个32 位的二进制数10000100001110011001101001100110。在做除法之前，先要分成两段进行“切割”，以分别装入寄存器DX 和AX 。为了方便， 我们通常用“DX:AX”来描述32 位的被除数。

同时，除数可以由16 位的通用寄存器或者内存单元提供，指令执行后，商在AX 中，余数在DX 中。比如下面的指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00094.jpeg)

源程序第45 行把0 传送到DX 寄存器，这意味着，我们是想把DX:AX 作为被除数，即被除数的高16 位是全零。至于被除数的低16 位，已经在第37 行的代码中被置为标号number 的汇编地址。

回到前面的第38 行，该指令把10 作为除数传送到通用寄存器BX 中。

一切都准备好了，源程序第46 行，div 指令用DX:AX 作为被除数，除以BX 的内容，执行后得到的商在AX 中，余数在DX 中。因为除数是10，余数自然比10 小，我们可以从DL 中取得。

第1 次相除得到的余数是个位上的数字，我们要将它保存到声明好的数据区中。所以，源程序第47 行，我们又一次用到了传送指令，把寄存器DL 中的余数传送到数据段。

可以看到，指令中没有使用段超越前缀，所以处理器在执行时，默认地使用段寄存器DS 来访问内存。偏移地址是由标号number 提供的，它是数据区的首地址，也可以说是数据区中第一个数据的地址。因此，number 和number+0x00 是一样的，没有区别。

因为我们访问的是number 所指向的内存单元，故要用中括号围起来，表明这是一个地址。

令人不解的是， 第47 行中， 偏移地址并非理论上的number+0x00 ， 而是0x7c00+ number+0x00。这个0x7c00 是从哪里来的呢？

标号number 所代表的汇编地址，其数值是在源程序编译阶段确定的，而且是相对于整个程序的开头，从0 开始计算的。请看一下表5-3 的第37 行，这个在编译阶段计算出来的值是0x012E。在运行的时候，如果该程序被加载到某个段内偏移地址为0 的地方，这不会有什么问题，因为它们是一致的。

但是，事实上，如图5-7 所示，这里显示的是整个0x0000 段，其中深色部分为主引导扇区所处的位置。主引导扇区代码是被加载到0x0000:0x7C00 处的，而非0x0000:0x0000。对于程序的执行来说，这不会有什么问题，因为主引导扇区的内容被加载到内存中并开始执行时，CS=0x0000， IP=0x7C00。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00095.jpeg)

图5-7　主引导程序加载到内存后的地址变化

加载位置的改变不会对处理器执行指令造成任何困扰，但会给数据访问带来麻烦。要知道，当前

数据段寄存器DS 的内容是0x0000，因此，number 的偏移地址实际上是0x012E+0x7C00=0x7D2E。当正在执行的指令仍然用0x012E 来访问数据，灾难就发生了。

所以，在编写主引导扇区程序时，我们就要考虑到这一点，必须把代码写成

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00096.jpeg)

指令中的目的操作数是在编译阶段确定的，因此，在编译阶段，编译器同样会首先将它转换成以下的形式，再进一步生成机器码：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00097.jpeg)

这样，如表5-3 的第47 行所示，在编译后，编译器就会将这条指令编译成88 16 2E 7D，其中前两个字节是操作码，后两个字节是低端字节序的0x7D2E。当这条指令执行时，处理器将段寄存器DS 的内容（和CS 一样，是0x0000）左移4 位，再加上指令中提供的偏移地址0x7D2E，就得到了实际的物理地址（0x07D2E）。

关于这条指令的另外一个问题是，虽然目的操作数也是一个内存单元地址，但并没有用关键字“byte”来修饰。这是因为源操作数是寄存器DL，编译器可以据此推断这是一个字节操作，不存在歧义。

现在已经得到并保存了个位上的数字，下一步是计算十位上的数字，方法是用上一次得到的商作为被除数，继续除以10。恰好，AX 已经是被除数的低16 位，现在只需要把DX 的内容清零即可。

为此，代码清单5-1 第50 行，用了一个新的指令xor 来将DX 寄存器的内容清零。

xor，在数字逻辑里是异或（eXclusive OR）的意思，或者叫互斥或、互斥的或运算。《在穿越计算机的迷雾》里，已经花了大量的篇幅讲解数字逻辑。在数字逻辑里，如果0 代表假，1 代表真，那么

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00098.jpeg)

xor 指令的目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）。而且，异或操作是在两个操作数相对应的比特之间单独进行的。

一般地，xor 指令的两个操作数应当具有相同的数据宽度。因此，其指令格式可以总结为以下几种情况：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00099.jpeg)

因为异或操作是在两个操作数相对应的比特之间单独进行，故，以下指令执行后，AX 寄存器中的内容为0xF0F3。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00100.jpeg)

注意，这两条指令的源操作数都采用了二进制数的写法，NASM 编译器允许使用下画线来分开它们，好处是可以更清楚地观察到那些感兴趣的比特。

回到当前程序中，因为指令xor dx,dx 中的目的操作数和源操作数相同，那么，不管DX 中的内容是什么，两个相同的数字异或，其结果必定为0，故这相当于将DX 清零。

值得一提的是，尽管都可以用于将寄存器清零，但是编译后，mov dx,0 的机器码是BA 00 00；而xor dx,dx 的机器码则是31 D2，不但较短，而且，因为xor dx,dx 的两个操作数都是通用寄存器，所以执行速度最快。

第二次相除的结果可以求得十位上的数字，源程序第52 行用来将十位上的数字保存到从number 开始的第2 个存储单元里，即number+0x01。

从源程序第55 行开始，一直到第67 行，做的都是和前面相同的事情，即，分解各位上的数字，并予以保存，这里不再赘述。
### 5.5.2　如何显示十进制数字

我们已经知道，标号代表并指示它所在位置处的汇编地址。现在，我们要编写指令，在屏幕上把这个地址的数值显示出来。为此，源程序的第37 行用于获取标号所代表的汇编地址：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00087.jpeg)

标号“number”位于源程序的第100 行，只不过后面没有跟着冒号“:”。你当然可以加上冒号，但这无关紧要。注意，传送到寄存器AX 的值是在源程序编译时确定的，在编译阶段，编译器会将标号number 转换成立即数。如表5-3 所示，标号number 处的汇编地址是0x012E，因此，这条语句其实就是（等效于）

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00088.jpeg)

问题在于，如果不是借助于别的工具和手段，你不可能知道此处的汇编地址是0x012E。所以，在汇编语言中使用标号的好处是不必关心这些。

因此，当这条指令编译后，得到的机器指令为B8[2E01]，或者B8 2E 01。B8 是操作码，后面是字操作数0x012E，只不过采用的是低端字节序。

十六进制数0x012E 等于十进制数302，但是，通过前面对字符显示原理的介绍，我们应该清楚，直接把寄存器AX 中的内容传送到显示缓冲区，是不可能在屏幕上出现“302”的。

解决这个问题的办法是将它的每个数位单独拆分出来，这需要不停地除以10。

考虑到寄存器AX 是16 位的， 可以表示的数从二进制的0000000000000000 到1111111111111111，也就是十进制的0～65535，故它可以容纳最大5 个数位的十进制数，从个位到万位，比如61238。那么，假如你并不知道它是多少，只知道它是一个5 位数，那么，如何通过分解得到它的每个数位呢？

首先，用61238 除以10，商为6123，余8，本次相除的余数8 就是个位数字；

然后，把上一次的商数6123 作为被除数，再次除以10，商为612，余3，余数3 就是十位上的数字；

接着，再用上一次的商数612 除以10，商为61，余2，余数2 就是百位上的数字；

同上，再用61 除以10，商为6，余1，余数1 就是千位上的数字；

最后，用6 除以10，商为0，余6，余数6 就是万位上的数字。

很显然，只要把AX 的内容不停地除以10，只需要5 次，把每次的余数反向组合到一起，就是原来的数字。同样，如果反向把每次的余数显示到屏幕上，应该就能看见这个十进制数是多少了。

不过，即使是得到了单个的数位，也还是不能在屏幕上显示，因为它们是数字，而非ASCII代码。比如，数字0x05 和字符“5”是不同的，后者实际上是数字0x35。

观察表5-1，你会发现，字符“0”的ASCII 代码是0x30，字符“1”的ASCII 代码是0x31，字符“9”的ASCII 代码是0x39。这就是说，把每次相除得到的余数加上0x30，在屏幕上显示就没问题了。
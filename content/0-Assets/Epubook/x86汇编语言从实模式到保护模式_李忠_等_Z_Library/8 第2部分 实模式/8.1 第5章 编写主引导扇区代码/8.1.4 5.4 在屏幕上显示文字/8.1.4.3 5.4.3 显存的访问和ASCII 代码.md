### 5.4.3　显存的访问和ASCII 代码

一旦将显存映射到处理器的地址空间，那么，我们就可以使用普通的传送指令（mov）来读写它，这无疑是非常方便的，但需要首先将它作为一个段来看待，并将它的基地址传送到段寄存器。

为此，源程序的第10、11 行，我们把0xB800 作为段地址传送到附加段寄存器ES，以后就用ES 来读写显存。这样，段内偏移为0 的位置就对应着屏幕左上角的字符。

在计算机中，每个用来显示在屏幕上的字符，都有一个二进制代码。这些代码和普通的二进制数字没有什么不同，唯一的区别在于，发送这些数字的硬件和接收这些数字的硬件把它们解释为字符，而不是指令或者用于计算的数字。

这就是说，在计算机中，所有的东西都是无差别的数字，它们的意义，只取决于生成者和使用者之间的约定。为了在终端和大型主机，以及主机和打印机、显示器之间交换信息，1967 年，美国国家标准学会制定了美国信息交换标准代码（American Standard Code for Information Interchange，ASCII），如表5-1 所示。

表5-1　ASCII 表

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00067.jpeg)

在不同设备之间，或者在同一设备的不同模块之间有一个信息传递标准是非常必要的。想想看，当你用手机向朋友发送短消息时，这些文字当然被编码成二进制数字。如果对方的手机使用了不同的编码，那么他将无法正确还原这些消息，而很可能显示为乱码。

值得注意的是，ASCII 是7 位代码，只用了一个字节中的低7 比特，最高位通常置0。这意味着，ASCII 只包含128 个字符的编码。所以，在表中，水平方向给出了代码的高3 比特，而垂直方向给出了代码的低4 比特。比如字符“*”，它的代码是二进制数的010 1010，即0x2A。

ASCII 表中有相当一部分代码是不可打印和显示的，它们用于控制通信过程。比如，LF 是换行；CR 是回车；DEL 和BS 分别是删除和退格，在我们平时用的键盘上也是有的；BEL 是振铃（使远方的终端响铃，以引起注意）；SOH 是文头；EOT 是文尾；ACK 是确认，等等。

注意，一定要遵从约定。比如，你在处理器上编写程序算了一道数学题2+3，你也希望把结果5 显示在屏幕上。这个时候，算出的结果是0000 0101，即0x05。但是，数字5 和字符5 是不同的，显卡在任何时候都认为你发送的是ASCII 码。所以，你不应该发送0x05，而应该发送0x35。

屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的ASCII 代码，后面是字符的显示属性，包括字符颜色（前景色）和底色（背景色）。如图5-4 所示，字符“H”的ASCII 代码是0x48，其显示属性是0x07；字符“e”的ASCII 代码是0x65，其显示属性是0x07。

如图5-4 所示，字符的显示属性（1 字节）分为两部分，低4 位定义的是前景色，高4 位定义的是背景色。色彩主要由R、G、B 这3 位决定，毕竟我们知道，可以由红（R）、绿（G）、蓝（B）三原色来配出其他所有颜色。K 是闪烁位，为0 时不闪烁，为1 时闪烁；I 是亮度位，为0时正常亮度，为1 时呈高亮。表5-2 给出了背景色和前景色的所有可能值。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00068.jpeg)

图5-4　字符代码及字符属性示意图

表5-2　80×25 文本模式下的颜色表

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00069.jpeg)

从表5-2 来看，图5-4 中的字符属性0x07 可以解释为黑底白字，无闪烁，无加亮。

你可能觉得奇怪，当屏幕上一片漆黑，什么内容都没有的时候，显存里会是什么内容呢？

实际上，这个时候，屏幕上显示的全是黑底白字的空白字符，也叫空格字符（Space），ASCII代码是0x20，当你用大拇指按动键盘上最长的那个键时，就产生这个字符。因为它是空白，自然就无法在黑底上看到任何痕迹了。
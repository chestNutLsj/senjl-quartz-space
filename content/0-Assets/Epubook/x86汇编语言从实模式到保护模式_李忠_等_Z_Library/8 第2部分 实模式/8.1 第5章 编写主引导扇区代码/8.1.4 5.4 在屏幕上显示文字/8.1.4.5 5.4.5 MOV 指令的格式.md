### 5.4.5　MOV 指令的格式

到目前为止，我们已经多次接触了mov 指令。在处理器的整个指令集中，mov 指令是用得最多的一条。

mov 指令用于数据传送。既然是数据传送，那么，目的操作数的作用应该相当于一个“容器”，故必须是通用寄存器或者内存单元；源操作数呢，也可以是和目的操作数具有相同数据宽度的通用寄存器和内存单元，还可以是立即数。传送指令只影响目的操作数的内容，不改变源操作数的内容。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00074.jpeg)

以上，第一条指令的目的操作数和源操作数都是8 位寄存器，指令执行后，寄存器AH 的内容和BH 相同；第二条指令的目的操作数和源操作数都是16 位寄存器，指令执行后，寄存器AX的内容和DX 相同。但是，由于数据宽度不同，下面这条指令就是错误的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00075.jpeg)

再来看下面两条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00076.jpeg)

以上，第一条指令是把寄存器BL 中的内容传送到偏移地址为0x02 的8 位内存单元；第二条指令是把偏移地址为0x06 的16 位内存单元里的内容传送到寄存器AX 中。由于这两条指令中都有寄存器操作数，故不需要用“byte”或者“word”来修饰。

传送指令的源操作数也可以是立即数。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00077.jpeg)

以上，第一条指令是把立即数0x05 传送到寄存器AH 中，指令执行后，AH 中的内容为0x05；第二条指令是把立即数0xf000 传送到偏移地址为0x1c 的16 位内存单元中。因为上一节所说的原因，这里要用word 来修饰。

mov 指令的目的操作数不允许为立即数，而且，目的操作数和源操作数不允许同时为内存单元。因此，下面两条指令都是不正确的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00078.jpeg)

以上，说第一条指令是错误的，这很好理解。想想看，你把寄存器AL 中的内容传送给一个立即数，这是什么意思呢？于理不通。至于第二条指令为什么不正确，那是因为处理器不允许在两个内存单元之间直接进行传送操作。事实上，这条指令的功能可以用两条指令实现（假设传送的是一个字）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00079.jpeg)

就算处理器支持在两个内存单元之间直接传送数据，那么，它依然是在内部按上面的两个步骤进行操作的。而且，支持这种直接传送操作还需要增加额外的电路。

不单单是mov 指令，其他指令都不支持在两个内存单元之间直接进行操作，包括加、减、乘、除和逻辑运算等指令。事情是明摆着的，既然增加了处理器的复杂性之后和用两条指令没什么区别，干脆就用两条指令好了。

检测点5.1

1． 在我们日常使用的个人计算机上，文本模式下的显示缓冲区被映射到物理内存地址空间，起始地址为（ ），它对应的段地址为（ ）。在标准的80×25 文本模式下，要想在屏幕右下角显示一个绿底白字的字符“H”，那么，应当在该段内偏移量为（ ）的地方开始，连续写入两个字节（ ）和（ ）。

2． 以下指令中，哪些是正确的，不正确的原因是什么？

A.mov al,0x55aa　　　　　　B.mov ds,0x6000　　　　　C.mov ds,al

D.mov [0x06],0x55aa　　　 　E.mov ds,bx　　　　　　 F.mov ax,0x02

G.mov word [0x0a],ax　　　　H.mov es,cx　　　　　　　I.mov ax,bl

J.mov byte [0x00],’c’　　　　 K.mov [0x02],[0xf000]　　　L.mov ds,[0x03]
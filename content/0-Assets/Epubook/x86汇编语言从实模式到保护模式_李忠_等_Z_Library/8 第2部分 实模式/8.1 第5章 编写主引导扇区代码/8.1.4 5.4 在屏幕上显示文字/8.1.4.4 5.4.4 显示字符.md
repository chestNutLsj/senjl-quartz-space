### 5.4.4　显示字符

从源程序的第10 行开始，到第35 行，目的是显示一串字符“Label offset:”。为此，需要把它们每一个的ASCII 码顺序写到显存中。

为了方便，多数汇编语言编译器允许在指令中直接使用字符的字面值来代替数值形式的ASCII 码，比如源程序第10 行：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00070.jpeg)

这等效于

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00071.jpeg)

尽管通过查表可以知道字符“L”的ASCII 代码是0x4C，但毕竟费事。不过，要在指令中使用字符的字面值，这个字符必须用引号围起来，就像上面一样。在源程序的编译阶段，汇编语言编译器会将它转换成ASCII 码的形式。

当前的mov 指令是将立即数传送到内存单元，目的操作数是内存单元，源操作数是立即数（ASCII 代码）。为了访问内存单元，需要给出段地址和偏移地址。在这条指令中，偏移地址0x00，段地址在哪里呢？一般情况下，如果没有附加任何指示，段地址默认在段寄存器DS 中。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00072.jpeg)

当执行这条指令后，处理器把段寄存器DS 的内容左移4 位（相当于乘以十进制数16 或者十六进制数0x10），加上这里的偏移地址0x00，就得到了物理地址。

但是实际上，在我们的程序中，显存的段地址位于段寄存器ES 中，我们希望使用ES 来访问内存。因此，这里使用了段超越前缀“es:”。这就是说，我们明确要求处理器在生成物理地址时，使用段寄存器ES，而不是默认情况下的DS。

因为指令中给出的偏移地址是0x00，且ES 的值已经在前面被设为0xB800，故它指向ES 段中，偏移地址为0 的内存单元，即0xB800:0x0000，也就是物理地址0xB8000，这个内存单元对应着屏幕左上角第一个字符的位置。

还需要注意的是，因为目的操作数给出的是一个内存地址，我们要用源操作数来修改这个地址里的内容，所以，目的操作数必须用方括号围起来，以表明它是一个地址，处理器应该用这个地址再次访问内存，将源操作数写进这个单元。实际上，这类似于高级语言里的指针。

最后，关键字“byte”用来修饰目的操作数，指出本次传送是以字节的方式进行的。在16 位的处理器上，单次操作的数据宽度可以是8 位，也可以是16 位。到底是8 位，还是16 位，可以根据目的操作数或者源操作数来判断。遗憾的是，在这里，目的操作数是偏移地址0x00，它可以是字节单元，也可以是字单元，到底是哪一种，无法判断；而源操作数呢，是立即数0x4C，它既可以解释为8 位的0x4C，也可以解释为16 位的0x004C。在这种情况下，编译器将无法搞懂你的真实意图，只能报告错误，所以必须用“byte”或者“word”进行修饰（明确指示）。于是，一旦目的操作数被指明是“byte”的，那么，源操作数的宽度也就明确了。相反地，下面的指令就不需要任何修饰：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00073.jpeg)

因为屏幕上的一个字符对应着内存中的两个字节：ASCII 代码和属性，所以，源程序第11 行的功能是将属性值0x07 传送到下一个内存单元，即偏移地址0x01 处。这个属性可以解释为黑底白字，无闪烁，也无加亮，请参阅表5-2。

后面，从第12 行开始，到第35 行，用于向显示缓冲区填充剩余部分的字符。注意，在这个过程中，偏移地址一直是递增的。
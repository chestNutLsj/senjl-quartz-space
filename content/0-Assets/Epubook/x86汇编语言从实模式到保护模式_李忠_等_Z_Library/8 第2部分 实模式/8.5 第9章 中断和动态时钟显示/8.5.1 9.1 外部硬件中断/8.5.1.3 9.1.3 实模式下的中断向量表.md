### 9.1.3　实模式下的中断向量表

所谓中断处理，归根结底就是处理器要执行一段与该中断有关的程序（指令）。处理器可以识别256 个中断，那么理论上就需要256 段程序。这些程序的位置并不重要，重要的是，在实模式下，处理器要求将它们的入口点集中存放到内存中从物理地址0x00000 开始，到0x003ff 结束，共1KB 的空间内，这就是所谓的中断向量表（Interrupt Vector Table，IVT）。

如图9-3 所示，每个中断在中断向量表中占2 个字，分别是中断处理程序的偏移地址和段地址。中断0 的入口点位于物理地址0x00000 处，也就是逻辑地址0x0000:0x0000；中断1 的入口点位于物理地址0x00004 处，即逻辑地址0x0000:0x0004；其他中断以此类推，总之是按顺序的。

当中断发生时，如果从外部硬件到处理器之间的道路都是畅通的，那么，处理器在执行完当前的指令后，会立即着手为硬件服务。它首先会响应中断，告诉8259 芯片准备着手处理该中断。接着，它还会要求8259 芯片把中断号送过来。

在8259 芯片那里，每个引脚都赋予了一个中断号。而且，这些中断号是可以改变的，可以对8259 编程来灵活设置，但不能单独进行，只能以芯片为单位进行。比如，可以指定主片的中断号从0x08 开始，那么它每个引脚IR0～IR7 所对应的中断号分别是0x08～0x0e。

中断信号来自哪个引脚，8259 芯片是最清楚的，所以它会把对应的中断号告诉处理器，处理器拿着这个中断号，要顺序做以下几件事。

① 保护断点的现场。首先要将标志寄存器FLAGS 压栈，然后清除它的IF 位和TF 位。TF 是陷阱标志，这个以后再讲。接着，再将当前的代码段寄存器CS 和指令指针寄存器IP 压栈。

② 执行中断处理程序。由于处理器已经拿到了中断号，它将该号码乘以4（毕竟每个中断在中断向量表中占4 字节），就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP 和CS，自然地，处理器就开始执行中断处理程序了。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00334.jpeg)

图9-3　实模式下的中断向量表

注意，由于IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用sti 指令开放中断。

③ 返回到断点接着执行。所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和FLAGS 的原始内容，于是转到主程序接着执行。

iret 同样没有操作数，执行这条指令时，处理器依次从栈中弹出数值到IP、CS 和标志寄存器。

顺便提醒一句，由于中断处理过程返回时，已经恢复了FLAGS 的原始内容，所以IF 标志位也自动恢复。也就是说，可以接受新的中断。

和可屏蔽中断不同，NMI 发生时，处理器不会从外部获得中断号，它自动生成中断号码2，其他处理过程和可屏蔽中断相同。

中断随时可能发生，中断向量表的建立和初始化工作是由BIOS 在计算机启动时负责完成的。BIOS 为每个中断号填写入口地址，因为它不知道多数中断处理程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。马上你就会看到，我们在本章也是这样做的。
### 9.1.8　实时时钟中断的处理过程

主程序就是这样了，停机、执行，接着停机。与此同时，中断也在不停地发生着，处理器还要抽出空来执行中断处理过程，下面就来看看RTC 的更新周期结束中断处理，该中断处理过程从代码清单9-1 的第27 行开始。

第28～32 行，先保护好现场，将后面用到的寄存器压栈保存。这一点特别重要，中断处理过程必须无痕地执行，你不知道中断会在什么时候发生，也不知道中断发生时，哪一个程序正在执行，所以，必须保证中断返回时，能还原中断前的状态。

第34～40 行，用于读RTC 寄存器A，根据UIP 位的状态来决定是等待更新周期结束，还是继续往下执行。UIP 位为0 表示现在访问CMOS RAM 中的日期和时间是安全的。注意第36 行，用于把寄存器AL 的最高位置1，从而阻断NMI。当然，这是不必要的，当NMI 发生时，整个计算机都应当停止工作，也不在乎中断处理过程能否正常执行。

第38 行从数据端口读取寄存器A 的内容；第39 行，test 指令用于测试寄存器AL 的第7 位是否为1。

“test”的意思是“测试”。顾名思义，可以用这条指令来测试某个寄存器，或者内存单元里的内容是否带有某个特征。

test 指令在功能上和and 指令是一样的，都是将两个操作数按位进行逻辑“与”，并根据结果设置相应的标志位。但是，test 指令执行后，运算结果被丢弃（不改变或破坏两个操作数的内容）。

test 指令需要两个操作数，其指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00348.jpeg)

和and 指令一样，test 指令执行后，OF＝CF＝0；对ZF、SF 和PF 的影响视测试结果而定；对AF 的影响未定义。对于test 指令的应用，这里有一个例子，比如，我们想测试Al 寄存器的第3 位是“0”还是“1”，可以这样编写代码：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00349.jpeg)

0x08 的二进制形式为00001000，它的第3 位是“1”，表明我们关注的是这一位。不管寄存器AL 中的内容是什么，只要它的第3 位是“0”，这条指令执行后，结果一定是00000000，标志位ZF＝1；

相反，如果寄存器AL 的第3 位是“1”，那么结果一定是00001000，ZF＝0。于是，根据ZF 标志位的情况，就可以判定寄存器AL 中的第3 位是“0”还是“1”。

第40 行，如果UIP 位是0，那么测试的结果是ZF＝1，继续往下执行第42 行；否则，说明UIP 位是1，需要返回到第34 行继续等待RTC 更新周期结束。

正常情况下，访问CMOS RAM 中的日期和时间，必须等待RTC 更新周期结束，所以上面的判断过程是必需的，而这些代码也适用于正常的访问过程。但是，当前中断处理过程是针对更新周期结束中断的，而当此中断发生时，本身就说明对CMOS RAM 的访问是安全的，毕竟留给我们的时间是999 毫秒，这段时间非常充裕，这段时间能执行千万条指令。所以，在这种特定的情况下，上面的判断过程是不必要的。当然，加上倒也无所谓。

第42～52 行，分别访问CMOS RAM 的0、2、4 号单元，从中读取当前的秒、分、时数据，按顺序压栈等待后续操作。

第60～62 行，读一下RTC 的寄存器C，使得所有中断标志复位。这等于是告诉RTC，中断已经得到处理，可以继续下一次中断。否则的话，RTC 看到中断未被处理，将不再产生中断信号。RTC 产生中断的原因有多种，可以在程序中通过读寄存器C 来判断具体的原因。不过这里不需要，因为除了更新周期结束中断外，其他中断都被关闭了。

现在，终于可以在屏幕上显示时间信息了。

第64、65 行，临时将段寄存器ES 指向显示缓冲区。

第67、68 行，首先从栈中弹出小时数，调用过程bcd_to_ascii 来将用BCD 码表示的“小时”转换成ASCII。该过程是在第105 行定义的，调用该过程时，寄存器AL 中的高4 位和低4 位分别是“小时”的十位数字和个位数字。

第108 行，将寄存器AL 中的内容复制一份给AH，以方便下一步操作。

第109、110 行，将寄存器AL 中的高4 位清零，只留下“小时”的个位数字。接着，将它加上0x30，就得到该数字对应的ASCII 码。

十位上的数字在寄存器AH 的高4 位。第112 行，用右移4 位的方法，将它“拉”到低4位，高4 位在移动的过程中自动清零。

接着，第113、114 行，用同样的办法来得到十位数字的ASCII 码。此时，寄存器AH 中是十位数字的ASCII 码，AL 中是个位数字的ASCII 码，它们将作为结果返回给调用者。

最后，第116 行用于返回调用者。

接着回到第69 行，为了连续在屏幕上显示内容，最好是采用基址寻址来访问显存。这一行用于指定显示的内容位于显存的什么位置。实际上，这里指定的是第12 行36 列。同以前一样，每个字符在显存中占两个字节，每行80 个字符，所以这里使用了表达式12*160 + 36*2，该表达式的值是在编译阶段计算的。

第71、72 行，分别将“小时”的两个数位写到显存中，段地址在ES 中，偏移地址分别是由寄存器BX 和BX+2 提供的。这里没有写入显示属性，这是因为我们希望采用默认的显示属性（屏幕是黑的，默认的显示属性是0x07，即黑底白字）。

第74、75 行，用于在下一个屏幕位置显示冒号“:”，这是在显示时间时都会采用的分隔符。当然，通过寄存器AL 中转是多余的，这两句可以直接写成

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00350.jpeg)

遗憾的是，等我发现这个问题时，本章已经快要写完了，重新排版实在太费工夫。其实，这不算是个问题，无伤大雅，难道不是吗？

为了验证RTC 更新结束中断是每秒发生一次的，第76 行，将冒号的显示属性（颜色）用not指令反转。就像手掌的两面一样，每次发生中断时，冒号的颜色将和上一次相反，但永远在两个属性之间来回变化。到程序运行的时候你就会发现，变化的频率是每秒一次。

剩下的指令都很好理解，因为它们的工作是按相同的方法显示分钟数和秒数。第78～90 行，依次从栈中弹出分钟和秒的数值，并转换成ASCII 码，然后显示在屏幕上，中间用冒号间隔。

在8259 芯片内部，有一个中断服务寄存器（Interrupt Service Register，ISR），这是一个8 位寄存器，每一位都对应着一个中断输入引脚。当中断处理过程开始时，8259 芯片会将相应的位置1，表明正在服务从该引脚来的中断。

一旦响应了中断，8259 中断控制器无法知道该中断什么时候才能处理结束。同时，如果不清除相应的位，下次从同一个引脚出现的中断将得不到处理。在这种情况下，需要程序在中断处理过程的结尾，显式地对8259 芯片编程来清除该标志，方法是向8259 芯片发送中断结束命令（End Of Interrupt，EOI）。

中断结束命令的代码是0x20。代码清单9-1 第92～94 行就用来做这件事。需要注意的是，如果外部中断是8259 主片处理的，那么，EOI 命令仅发送给主片即可，端口号是0x20；如果外部中断是由从片处理的，就像本章的例子，那么，EOI 命令既要发往从片（端口号0xa0），也要发往主片。

最后，第96～102 行，从栈中恢复被中断程序的现场，并用中断返回指令iret 回到中断之前的地方继续执行。iret 的意思是Interrupt Return。
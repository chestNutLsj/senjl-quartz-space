### 9.1.6　初始化8259、RTC 和中断向量表

本章提供的代码清单中，没有加载器程序。这是因为可以利用上一章提供的加载器来加载用户程序，只要符合规则，加载器是通用的。

用户程序的入口点在代码清单9-1 的第119 行，从这一行开始，到第124 行，用于初始化各个段寄存器的内容。下面开始在中断向量表中安装实时时钟中断的入口点。既然本章的主题是中断，那么就很有必要强调一件事。当处理器执行任何一条改变栈段寄存器SS 的指令时，它会在下一条指令执行完期间禁止中断。

栈无疑是很重要的，不能被破坏。要想改变代码段和数据段，只需要改变段寄存器就可以了。但栈段不同，因为它除了有段寄存器，还有栈指针。因此，绝大多数时候，对栈的改变是分两步进行的：先改变段寄存器SS 的内容，接着又修改栈指针寄存器SP 的内容。

想象一下，如果刚刚修改了段寄存器SS，在还没来得及修改SP 的情况下，就发生了中断，会出现什么后果，而且要知道，中断是需要依靠栈来工作的。

因此，处理器在设计的时候就规定，当遇到修改段寄存器SS 的指令时，在这条指令和下一条指令执行完毕期间，禁止中断，以此来保护栈。换句话说，你应该在修改段寄存器SS 的指令之后，紧跟着一条修改栈指针SP 的指令。

就代码清单9-1 来说，在第121、122 行执行期间，处理器禁止中断。再比如以下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00344.jpeg)

在后面两行指令执行期间，处理器禁止中断。

RTC 芯片的中断信号，通向中断控制器8259 从片的第1 个中断引脚IR0。在计算机启动期间，BIOS 会初始化中断控制器，将主片的中断号设为从0x08 开始，将从片的中断号设为从0x70开始。所以，计算机启动后，RTC 芯片的中断号默认是0x70。尽管我们可以通过对8259 编程来改变它，但是没有必要。

检测点9.2

在Bochs 中使用“xp”命令显示实模式下的中断向量表，并找出0x70 号中断处理过程的段地址和偏移地址。

在安装中断向量之前，应该先显示些什么。第126～130 行，显示两行提示信息，表明正在安装中断向量。这两个字符串位于第286 行的数据段中。对于过程put_string 没有什么好说的，它的代码和上一章相同，工作过程更没有区别。

为了修改某中断在中断向量表中的登记项，需要先找到它。第132～135 行，将中断号0x70乘以4，就是它在中断向量表内的偏移。

第137 行，修改中断向量表时，需要先用cli 指令清中断。当表项信息只修改了一部分时，如果发生0x70 号中断，则会产生不可预料的问题。

第139～141 行，将段寄存器ES 压栈暂时保存，并使它指向中断向量表（所在的段）。

接着，第142～145 行，访问中断向量表内0x70 号中断的表项，分别写入新中断处理过程的偏移地址和段地址。新的中断处理过程是从标号new_int_0x70 处开始的，而且位于当前代码段内。所以，该中断处理过程的偏移地址就是标号new_int_0x70 的汇编地址（注意，段code 的定义中带有vstart=0 子句），段地址就是当前段寄存器CS 的内容。表项修改完毕，从栈中恢复段寄存器ES 的原始内容。

接下来，我们要设置RTC 的工作状态，使它能够产生中断信号给8259 中断控制器。

RTC 到8259 的中断线只有一根，而RTC 可以产生多种中断。比如闹钟中断、更新结束中断和周期性中断（参见表9-3 和表9-4）。RTC 的计时（更新周期）是独立的，产生中断信号只是它的一个赠品。所以，如果希望它能产生中断信号，需要额外设置。

以上所说的三种中断，我们只要设置一种就可以了。其实，最简单的就是设置更新周期结束中断。每当RTC 更新了CMOS RAM 中的日期和时间后，将发出此中断。更新周期每秒进行一次，因此该中断也每秒发生一次。

为了设置该中断，代码清单9-1 第147 行，将RTC 寄存器B 的索引0x0b 传送到寄存器AL。在访问RTC 期间，最好是阻断NMI，因此，第148、149 行，先用or 指令将AL 的最高位置1，再写端口0x70。

第150、151 行，用于通过数据端口0x71 写寄存器B。写的内容是0x12，其二进制形式为00010010，对照表9-3，其意义不难理解：允许更新周期照常发生，禁止周期性中断，禁止闹钟功能，允许更新周期结束中断，使用24 小时制，日期和时间采用BCD 编码。

每次当中断实际发生时，可以在程序（中断处理过程）中读寄存器C 的内容来检查中断的原因。比如，每当更新周期结束中断发生时，RTC 就将它的第4 位置1。该寄存器还有一个特点，就是每次读取它后，所有内容自动清零。而且，如果不读取它的话（换句话说，相应的位没有清零），同样的中断将不再产生。

为此，第153～155 行，读一下寄存器C 的内容，使之开始产生中断信号。注意，在向索引端口0x70 写入的同时，也打开了NMI。毕竟，这是最后一次在主程序中访问RTC。

当然，如果采用周期性中断而不是更新周期结束中断，则稍微麻烦一些，因为要设置分频电路的分节点。以下代码片断用于产生2 次/秒的周期性中断：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00345.jpeg)

除此之外，还要设置寄存器B 的PIE 位，以允许周期性中断。

RTC 芯片设置完毕后，再来打通它到8259 的最后一道屏障。正常情况下，8259 是不会允许RTC 中断的，所以，需要修改它内部的中断屏蔽寄存器IMR。IMR 是一个8 位寄存器，位0 对应着中断输入引脚IR0，位7 对应着引脚IR7，相应的位是0 时，允许中断，为1 时，关掉中断。

8259 芯片是我见过的芯片中，访问起来最麻烦，也是我最讨厌的一个。好在有关它的资料非常好找，这里就简单地进行讲解。代码清单9-1 第157～159 行，通过端口0xa1 读取8259 从片的IMR 寄存器，用and 指令清除第0 位，其他各位保持原状，然后再写回去。于是，RTC 的中断可以被8259 处理了。

第161 行，sti 指令将标志寄存器的IF 位置1，开放设备中断。从这个时候开始，中断随时都会发生，也随时会被处理。
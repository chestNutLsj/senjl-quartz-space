### 9.1.4　实时时钟、CMOS RAM 和BCD 编码

也许你曾经觉得奇怪，为什么计算机能够准确地显示日期和时间？原因很简单，如图9-2 所示，在外围设备控制器芯片ICH 内部，集成了实时时钟电路（Real Time Clock，RTC）和两小块由互补金属氧化物（CMOS）材料组成的静态存储器（CMOS RAM）。实时时钟电路负责计时，而日期和时间的数值则存储在这块存储器中。

实时时钟是全天候跳动的，即使是在你关闭了计算机的电源之后，原因在于它由主板上的一个小电池提供能量。它为整台计算机提供一个基准时间，为所有需要时间的软件和硬件服务。不像8259 芯片，有关RTC CMOS 的资料相当少见，很不容易完整地找到，而8259 的内容则铺天盖地，到处都是。所以，本章只是简要地介绍8259，而尽量多说一些和RTC 有关的知识。

早期的计算机没有ICH 芯片，各个接口单元都是分立的，单独地焊在主板上，并彼此连接。早期的RTC 芯片是摩托罗拉（Motorola）MS146818B，现在直接集成在ICH 内，并且在信号上与其兼容。除了日期和时间的保存功能外，RTC 芯片也可以提供闹钟和周期性的中断功能。

日期和时间信息是保存在CMOS RAM 中的，通常有128 字节，而日期和时间信息只占了一小部分容量，其他空间则用于保存整机的配置信息，比如各种硬件的类型和工作参数、开机密码和辅助存储设备的启动顺序等。这些参数的修改通常在BIOS SETUP 开机程序中进行。要进入该程序，一般需要在开机时按DEL、ESC、F1、F2 或者F10 键。具体按哪个键，视计算机的厂家和品牌而定。

RTC 芯片由一个振荡频率为32.768kHz 的石英晶体振荡器（晶振）驱动，经分频后，用于对CMOS RAM 进行每秒一次的时间刷新。

如表9-1 所示，常规的日期和时间信息占据了CMOS RAM 开始部分的10 字节，有年、月、日和时、分、秒，报警的时、分、秒用于产生到时间报警中断，如果它们的内容为0xC0～0xFF，则表示不使用报警功能。

表9-1　CMOS RAM 中的时间信息

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00335.jpeg)

CMOS RAM 的访问，需要通过两个端口来进行。0x70 或者0x74 是索引端口，用来指定CMOS RAM 内的单元；0x71 或者0x75 是数据端口，用来读写相应单元里的内容。举个例子，以下代码用于读取今天是星期几：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00336.jpeg)

不得不说的是，从很早的时候开始，端口0x70 的最高位（bit 7）是控制NMI 中断的开关。当它为0 时，允许NMI 中断到达处理器，为1 时，则阻断所有的NMI 信号，其他7 个比特，即0～6位，则实际上用于指定CMOS RAM 单元的索引号，这种规定直到现在也没有改变。

如图9-4 所示，尽管端口0x70 的位7 不是中断信号，但它能控制与非门的输出，决定真正的NMI 中断信号是否能到达处理器。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00337.jpeg)

图9-4　端口0x70 的位7 用于禁止或允许NMI（仅为示意图）

通常来说，在往端口0x70 写入索引时，应当先读取0x70 原先的内容，然后将它用于随后的写索引操作中。但是，该端口是只写的，不能用于读出。在早期的系统中，计算机的制造成本很高，为了最大化地利用硬件资源，导致出现很多稀奇古怪的做法，这就是一个活生生的例子。

为了解决这个问题，同时也为了兼容以前的老式硬件，ICH 芯片允许通过切换访问模式来临时取得那些只写寄存器的内容，但这涉及更高层次的知识，已经超出了当前的话题范畴。现在，我们只想把问题搞得简单些，这么说吧，NMI 中断应当始终是允许的，在访问RTC 时，我们直接关闭NMI，访问结束后，再打开NMI，而不管它以前到底是什么样子。

在早期，CMOS RAM 只有64 字节，而最新的ICH 芯片内则可能集成了256 字节，新增的128字节称为扩展的CMOS RAM。当然，在此之前，要先确保ICH 内确实存在扩展的CMOS RAM。

CMOS RAM 中保存的日期和时间，通常是以二进制编码的十进制数（Binary Coded Decimal，BCD），这是默认状态，如果需要，也可以设置成按正常的二进制数来表示。要想说明什么是BCD 编码，最好的办法是举个例子。比如十进制数25，其二进制形式是00011001。但是，如果采用BCD 编码的话，则一个字节的高4 位和低4 位分别独立地表示一个0 到9 之间的数字。因此，十进制数25 对应的BCD 编码是00100101。由此可以看出，因为十进制数里只有0～9，故用BCD 编码的数，高4 位和低4 位都不允许大于1001，否则就是无效的。

单元0x0A～0x0D 不是普通的存储单元，而被定义成4 个寄存器的索引号，也是通过0x70 和0x71 这两个端口访问的。这4 个寄存器用于设置实时时钟电路的参数和工作状态。

寄存器A 和B 用于对RTC 的功能进行整体性的设置，它们都是8 位的寄存器，可读可写，其各位的用途如表9-2 和表9-3 所示。

表9-2　寄存器A 各位功能说明

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00338.jpeg)

续表

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00339.jpeg)

表9-3　寄存器B 各位功能说明

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00340.jpeg)

寄存器C 和D 是标志寄存器，这些标志反映了RTC 的工作状态，寄存器C 是只读的，寄存器D 则可读可写，它们也都是8 位寄存器，其各位的含义如表9-4 和表9-5 所示。特别是寄存器C，因为RTC 可以产生中断，当中断产生时，可以通过该寄存器来识别中断的原因，比如，是周期性的中断，还是闹钟中断。

表9-4　寄存器C 各位功能说明

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00341.jpeg)

表9-5　寄存器D 各位功能说明

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00342.jpeg)

讲了这么多和8259 以及RTC 有关的内容，现在，我们想让RTC 芯片定期发出一个中断，当这个中断发生的时候，还能执行我们自己编写的代码，来访问CMOS RAM，在屏幕上显示一个动态走动的时钟。
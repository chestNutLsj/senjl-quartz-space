### 9.3.1　BIOS 中断

可以为所有的中断类型自定义中断处理过程，包括内部中断、硬件中断和软中断。特别是考虑到处理器允许256 种中断类型，而且大部分都没有被硬件和处理器内部中断占用。

编写自己的中断处理程序有相当大的优越之处。不像jmp 和call 指令，int 指令不需要知道目标程序的入口地址。远转移指令jmp 和远调用指令call 必须直接或者间接给出目标位置的段地址和偏移地址，如果所有这一切都是自己安排的，倒也不成问题，但如果想调用别人的代码，比如操作系统的功能，这就很麻烦了。举个例子来说，假如你想读硬盘上的一个文件，因为操作系统有这样的功能，所以就不必在自己的程序中再写一套代码，直接调用操作系统例程就可以了。

但是，操作系统通常不会给出或者公布硬盘读写例程的段地址和偏移地址，因为操作系统也是经常修改的，经常发布新的版本。这样一来，例程的入口地址也会跟着变化。而且，也不能保证每次启动计算机之后，操作系统总待在同一个内存位置。

因为有了软中断，这是个利好条件。每次操作系统加载完自己之后，以中断处理程序的形式提供硬盘读写功能，并把该例程的地址填写到中断向量表中。这样，无论在什么时候，用户程序需要该功能时，直接发出一个软中断即可，不需要知道具体的地址。

最有名的软中断是BIOS 中断，之所以称为BIOS 中断，是因为这些中断功能是在计算机加电之后，BIOS 程序执行期间建立起来的。换句话说，这些中断功能在加载和执行主引导扇区之前，就已经可以使用了。

BIOS 中断，又称BIOS 功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号，比如，使用键盘服务时，中断号是0x16，即

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00354.jpeg)

通常，为了区分针对同一硬件的不同功能，使用寄存器AH 来指定具体的功能编号。举例来说，以下指令用于从键盘读取一个按键：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00355.jpeg)

在这里，当寄存器AH 的内容是0x00 时，执行int 0x16 后，中断服务例程会监视键盘动作。当它返回时，会在寄存器AL 中存放按键的ASCII 码。

BIOS 中断很多，它们是在BIOS 执行期间安装的，当主引导程序开始执行时，就可以在程序中使用了。本准备给出一张BIOS 功能调用列表，但是考虑到现在网络技术很发达，上网很方便，大家可以自行从互联网上寻找相关的BIOS 功能调用资料，然后在自己的程序中做实验。

你可能觉得奇怪，BIOS 是怎么建立起这套功能调用中断的？它又是怎么知道如何访问硬件的？毕竟，即使是它，要访问硬件也得通过端口一级的途径。

答案是，BIOS 可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS 中断是由外部设备接口自己建立的。

首先，每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器（Read Only Memory，ROM），类似于BIOS 芯片，这些ROM 中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容是0x55 和0xAA，第三个单元是本ROM 中以512 字节为单位的代码长度；从第四个单元开始，就是实际的ROM 代码。

其次，我们知道，从内存物理地址A0000 开始，到FFFFF 结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的ROM 会映射到分配给它的地址范围内。

在计算机启动期间，BIOS 程序会以2KB 为单位搜索内存地址C0000～E0000 之间的区域。当它发现某个区域的头两个字节是0x55 和0xAA 时，那意味着该区域有ROM 代码存在，是有效的。接着，它对该区域做累加和检查，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。
### 6.12.1　调试命令“n”的使用

要调试本章的程序，可以利用上一章里介绍的方法，其中非常重要的一个调试命令是单步执行命令“s”。

单步执行有一个缺点，就是会陷入同一条指令的多次重复执行里，比如rep movsw 指令。如图6-7 所示，由于是在两个内存区域之间复制字符，rep movsw 指令要执行很多次，每当输入“s”命令后，执行的依然是movsw 指令，直到寄存器CX 的内容为零，复制过程结束后，才开始单步执行下一条指令。注意，在图中，Bochs 使用了rep movsw 指令的另一种形式“rep movsw word ptr es:[di],word ptr ds:[si]”，它们其实是一回事。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00188.jpeg)

图6-7　单步执行rep movsw 指令时的情景

除了rep movsw 指令，本章中的loop 指令也会使单步执行陷入循环体中，直到循环条件不成立，退出循环时，才开始单步执行循环体外的下一条指令。如图6-8 所示，当单步执行循环指令loop .-9 时（本指令的物理内存地址是0x0000000000007C4A），下一条指令马上变成循环体内的第一条指令（xor dx,dx，物理内存地址为0x0000000000007C43）。只有当寄存器CX 的内容为零时，才开始单步执行循环体外的下一条指令。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00189.jpeg)

图6-8　Bochs 单步执行loop 指令时的情景

在图中，loop 指令的目标地址是用标号“.-9”表示的，这条指令就是本章程序中的指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00190.jpeg)

但是，程序在编译后，所有标号都消失了。当Bochs 重现这些程序时，不可能知道这里原先是一个标号“digit”。因此，它用loop 指令的操作数作为标号。我们知道，loop 指令的操作数是一个相对量，是用目标处的汇编（偏移）地址减去当前指令的汇编（偏移）地址，再减去loop 指令的长度（2）得到的。因此，如图中所示，0x7c4a 减去0x7c43（循环体内的第一条指令xor dx,dx），再减去2，只保留一个字节，就是0xf7，即十进制数－9。

可以想象，如果循环的次数很多（有时候，循环成千上万次是很正常的），则我们就无法调试循环体后面的程序。在这种情况下，你应当在执行rep movsb、repmovsw 和loop 指令的时候，使用调试命令“n”。此时，Bochs 将自动完成循环过程，并在循环体外的下一条指令前停住。
### 6.9.3　溢出标志OF

对于无符号数运算来说，进位标志CF 通常意味着得到了错误的计算结果，因为目的操作数没能容纳那个进位。这里有一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00177.jpeg)

执行以上两条指令后，进位标志CF 为1，这是肯定的了，因为最高位有进位。从无符号数的角度来看，是255+2，结果应当是257。但是你看，因为寄存器AH 只有8 位，所以进位丢失，得到的结果是1，这明显是错的。

但是，如果上面进行的是有符号数运算，那么，这实际上是在计算-1+2（十进制），AH 中的最终的结果是1，这是正确的。

很显然，同样的运算，从无符号数和有符号数的视角来看，是不同的。但是，在所有的情况下，处理器都不可能知道你的意图，不知道你进行的是有符号数运算，还是无符号数运算。为此，它提供了溢出标志OF，该标志的意思是，假定你进行的是有符号数运算，如果运算结果是正确的，那么OF=0，否则OF=1。比如上面的例子，因为从有符号数的角度来看，是-1 和2 相加，结果为1，未溢出，故OF=0。简单地说，OF 标志用于指示两个有符号数的运算结果是否错误。

再看一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00178.jpeg)

首先，本次相加，用二进制数来说就是01110000+01110000=11100000，最高位没有进位，故CF=0。

其次，从无符号数的角度来看（十进制），即112+112=224，并未超出一个字节所能容纳的数值上限255，结果是正确的。

但是，从有符号数运算的角度来看（十进制），即112+112=-32，两正数相加，结果为负，明显是错的，在这种情况下，OF=1。错误的原因是，两个正数112 和112 相加，理论上的计算结果224 超出了寄存器AH 所能容纳的有符号数的范围-128～127，所以破坏了符号位，使得结果变成了负数（-32）

既然如此，可以使用16 位寄存器AX，毕竟它能容纳的数据范围更大一些：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00179.jpeg)

这次，无论它是有符号数运算，还是无符号数运算，结果都是正确的。故CF=0，OF=0。

因为在任何时候，处理器都不可能知道你的意图，不知道你进行的是有符号数运算，还是无符号数运算。因此，它所能做的，就是假定进行的是有符号数运算，并根据结果提供OF 标志，至于如何处理，是你自己的事。比如说，如果你进行的是无符号数运算，那么，你可以不用理会该标志。
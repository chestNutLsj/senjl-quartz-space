### 6.7.2　处理器视角中的数据类型

无符号数和有符号数的划分并没有从根本上打消我们的疑虑，即假如寄存器AX 中的内容是0xB23C，那么，它到底是无符号数45628 呢，还是应当将其看成是－19908？

答案是，这是你自己的事，取决于你怎么看待它。对于处理器的多数指令来说，执行的结果和操作数的类型没有关系。换句话说，无论你是从无符号数的角度来看，还是从有符号数的角度来看，指令的执行结果都是正确无误的。比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00158.jpeg)

这条指令显然根本不考虑操作数的类型。再比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00159.jpeg)

在这里，0xf0 的二进制形式是11110000，它既可以解释为无符号数240（十进制），也可以解释为有符号数－16，毕竟它的符号位是1。无论如何，inc 是加一指令，这条指令执行后，AH 中的内容是二进制数11110001，既是无符号数241，也是有符号数－15。

再考虑加法运算。比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00160.jpeg)

0x8c03 的二进制形式是1000110000000011，既可以看做无符号数35843（十进制），也可以看成是有符号数－29693（十进制）。在运算过程中，数的视角要统一，如果把0x8c03 看成是无符号数，那么0x05 也是无符号数；如果0x8c03 是有符号数，那么0x05 也是有符号数。

关键是运算后的结果。很幸运的是，add 指令同样适用于无符号数和有符号数。所以，这两条指令执行后，AX 中的内容是0x8c08，分别可以看成是无符号数35848 和有符号数－29688。

再来考虑一下减法。考虑一下，如果要计算10－3，这其实可以看成是10＋（－3）。因此，使用以下三条指令就可以完成减法运算：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00161.jpeg)

正是因为这个原因，很多处理器内部不构造减法电路，而是使用加法电路来做减法。

尽管如此，为了方便起见，处理器还是提供了减法指令sub，该指令和加法指令add 相似，目的操作数可以是8 位或者16 位通用寄存器，也可以是8 位或者16 位的内存单元；源操作数可以是通用寄存器，也可以是内存单元或者立即数（不允许两个操作数同时为内存单元）。比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00162.jpeg)

因为处理器没有减法运算电路，所以，举例来说，sub ah,al 指令实际上等效于下面两条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00163.jpeg)

可以这么说，几乎所有的处理器指令既能操作无符号数，又能操作有符号数。但是，有几条指令除外，比如除法指令和乘法指令。

我们已经学过除法指令div。严格地说，它应该叫做无符号除法指令（Unsigned Divide），因为这条指令只能工作于无符号数。换句话说，只有从无符号数的角度来解释它的执行结果才能说得通。举个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00164.jpeg)

从无符号数的角度来看，0x0400 等于十进制数1024，0xf0 等于十进制数240。相除后，寄存器AL 中的商为0x04，即十进制数4，完全正确。

但是，从有符号数的角度来看，0x0400 等于十进制数1024，0xf0 等于十进制数－16。理论上，相除后，寄存器AL 中结果应当是0xc0。因其最高位是“1”，故为负数，即十进制数为－64。

为了解决这个问题，处理器专门提供了一个有符号数除法指令idiv（Signed Divide）。idiv 的指令格式和div 相同，除了它是专门用于计算有符号数的。如果你决定要进行有符号数的计算，必须采用如下代码：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00165.jpeg)

在用idiv 指令做除法时，需要小心。比如用0xf0c0 除以0x10，也就是十进制数的除法－3904÷ 16。你的做法可能会是这样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00166.jpeg)

以上的代码是16 位二进制数除法，结果在寄存器AL 中。除法的结果应当是十进制数－244，遗憾的是，这样的结果超出了寄存器AL 所能表示的范围，必然因为溢出而不正确。为此，你可能会用32 位的除法来代替以前的做法：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00167.jpeg)

很遗憾，这依然是错的。十进制数－3904 的16 位二进制形式和32 位二进制形式是不同的。前者是0xf0c0，后者是0xfffff0c0。还记得cwd 吗？你应该用这条指令把寄存器AX 中数的符号扩展到DX。所以，完全正确的写法是这样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00168.jpeg)

以上指令全部执行后，寄存器AX 中的内容为0xff0c，即十进制数－244。

主动权在你自己手上，在写程序的时候，你要做什么，什么目的，你自己最清楚。如果是无符号数计算，必须使用div 指令；如果你是在做有符号数计算，就应当使用idiv 指令。

检测点6.3

假如以下声明的是有符号数，那么，其中的负数是（　　　　　　　　　　　　　）。

data0 db 0xf0,0x05,0x66,0xff,0x81

data1 dw 0xfff,0xffff,0x8b,0x8a08
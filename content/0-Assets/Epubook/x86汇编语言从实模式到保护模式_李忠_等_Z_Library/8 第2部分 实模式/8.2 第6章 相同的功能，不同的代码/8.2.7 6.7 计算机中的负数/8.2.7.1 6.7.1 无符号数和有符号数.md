### 6.7.1　无符号数和有符号数

为了讲解后面的内容时能够顺利一些，现在我们离开源程序，来介绍一些题外的知识。

从本书的开篇到现在，我们一直没有提到负数，就好像世界上根本没有负数一样。计算机当然要处理负数，要不然它将没有多少实用价值。

在计算机中使用负数，这是一个容易令人产生迷惑的话题。不信？现在就开始了。

尽管我们从来没有考虑过数的正负问题，但是，事实上，我们在编写程序的时候，既可以使用正数，也可以使用负数。如图6-3 所示，我们在程序中用伪指令db 声明了一些正数和一些负数。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00143.jpeg)

图6-3　在汇编源程序中使用负数的例子

图6-4 显示了编译后的结果。用伪指令db 声明的数据都只有一个字节的长度， 所以很容易在这两幅图的各个数之间建立对应关系。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00144.jpeg)

图6-4　正数和负数编译后的结果

前面的正数都很好理解，十进制数128 对应的二进制数是10000000，对应的十六进制数是0x80；十进制数0 对应的二进制数是00000000，对应的十六进制数是0x00。为什么我们对此不感到新鲜？因为这显得非常自然，从本书一开始到现在，我们就是这样工作的。

真正的麻烦在于后面的负数，比如－1，它在编译的时候，编译器会怎么做呢？

它很笨，但也很聪明。因为－1 其实等于0－1，它就知道可以做一次减法。当然，这个减法，不是你已经熟悉的十进制减法，这没有用，你得做二进制的减法，也就是用二进制数0 减去二进制数1，结果是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00145.jpeg)

注意左边的省略号，这是因为在相减的过程中，不停地向左边借位的结果。因此，可以说，这个数字是很长的，取决于你什么时候停止借位。

再比如十进制数－2，可以用0－2 来得到，在二进制的世界里，该减法是二进制数0 减去二进制数10，结果是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00146.jpeg)

同样，相减的过程要向左借位，所以这个数字相当长。但是，最右边那一位是0。

在计算机中，数字保存在寄存器里，而在16 位处理器里，寄存器通常是8 位和16 位的。因此，以上相减的结果，只能保留最右边的8 位或者16 位。举个例子，十进制数－1 在寄存器AL中的二进制形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00147.jpeg)

即0xFF；十进制数－2 在寄存器AL 中的二进制形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00148.jpeg)

即0xFE。如果是16 位的寄存器，则相应地，要保留相减结果的最右边16 位。因此，十进制数-1 在AX 寄存器中的二进制形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00149.jpeg)

即0xFFFF；十进制数－2 在寄存器AX 中的二进制形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00150.jpeg)

即0xFFFE。

当然，数据还可以保存在内存中，或者编译后的二进制文件中。在二进制文件中，数据是用伪指令db 或者dw 等定义的。但是，数据的表示形式和它们在寄存器中的形式相同，以下代码片断很清楚地说明了这一点。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00151.jpeg)

这是很令人吃惊的。因为我们知道，0xFF 等于十进制数255，但现在它又是十进制数－1，哪一个才是正确的呢？我们应该以哪一个为准呢？

好吧，假设这勉强能接受的话，那么，对照一下图6-3 和图6-4，你会发现，0x80 既是十进制数128，又是十进制数－128，到底哪一个是正确的呢？

这真是令人头疼的问题，不单单是对我们，对几十年前那些计算机工程师们来说也是如此。

一个良好的解决方案是，将计算机中的数分成两大类：无符号数和有符号数。无符号数的意思是我们不关心这些数的符号，因此也就无所谓正负，反正它们就是数而已，就像小学生一样，眼中只有自然数。在8 位的字节运算中，无符号数的范围是00000000～11111111，即十进制的0～255；在16 位的字运算中，无符号数的范围是0000000000000000～1111111111111111，即十进制的0～65535；在将来要讲到的32 位运算中，无符号数的范围是000000000000000000000000～ 11111111111111111111111111111111，即十进制的0～4294967295。很显然，我们以前使用的一直是无符号数。

相反地，有符号数是分正、负的，而且规定，数的正负要通过它的最高位来辨别。如果最高位是0，它就是正数；如果是1，就是负数。如此一来，在8 位的字节运算环境中，正数的范围是00000000～01111111，即十进制的0～127；负数的范围是10000000～11111111，即十进制的－128～－1。

正的有符号数，和与它同值的无符号数相同，这没什么好说的，毕竟它们形式上相同，按相同的方式处理最为方便。但是，负数就不同了，在这里，10000000～11111111 这些负数，都是用0减去它们相对应的正数得到的。想知道它们各自对应的正数是谁吗？很简单，因为“负数的负数”是正数，所以只需要用0 减去这个负数就行。所以，你可以试试看，因为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00152.jpeg)

所以，10000000～11111111 这个范围内的有符号数，对应着十进制数－128～－1。

顺便说一下，在8086 处理器中，有一条指令专门做这件事，它就是neg。neg 指令带有一个操作数，可以是8 位或者16 位的寄存器，或者内存单元。如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00153.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00154.jpeg)

它的功能很简单，用0 减去指令中指定的操作数。例子：如果AL 中的内容是00001000（十进制数8），执行neg al 后，AL 中的内容变为11111000（十进制数－8）；如果AL 中的内容为11000100（十进制数－60），执行neg al 后，AL 中的内容为00111100（十进制数60）。

相应地，在16 位的字运算环境中，正数的范围是0000000000000000～0111111111111111，即十进制的0～32767，负数的范围是1000000000000000～1111111111111111，即十进制的－32768～－1。

不要给计算机和编译器添麻烦。既然你已经知道一个字节可以容纳的数据范围是十进制的－128～127，就不要这样写：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00155.jpeg)

寄存器AL 只有8 位，因此，编译后，－200 将被截断，机器码为B0 38。你可以这样写：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00156.jpeg)

这时，编译后的机器码为B8 38 FF。

同样的规则也适用于伪指令db 和dw。举例（以下均为十进制数）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00157.jpeg)

32 位有符号数是16 位和8 位有符号数的超集，16 位有符号数又是8 位有符号数的超集，它们互相之间有重叠的部分。正数还好说，十进制数15，在8 位运算环境中是00001111，在16位运算环境中是0000000000001111，没有什么区别。但是，同一个负数，其表现形式略有差别。比如十进制数－3，它在8 位运算中是11111101，即0xFD；在16 位运算中，则是1111111111111101，即0xFFFD。这种差别的来源很简单，我们已经讲过了，在计算机中，－3 是用0 减去3 得到的，在8 位运算中只能保留结果的低8 位，即11111101（0xFD）；在16 位运算中只能保留结果的低16 位，即1111111111111101（0xFFFD）。

很显然，一个8 位的有符号数，要想用16 位的形式来表示，只需将其最高位，也就是用来辨别符号的那一位（几乎所有的书上都称之为符号位，实际上这并不严谨），扩展到高8 位即可。为了方便，处理器专门设计了两条指令来做这件事：cbw（Convert Byte to Word）和cwd（Convert Word to Double-word）。

cbw 没有操作数，操作码为98。它的功能是，将寄存器AL 中的有符号数扩展到整个AX。举个例子，如果AL 中的内容为01001111，那么执行该指令后，AX 中的内容为0000000001001111；如果AL 中的内容为10001101，执行该指令后，AX 中的内容为1111111110001101。

cwd 也没有操作数，操作码为99。它的功能是，将寄存器AX 中的有符号数扩展到DX:AX。举个例子，如果AX 中的内容为0100111101111001，那么执行该指令后，DX 中的内容为0000000000000000，AX 中的内容不变；如果AX 中的内容为1000110110001011，那么执行该指令后，DX 中的内容为1111111111111111，AX 中的内容同样不变。

尽管有符号数的最高位通常称为符号位，但并不意味着它仅仅用来表示正负号。事实上，通过上面的讲述和实例可以看出，它既是数的一部分，和其他比特一起共同表示数的大小，同时又用来判断数的正负。
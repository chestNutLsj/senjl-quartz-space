   

## 12.5　使用别名访问代码段对字符排序

接下来要做的事情是对一串散乱的字符进行排序。坦白地说，排序是假，主要目的是演示如何在保护模式下使用别名段。

字符串位于代码清单12-1 的第105 行，用标号string 声明，并初始化为以下字符：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00505.jpeg)

这串字符是主引导程序的一部分，在进入保护模式时，它就位于32 位代码段中。代码段是用来执行的，能不能读出，取决于其描述符的类别字段。但是无论如何，它都不允许写入。

这可就难办了。我们想就地把这串字符按ASCII 码从小到大排列，涉及原地写入数据的操作。好在前面已经建立了代码段的别名描述符，而且用段寄存器DS 指向它。参见代码清单12-1第59、60 行。

冒泡排序是比较容易理解的排序算法，但却并不是效率最高的，因此，速度自然也就很慢。如果字符串的长度（字符的数量）是n 个，而且要从小到大排序，那么，可以将它们从头至尾两两比较，需要比较n-1 次。但是，不要高兴太早，这一次遍历只会使最大的那个字符慢慢地、像气泡一样移动到最右边。

所以，你需要多次进行这样的遍历才能完成所有字符的排序，每一次遍历都会使一个字符冒泡到正确的位置。可以计算，共需要n-1 次这样的遍历。有关冒泡排序算法的更多信息，请参考其他资料。

可见，这需要两个循环，一个外循环，用于控制遍历次数；一个内循环，用于控制每次遍历时的比较次数。在32 位模式下，loop 指令所用的计数器不是CX，而是ECX。两个循环需要共用ECX，这需要点技巧，那就是利用栈：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00506.jpeg)

我相信这段框架性的代码还是很好理解的。外循环总共执行n-1 次。每执行一次外循环，内循环就会将一个数排到正确的位置，从而使下一次内循环少一次两两比对（少执行一次）。也就是说，ECX 寄存器的当前值总是内循环的次数，这就是为什么内循环的loop 指令要使用外循环的ECX 值。

代码清单12-1 第77 行，用后面的标号pdgt 减去声明字符串的标号string，就是字符串的长度，再减去一，就是控制循环的次数。

第79 行，将循环次数压栈，因为内循环会改变ECX 的内容。

第80 行，清零BX 寄存器。该寄存器在每次内部循环之前清零，用于从字符串的开始处进行比对。之所以没有使用EBX，是因为要让你知道，32 位代码中也可以使用16 位的寄存器来寻址。注意，我们知道，在32 位模式下，如果指令的操作数是16 位的，要加前缀0x66。相似地，在32 位模式下，如果要在指令中使用16 位的有效地址，那么，必须为该指令添加前缀0x67。因此，当指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00507.jpeg)

用bits 32 编译后，会有指令前缀0x67；在32 位模式下执行时，处理器会用数据段描述符中给出的32 位数据段基地址，加上BX 寄存器的16 位偏移量，形成32 位线性地址。

实际进行字符比对的代码是第81～91 行。首先一次性读取两个字符到AX 寄存器中。当前的数据段是由段寄存器DS 指向的，其描述符给出的基地址为0x00007C00，字符串的首地址就是标号string 的汇编地址，寄存器BX 用来指定字符串内的偏移量。

接着，对寄存器AH 和AL 的内容进行比较。如图12-6 所示，AL 中存放的是前一个字符，AH 中存放的是后一个字符。如果前一个字符较大，则交换AH 和AL 的内容，然后重新写回原来的字单元。然后，将BX 寄存器的内容加一，以指向下一个字符。

xchg 是交换指令，用于交换两个操作数的内容，源操作数和目的操作数都可以是8/16/32 位的寄存器，或者指向8/16/32 位实际操作数的内存单元地址，但不允许两者同时为内存地址。其格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00508.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00509.jpeg)

举个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00510.jpeg)

以上指令执行后，寄存器ECX 中的内容为0xABCDEF00，EDX 中的内容为0xF000F000。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00511.jpeg)

图12-6　通过AX 寄存器比对和排序相邻字符

第93～100 行用于显示最终的排序结果，同样使用了循环，循环次数就是字符串的长度。和排序的时候不同，现在终于使用EBX 了，这将提供32 位的偏移地址。

第96 行，向寄存器AH 传送的是字符的显示属性（颜色），0x07 表示黑底白字，我们已经无数次重复说过了。

第98 行是向显存中传送字符及其显示属性：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00512.jpeg)

段寄存器ES 是在刚进入保护模式时设置的，它指向0～4GB 内存的段。0xb80a0 等于0xb8000 加上十进制数160（0xa0）。在显存中，偏移量为160 的地方对应着屏幕第2 行第1 列。32 位处理器提供了强大的寻址方式，可以在基址寄存器的基础上使用比例因子，这里是将EBX 寄存器的内容乘以2。当EBX 的内容为0、1、2、3、…时，计算出来的有效地址分别是0xb80a0、0xb80a2、0xb80a4、0xb80a6、…，后面的以此类推，很容易看到使用比例因子的好处。注意，该表达式的值是在本指令执行时，由处理器来计算的。

最后，在完成了所有的工作之后，第102 行，hlt 指令使处理器处于停机状态。
### 12.4.2　栈操作时的保护

在保护模式下操作时，栈是一个容易令人感到迷惑的话题。在截止到目前的所有例子中，栈段一直是使用向下扩展的内存段，段界限的检查和向上扩展的数据段和代码段不同。当然，栈也可以使用向上扩展的段，即，把数据段用做栈段。在这种情况下，对段界限的检查按数据段的规则进行，但是无论如何，栈本身始终总是向下增长的，即，向低地址方向推进。段的扩展方向用于处理器的界限检查，而对栈的性质以及在栈上进行的操作没有关系。在第16、17 章中，我们会接触到用向上扩展的段作为栈段的情况，现在仍然只讨论向下扩展的栈段。

对栈操作的指令一般是push、pop、ret、iret 等。这些指令在代码段中执行，但实际操作的却是栈段。

现在只讨论32 位的栈段，即，其描述符B 位是1 的栈段。处理器在这样的段上执行压栈和出栈操作时，默认使用ESP 寄存器。

和前面刚刚讨论过的代码段一样，在栈段中，实际使用的段界限也和粒度（G）位相关，如果G＝0，实际使用的段界限就是描述符中记载的段界限；如果G＝1，则实际使用的段界限为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00488.jpeg)

栈段是向下扩展的，每当往栈中压入数据时，ESP 的内容要减去操作数的长度。所以，和向高地址方向扩展的段相比，非常重要的一点就是，实际使用的段界限就是段内不允许访问的最低端偏移地址。至于最高端的地址，则没有限制，最大可以是0xFFFFFFFF。也就是说，在进行栈操作时，必须符合以下规则：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00489.jpeg)

在上一章里，栈段的粒度是字节（G＝0），描述符中的段界限是0x07A00。此时，实际使用的段界限也是0x07A00。

假设现在ESP 的内容是0x00007A04，那么，执行下面的指令时，会怎样呢？

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00490.jpeg)

因为是要压入一个双字（4 字节），故处理器在向栈中写入数据之前，先将ESP 的内容减去4，得到0x7A00，这就是ESP 寄存器在进行压栈操作时的新值。因为该值小于实际使用的段界限0x7A00 加一（0x7A01），因此不允许执行该操作。

但是，如果执行的是这条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00491.jpeg)

那么，因为要压入一个字（2 字节），故实际执行压栈操作时，ESP 的内容是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00492.jpeg)

结果大于实际使用的段界限加一，允许操作。

回到本章中，看代码清单12-1 第67～69 行。这三行设置栈的线性基地址为0x00007C00，段界限为0xFFFFE，粒度为4KB，并设置栈指针寄存器ESP 的初值为0。

因为段界限的粒度是4KB（G＝1），故实际使用的段界限为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00493.jpeg)

又因为ESP 的最大值是0xFFFFFFFF，因此，如图12-4 所示，在操作该段时，处理器的检查规则是：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00494.jpeg)

栈指针寄存器ESP 的内容仅仅在访问栈时提供偏移地址，操作数在压入栈时的物理地址要用段寄存器的描述符高速缓存器中的段基址和ESP 的内容相加得到。因此，该栈最低端的有效物理地址是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00495.jpeg)

最高端的有效物理地址是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00496.jpeg)

也就是说，当前程序所定义的栈空间介于地址为0x00006C00～0x00007BFF 之间，大小是4KB。

现在结合该栈段，用一个实例来说明处理器的检查过程。代码清单第69 行将ESP 的初始值设定为0，因此，当第一次进行压栈操作时，假如压入的是一个双字（4 字节）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00497.jpeg)

因为压栈操作是先减ESP，然后再访问栈，故ESP 的新值是（可以自行用Windows 计算器算一下）

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00498.jpeg)

这个结果符合上面的限制条件，允许操作。此时，被压入的那个双字，其线性地址为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00499.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00500.jpeg)

图12-4　对栈段偏移地址的检查

尽管这里讨论的是push 指令，但对于其他隐式操作栈的指令，比如pop、call、ret 等，情况也没有什么不同，也要根据操作数的大小来检查是否违反了段界限的约束，以防止出现访问越界的情况。
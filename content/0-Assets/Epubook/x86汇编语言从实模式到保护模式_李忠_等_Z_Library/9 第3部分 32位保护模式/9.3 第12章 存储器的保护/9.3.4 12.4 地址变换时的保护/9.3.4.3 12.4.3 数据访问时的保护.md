### 12.4.3　数据访问时的保护

这里所说的数据段，特指向上扩展的数据段，有别于栈和向下扩展的数据段。

因为是向上扩展的，所以代码段的检查规则同样适用于数据段。不同之处仅仅在于，对于取指令来说，是否越界取决于指令的长度；而对于数据段来说，则取决于操作数的尺寸。考虑以下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00501.jpeg)

这条指令将访问内存，并将EDX 寄存器的内容写入当前段内偏移量为0x2000 的双字单元。指令中给出了内存单元的有效地址EA（0x2000），也给出了操作数的大小（4）。

很好，现在，当处理器访问数据段时，要依据以下规则进行检查：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00502.jpeg)

在任何时候，段界限之外的访问企图都会被阻止，并引发处理器异常中断。

在32 位处理器上，尽管段界限的检查总在进行着，但如果段界限具有最大值，则对任何内存地址的访问都将不会违例。比如本章就定义了一个具有4GB 长的段，段的基地址是0x00000000，段界限是0xFFFFF，粒度为4KB。因此，实际使用的段界限是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00503.jpeg)

在这样的段内，访问任何一个内存单元都是允许的，针对段界限的检查都会获得通过。

在32 位模式下，处理器使用32 位的段基地址加上32 位的偏移量，共同形成32 位的物理地址来访问内存。段基地址由段描述符指定，而偏移量由指令直接或者间接给出。很显然，在段最大的时候，可以自由访问4GB 空间内的任何一个单元。

代码清单12-1 第71～74 行，从物理地址0x000B8000 开始写入16 字节的内容，用于演示4GB 内存地址空间的访问。段寄存器ES 当前正指向0 到4GB 的内存空间，其描述符高速缓存器中的基地址是0x00000000，加上指令中提供的32 位偏移量，所访问的地方正是显示缓冲区（显存）所在的区域。这其中的道理很简单，首先，内存的寻址依赖于段基地址和偏移地址，段基地址是0，所以，可以把任何要访问的物理地址作为偏移量。

这16 字节的内容是8 个字符的ASCII 码，以及它们各自的显示属性（颜色）。如图12-5 所示，和往常一样，双字在内存中的写入依然是低端字节序的，这里再次展示一下，以帮助理解。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00504.jpeg)

图12-5　以低端字节序向内存中写入双字

要理解32 位模式下的寻址，以及数据访问时的保护机制，这是一个很好的例子。

检测点12.2

当前栈段描述符的B 位是1，基地址为0x00700000，界限值为0xFFFFE。那么，在32 位模式下，该栈段的有效地址范围是0x00700000～（　　　）。当ESP 的内容为0xFFFFF002 时，还能压入一个双字吗？为什么？
### 12.4.1　代码段执行时的保护

在32 位模式下，尽管段的信息在描述符表中，但是，一旦相应的描述符被加载到段寄存器的描述符高速缓存器，则处理器取指令和执行指令时，将不再访问描述符表，而是直接使用段寄存器的描述符高速缓存器，从中取得线性基地址，同指令指针寄存器EIP 的内容相加，共同形成32位的物理地址从内存中取得下一条指令。不过，在指令实际开始执行之前，处理器必须检验其存放地址的有效性，以防止执行超出允许范围之外的指令。

每个代码段都有自己的段界限，位于其描述符中。实际使用的段界限，其数值和粒度（G）位有关，如果G＝0，实际使用的段界限就是描述符中记载的段界限；如果G＝1，则实际使用的段界限为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00484.jpeg)

该计算公式已经在前面出现过，不再解释。

代码段是向上（高地址方向）扩展的，因此，实际使用的段界限就是当前段内最后一个允许访问的偏移地址。当处理器在该段内取指令执行时，偏移地址由EIP 提供。指令很有可能是跨越边界的，一部分在边界之内，一部分在边界之外，或者一条单字节指令正好位于边界上。因此，要执行的那条指令，其长度减1 后，与EIP 寄存器的值相加，结果必须小于等于实际使用的段界限，否则引发处理器异常。即：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00485.jpeg)

在本章中，代码段描述符中给出的界限值是0x001FF，粒度是字节，可以认为它就是段内最后一个允许访问的偏移地址。如图12-3 所示，在处理器取得一条指令后，EIP 寄存器的数值加上该指令的长度减1，得到的结果必须小于等于0x000001FF，如果等于或者超出这个数值，必然引发异常中断。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00486.jpeg)

图12-3　对代码段偏移地址的检查

做为一个额外的例子，现在，假设当前代码段的粒度是4KB，那么，因为描述符中的段界限值是0x001FF，故实际使用的段界限是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00487.jpeg)

可以认为，此数值就是当前段内最后一个允许访问的偏移地址。任何时候，EIP 寄存器的内容加上取得的指令长度减1，都必须小于等于0x001FFFFF，否则将引发处理器异常中断。

任何指令都不允许，也不可能向代码段写入数据。而且，只有在代码段可读的情况下（由其描述符指定），才能由指令读取其内容。
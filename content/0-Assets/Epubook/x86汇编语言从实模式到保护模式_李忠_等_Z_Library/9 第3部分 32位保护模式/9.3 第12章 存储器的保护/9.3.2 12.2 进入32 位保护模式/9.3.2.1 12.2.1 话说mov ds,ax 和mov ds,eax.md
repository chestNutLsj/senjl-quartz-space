### 12.2.1　话说mov ds,ax 和mov ds,eax

本章的代码和上一章有几分类似，但实质上有很大区别。

我们知道，段寄存器（选择器）的值只能用内存单元或者通用寄存器来传送，一般的指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00465.jpeg)

这里有一个常见的例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00466.jpeg)

在16 位模式下，传送到DS 中的值是逻辑段地址；在32 位保护模式下，传送的是段描述符的选择子。无论传送的是什么，这都不重要，重要的是，在16 位模式和32 位模式下，一些老式的编译器会生成不同的机器代码。下面是一个例证：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00467.jpeg)

由于在16 位模式下，默认的操作数大小是字（2 字节），故生成8E D8 也不难理解。在32 位模式下，默认的操作数大小是双字（4 字节）。由于指令中的源操作数是16 位的AX，故编译后的机器码前面应当添加前缀0x66 以反转默认的操作数大小，即66 8E D8。

很遗憾，由于这一点点区别，有前缀的和没有前缀的相比，处理器在执行时会多花一个额外的时钟周期。问题在于，这样的指令用得很频繁，而且牵扯到内存段的访问，自然也很重要。因此，它们在16 位模式和32 位模式下的机器指令被设计为相同。即都是8E D8，不需要指令前缀。

这可难倒了很多编译器，它们固执地认为，在32 位模式下，源操作数是16 位的寄存器AX时，应当添加指令前缀。好吧，为了照顾它们，很多程序员习惯使用这种看起来有点别扭的形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00468.jpeg)

你别说，还真有效，果然生成的是不加前缀的8E D8。

说到这里，我觉得NASM 编译器还是非常优秀的，起码它不会有这样的问题。因此，不管处理器模式如何变化，也不管指令形式如何变化，以下代码编译后的结果都一模一样：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00469.jpeg)

和这个示例一样，其他从通用寄存器到段寄存器的传送也符合这样的编译规则。因此，代码清单12-1 第7、8 行，用于通过寄存器EAX 来初始化栈段寄存器SS。
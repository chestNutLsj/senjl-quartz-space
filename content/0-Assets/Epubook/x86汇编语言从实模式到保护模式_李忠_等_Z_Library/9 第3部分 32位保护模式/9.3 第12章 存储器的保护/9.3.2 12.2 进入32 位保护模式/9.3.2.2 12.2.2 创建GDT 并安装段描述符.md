### 12.2.2　创建GDT 并安装段描述符

准备进入保护模式。

首先是创建GDT，并安装刚进入保护模式时就要使用的描述符。第12～15 行，首先计算GDT 在实模式下的逻辑地址。在上一章里，GDT 的大小和线性基地址分别是用两个标号gdt_size 和gdt_base 声明和初始化的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00470.jpeg)

但是，如后面的第107、108 行所示，现在已经改成

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00471.jpeg)

另外一个区别是计算GDT 逻辑地址的方法。在32 位处理器上，即使是在实模式下，也可以使用32 位寄存器。所以，第12 行，直接将GDT 的32 位线性基地址传送到寄存器EAX 中。

我们知道，32 位处理器可以执行以下除法操作：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00472.jpeg)

其中，64 位的被除数在EDX:EAX 中，32 位被除数可以在32 位通用寄存器中，也可以在32位内存单元中。因此，第13～15 行，用64 位的被除数EDX:EAX 除以32 位的除数EBX。指令执行后，EAX 中的商是段地址，仅低16 位有效；EDX 中的余数是段内偏移地址，仅低16 位有效。

第17、18 行，初始化段寄存器DS，使其指向GDT 所在的逻辑段。

第21、22 行，安装空描述符。该描述符的槽位号是0，处理器不允许访问这个描述符，任何时候，使用索引字段为0 的选择子来访问该描述符，都会被处理器阻止，并引发异常中断。在现实中，一个忘了初始化的指针往往默认值就是0，所以空描述符的用意就是阻止不安全的访问。很多人喜欢用这个槽位来记载一些私人信息，做一些特殊的用途，认为反正处理器也不用它。但是，这样做可能是不安全的，还没有证据表明Intel 公司保证决不会使用这个槽位。

第25、26 行，安装保护模式下的数据段描述符。参考前面的段描述符格式，可以看出，该段的线性基地址位于整个内存的最低端，为0x00000000；属于32 位的段，段界限是0xFFFFF。但是要注意，段的粒度是以4KB 为单位的。对于以4KB（十进制数4096 或者十六进制数0x1000）为粒度的段，描述符中的界限值加1，就是该段有多少个4KB。因此，其实际使用的段界限为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00473.jpeg)

将其展开后，即

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00474.jpeg)

因此，在换算成实际使用的段界限时，其公式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00475.jpeg)

这就是说，实际使用的段界限是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00476.jpeg)

也就是4GB。就32 位处理器来说，这个地址范围已经最大了。一旦使用这个段，就可以访问0 到4GB 空间内的任意一个单元，这是本书开篇以来，从来没有过的事情。

第29、30 行，安装保护模式下的代码段描述符。该段是32 位的代码，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。对于向上扩展的段来说，段界限在数值上等于段的长度减去1，因此该段的长度是0x200，即512 字节。

根据上一章的经验，该段实际上就是当前程序所在的段（正在安装该描述符呢），也就是主引导程序所在的区域。尽管在描述符中把它定义成32 位的段，但它实际上既包含16 位代码，也包含32 位代码。[bits 32]之前的代码是16 位的，之后的代码是32 位的。不过，在该描述符生效的时候，处理器的执行流已经位于32 位代码中了。

第33、34 行，安装保护模式下的数据段描述符。该段是32 位的数据段，线性基地址为0x00007C00；段界限为0x001FF，粒度为字节。可以看出，该描述符和前面的代码段描述符，描述和指向的是同一个段。你可能很想知道，这样做的用意何在？

参见上一章的表11-1，我们都已经知道，在保护模式下，代码段是不可写入的。所谓不可写入，并非是说改变了内存的物理性质，使得内存写不进去，而是说，通过该段的描述符来访问这个区域时，处理器不允许向里面写入数据或者更改数据。

但是，很多时候，又需要对代码段做一些修改。比如在调试程序时，需要加入断点指令int3。不管怎么样，如果需要访问代码段内的数据，只能重新为该段安装一个新的描述符，并将其定义为可读可写的数据段。这样，当需要修改代码段内的数据时，可以通过这个新的描述符来进行。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00477.jpeg)

图12-1　本章程序中各个部分在内存中的映象

像这样，当两个以上的描述符都描述和指向同一个段时，把另外的描述符称为别名（alias）。注意，别名技术并非仅仅用于读写代码段，如果两个程序想共享同一个内存区域，可以分别为每个程序都创建一个描述符，而且它们都指向同一个内存段，这也是别名应用的例子。

第36、37 行，安装保护模式下的栈段描述符。该段的线性基地址是0x00007C00，段界限为0xFFFFE，粒度为4KB。

尽管该段和代码段使用同一个线性基地址，但这不会有什么问题，代码段是向上（高地址方向）扩展的，而栈段是向下（低地址方向）扩展的。至于段界限为0xFFFFE，粒度为4KB，我知道你可能会有某些疑问，这些事情马上就会讲到。

第40 行，设置GDT 的界限值为39，因为这里共有5 个描述符，总大小为40 字节，界限值为39。后面的代码用于进入保护模式，差不多和上一章相同，不再赘述。GDT 和GDT 内的描述符，以及本章程序，它们在内存中的映象如图12-1 所示。
   

## 13.5　执行用户程序

在load_relocate_program 过程的最后，第517 行，把用户程序头部段的选择子传送到AX 寄存器。第519～528 行，从栈中弹出并恢复各个寄存器的原始内容，并返回到调用者。AX 寄存器中的选择子是作为参数返回到主程序的。主程序将用它来找到用户程序的入口，并从那里进入。

从load_relocate_program 过程返回后，第572、573 行用于在屏幕上显示信息，表示加载和重定位工作已经完成。

第575 行，保存内核的栈指针。这是通过将ESP 寄存器的当前值写入内核数据段中来完成的。写入的位置是由标号esp_pointer 指示的，位于第378 行，初始化为一个双字。在进入用户程序后，用户程序应当切换到它自己的栈。从用户程序返回时，还要从这个内存位置还原内核栈指针。

第577 行，使段寄存器DS 指向用户程序头部。这是通过将用户程序头部段选择子传送到DS 来办到的。在用户程序头部段内偏移0x10 处，是用户程序的入口点，分别是32 位的偏移量和16 位的代码段选择子。第579 行，执行一个间接远转移，进入用户程序内接着执行。

现在转到代码清单13-3。

用户程序的入口点是在第56 行。进入用户程序开始执行时，段寄存器DS 是指向头部段的。第57、58 行，使段寄存器FS 指向头部段，因为后面要调用内核过程，而这些过程都要求使用DS，所以要把DS 解放出来。

第60～62 行，切换到用户程序自己的栈，并初始化栈指针寄存器ESP 的内容为0。

第64、65 行，设置段寄存器DS 到用户程序自己的数据段。

第67、68 行，调用内核过程显示字符串，以表明用户程序正在运行中。该内核过程要求用DS:EBX 指向零终止的字符串。

第70～72 行，调用内核过程，从硬盘读一个扇区。从内核代码清单可以知道，ReadDiskData过程的内部名称是read_hard_disk_0。所以，ReadDiskData 需要传入两个参数，第一个是EAX 寄存器，传入要读的逻辑扇区号；第二个是DS:EBX，传入缓冲区的首地址，毕竟读出来的数据要有个地方保存。缓冲区位于用户程序的数据段中，是在第43 行用标号buffer 声明的，并初始化了1024 字节的空间。要读的逻辑扇区号是100，在此之前，我们应当在这个扇区里写一些东西。这件事我们马上就要讲到。

第74～78 行，先调用内核过程显示一个题头，接着，再次调用内核过程显示刚刚从硬盘读出的内容。

在做完了上述事情之后，用户程序的任务也就完成了。第80 行，调用内核过程，以返回到内核。

再次回到代码清单13-2。

在内核中，用户程序的返回点位于第582 行。

在重新接管了处理器的控制权后，第583、584 行，使段寄存器DS 重新指向内核数据段。

第586～588 行，切换栈，使栈段寄存器SS 重新指向内核栈段，并从内核数据段中取得和恢复原先的栈指针位置。

第590、591 行，显示一条消息，表示现在已经回到了内核。

对于一个操作系统来说，下面的任务是回收前一个用户程序所占用的内存，并启动下一个用户程序。但是，我们现在无事可做，所以，第596 行，使处理器进入停机状态。别忘了，在进入保护模式之前，我们已经用cli 指令关闭了中断，所以，除非有NMI 产生，处理器将一直处于停机状态。
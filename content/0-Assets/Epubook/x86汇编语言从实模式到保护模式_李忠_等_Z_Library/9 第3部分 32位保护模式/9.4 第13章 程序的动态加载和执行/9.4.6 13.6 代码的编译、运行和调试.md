   

## 13.6　代码的编译、运行和调试

首先编译本章所有的源程序文件，它们是c13_mbr.asm、c13_core.asm 和c13.asm，这将分别生成c13_mbr.bin、c13_core.bin 以及c13.bin。

使用配书工具FixVhdWr 分别将这些二进制文件写入虚拟硬盘。c13_mbr.bin 的起始逻辑扇区号是0，因为它是主引导代码；c13_core.bin 的起始逻辑扇区号是1；c13.bin 的起始逻辑扇区号是50。除了c13_mbr.bin 外，其他文件的写入位置可以改变，但前提是要修改使用它们的源代码。

用户程序的功能是读取逻辑扇区100，并显示其内容。为此，需要找一个文本文件，并将它写入该扇区。在配书源代码中，提供了一个文本文件diskdata.txt，其大小是512 字节。如图13-11 所示，它包含了512 字节的英文文本。

不强迫你一定要使用这个文件。你完全可以选用其他文件，文件的内容也无所谓，但最好是可读的ASCII 字符。

使用配书工具FixVhdWr 将你采用的文本文件写入虚拟硬盘，逻辑扇区号是100。如果你采用的是其他文件，它或许很长，会连续写入多个扇区。这无所谓，用户程序只读取第一个。

最后，启动虚拟机时，如果一切正常，所显示的画面将如图13-12 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00560.jpeg)

图13-11　diskdata.txt 文件的内容

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00561.jpeg)

图13-12　本章程序的运行结果

具有讽刺意味的是，我在这里大书特书、侃侃而谈INTEL 的处理器，但是，从截图上可以看出，我用的处理器却是AMD 生产的。至于你的计算机用了什么处理器，你自己看看吧，屏幕上的显示会说明一切的。

随着程序代码量的增大，程序的编写和调试也会变得越来越困难。特别是当问题发生的时候，追查出错的位置和错误的原因都需要花费大量的时间、消耗大量的精力。

有时候，最简单的方法却很有效。比如，可以写一个特殊的过程，用来显示某个寄存器的内容。如果你的程序运行时出了问题，可以在有重大嫌疑的指令前后安排一些调用该过程的代码，看看是哪里不正常。这些用于调试程序的位置，叫做检查点。

为了方便调试程序，代码清单13-2 提供了一个过程put_hex_dword，用于以十六进制的形式显示EDX 寄存器的内容。

该过程位于第202 行，它的工作原理很简单，EDX 寄存器是32 位的，从右到左，将它以4 位为一组，分成8 组。每一组的值都在0～15（0x0～0xf）之间，我们把它转换成相应的字符’0’ ～’F’即可。

为了将数值转换成可显示的ASCII 码，可以使用处理器的查表指令xlat（Table Look-up Translation），该指令要求事先在DS:(E)BX 处定义一个用于转换编码的表格，在16 位模式下，使用BX 寄存器；在32 位模式下，使用EBX 寄存器。指令执行时，处理器访问该表格，用AL 寄存器的内容作为偏移量，从表格中取出一字节，传回AL 寄存器。

代码清单13-2 定义的表格在第374 行。在那里，声明了标号bin_hex，并初始化了16 个字符，这是一个二进制到十六进制的对照（检索）表。偏移（索引）为0 的位置是字符“0”；偏移（索引）为0x0f 的位置是字符“F”。

第209、210 行，使段寄存器DS 指向内核数据段，因为对照表bin_hex 位于内核数据段中。

第212 行，使EBX 寄存器指向检索（对照表）的起始处。

转换过程使用了循环，每次将EDX 寄存器的内容循环左移4 位，共需要循环8 次。每次移位后的内容被传送到EAX 寄存器，并用and 指令保留低4 位，高位清零。第218 行，xlat 指令用AL 寄存器中的值作为索引访问对照表，取出相应的字符，并回传到AL 寄存器。

每次从检索（对照）表中得到一个字符，就要调用put_char 过程显示它。但put_char 过程需要使用CL 寄存器作为参数。因此，第220 行，在显示之前先要将ECX 寄存器压栈保护。

xlat指令不影响任何标志位。
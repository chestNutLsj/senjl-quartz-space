### 13.4.3　简单的动态内存分配

下面的工作是把用户程序从硬盘上读到内存中。我们以前的做法是指定一个区域，比如物理地址0x100000，然后把程序加载到那里。如果要加载的程序很多，这就会成为一种需要仔细规划的工作，每个程序加载到哪里，都需要一一指定。

在流行的操作系统里，内存管理是一项重要而又严肃的工作，不用说也相当复杂。它要记住所有可以分配的内存，将它们分成块。这样，当要求分配内存时，内存管理程序将查找并分配那些大小相符的空闲块；当占用这些块的用户终止执行后，还要负责回收它们，以便再用于分配；当内存空间紧张，找不到空闲块，或者空闲块的大小不能满足需求时，内存管理程序还要负责查找那些很少被访问的块，将其中的数据移到硬盘上，腾出空间来满足当前的需求。下次当这些块再次被用到时，再用同样的办法从硬盘调回内存。

讲了这么多，你可能以为我们现在就要写一个内存管理程序。不，不会的，这不太现实。就我们目前的需求来说，只需要一个简单的内存分配程序就可以了，这就是allocate_memory 例程。

allocate_memory 例程位于代码清单13-2 的公共例程段中，它仅仅需要通过ECX 寄存器传入希望分配的字节数。当过程返回时，ECX 寄存器包含了所分配内存的起始物理地址。

allocate_memory 的内存分配策略非常简单。请看代码清单13-2 的第335 行，在内核数据段中声明了标号ram_alloc，并初始化为一个双字0x00100000，这就是可用于分配的初始内存地址。很显然，这个位置正好在1MB 之外。每次请求分配内存时，allocate_memory 过程仅简单地返回该内存单元的值，作为所分配内存的起始地址。同时，将这个值加上所分配的长度，作为下次分配的起始地址写回该内存单元。

因此，在进行了必要的现场压栈保护之后，第239～247 行，先使段寄存器DS 指向内核数据段以访问标号ram_alloc 所指向的内存单元；然后，计算下次可用于分配的起始内存地址并存放到EAX 寄存器中；最后，在ECX 中得到本次分配到的起始内存地址，这个值将返回给调用者。当然，在这个过程中没有检测是否超越了实际拥有的物理内存。我们的程序都非常小，现在哪台计算机没有几十兆、几百兆甚至几个吉的内存呢？

原则上，将EAX 寄存器中的值写回ram_alloc 所指向的双字单元即可。不过，32 位的计算机系统建议内存地址最好是4 字节对齐的，这样做的好处是访问速度最快。为此，在将EAX 寄存器的值写回内存之前，最好使之成为可被4 整除的值，这种数值的特点是最低两个比特为“0”。

第249～254 行，先将EAX 寄存器的内容传送到EBX 进行备份；接着，强制EBX 中的地址对齐在下一个4 字节边界，对齐之后的值肯定会比原先大；然后，看一看原始分配的起始地址（在EAX 寄存器中）是否是4 字节对齐的，如果不是，就采用对齐之后的值；如果原本就是4 字节对齐的，那么，依然采用原值；最后，将这个值写回到原内存单元中，作为下次内存分配的起始地址。

过程allocate_memory 是用retf 指令返回的。因此，它只能通过远过程调用来进入。
### 13.4.5　重定位用户程序内的符号地址

为了使用内核提供的例程，用户程序需要建立一个符号-地址对照表（SALT）。这样，当用户程序加载后，内核应该根据这些符号名来回填它们对应的入口地址，这称为符号地址的重定位。显然，重定位的过程就是字符串匹配和比较的过程。

为了对用户程序内的符号名进行匹配，内核也必须建立一张符号-地址对照表（SALT）。

内核的SALT 表位于代码清单13-2 的内核数据段中，从第338 行开始，一直到第357 行结束。实际上，这个表是可以根据需要扩展的。

如图13-9 所示，用户程序内的SALT 表，每个条目是256 字节，用于容纳符号名，不足256字节的，用零填充。内核中的SALT 表，每个条目则包括两部分，第一部分也是256 字节的符号名；第二部分有6 字节，用于容纳4 字节的偏移地址和2 字节的段选择子，因为符号名是用来描述例程的，这6 字节就是例程的入口地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00550.jpeg)

图13-9　内核和用户程序内的符号表结构

举个内核中的例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00551.jpeg)

这是内核SALT 表的第一个条目。它初始化了一个256 字节的符号名，该名称的前12 个字符是“@PrintString”，因为不足256 字节，后面填充244 个0x00。

在该条目的后面，先是一个双字，初始化为put_string 例程的偏移地址。这就是说，PrintString 其实就是put_string 的别名，调用PrintString，其实是调用put_string 例程。在用户程序内，只能通过远过程调用来进入该例程，所以，该条目的最后是一个字，用公共例程段的选择子来初始化，因为put_string 例程位于公共例程段。

在内核SALT 表中，比较有意思的是最后一个条目：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00552.jpeg)

在这里，从名字可以看出，“TerminateProgram”的意思是终止程序。当用户程序调用该过程时，意味着结束用户程序，将控制返回到内核。

当用户程序终止并返回时，返回点位于标号return_point 所在的位置。该标号位于第582 行，属于内核代码段。在这一行之前，是内核将控制权交给用户程序的指令。

内核的SALT 表是静态的，适用于所有要加载的用户程序，理所当然地要比用户程序的SALT表大，因为它要提供所有可被用户程序调用的过程列表。至于用户程序，根据需要，它只会列出自己用到的那些。

在用户程序加载时，内核的任务是比对这两张SALT 表，并将用户程序SALT 表中的符号名替换成相应的入口地址。为了便于说明，用户程序的SALT 表简称U-SALT，内核的SALT 表简称C-SALT。

基本的算法是使用内外层循环，外循环依次从U-SALT 表中取出条目，每取出一个条目，就进入内循环进行比对；内循环遍历C-SALT 中的每一个条目，同外循环输入的条目进行比对。

比对的过程就是两个字符串的比较过程，可以使用cmps 指令（Compare String Operands）。该指令有3 种基本的形式，分别用于字节、字和双字的比较：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00553.jpeg)

在16 位模式中，源字符串的首地址由DS:SI 指定，目的字符串的首地址由ES:DI 指定；在32位模式下，则分别是DS:ESI 和ES:EDI。在处理器内部，cmps 指令的操作是把两个操作数相减，然后根据结果设置标志寄存器中相应的标志位。

取决于标志寄存器EFLAGS 中的DF 位，如果DF＝0，表明是正向比较，也就是按地址递增的方向比较，这些指令执行后，SI（ESI）和DI（EDI）的内容分别加1、加2 和加4；否则，如果DF ＝1，表明是反向比较，这些指令执行后，SI（ESI）和DI（EDI）的内容分别减1、减2 和减4。

单纯的cmps 指令只比较一次，它属于推一下才动一动的那种类型。所以，需要加指令前缀rep 使比较连续进行。连续比较的次数由CX（ECX）寄存器控制，在16 位模式下，使用CX 寄存器；在32 位模式下，使用ECX 寄存器，举个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00554.jpeg)

该指令执行时，每次比较4 字节，连续比较直至ECX 寄存器的内容为零。

问题是，用rep 前缀比不出个所以然来，你就是重复比较100000 次，也看不出两个字符串哪里不同。所以，针对cmps 指令，应当使用repe（repz）和repne（repnz）前缀，前者的意思是“若相等（为零）则重复”，后者的意思是“若不等（非零）则重复”。但无论是哪种情况，总的比较次数由CX（ECX）控制，表13-1 显示了这几种控制手段的区别。

表13-1　重复前缀

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00555.jpeg)

可见，repe/repz 用于搜索第一个不匹配的字节、字或者双字，repne/repnz 用于搜索第一个匹配的字节、字或者双字。无论如何，匹配和不匹配的位置分别由(E)SI 和(E)DI 寄存器指示。

言归正传，我们继续回到代码清单13-2 中来。

如图13-10 所示，为了重定位U-SALT，我们打算用DS:ESI 指向C-SALT，用ES:EDI 指向USALT。第477、478 行，访问4GB 内存段，从用户程序头部偏移为0x04 的地方取出刚刚安装好的头部段选择子，并使段寄存器ES 指向用户程序头部段，因为U-SALT 位于用户程序头部段内。

第479、480 行，使段寄存器DS 指向内核数据段。因为C-SALT 位于内核数据段中。

第482 行，清标志寄存器EFLAGS 中的方向标志，使cmps 指令按正向进行比较。

实施比较的算法我们已经介绍过了。外循环的作用是依次从U-SALT 中取出各个条目，因此，第484 行，将取的次数（条目的个数）从用户程序头部取出，传送到ECX 寄存器。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00556.jpeg)

图13-10　U-SALT 和C-SALT 的比对过程示意图

接着，第485 行，用于将U-SALT 在头部段内的偏移量传送到EDI 寄存器。刚才我们已经使段寄存器ES 指向了头部段。

外循环的结构如下所示，这是从代码清单中抽出来的，行号也保持不变。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00557.jpeg)

由于内循环也要使用ECX 和EDI 寄存器，并有可能破坏它们的内容，因此，在进入内循环之前，要对它们压栈保护，以便退出内循环后继续使用。外循环的任务是从U-SALT 中依次取出表项，因此，当内循环完成比对后，第512、513 行，从栈中弹出EDI 寄存器的原始内容，并加上256，以指向下一个条目。第514、515 行，从栈中弹出ECX 寄存器的原值。loop 指令将ECX 的内容减一，根据结果判断是否继续循环。

对于外循环所指向的每一个条目，内循环要用它和C-SALT 中的所有条目进行比对，内循环的代码如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00558.jpeg)

每次从外循环进入内循环时，都要重新设置比对次数，并重新使ESI 寄存器指向C-SALT 的开始处，这是第490、491 行的工作。标号salt_item_len 是在第359 行声明的，并用一个表达式初始化。每个条目的长度都是相同的，用当前汇编地址减去标号salt_4 的汇编地址，即$-salt_4，就是每个条目的长度（字节数）。事实上，这个数值是在编译阶段由编译器计算的，在数值上等于262。

标号salt_items 是在第360 行声明的，并初始化为一个表达式。该表达式的意思是，用整个CSALT 的长度，除以每个条目的长度，就是条目的个数。

对于内循环的每一次执行，都要把ESI、EDI 和ECX 压栈保护，以免在比对的过程中用到并破坏这些寄存器。每次比对结束后，第506～509 行，依次弹出这些寄存器的值，并把ESI 的内容加上C-SALT 每个条目的长度（262 字节），以指向下一个C-SALT 条目。第510 行，loop 指令执行时，将ECX 的内容减一并判断是否继续循环。

第497～503 行，是整个比对过程的核心部分。每当处理器执行到这里时，DS:ESI 和ES:EDI都各自指向C-SALT 和U-SALT 中的某个条目：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00559.jpeg)

因为每个条目的符号名部分是256 字节，每次用cmpsd 指令比较4 字节，故每个条目至多需要比对64 次。第497 行把立即数64 传送到ECX 寄存器以控制整个比对过程。

第498 行，开始比对，直到发现一个不相符的地方。

如果两个字符串相同，则需要连续比对64 次，而且，在比对结束时，ZF＝1，表示最后4字节也相同；如果两个字符串不同，比对过程会提前结束，且ZF＝0。在最坏的情况下，这两个字符串可能只有最后4 字节是不同的。在这种情况下，也需要比对64 次，但ZF＝0。

无论哪种情况，如果在退出repe cmpsd 指令时ZF＝0，即表明两个字符串是不同的。所以，第499 行，如果ZF＝0，则表明两个字符串不同，直接转移到内循环的末尾，以开始下一次内循环。

如果两个字符串是相同的，那么，比较指令执行后，ESI 寄存器正好指向C-SALT 每个条目后的入口数据。要知道，C-SALT 中的每个条目是262 字节，最后的6 字节分别是偏移地址和段选择子。

因此，现在的任务是将这结尾的6 字节传送到U-SALT 当前条目的开始部分，这是第500～503 行的工作。最后的结果是，U-SALT 中的当前条目，其开始的6 字节被改写为一个入口地址。
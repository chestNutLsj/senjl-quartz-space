### 13.4.2　计算用户程序占用的扇区数

再次回到代码清单13-2。

用户程序的加载是在例程load_relocate_program 内进行的，该过程需要用ESI 寄存器传入用户程序的起始逻辑扇区号。当过程返回时，在AX 寄存器内包含了指向用户头部段的选择子。

第396、397 行，因为在过程中要用到DS 和ES，故将其原先的内容压栈保存。

为了得到用户程序的大小，需要先预读它的第一个扇区，第399～404 行就在做这件事。首先，使段寄存器DS 指向内核数据段；然后，调用读硬盘的过程read_hard_disk_0 来预读用户程序。进入过程前，EAX 寄存器的内容是用户程序的起始逻辑扇区号；数据的存放地点是内核缓冲区core_buf，它位于内核数据段中，是在第376 行声明和初始化的。在内核中开辟出一段固定的空间，对于分析、加工和中转数据都比较方便。

接下来的工作是计算用户程序到底占用了多少个扇区。用户程序的总大小就在头部内偏移量为0x00 的地方，因此，第407 行直接访问内核缓冲区取得这个双字。

用户程序的大小（总字节数）不一定恰好是512 的整数倍。也就是说，最后一个扇区未必是满的。因此，如果直接除以512，可能会使结果（除法的商）比实际的扇区数少一。通常情况下，需要判断除法的余数，根据余数是否为零，来决定实际的扇区总数，这不可避免地要使用判断和条件转移指令。

在早先的处理器中，转移指令是影响处理器速度的重大因素之一，因为它会使流水线中那些已经预取和译码的指令失效。在较晚的处理器中，普遍采用了分支预测技术，但并不总能保证预测是准的。因此，最好的办法就是尽量不使用转移指令。为了帮助程序员部分地戒掉使用转移指令的欲望，处理器引入了条件传送指令cmovcc。

cmovcc 指令是从P6 处理器族开始引入的，因此并非所有处理器都支持它。如果你想知道确切的结果，可以先以1 号功能执行cpuid 指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00534.jpeg)

当处理器执行这两条指令后，会在EBX、ECX 和EDX 寄存器返回丰富的信息，以指示各种详尽的处理器特性。此时，检查EDX 寄存器的第16 位（bit 15），当它是“1”时，表明处理器支持cmovcc 指令。

条件转移指令和传送指令相结合的产物，既有条件转移指令的多样性，又执行的是传送操作。但是，和mov 指令不同的是，它的目的操作数只允许是16 位或者32 位通用寄存器，源操作数只能是相同宽度的通用寄存器和内存单元，以下是几个常用的例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00535.jpeg)

条件传送指令是很多的。在第6 章的表6-1 中，列举了所有的条件转移指令。完整的cmovcc指令列表，可以在表6-1 的基础上，将那些指令的首字母“j”换成“cmov”即可。

cmovcc 指令不影响EFLAGS 寄存器中的任何标志位。相反地，它的执行过程要依赖于这些标志，就像条件转移指令一样。

言归正传，为了不使用条件转移指令而又能算出用户程序实际占用的扇区数，需要一点技巧。考察一下，你发会现，所有能被512 整除的数，其最低端的9 个比特都是“0”。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00536.jpeg)

很好，第408 行，将用户程序的总大小从EAX 寄存器传送到EBX 寄存器，等于是做个备份，因为后面还要用到；第409、410 行，先用and 指令将其最低的9 个比特清零，等于是去掉那些不足512 的零头，然后，再将其加上512，等于是将那些零头凑整。

但是，若人家原本就是512 的整数倍，你这么做无疑是多加了一个扇区。因此，第411、412 行，先测试EAX 寄存器的最低9 个比特，如果测试的结果是它们不全为零，则采用凑整的结果；如果为全零，则cmovcc 指令什么也不做，依然采用用户程序原本的长度值。
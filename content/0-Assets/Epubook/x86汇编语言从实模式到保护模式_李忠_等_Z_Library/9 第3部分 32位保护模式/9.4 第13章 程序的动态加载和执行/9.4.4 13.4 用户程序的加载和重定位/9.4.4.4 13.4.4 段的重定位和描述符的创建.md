### 13.4.4　段的重定位和描述符的创建

接着回到load_relocate_program 过程。

在13.4.2 节里，我们算出了用户程序的总长度，而且已经被调整为可以被512 整除的数。第414、415 行，用这个数值去调用allocate_memory 过程分配内存。分配到手的内存块，起始地址在ECX 寄存器中。

第416 行，将ECX 寄存器的内容传送到EBX，其动机是作为起始地址从硬盘上加载整个用户程序。

第417 行，将该首地址压栈保存，其目的是用于在后面访问用户程序头部。

第418～420 行，用户程序的总长度除以512，得到它所占用的扇区总数。

第421 行，将扇区数传送到ECX 寄存器，用于控制后面的循环次数。该循环是用来加载整个用户程序的。

第423、424 行，使段寄存器DS 指向4GB 的内存段，这样就可以加载用户程序了。

第428～430 行，循环读取硬盘以加载用户程序。读取的次数由ECX 控制；加载之前，其首地址已经位于EBX 寄存器。起始逻辑扇区号原本是通过ESI 寄存器传入的，循环开始之前已经传送到EAX 寄存器（第426 行）。

既然用户程序已经全部读入内存，现在的任务就是根据它的头部信息来创建段描述符。

第433 行，从栈中弹出用户程序首地址到EDI 寄存器，它是在前面第417 行压入的，该地址也是用户程序头部的起始地址。

第434～438 行，读用户程序头部信息，根据这些信息创建头部段描述符。在主引导程序里，有一个创建描述符的例程，在内核中，也编写了一个同样的例程make_seg_descriptor，甚至它们所用的指令都一模一样。它属于公共例程段，是在第308 行定义的。

该过程要求用EAX 寄存器传入段的基地址，这是第434 行的工作。段界限由EBX 寄存器传入，第435、436 行访问4GB 内存段，从用户程序头部偏移0x04 处取出段长度，减一后形成段界限。第437 行用于给出头部段的属性值。

从过程返回时，EDX：EAX 中包含了64 位的段描述符。紧接着，第439 行调用公共例程段内的另一个过程set_up_gdt_descriptor，把该描述符安装到GDT 中。

set_up_gdt_descriptor 也属于公共例程段，是在第263 行定义的，它需要通过EDX:EAX 传入描述符作为唯一的参数。该过程返回时，CX 寄存器中包含了那个描述符的选择子。

要在GDT 内安装描述符，必须知道它的物理地址和大小。而要知道这些信息，可以使用指令sgdt（Store Global Descriptor Table Register），它用于将GDTR 寄存器的基地址和边界信息保存到指定的内存位置。sgdt 指令的格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00537.jpeg)

其中，m 是一个6 字节内存区域的首地址。该指令不影响任何标志位。

第332、333 行，在内核数据段中，声明了标号pgdt，并初始化了6 字节，供sgdt 指令使用。低2 字节用于保存GDT 的界限（大小）；高4 字节用于保存GDT 的32 位物理地址。

回到例程set_up_gdt_descriptor 中。第270～276 行，在压栈保存了DS 和ES 的原始内容后，使DS 指向内核数据段。紧接着，使用sgdt 指令取得GDT 的基地址和大小。

第278、279 行，使段寄存器ES 指向4GB 内存段以操作全局描述符表（GDT）。

下面的工作是计算描述符的安装地址。这个地址可以这样计算：先得到描述符表的界限值，将它加一，得到描述符表的总字节数，这实际上也是新描述符在GDT 内的偏移量。然后，用GDT 的线性地址加上这个偏移量，就是用于安装新描述符的线性地址。

第281 行，先访问内核数据段，取得GDT 的界限值。注意，这里出现了一个新指令movzx，其作用是带零扩展的传送（Move with Zero-Extend），指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00538.jpeg)

也就是说，movzx 指令的目的操作数只能是16 位或者32 位的通用寄存器，源操作数只能是8位或者16 位的通用寄存器，或者指向一个8 位或16 位内存单元的地址。而且，很有意思的是，目的操作数和源操作数的大小是不同的。这里有几个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00539.jpeg)

对于上面的第一个例子，如果指令执行前，AL 寄存器的内容是0xC0，那么，指令执行后，CX 寄存器的内容为0x00C0；对于第二个例子，处理器访问段寄存器DS 所指向的段，从偏移地址0x2000 处取得一字节，左边添加24 个“0”，使之扩展到32 位，然后传送到EAX 寄存器；对于第三个例子，如果指令执行前，BX 寄存器的内容为0x55AA，那么，指令执行后，ECX 寄存器的内容为0x000055AA。

另一个非常有用的指令是movsx，意思是带符号扩展的传送（Move with Sign-Extension），指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00540.jpeg)

和movzx 不同，movsx 在执行扩展时，用于扩展的比特取自源操作数的符号位。比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00541.jpeg)

GDT 的界限是16 位的，允许64KB 的大小，即8192 个描述符，似乎不需要使用32 位的寄存器EBX。事实上，还是需要的，因为后面要用它来计算新描述符的32 位线性地址，加法指令add要求的是两个32 位操作数。

第282 行，将GDT 的界限值加1，就是GDT 的总字节数，也是新描述符在GDT 内的偏移量。不过，很奇怪的是，我们用的是指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00542.jpeg)

而不是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00543.jpeg)

这是为什么呢？

这是有道理的。就一般的情况来说，在这里用这两条指令的哪一条，都没有问题。但是，如果这是启动计算机以来，第一次在GDT 中安装描述符，可能就会产生问题。在初始状态下，也就是计算机启动之后，这时还没有使用GDT，GDTR 寄存器中的基地址为0x00000000，界限为0xFFFF。

当GDTR 寄存器的界限部分是0xFFFF 时，表明GDT 中还没有描述符。因此，将此值加1，结果是0x10000，由于该寄存器的界限部分只有16 位，所以只能容纳16 位的结果，即0x0000，这就是第一个描述符在表内的偏移量。

同样的道理，因为EBX 寄存器中的内容是GDT 的界限值0x0000FFFF，如果执行的是指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00544.jpeg)

那么，EBX 寄存器中的内容将是0x00010000，以它作为第一个描述符的偏移量显然是不对的。相反，如果执行的是指令是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00545.jpeg)

那么，因为BX 寄存器只有16 位，故，结果为0x0000，进位被丢弃（决不会影响EBX 寄存器的高16 位）。此指令执行后，EBX 寄存器的内容是0x00000000。

第283 行，用计算出来的偏移量加上GDT 的基地址，结果就是新描述符的线性地址。事实上，这三行或许可以按以下方法来简单处理，就没那么啰嗦了：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00546.jpeg)

但是，少用一条指令似乎更好，谁知道呢！

既然已经知道新描述符应该安装在哪里，第285、286 行，访问段寄存器ES 所指向的4GB 内存段，将EDX:EAX 中的64 位描述符写入由EDI 寄存器所指向的偏移处。

第288～290 行，访问内核数据段，将GDT 的界限值加上8，然后用lgdt 指令重新加载GDTR，使新的描述符生效。GDTR 寄存器中的界限值总是单数（8 的整数倍减1），包括它的初始值0xFFFF。所以，每次只要加上新描述符的实际大小就能得到正确的界限值。

最后，第292～297 行，根据GDT 的新界限值，来生成相应的段选择子。具体的算法是，取得GDT 的当前界限值，除以8，余数丢弃。描述符的索引是从0 开始编号的，界限值总是比GDT的总字节数小1。因此，界限值除以8，一定会有余数（余7，丢弃不用），商就是我们所要得到的描述符索引号。最后，将索引号左移3 次，留出TI 位和RPL 位（TI＝0，指向GDT，RPL＝00），这就是要生成的选择子。

第299～306 行，恢复调用之前的现场，返回调用者。返回时用了retf 指令，因此，本过程只能通过远过程调用的方式进入。

继续回到过程load_relocate_program。

安装了用户程序头部段的描述符后，第440 行，将该段的选择子写回到用户程序头部，供用户程序在接管处理器控制权之后使用。实际上，在内核向用户程序转交控制权时，也要用到。

第443～460 行，用于重定位用户程序代码段和数据段，并创建和安装相应的描述符，整个过程都是一样的，也很容易理解。

唯一不同的是栈段，栈所用的空间不需要用户程序提供，而是由内核动态分配。内核分配栈空间时，是以4KB 为单位的，也就是说，每次分配至少是4KB 的倍数。至于到底分配多少，用户程序应该根据自己的实际需求提出建议。

第463 行，从用户程序头部偏移为0x0C 的地方获得一个建议的栈大小。这是一个倍率，至少应当为1，说明用户程序希望分配4KB 栈。如果为2，说明希望分配8KB；为3 则表明希望分配12KB，依此类推。

第464、465 行，计算栈段的界限。如果栈段的粒度是4KB，那么，用0xFFFFF 减去倍率，就是用来创建描述符的段界限。举例来说，如果用户程序建议的倍率是2，那么，这意味着他想创建的栈空间为8KB。因此，段的界限值为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00547.jpeg)

那么，当处理器访问该栈段时，实际使用的段界限为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00548.jpeg)

栈是向下扩展的，访问32 位的栈，要使用栈指针寄存器ESP，其最大值是0xFFFFFFFF。因此，ESP 的值只允许在0xFFFFDFFF 和0xFFFFFFFF 之间变化，共8KB。

第466～469 行，用4096（4KB）乘以倍率，得到所需要的栈大小，然后，用这个值去申请内存。这是一个32 位的无符号数乘法，指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00549.jpeg)

这里，用EAX 寄存器的值，乘以另一个32 位的数（可以在通用寄存器或者内存单元里），在EDX:EAX 中得到64 位的乘法结果。

注意，allocate_memory 过程返回所分配内存的低端地址。和一般的数据段不同，栈描述符中的基地址，应当是栈空间的高端地址。所以，第470 行，用allocate_memory 返回的低端地址，加上栈的大小，得到栈空间的高端地址。

第471～473 行，依次调用两个例程，来生成和安装栈段的描述符。注意栈的属性值，它指明了这是一个32 位的栈段，粒度为4KB。

第474 行，将栈段的选择子写回到用户程序头部，供用户程序在接管处理器控制权之后使用。
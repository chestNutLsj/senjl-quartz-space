   

# 第13章　程序的动态加载和执行

像我一样，很多人在了解了保护模式的基本工作原理之后，会产生一个疑问。那就是，所有的段在使用之前，都必须以描述符的形式在描述符表中进行定义，那么，像操作系统这样的软件，又怎么能够加载和执行其他各种用户程序呢？毕竟，你并不知道这些程序都定义了哪些段，每个段是什么类型，有多长。

未必所有人都会产生这样的疑惑，但我确实算一个，可能我还不够聪明。事实上，这仅仅是一层窗户纸，一旦捅破了，才发现原来竟是那么简单。从某种意义上来说，保护模式的工作机制对用户程序的加载和执行非但没有增加困难，反而带来了很大的便利。

一套能够充分说明问题的例子需要很大的代码量，也许把本书的汉字都去掉，全部换成代码也不够。不过，只要能说明问题，也不一定非得完善周全、面面俱到。因此，本章中用于加载和处理用户程序的做法，不一定，甚至根本就不是操作系统采用的方法。这一点，务必明了。

计算机硬件之上是软件。软件分两个层次，一是操作系统，二是应用（用户）程序。通常，用户程序只关心问题的解，就是采用各种算法来解决实际问题。至于软件是怎么加载到内存的，怎么定位的，不是它所操心的事。但是，它有义务提供一些必要的信息，来帮助操作系统将自己加载到内存中。

相反，操作系统则必须考虑采用什么方法来加载用户程序，并在适当的时候将处理器的执行流转移到用户代码中去。同时，为了减轻用户程序的工作量，操作系统还应当管理硬件，并提供大量的例程供用户程序使用。比如，显示一个字符串，就不要让用户自己来写代码了，直接调用操作系统的代码即可。但操作系统和用户程序应当协商一种机制，让用户程序能够在使用这些例程时，不必考虑和关心它们的位置。

本章提供了一个小小的“操作系统”，因为当不起这么大的名称，所以叫“内核”或者“核心”。即使是这样，它依然当不起，因为它实在是太简单了。不过，也没有办法，就这么凑合着叫吧。

内核不能放到主引导扇区里，毕竟它都很大。所以，计算机首先从主引导程序开始执行，主引导程序负责加载内核，并转交控制权。然后，内核负责加载用户程序，并提供各种例程给用户程序调用。提供给用户程序调用的例程也叫应用程序接口（Application Programming Interface，API），本章用简单的方法来允许用户程序使用API 工作。

本章学习目标：

1．了解保护模式是为操作系统提供的技术，并没有给普通应用程序的编程带来负担（这从本章的程序实例中就可以看出来）。

2．学习操作系统在保护模式下加载和重定位应用程序的一般原理，学习简单的内存动态分配，了解应用程序接口API 的简单原理，学习字符串的比较算法。

3．学习若干x86 处理器的新指令，包括bswap、cpuid、cmovcc、sgdt、movzx、movsx、cmpsb、cmpsw、cmpsd 和xlat 等。
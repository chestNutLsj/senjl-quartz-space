   

## 13.3　在内核中执行

现在转到代码清单13-2，这是内核的主体部分。

从主引导程序转移到内核之后，处理器会从第532 行开始执行，因为这里是内核的入口。

第532、533 行，初始化段寄存器DS，使它指向内核数据段。然后，第535、536 行，调用公共例程段内的一个过程来显示字符串。该call 指令属于直接远转移，指令中给出了公共例程段的选择子和段内偏移量。字符串是在第362 行，用标号message_1 声明，并初始化了一段文字，意思是“如果你看到这段信息，那么这意味着我们正在保护模式下运行，内核已经加载，而且显示例程工作得也很完美。”

显示例程put_string 位于公共例程段内，是在第37 行定义的。基本上，它的代码组成和工作原理都和从前一样，但也有不同之处。首先，这里的代码是32 位模式的，字符串的地址由DS:EBX 传入，过程返回时用retf 指令，而不是ret。这意味着，必须以远过程调用的方式使用它。

和往常一样，put_string 在内部调用了另一个过程put_char。注意，第110～113 行，movsd 用于在两个内存区域间传送双字数据（一次传送4 字节）。不管是movsb，还是movsw，抑或是movsd，在16 位模式下，是把由DS:SI 指定的源操作数传送到由ES:DI 指定的目的地。但是，在32 位模式下，源和目的则分别是DS:ESI 和ES:EDI。

再回到539 行，下面的工作是显示处理器品牌信息。

处理器的功能是强劲的，这个没有人怀疑。同时，在处理器内部也隐藏着太多的秘密，除了处理器的型号，还有大量的特性信息，比如高速缓存的数量、是否具备温度和电源管理功能、逻辑处理器的数量、高级可编程中断控制器的类型、线性（物理）地址的宽度、是否具有多媒体扩展和单指令多数据指令等特性。

处理器功能强了是好事，大家都很欢喜。麻烦在于，很多新功能是处理器更新换代的产物，只存在于最新的版本中，旧的处理器没有。比如多媒体扩展指令可以加速多媒体的处理速度，但用了新指令的软件不能运行在旧的处理器上，因为它们不支持。可怕之处在于，没有人知道自己的软件被终端销售商卖给了谁，更不知道那个谁用的是什么处理器。

因此，你的软件应当准备两套方案，而且，在决定使用哪套方案之前，必须探测和挖掘处理器内部的秘密，好知道该怎么办。Intel 公司显然洞悉了市场上发生的一切，它们给出的方案是使用cpuid 指令。

cpuid 指令（CPU Identification）用于返回处理器的标识和特性信息。EAX 用于指定要返回什么样的信息，也就是功能。有时候，还要用到ECX 寄存器。cpuid 指令执行后，处理器将返回的信息放在EAX、EBX、ECX 或者EDX 中。

cpuid 指令是从80486 处理器的后期版本开始引入的，从此以后，每款处理器都会对可以返回的信息有所扩充。原则上，在使用cpuid 指令前，先要检测处理器是否支持该指令；接着再用cpuid 指令检测是否支持所需要的功能。

如图13-8 所示，在32 位处理器上，原先的标志寄存器FLAGS 也相应地扩充到了32 位，以支持更多的标志。扩充之后的标志寄存器称为EFLAGS 寄存器，它的ID 标志位（位21）如果为“0”，则不支持cpuid 指令；反之，该处理器支持cpuid 指令。80486 处理器已经很久远了，我想没有谁还在使用这样的计算机，况且它已经停产。一般情况下，不需要检测处理器是否支持cpuid 指令。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00529.jpeg)

图13-8　扩展到32 位长度的标志寄存器EFLAGS

图13-8 中，灰色的部分是保留位，通常设置为固定的值。EFLAGS 还包括更多的标志位，图中未予显示，仅在以后用到的时候一一介绍。

为了探测处理器最大能够支持的功能号，应该先用0 号功能来执行cpuid 指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00530.jpeg)

处理器执行后，将在EAX 寄存器返回最大可以支持的功能号。同时，还在EBX、ECX 和EDX 中返回处理器供应商的信息。对于Intel 处理器来说，返回的信息如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00531.jpeg)

组合起来就是“GenuineIntel”。

要返回处理器的品牌信息，需要使用0x80000002～0x80000004 号功能，分三次进行。注意，该功能仅被奔腾4（Pentium 4）之后的处理器支持，所以，正确的做法是先用0 号功能执行cpuid指令，以判断自己的处理器是否支持。代码清单13-2 并没有这样做，因此可视为一个反面典型。

第539～558 行，分别用三种功能号执行cpuid 指令，返回三组字符串，共48 个字符，依次保存在核心数据段中，起始位置是由标号cpu_brand 指定的。第381 行，声明了标号cpu_brand，并初始化了52 字节，足以容纳这些数据。

从处理器返回的数据都是现成的ASCII 码。第560～565 行，先在屏幕上留出空行，再显示处理器品牌信息，然后再留空，以突出要显示的内容。
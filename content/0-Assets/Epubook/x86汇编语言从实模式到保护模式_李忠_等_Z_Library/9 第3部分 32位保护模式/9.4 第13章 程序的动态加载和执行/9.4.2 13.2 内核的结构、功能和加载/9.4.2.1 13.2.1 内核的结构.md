### 13.2.1　内核的结构

内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和公共例程段，主引导程序也是初始化代码的组成部分。

初始化代码用于从BIOS 那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。初始化代码大部分位于代码清单13-1 中。

内核的代码和数据位于代码清单13-2 中。如图13-1 所示，内核代码段是在第385 行定义的，用于分配内存，读取和加载用户程序，控制用户程序的执行。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00515.jpeg)

图13-1　内核程序的各个组成部分

内核数据段是在第330 行定义的，提供了一段可读写的内存空间，供内核自己使用。

公共例程段是在第34 行定义的，用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。

除了以上的内容之外，内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数据用于告诉初始化代码如何加载内核。

回到代码清单13-2 的开头。

从第7 行开始，一直到第12 行，用于声明常数。很明显，这是一些内存段的选择子，它们对应的描述符会在内核初始化的时候创建。这些段是内核的段，供内核代码使用，对内核代码是透明的，内核代码“知道”每个段选择子的具体数值，就象你知道自己办公室里有哪些人，可以直接喊他的名字让他做某件事一样。但是，段选择子的具体数值是和它们在GDT 中的位置相关的。为了不至于在往后因为调整段的位置而修改程序代码，将它们声明成常数是最好的。我们知道，伪指令equ 仅仅是允许我们用符号代替具体的数值，但声明的数值并不占用空间。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00516.jpeg)

图13-2　本章内存布局示意图

内核文件的真正开始部分是头部，偏移量为0x00 的地方是一个双字，可以通过标号core_length 引用，记录了整个内核文件的大小，以字节为单位；偏移量为0x04 的地方是公用例程段的起始汇编地址， 是一个双字， 可以通过标号sys_routine_seg 引用；偏移量为0x08 的地方是核心数据段的起始汇编地址，也是一个双字，可以通过标号core_data_seg 引用；偏移量为0x0C 的地方是核心代码段的起始汇编地址， 双字大小， 可以通过标号core_code_seg 引用；从偏移量为0x10 开始的地方用于指示内核入口点，可以通过标号core_entry 引用，在主引导程序加载了内核之后，从这里把处理器的控制权交给内核代码。注意，不要忘了这个表达式，我们以前学过的，它用来得到段的起始汇编地址：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00517.jpeg)

入口点共有6 字节，低地址部分是一个双字，指示段内偏移，将来会传送到指令指针寄存器EIP，它来自一个标号start，位于第531 行；高地址部分是一个字，指定一个内存代码段的选择子。在这里，填充的是刚刚在第7 行声明过的常数core_code_seg_sel，在数值上等于0x38。
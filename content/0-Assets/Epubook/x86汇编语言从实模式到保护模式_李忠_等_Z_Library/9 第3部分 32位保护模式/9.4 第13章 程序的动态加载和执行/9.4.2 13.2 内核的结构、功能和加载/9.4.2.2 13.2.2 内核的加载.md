### 13.2.2　内核的加载

现在来看代码清单13-1，也就是主引导程序。

第6 行和第7 行声明了两个常数，分别是内核程序在硬盘上的位置，以及它将要被加载的物理内存地址。声明常数的好处你也知道，将来改起来方便。

接下来，从第9 行开始，一直到第55 行，是为进入保护模式做准备。如图13-2 所示，因为主引导程序的加载位置是物理地址0x00007C00，所以，从这个位置往上是512 字节的初始化代码段，从这个位置往下是4KB 的内核栈。

全局描述符表（GDT）是不可或缺的，和从前一样，我们将它定义在从物理地址0x00007E00开始的地方，紧挨着初始化代码段。GDT 可大可小，最大能达到64KB，所以，它的空间一定要留够。

和GDT 一样，内核程序的大小也是不定的，但可以规定它的起始位置。在这里，我们决定将它加载到从物理内存地址0x00040000 开始的地方。从这个地方往上，一直到0x0009FFFF，都是它的地盘，取决于它到底有多大，想用多少就用多少。从0x000A0000 往上，是ROM BIOS，硬件专有的。

显示器是窥视程序工作的窗口，显示功能自然少不了。因此，从0x000B8000 往上的32KB，是文本模式的显示缓冲区。

最后，从1MB 开始的大量空间是留给用户程序用的，具体数量取决于你到底安装了多少物理内存。对于本章来说，程序都很小，功能都很简单，用不了多少内存空间，都才几KB、几十KB；但是，你平时所用的Windows、Linux 和MacOS，以及运行于其上的程序，都是VIP、大客户，动辄几MB、几百MB。

在进入保护模式之前，初始化程序（主引导程序）已经在全局描述符表（GDT）中安装了几个必要的描述符。如图13-3 所示，第一个是用于访问0~4GB 内存的数据段，它很重要，内核只有在具备了访问全部4GB 内存空间的能力时，才能随心所欲地做任何事情。

第二个是初始化代码段，也就是主引导程序所在的段。进入保护模式后，要继续执行主引导程序的后半部分代码，必须按处理器的要求，为它创建描述符。

最后两个分别是初始的栈段和显示缓冲区的描述符。这里定义的栈在初始化过程中就要使用，而在进入内核之后，它又是内核的栈。

创建这些描述符的代码位于代码清单13-1 的第19～40 行，这几个描述符都和上一章差不多，而且用于创建它们的代码也基本相同，不再逐个讲解。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00518.jpeg)

图13-3　进入保护模式前创建的描述符

下面开始加载内核。

首先是初始化各个段寄存器以访问相应的内存段。第59、60 行，使DS 指向全部4GB 的内存空间；第62～64 行，使SS 指向初始的栈空间，并初始化栈指针寄存器ESP 的内容为0。第一个数据压入时，因为栈的操作是先减ESP 的值，再保存数据，所以，如果是压入一个字，ESP 的内容为0xFFFFFFFE；如果压入的是双字，ESP 的内容为0xFFFFFFFC。

接下来是从硬盘把内核程序读入内存，第67～69 行，它在硬盘上的起始逻辑扇区号和物理内存地址已经由两个常数给出，现分别将它们传送到EAX 和EDI 寄存器。

初始化代码并不知道内核有多大，所以也就不知道应该读多少个扇区。不过，它可以先读一个扇区，因为那里包含着内核的头部数据，根据这些数据，就可以知道内核的总扇区数。

和以前一样， 我们把读硬盘扇区的指令归拢到一起， 做成可以反复调用的过程read_hard_disk_0，它位于第138～192 行。基本上，它的工作过程和具体的代码都和从前一样，但略有不同。首先，该过程要求使用EAX 寄存器来传入28 位的逻辑扇区号。我们现在已经可以使用32 位的寄存器了，再也不会因为16 位寄存器太小，无法容纳28 位的逻辑扇区号而发愁。

其次，这里使用EBX 寄存器来传入偏移地址。因为在32 位模式下，可以访问全部4GB 内存，允许使用32 位的偏移地址。这是好事，我们再也不需要为64KB 的段而受折磨了。

最后一个不同之处在于，每次过程返回时，会使EBX 寄存器的值比原来多512。这是有意的，因为在32 位模式下，内存的访问不再受64KB 限制，所以就能够连续访问。这里，每次将EBX 寄存器的内容加上512，目的是指向下一个内存块，我相信这种工作方式会给调用它的主程序带来方便。

接下来是取得内核的长度，并计算它所占用的扇区数。

因为段寄存器DS 是指向4GB 内存段的，其描述符高速缓存中的基地址是0x00000000，故，第75 行，可以直接用EDI 寄存器中的数值作为偏移量来访问内存，最终生成的线性地址在数值上和EDI 寄存器的内容相同。当前指令的功能是取得内核的总长度，因为它就位于内核的偏移0 处。

第75～77 行，将取得的总字节数除以512，就能在EAX 寄存器中得到内核所占用的扇区数。不过，在没能整除的情况下，实际的扇区总数要比EAX 寄存器中的值多一。

但是，我们要的是剩余扇区数，毕竟已经读了一个。为此，第79～81 行，先判断EDX 寄存器中的余数是否为零。取决于EDX 的实际内容，or 指令会影响ZF 标志位。如果EDX 不为零，则EAX 寄存器里实际上就是剩余的扇区数，因为它比实际的扇区数少一。相反，如果EDX 的内容为零，则EAX 中的内容就是总扇区数，还要用dec 指令减一才行。

无论是哪种情况，指令的执行流程都会到达第83 行。这个地方指令是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00519.jpeg)

这条指令的工作是检查EAX 寄存器，看它的内容是否为零。第84 行，如果为零，说明内核就占用了一个扇区（确实够小的，但一般不太可能），于是不再读硬盘，直接转到标号setup 处执行。

第87～93 行，用于从硬盘读取剩余的扇区，用的是loop 指令循环读取，循环的次数在ECX寄存器中。再重复一遍，32 位模式下的循环指令需要使用ECX 寄存器，而不是CX。如果没有第83、84 行的条件判断，而且剩余扇区数为0，那么，这里的循环将执行0xFFFFFFFF＋1 次，显然不是我们希望的。
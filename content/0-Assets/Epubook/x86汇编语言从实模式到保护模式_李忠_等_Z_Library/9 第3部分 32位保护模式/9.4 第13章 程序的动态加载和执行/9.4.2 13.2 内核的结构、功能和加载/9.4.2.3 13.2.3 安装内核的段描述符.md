### 13.2.3　安装内核的段描述符

要使内核工作起来，首要的任务是为它的各个段创建描述符。换句话说，还要为GDT 续添新的描述符。进入保护模式前，我们在代码清单13-1 的第42 行使用指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00520.jpeg)

来加载全局描述符表寄存器（GDTR），标号pgdt 所指向的内存位置包含了GDT 的基地址和大小。现在，我们的任务是重新从标号pgdt 处取得GDT 的基地址，为其添加描述符，并修改它的大小，然后用lgdt 指令重新加载一遍GDTR 寄存器，使修改生效。

但是，如果忽略了一件事，你可能不会得逞。标号pgdt 所指向的内存区域位于主引导程序内，而我们当前正在保护模式下执行主引导程序。保护模式下的代码段只是用来执行的，是否能读出，取决于其描述符的类别字段，但无论如何它都不能写入。

对代码段实施保护的意思是通过代码段描述符不能修改段中的内容，但不意味着通过其他描述符做不到。想想看，我们拥有一个指向全部4GB 内存空间的描述符，标号pgdt 所指向的内存位置不单单是在主引导程序内，同时也是4GB 内存空间的一部分。

如图13-4 所示，标号pgdt 在数值上等于它距离段首的偏移量，也就是编译阶段的汇编地址。主引导程序的物理起始地址是0x00007C00，故pgdt 在4GB 段内的偏移量是0x00007C00＋pgdt。

这样，为了得到GDT 的基地址，代码清单13-1 第96 行，使用了指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00521.jpeg)

注意，指令中的表达式是在编译阶段计算的。默认的段寄存器是DS，当这条指令执行时，处理器用DS 描述符高速缓存器中的32 位线性基地址0x00000000 加上用该表达式计算出的偏移量来访问内存。

现在可以创建与内核相关的其他段描述符。首先是公共例程段。如图13-5 所示，内核头部偏移0x04 处的一个双字，就是公共例程段的起始汇编地址。由于内核被加载的物理地址是由EDI 寄存器指向的，所以，第99 行，直接访问4GB 内存段，从该偏移位置取出公共例程段的起始汇编地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00522.jpeg)

图13-4　通过4GB 数据段访问代码段内的数据

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00523.jpeg)

图13-5　内核头部的组成

创建描述符还需要知道段界限。在内核中，各个段有着确定的先后次序，而且是紧挨着的。公共例程段的后面是内核数据段，用内核数据段的起始汇编地址，减去公共例程段的起始汇编地址，再减去一，就是公共例程段的段界限，这就是第100～102 行所做的工作。对于向上扩展的段来说，段界限在数值上等于段的长度减去一，这个必须要清楚。

第103 行，用公共例程段的起始汇编地址，加上内核的加载地址，就是公共例程段的基地址。

在已经知道某个内存段的细节时，写出它的描述符是很容易的。比如，如果已经知道栈的基地址是0x00007C00，粒度是4KB，大小是8KB，那么，它的描述符就可以直接给出：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00524.jpeg)

问题是，这种清楚明白的情形不常见。在百分之九十以上的场合，段的信息只有在程序运行的时候才能确定，它们都是在程序运行时，根据实际情况得到的随机值。为此，就需要利用指令来以不变应万变，“拼凑”出描述符来。

既然是灵活的方法，还能以不变应万变，就应该定义成过程，以方便在需要的时候随时调用。在这里，我们的方法是使用过程make_gdt_descriptor。

过程make_gdt_descriptor 位于代码清单13-1 的195～217 行，调用该过程需要三个参数，分别是段的线性基地址、段界限和段的属性值。段的基地址用EAX 寄存器传入；段界限用EBX 寄存器传入，但只用其低20 位；段属性用ECX 寄存器传入，各属性位在ECX 寄存器中的分布和它们在描述符高32 位中的时候一样，其他和段属性无关的位都清零。

因此，第104 行，将段属性值0x00409800 传送到ECX 寄存器。结合第11 章的图11-4，可以知道，这是一个P＝1、D＝1、G＝0、DPL＝0、S＝1，TYPE＝1000 的（代码）段描述符。第105 行，调用过程创建描述符，下面来看看具体的创建过程。

代码清单13-1 的第201～203 行用于构造描述符的低32 位。首先是将32 位段基地址从EAX 寄存器复制一份给EDX 寄存器，过一会儿构造描述符的高32 位时，还要用到基地址。

描述符的低32 位中，高16 位是基地址；低16 位是段界限，所以，第202～203 行，将EAX寄存器中的32 位基地址左移16 次，使基地址部分就位。然后，把BX 寄存器中的段界限用or 指令安排就位。这样，描述符的低32 位就构造完毕了。

相比之下，描述符的高32 位构造起来比较麻烦。如图13-6 所示，描述符高32 位的标准形态是有两个基地字段和一个段界限字段。基地址在EDX 寄存器中有备份，执行第205～207 行的指令后，会使基地址部分在两边就位。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00525.jpeg)

图13-6　描述符高32 位的构造过程

bswap 是字节交换指令（Byte Swap），在标准的32 位处理器上只允许32 位的寄存器操作数，其格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00526.jpeg)

处理器执行该指令时，按如下过程操作（DEST 是指令中的操作数，TEMP 是处理器内的临时寄存器）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00527.jpeg)

接下来，要在描述符的高32 位中装配段界限字段。第209、210 行，先清除EBX 寄存器的低16 位，然后同EDX 寄存器合并。这里是假设EBX 寄存器的高12 位为全零，所以用了xor bx，bx指令。实际上，安全的做法是使用指令

and ebx,0x000f0000 最后，第212 行，将ECX 寄存器中的段属性与EDX 寄存器中的描述符高32 位合并。至此，我们就在EDX:EAX 中得到了完整的64 位描述符。第214 行，ret 指令将控制返回到调用者。

现在，回到主程序，来看第106、107 行，ESI 寄存器的内容是GDT 的基地址，这两条指令访问4GB 的段，定位到GDT，在原先的基础上，再添加一个描述符，就是我们刚刚创建的描述符。

第110～129 行，用于安装内核数据段和内核代码段的描述符，也采用了相同的过程，不再一一讲解。

第131 行，通过4GB 的数据段访问pgdt，修改它的界限值。现在，GDT 中已经有8 个描述符，故其总长度为64 字节。相应地，界限值为63。

第133 行，通过4GB 的数据段访问pgdt，重新加载GDTR，使上面那些对GDT 的修改生效。

至此，内核已经全部加载完毕，图13-7 是内核加载完成之后的GDT 布局。

第136 行，通过4GB 的数据段访问内核的头部，用间接远转移指令从给定的入口进入内核执行。观察图13-5，再参考代码清单13-2 就可以明白，在内核头部偏移0x10 处，是6 字节的内核入口点。前面是32 位的段内偏移地址，后面是16 位的段选择子，指向内核代码段。在这里，段选择子直接使用固定的数值不是一个好主意，怕的是往后内核有重大调整时，会改变描述符的次序。在这种情况下，如果别处改了，这里忘了修改，就一定会出现问题。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00528.jpeg)

图13-7　内核加载完成后的GDT 布局
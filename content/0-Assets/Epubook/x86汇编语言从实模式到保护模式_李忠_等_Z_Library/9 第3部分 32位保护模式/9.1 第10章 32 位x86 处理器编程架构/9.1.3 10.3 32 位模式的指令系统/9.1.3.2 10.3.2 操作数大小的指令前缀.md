### 10.3.2　操作数大小的指令前缀

Intel 处理器的指令系统比较复杂，这种复杂性来源于两个方面，一是指令的数量较多，二是寻址方式也很多。可以想象，为了组成这些众多的指令，必须有一套同样复杂的指令格式。

如图10-7 所示，每一条处理器指令都可以拥有前缀，比如重复前缀（REP/REPE/ REPNE）、段超越前缀（如ES：）、总线封锁前缀（LOCK）等。前缀是可选的，每个前缀的长度是1 字节，每条指令可以有1～4 个前缀，或者不使用前缀。

前缀（如果有的话）的后面是操作码部分，指示执行什么样的操作，比如传送、加法、减法、乘法、除法、移位等。根据指令的不同，操作码的长度是1～3 字节。同时，操作码还可以用来指示操作的字长，即数据宽度为字节还是字。

操作码之后是操作数类型和寻址方式部分。这部分是可选的，简单的指令不包含这一部分，稍微复杂一点的指令，这一部分只有1 字节；最复杂的指令，可能有2 字节。这部分给出了指令的寻址方式，以及寄存器的类型（用的是哪个寄存器）。

指令的最后是立即数和偏移量。如果指令中使用了立即数，那么立即数就在这一部分给出；如果指令使用了带偏移量的寻址方式，如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00387.jpeg)

那么，偏移量0x2000 和0x02 也在这部分出现。取决于具体的指令，立即数可以是1、2 或者4 字节，偏移量部分与此相同。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00388.jpeg)

图10-7　IA-32 的指令格式

上述的指令编码格式发源于16 位处理器时代，并在32 位处理器出现之后做了修改，主要是扩展了数据的宽度，其他都保持不变。毕竟，兼容性是首要考虑的因素。但是，这也带来了一些问题。考虑以下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00389.jpeg)

在16 位指令编码格式中，这种内存单元到寄存器的传送指令使用了操作码0x8B。如图10-8（a）所示，在操作码0x8B 之后是1 字节的寻址方式和操作数类型部分。位7 和位6 的值是01，表示使用了基地址变址的寻址方式，而且带有8 位偏移量；位5～位3 的值是010，指示目的操作数为寄存器DX；位2～位0 的值是000，表示寻址方式为“BX+SI+8 位偏移量”。在该字节之后，是1 字节的偏移量0x02。因此，这条指令编译后的机器代码是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00390.jpeg)

32 位处理器使用相同的编码格式，但是，寻址方式和寄存器的定义却是另起炉灶的，完全不同于16 位指令。如图10-8（b）所示，在32 位处理器上，位7 和位6 的值是01，表示使用了基址寻址方式，而且带有8 位偏移量；位5～位3 的值是010，指示目的操作数为寄存器EDX；位2～位0 的值是000，表示寻址方式为EAX+8 位偏移量。在该字节之后，是1 字节的偏移量0x02。因此，同样的机器指令码，却对应着不同的32 位指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00391.jpeg)

这就是说，相同的机器指令，在16 位模式下和32 位模式下的解释和执行效果是不同的。但是，别忘了，32 位处理器可以执行16 位的程序，包括实模式和16 位保护模式。为此，在16 位模式下，处理器把所有指令都看成是16 位的。举个例子，机器指令码0x40 在16 位模式下的含义是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00392.jpeg)

当处理器在16 位模式下运行时，也可以使用32 位的寄存器，执行32 位的运算。为此，必须使用指令前缀0x66 来临时改变这种默认状态，因为同一个指令码，在16 位模式下和32 位模式下具有不同的解释。因此，当处理器在16 位模式下运行时，机器指令码

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00393.jpeg)

对应的指令不再是inc ax，而是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00394.jpeg)

相反地，如果处理器运行在32 位模式下，那么，处理器认为指令的操作数都是32 位的，如果你加了前缀，这个前缀就用来指示指令是16 位的。因此，指令前缀0x66 具有反转当前默认操作数大小的作用。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00395.jpeg)

图10-8　16 位指令和32 位指令的寻址方式和操作数类型编码对比

在编写程序的时候，就应当考虑到指令的运行环境。为了指明程序的默认运行环境，编译器提供了伪指令bits，用于指明其后的指令应该被编译成16 位的，还是32 位的。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00396.jpeg)

注意，bits 16 或者bits 32 可以放在方括号中，也可以没有方括号。以下两种方式都是允许的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00397.jpeg)

最后，16 位模式是默认的编译模式。如果没有指定指令的编译模式，则默认是“bits 16”的。

有关寻址方式和指令前缀的话题比较复杂，在后面的章节里，我们将在适当的时候，结合程序和具体的指令进行讲解。
### 10.3.1　32 位处理器的寻址方式

在16 位处理器上，指令中的操作数可以是8 位或者16 位的寄存器、指向8 位或者16 位实际操作数的16 位内存地址，以及8 位或16 位的立即数。

如果指令中包含了内存地址操作数，那么，它必然是一个16 位的段内偏移地址，称为有效地址。通过有效地址，可以间接取得8 位或者16 位的实际操作数。指定有效地址可以使用基址寄存器BX、BP，变址（索引）寄存器SI 和DI，同时还可以加上一个8 位或16 位的偏移量。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00378.jpeg)

以上，第1 条指令，寄存器BX 中的内容是指向16 位实际操作数的16 位地址；第2 条指令，寄存器BX 和DI 的内容相加，形成指向16 位实际操作数的16 位地址；第3 条指令，寄存器BX、SI 和8 位偏移量共同形成指向8 位实际操作数的16 位地址。

如图10-5 所示，这是16 位处理器的内存寻址方式示意图。从图中可以看出，允许使用基址寄存器BX 或者BP，同变址寄存器SI 或者DI 结合，再加上8 位或者16 位偏移量来寻址内存操作数。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00379.jpeg)

图10-5　16 位处理器的内存寻址方式

16 位处理器的寻址方式本来就很复杂，当32 位处理器出现后，寄存器和偏移地址的宽度都扩展了，相应地，要继续扩展原有的寻址方式。但是，原有的16 位方案已经成型，再进行修补是非常困难的。一个可行的解决方案是，让16 位指令和32 位指令共用相同的指令码，但通过不同的指令前缀，结合处理器当前的运行状态来决定该指令的寻址方式。

比如，当处理器运行在16 位模式时，如果没有指令前缀0x66，则认为指令是传统的16 位寻址方式；若有指令前缀0x66，则指令是新的32 位寻址方式。如果处理器当前运行在32 位模式下且没有指令前缀0x66，则视为默认的32 位寻址方式，否则就是传统的16 位寻址方式。

32 位处理器兼容16 位处理器的工作模式，可以运行传统的16 位代码。但是，它有自己独立的32 位运行模式，而且只有在这种模式下才能发挥最高的运行效率。

在32 位模式下，默认使用32 位宽度的寄存器。如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00380.jpeg)

如果指令中使用了立即数，那么，该数值默认是32 位的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00381.jpeg)

还有，如果指令中的操作数是指向内存单元的地址，那么，该地址默认是32 位的段内偏移地址，或者叫段内偏移量：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00382.jpeg)

这就是说，如果指令中包含了内存地址操作数，那么，它必然默认地是一个32 位的有效地址。通过有效地址，可以间接取得32 位的实际操作数。如图10-6 所示，指定有效地址可以使用全部的32 位通用寄存器作为基址寄存器。同时，还可以再加上一个除ESP 之外的32 位通用寄存器作为变址寄存器。变址寄存器还允许乘以1、2、4 或者8 作为比例因子。最后，还允许加上一个8 位或者32 位的偏移量。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00383.jpeg)

图10-6　32 位处理器的内存寻址方式

以下是几个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00384.jpeg)

值得说明的是，在16 位模式下，内存寻址方式的操作数不允许使用栈指针寄存器SP。因此，象这条指令就是不正确的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00385.jpeg)

但是，在32 位模式下，允许在内存操作数中使用栈指针寄存器ESP。因此，下面的指令形式是合法的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00386.jpeg)
### 10.3.3　一般指令的扩展

由于32 位的处理器都拥有32 位的寄存器和算术逻辑部件，而且同内存芯片之间的数据通路至少是32 位的，因此，所有以寄存器或者内存单元为操作数的指令都被扩充，以适应32 位的算术逻辑操作。而且，这些扩展的操作即使是在16 位模式下（实模式和16 位保护模式）也是可用的。比如加法指令ADD，在32 位处理器上，除了允许8 位或者16 位的操作数外，32 位的操作数现在也是可用的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00398.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00399.jpeg)

除了双操作数指令，单操作数指令也同样允许32 位操作数。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00400.jpeg)

我们已经接触过的逻辑移动指令，如shl、shr 等，目的操作数也扩展至32 位，但用于指定移动次数的源操作数足够应付32 位的环境，没有变化。举例：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00401.jpeg)

和16 位时代一样，在32 位处理器上，逻辑移动指令的源操作数如果是寄存器的话，则依然必须使用CL。同时，32 位处理器在实际执行时，要先将源操作数（在CL 寄存器内）同0x1F 做逻辑与。也就是说，仅保留源操作数的低5 位，因此，实际移动的次数最大为31。

在16 位处理器上，loop 指令的循环次数在寄存器CX 中。在32 位处理器上，如果当前的运行模式是16 位的（bits 16，8086 实模式或者16 位保护模式），那么，loop 指令执行时，依然使用CX 寄存器；否则，如果运行在32 位模式下（bits 32），则使用的是ECX 寄存器。

在16 位处理器上，无符号数乘法指令mul 的格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00402.jpeg)

在32 位处理器上，除了依然支持上述操作外，还支持以下扩展的格式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00403.jpeg)

这样，两个32 位的数相乘，得到一个64 位的结果。这里有个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00404.jpeg)

有符号数乘法指令imul 与此相同。

相应地，无符号数和有符号数除法也做了32 位扩展：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00405.jpeg)

在这里，被除数是64 位的，高32 位在EDX 寄存器；低32 位在EAX 寄存器。除数是32 位的，位于32 位的寄存器，或者存放有32 位实际操作数的内存地址。指令执行后，32 位的商在EAX 寄存器，32 位的余数在EDX 寄存器。

32 位处理器的栈操作指令push 和pop 也有所扩展，允许压入双字操作数。特别是，它现在支持立即数压栈操作。立即数压栈操作的指令格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00406.jpeg)

举个例子可能更清楚一些。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00407.jpeg)

在这里，关键字“byte”仅仅是给编译器用的，告诉它，压入的是字节（毕竟立即数0x55 可以解释为字0x0055 或者双字0x00000055），而不是用来在编译后的机器指令前添加指令前缀。

这条指令的16 位形式（用bits 16 编译）和32 位形式（用bits 32 编译）是一样的，机器代码都是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00408.jpeg)

但是，当它执行时，就不同了。注意，无论在什么时候，处理器都不会真的压入一字节，要么压入字，要么压入双字。因此，在16 位模式下，默认的操作数字长是16，处理器在执行时，将该字节的符号位扩展到高8 位，然后压入栈，压栈时使用SP 寄存器，且先将SP 的内容减去2。这就是说，实际压入栈中的数值是0x0055；在32 位模式下，压入的内容是该字节操作数符号位扩展到高24 位的结果，即0x00000055。压栈时使用ESP 寄存器，且先将ESP 的内容减去4。

如果压入的是字操作数，则必须用关键字“word”来修饰。如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00409.jpeg)

在16 位模式下，默认的操作数字长是16，处理器在执行时，直接压入该字，压栈时使用SP 寄存器，且先将SP 的内容减去2；在32 位模式下，压入的内容是该操作数符号位扩展到高16 位的结果，即0xFFFFFFFB，压栈时使用ESP 寄存器，且先将ESP 的内容减去4。

如果压入的是双字操作数，则必须用关键字“dword”来修饰。如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00410.jpeg)

则无论是在16 位模式下，还是在32 位模式下，压入的都是0x000000FB，而且栈指针寄存器（SP 或者ESP）都先减去4。

对于实际操作数位于通用寄存器，或者位于内存单元的情况，只能压入字或者双字，指令格式为：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00411.jpeg)

如果是寄存器，则可以使用16 位或者32 位的通用寄存器。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00412.jpeg)

如果被压入的16 位或者32 位操作数位于内存单元中，则必须用关键字“word”或者“dword”修饰，以指示操作数的大小：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00413.jpeg)

无论被压入的数位于寄存器，还是位于内存单元，在16 位模式下，如果压入的是字操作数，那么先将SP 的内容减去2；如果压入的是双字，应当先将SP 的内容减去4。在32 位模式下，如果压入的是字操作数，那么先将ESP 的内容减去2；如果压入的是双字，应当先将ESP 的内容减去4。

压入段寄存器的操作比较特殊。以下是压入段寄存器的push 指令格式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00414.jpeg)

在16 位模式下，先将SP 的内容减去2，然后直接压入段寄存器的内容；在32 位模式下，要先将段寄存器的内容用零扩展到32 位，即高16 位为全零。然后，将ESP 的内容减去4，再压入扩展后的32 位值。
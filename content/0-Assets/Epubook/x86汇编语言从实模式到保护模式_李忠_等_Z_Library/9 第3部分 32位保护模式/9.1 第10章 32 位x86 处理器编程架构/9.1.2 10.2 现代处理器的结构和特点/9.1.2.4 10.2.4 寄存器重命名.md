### 10.2.4　寄存器重命名

考虑以下例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00373.jpeg)

以上代码片断做了两件事，但互不相干：将mem1 里的内容左移3 次（乘以8），并将mem3里的内容加2。如果我们为最后三条指令使用不同的寄存器，那么将更明显地看出这两件事的无关性。并且，事实上，处理器实际上也是这样做的。处理器为最后三条指令使用了另一个不同的临时寄存器，因此，左移（乘法）和加法可以并行地处理。

IA-32 架构的处理器只有8 个32 位通用寄存器，但通常都会被我们全部派上用场（甚至还觉得不够）。因此，我们不能奢望在每个计算当中都使用新的寄存器。不过，在处理器内部，却有大量的临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器，比如EAX。

寄存器重命名以一种完全自动和非常简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。再来看一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00374.jpeg)

假定现在mem1 的内容在高速缓存里，可以立即取得，但mem2 的内容不在高速缓存中。这意味着，左移操作可以在加法之前开始（使用临时寄存器代替EAX）。为左移的结果使用一个新的临时寄存器，其好处是EAX 寄存器中仍然是以前的内容，它将一直保持这个值，直到EBX 寄存器中的内容就绪，然后同它一起做加法运算。如果没有寄存器重命名机制，左移操作将不得不等待从内存中读取mem2 的内容到EBX 寄存器以及加法操作完成。

在所有的操作都完成之后，那个代表EAX 寄存器最终结果的临时寄存器的内容被写入真实的EAX 寄存器，该处理过程称为引退（Retirement）。

所有通用寄存器，栈指针、标志、浮点寄存器，甚至段寄存器都有可能被重命名。
### 10.2.3　乱序执行

为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作（microoperations），简写为μops。

有些指令非常简单，因此只需要一个微操作。如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00367.jpeg)

再比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00368.jpeg)

可以拆分成两个微操作，一个用于从内存中读取数据并保存到临时寄存器，另一个用于将EAX 寄存器和临时寄存器中的数值相加。

再举个例子，这条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00369.jpeg)

可以拆分成三个微操作，一个从内存中读数据，一个执行相加的动作，第3 个用于将相加的结果写回到内存中。

一旦将指令拆分成微操作，处理器就可以在必要的时候乱序执行（Out-Of-Order Execution）程序。考虑以下例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00370.jpeg)

这里，指令add eax,[mem2]可以拆分为两个微操作。如此一来，在执行逻辑左移指令的同时，处理器可以提前从内存中读取mem2 的内容。典型地，如果数据不在高速缓存中（不中），那么处理器在获取mem1 的内容之后，会立即开始获取mem2 的内容，与此同时，shl 指令的执行早就开始了。

将指令拆分成微操作，也可以使得栈的操作更有效率。考虑以下代码片断：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00371.jpeg)

这里，push eax 指令可以拆分成两个微操作，即可以表述为以下的等价形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00372.jpeg)

这就带来了一个好处，即使EAX 寄存器的内容还没有准备好，微操作sub esp,4 也可以执行。call 指令执行时需要在当前栈中保存返回地址，在以前，该操作只能等待push eax 指令执行结束，因为它需要ESP 的新值。感谢微操作，现在，call 指令在微操作sub esp,4 执行结束时就可以无延迟地立即开始执行。
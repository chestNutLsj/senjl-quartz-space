### 16.3.2　任务全局空间和局部空间的页面映射

和往常一样，接下来的工作是加载用户程序，并创建一个任务。

每个任务都有自己独立的4GB 虚拟地址空间。这话说来简单，大家也都能在理论的层面上理解，但从来没有实现过，今天我们就来实践一回。

但是细一琢磨，这里面有个问题。

每个任务都有自己的页目录表和页表，当任务创建时，它们一同被创建。当任务执行时，页部件使用它们访问任务自己的私有内存空间（页面）。但是，任务的页目录表和页表不能只包含任务的私有页面。如果不是这样，当任务调用内核服务时，或者换句话说，进入0 特权级的全局地址空间执行时，地址转换将无法进行，因为任务的页目录表和页表里没有登记内核所占用的那些物理页面。

还记得吗，我们一直在说，任务的4GB 地址空间包括两个部分：局部空间和全局空间，全局空间是所有任务共用的。很明显，内核就是所有任务共用的，它应当属于每个任务的全局空间。

一般来说，公平起见，全局地址空间占据着任务4GB 地址空间的高2GB，对应的线性地址范围是0x80000000～0xFFFFFFFF；而局部地址空间则使用低2GB，对应的线性地址范围是0x00000000～0x7FFFFFFF。如图16-15 所示，地址空间的分配必须在每个任务的页目录中体现，页目录的前半部分指向任务自己的页表；后半部分则指向内核的页表。否则的话，当转到内核中执行时，是无法完成地址转换的，因为找不到对应的目录项和页表项。

在任何任务内，在任何时候，如果段部件发出的线性地址高于等于0x80000000，指向和访问的就是全局地址空间，或者说内核。

为此，我们要修改内核自己的页目录表，甚至是内核各个段的描述符，将内核挪到虚拟地址空间的高端，也就是虚拟地址空间中，从0x80000000 开始的一段连续区域。也许你并未安装这么多物理内存，但是，没有关系，我都说了，这是线性地址空间，或者叫虚拟地址空间。

如图16-16 所示，这是映射到虚拟内存高端地址后的内核布局图。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00689.jpeg)

图16-15　通过页目录和页表来实现地址空间的分配

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00690.jpeg)

图16-16　映射到高端地址后的系统核心布局

第969～973 行，在内核的页目录表中，创建一个和线性地址0x80000000 对应的目录项，并使它指向同一个页表。毕竟，我们只改变了线性地址空间范围，内核的数据和代码仍然在原来的页内，没有改变。

为了修改页目录表PDT，需要访问它，知道它的物理地址。但是，当前已经开启了分页功能，在分页机制下，程序只能使用线性地址，访问内存必须先访问页目录和页表，通过它们转换之后的地址才是能够发送到内存芯片的物理地址，你自己知道页目录表的物理地址，这没有用。或者，说得更清楚一点，你访问的是页目录表，但却还要通过页目录表进行地址转换之后才能访问内存中的页目录表。这有点自相矛盾，除非页目录表中有一个目录项能指向页目录表自己。否则，访问一个并未在页目录表和页表内登记的页，会引发处理器异常中断。

这段代码，其实倒过来，先从结果着手可能更容易理解。经过分析可知，当第973 行的指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00691.jpeg)

执行时，ES 是指向0～4GB 内存段的，EBX 寄存器的内容为0xFFFFF000，ESI 寄存器的内容为0x00000200，因此，段部件发出的线性地址是0xFFFFF200。

如图16-17 所示，当前程序或者任务的页目录表，其物理基地址是由控制寄存器CR3 指示的，仅高20 位有效，是多少并不重要，可以假定为0x?????000。段部件产生的线性地址是0xFFFFF200，其高10 位的值是0x3FF，这个值乘以4，结果为0xFFC。这个值同CR3 寄存器提供的页目录表物理地址相加，结果是0x?????FFC，它就是页目录表内最后一个目录项的物理地址。从此处取出一个双字，就是线性地址0xFFFFF200 所对应页表的物理地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00692.jpeg)

图16-17　使用线性地址访问和修改页目录表（图示一）

有趣的是，在前面第936 行，我们已经在该目录项内填写了页目录表的物理基地址。因此，该目录项所指向的页表正是当前的页目录表自己，这实际上是把页目录表当成页表来用。

接下来，如图16-18 所示，处理器用线性地址0xFFFFF200 的中间10 位作为偏移量访问页表，这10 位的值是0x3FF。页表的物理地址就是页目录表的物理地址，即0x?????000；表内偏移量是0x3FF 乘以4，即0xFFC。故，这一次处理器发出的最终物理地址也同样是0x?????FFC，它就是页表内最后一个页表项的物理地址。从此处取出一个双字，就是线性地址0xFFFFF200 所在的那个页的物理地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00693.jpeg)

图16-18　使用线性地址访问和修改页目录表（图示二）

因为访问的又是同一内存位置，故最终要访问的页仍是页目录表自己。不过，如图16-19 所示，这一次稍有不同，页的物理地址是0x?????000，页内偏移由线性地址的低12 位乘以4 给出，其值为0x800。所以，当指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00694.jpeg)

图16-19　使用线性地址访问和修改页目录表（图示三）

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00695.jpeg)

执行时，处理器发出的物理地址是0x?????800，并将该双字单元的内容改写为0x00021003。

综合上面的分析，这就是说，如果页目录表的最后一个目录项指向当前页目录表自己，那么，无论任何时候，当线性地址的高20 位是0xFFFFF 时，访问的就是页目录表自己。

修改页目录表的原理就是这样。因此，当我们回过头去看时，第969 行，实际上给出了当前正在使用的页目录表的线性基地址0xFFFFF000；第970 行，给出了要修改的那个目录项所对应的线性基地址，其高10 位的值乘以4，决定了该线性地址所对应的页目录表内偏移量。因此，第971 行，将线性地址右移22 位，只保留高10 位；第972 行，再将它左移2 位，相当于乘以4。

最终，页目录表内有两个目录项都指向同一个页表，如图16-20 所示。不过，尽管指向的是同一个页表，这两个目录项所映射的线性地址是不一样的，旧表项依然对应着线性地址0x00000000～0x000FFFFF；新表项则对应着一个高端的地址范围0x80000000～0x800FFFFF。

这回，你应该很清楚了，为什么处理器会使用层次化的分页结构，而不是用4MB 内存组建单一的页映射表。如果采用后者，将不得不至少保留2MB 的内存空间。当然，这对于现在的计算机来说算不了什么，但是，在1978 年，80386 处理器刚刚问世的时候，拥有2MB 物理内存还是一种非常奢侈的想法。即使是在15 年之后的1993 年，在我使用的计算机上也才有2MB 物理内存，已经是相当不错的，那台计算机花了7000 多元人民币。

仅仅修改页目录表是没有用的，如果段部件给出的线性地址并不在0x80000000 以上，是没有用的。因此，必须修改与内核有关的段描述符，包括全局描述符表（GDT）自己的线性地址。一旦开启页功能，除页目录表和页表的地址外，其他所有地址都是线性地址，即使是在访问GDT 和LDT 的时候，内核就更不用说了，不可能因为它靠近硬件就能搞特殊。

修改段描述符很简单，只需要将其中的基地址部分加上0x80000000 即可。比如GDT，原先的地址是0x00007E00，现在则要改为0x80007E00。说起来容易做起来难，段描述符中的基地址不是连续的，处于高低两个双字中的不同位置，重新计算比较麻烦。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00696.jpeg)

图16-20　将内核映射到高端地址后的页目录表

幸运的是，0x80000000 是一个有趣的数，仅最高位是“1”，其余31 比特都是“0”。因此，只需要访问全局描述符表（GDT），将所有描述符高字部分的最高位置“1”即可。

第977～979 行，先取得GDT 的线性基地址，并传送到EBX 寄存器，准备开始访问GDT 内的段描述符。

第981～986 行，依次找到内核栈段、文本模式下的视频缓冲区段、公共例程段、内核数据段和内核代码段的描述符，并将每个描述符的最高位改成“1”。在这里，EBX 寄存器提供了GDT 的基地址；0x10、0x18、0x20 等这些数提供了每个描述符在表内的偏移量；在偏移量的基础上加4，就是每个描述符的高32 位。唯一没有修改的是0～4GB 内存段的描述符，它本身就是为访问整个内存空间而存在的，不需要修改。

尽管全局描述符表（GDT）很重要，但处理器不会对它有任何照顾，开启分页功能后，访问GDT 也同样需要使用线性地址。因此，第988 行，将GDT 的基地址映射到内存的高端，即加上0x80000000。第990 行，将修改后的GDT 基地址和界限值加载到全局描述符表寄存器（GDTR），使修改生效。

我知道，很多人会有一个疑问：在修改段描述符的时候，以及重新设定了GDT 基地址的时候，会不会导致程序的执行出现问题，毕竟访问内存需要先访问GDT，然后访问GDT 内的描述符，而你已经改变了它们。

答案是不会。在你能够访问GDT，或者能够修改描述符的时候，段寄存器CS、SS、DS、ES、FS 和GS 已经指向了相应的段，对不对？

那么，我们知道，段寄存器实际上由段选择器和描述符高速缓存器组成。当取指令和执行指令时，或者访问内存中的数据时，处理器不会每次都重新加载段寄存器，而是使用CS、SS、DS、ES、FS 和GS 描述符高速缓存器中的内容。

所以，当你改变了GDT 的基地址，或者修改了段描述符之后，这些修改不会立即反映到段寄存器的描述符高速缓存器，对程序的运行没有任何影响。

但是，当执行一个段间转移指令，或者往段寄存器里加载一个新的段描述符选择子时，处理器将会访问GDT 或者LDT，并刷新段寄存器描述符高速缓存器的内容。因此，为了使处理器转移到内存的高端位置执行，需要显式地刷新段寄存器的内容。

代码段寄存器CS 的刷新一般使用转移指令完成。因此，第992 行，使用远转移指令jmp 跳转到下一条指令的位置接着执行。这将导致处理器用新的段描述符选择子core_code_seg_sel（0x38）访问GDT，从中取出修改后的内核代码段描述符，并加载到其描述符高速缓存器中。同时，这也直接导致处理器开始从内存的高端位置取指令执行。

第995～999 行，重新加载段寄存器SS 和DS 的描述符高速缓存器，使它们的内容变成修改后的数据段描述符。注意，这些段在内存中的物理位置并没有改变。特别是栈段，因为仅仅是线性地址变了，栈在内存中的物理位置并没有发生变化，所以栈指针寄存器ESP 仍指向正确的位置。段寄存器ES 没有修改，因为它指向整个0～4GB 内存段，内核需要有访问整个内存空间的能力。段寄存器FS 和GS 没有使用。

第1001、1002 行，显示一条消息，告诉屏幕前的人，已经开启了分页功能，而且内核已经被映射到线性地址0x80000000 以上。需要特别说明的是，即使是在分页机制下，相对于上一章，过程put_string 及其嵌套过程put_char 也没有做任何修改，但依然工作得很好。原因很简单，尽管文本模式的显示缓冲区基地址已经映射到一个较高的地址0x800B8000，但是，向该区域内的任何一个单元，比如线性地址0x800B8020 写字符时，页部件最终会在页表内找到显示缓冲区所在的那个页，页的物理地址是0x000B8000。用页的物理地址加上12 位的页内的偏移量0x020，就是最终的物理地址0x000B8020。

第1005～1023 行，安装供用户程序使用的调用门，并显示安装成功的消息。这一段代码和上一章相同，没有做任何修改。门描述符只涉及目标代码段的选择子和偏移量，但是你应该清楚，目标代码实际上已经被映射到内存的高端了。
### 16.3.1　创建内核的页目录表和页表

必须说明的是，必须在保护模式下才能启动页功能。和往常一样，首先进入保护模式执行的是内核程序，而且，我们要先让内核在分页机制下工作。

本章依然没有提供新的主引导程序，这意味着，还要用以前的主引导程序，同时还意味着，内核程序的总体结构没有变化，否则主引导程序又怎么可能按往常的方式加载它呢。

内核的入口点是在代码清单16-1 的第884 行，即标号“start”处。执行到这里的时候，主引导程序已经创建了内核的大部分要素：全局描述符表（GDT）、公共例程段、内核数据段、内核代码段、内核栈，还包括一个用于访问全部4GB 内存空间的段。

内核的总体结构和它在内存中的布局，从第14 章以来就没什么变化，而且第14 章还曾经给出了一幅内核的内存布局图。为了方便，这里用另一种形式再次展示一下，如图16-9 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00681.jpeg)

图16-9　内核加载之后的内存布局图

其中，各个段在内存中的位置、段描述符和描述符的选择子，都没有变化，可以和前面的章节对照一下。强调这些，只是要表明，即使是在分页机制下工作，对以往的代码和内存分配都没有什么影响。

接着回到代码清单16-1 中来。

第885～889 行，令段寄存器DS 和ES 分别指向内核数据段与0～4GB 数据段，以方便后面的操作。

第891、892 行，在屏幕上显示第一个字符串，表明当前正在内核中执行，而且是在保护模式下工作。

第895～921 行，在屏幕上显示处理器的品牌信息，这段代码和往常一样，没有任何变化。

接下来的工作是准备开启页功能，首先必须创建页目录和页表。每个任务都有自己的页目录和页表，内核也不例外，尽管它是为所有任务所共有的，但也包括作为任务而独立存在的部分，以执行必要的系统管理工作。因此，要想内核正常运行，必须创建它自己的页目录和页表。

麻烦在于，内核已经加载完毕，它的所有部分都已经位于内存中。当然，你可能会问，这怎么会是个麻烦事呢？原因是，在一个理想的分页系统中，要加载程序，必须先搜索可用的页，并将它们与段对应起来。在这种情况下，段部件输出的线性地址和页部件输出的物理地址不同，是很自然的事，因为一切都发生在程序加载完毕、段和页已经有了确定的映射关系之后。在这种情况下，页功能开启之后，各方都能很好地适应。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00682.jpeg)

图16-10　加入页目录和页表后的低端1MB 内存布局

然而，由于内核是在开启页功能之前加载的，段在内存中的位置已经固定。在这种情况下，即使开启了页功能，线性地址也必须和物理地址相同才行。比如， 在开启页功能之前，GDT 在内存中的基地址是0x00007E00，它就是全局描述符表的物理地址，段部件输出的线性地址就是物理地址。在开启页功能之后，它还在那个内存位置，这就要求页部件输出的物理地址和段部件输出的线性地址相同。一句话，要求线性地址等于物理地址才行。

注意，进入分页模式之后，所有东西的地址都成了线性地址，包括GDT、LDT 和TSS 的地址，等等。

其实这也好办。

不像流行的操作系统，我们的内核非常小，这是没有办法的事，我们的任务不是写一个操作系统，能说明问题即可。也正是因为我们的内核很小，所以低端1MB 的空间对它来说已经绰绰有余了。如此一来，我们只需要将低端1MB 内存特殊处理，使这一部分内存的线性地址和经过页部件转换之后的物理地址相同即可。这样做的好处是，内核不用做任何变动即可在分页机制下正常工作。

对页目录和页表在内存中的位置没有什么限制，在哪里都行，前提是属于有效的可用内存范围，如果只安装了1GB 的物理内存，而想把页目录放到2GB 的位置，是不行的。而且，页目录和页表必须各自占用一个自然页，也就是说，它们的物理地址的低12 位必须全是零。

在页目录中，一个目录项对应着一个页表，而一个页表可以容纳1024 个页，也就是4MB 内存。所以，对于内核来说，只需要一个页表就行了，还用不完。这就是说，一个页目录和一个页表就足够了。

再来看图16-9，在GDT 和内核加载的区域之间，是一片空白。因此，我们可以将内核的页目录表放在物理地址0x00020000 处；而把内核的第一个页表放在物理地址0x00021000 处。此时，新的低端1MB 内存布局就如图16-10所示了。

既然我们的目的清楚了，也知道该怎么干，那么，回到代码清单16-1，先来创建页目录表和页表。

第927～933 行，访问段寄存器ES 所指向的4GB 数据段，用0x00020000 作为偏移量，访问页目录，将所有目录项清零。

如图16-11 所示，这是页目录项和页表项的格式。可以看出，在页目录和页表中，只保存了页表或者页物理地址的高20 位。原因很简单，页表或者页的物理地址，都要求必须是4KB 对齐的，以便于放在一个页内，故其低12 位全是零。在这种情况下，可以只关心其高20 位，低12 位安排其他用途。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00683.jpeg)

图16-11　页目录项和页表项的组成

●P（Present）是存在位，为“1”时，表示页表或者页位于内存中。否则，表示页表或者页不在内存中，必须先予以创建，或者从磁盘调入内存后方可使用。

●RW（Read/Write）是读/写位。为“0”时表示这样的页只能读取，为“1”时，可读可写。

●US（User/Supervisor）是用户/管理位。为“1”时，允许所有特权级别的程序访问；为“0”时，只允许特权级别为0、1 和2 的程序访问，特权级别为3 的程序不能访问。

● PWT（Page-level Write-Through）是页级通写位，和高速缓存有关。“通写”是处理器高速缓存的一种工作方式，这一位用来间接决定是否采用此种方式来改善页面的访问效率。由于高速缓存的知识将在下册中介绍，所以在本章中该位直接清零。

● PCD（Page-level Cache Disable）是页级高速缓存禁止位，用来间接决定该表项所指向的那个页是否使用高速缓存策略。同样，在本章中，该位将被清零；

● A（Accessed）是访问位。该位由处理器固件设置，用来指示此表项所指向的页是否被访问过。这一位很有用，可以被操作系统用来监视页的使用频率，当内存空间紧张时，用以将较少使用的页换出到磁盘，同时将其P 位清零。然后，将释放的页分配给马上就要运行的程序，以实现虚拟内存管理功能。

● D（Dirty）是脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。

● PAT（Page Attribute Table）页属性表支持位。此位涉及更复杂的分页系统，和页高速缓存有关，可以不予理会，在普通的4KB 分页机制中，处理器建议将其置“0”。

●G（Global）是全局位。用来指示该表项所指向的页是否为全局性质的。如果页是全局的，那么，它将在高速缓存中一直保存（也就意味着地址转换速度会很快）。因为页高速缓存容量有限，只能存放频繁使用的那些表项。而且，当因任务切换等原因改变CR3 寄存器的内容时，整个页高速缓存的内容都会刷新。

●AVL 位被处理器忽略，软件可以使用。

回到代码清单16-1 中来。

将页目录清零的原因，主要是使所有目录项的P 位为“0”。目录项用于定位对应的页表，如果其P 位是“0”，表明该页表并不在内存中，在地址变换时将引发处理器异常中断。

在建立了一个为空的页目录表之后，第936 行，将页目录表的物理地址登记在它自己的最后一个目录项内。页目录最大4KB，最后一个目录项的偏移量是0xFFC，即十进制数4092。页目录需要频繁地进行修改，为了方便用线性地址访问页目录表自身，需要使用这项技术，马上我们就要讲到。注意，填写的内容是0x00020003，该数值的前20 位是物理地址的高20 位；P＝1，页是位于内存中的；RW＝1，该目录项指向的页表可读可写。还要注意到，US 位是“0”，故此目录项指向的页表不允许特权级为3 的程序和任务访问。

注意，这将浪费一个页目录表项，同时使得最高端的4MB 内存无法访问（0xFFC00000～0xFFFFFFFF）。不过，即使不浪费，一般的软件也不会涉足这个区域。

如图16-12 所示，内核占用着内存的低端1MB，线性地址范围是0x00000000～0x000FFFFF，共256 个4KB 页，占用了页目录表的第1 个目录项，以及该目录项下属页表的前256 个页表项。第939 行，修改页目录内第1 个目录项的内容，使其指向页表，页表的物理地址是0x00021000，该页位于内存中，可读可写，但不允许特权级别为3 的程序和任务访问。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00684.jpeg)

图16-12　内核所占用的低端1MB 内存分页效果图

第942～952 行，将内存低端1MB 所包含的那些页的物理地址按顺序一个一个地填写到页表中，当然，仅填写256 个页表项。第1 个页表项对应的是线性地址0x00000000～0x00000FFF，填写的内容是第1 个页的物理地址0x00000000；第2 个页表项对应的是线性地址0x00001000～0x00001FFF，填写的是第2 个页的物理地址0x00001000；第3 个页表项对应的是线性地址0x00002000～0x00002FFF，填写的是第3 个页的物理地址0x00002000，……。如此一来，这部分内存的线性地址就和物理地址一样了。

这部分代码还是很容易看懂的，第942～944 行，用EBX 寄存器指向页表基地址；用EAX 寄存器保存页的物理地址，初始为0x00000000，每次按0x1000 递增，以指向下一个页；ESI 寄存器用于定位每一个页表项。

参见图16-11，因为页的物理地址是4KB 对齐的，故其低12 位全为零，在写入页表项时，仅保存它的前20 位，低12 位是页属性。在实际写入每个页表项之前，先将页的物理地址转存到EDX 寄存器，并将属性值加到其低12 位上。属性值是3，故P＝1，RW＝1；US＝0，特权级别为3 的程序和任务不能访问这些页。

尤其注意第948 行的指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00685.jpeg)

再重复一次，请务必注意，32 位处理器允许在寻址时使用一个倍率因子，在这里是乘以4，表达式的计算不在编译期间进行，而在指令执行的时候进行。

页表的前256 个表项填写之后，EBX 寄存器的当前值是256，它又被用于第955～958 行，接着处理其余的表项，使它们的内容为全零。即，将它们置为无效表项。

页目录和页表都已创建，它们的表项也都安排妥当，第961、962 行，将页目录表的物理基地址传送到控制寄存器CR3，也就是页目录表基地址寄存器PDBR，该寄存器的格式如图16-13所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00686.jpeg)

图16-13　控制寄存器CR3（PDBR）的组成

由于页目录表必须位于一个自然页内，故其物理基地址的低12 位是全零，处理器的设计者认为既然如此，只登记它的高20 位即可。低12 位，除了PCD 和PWT 位外，都没有使用。这两位用于控制页目录的高速缓存特性，请参照前面的解释。在本章中，为了方便，这两位一律为“0”。

从表面上看，和控制寄存器有关的传送指令和普通的传送指令一样。实际上，这是两种不同类型的指令，操作码是不一样的。控制寄存器是在有了32 位处理器之后才开始出现的，故其长度至少是32 位。在32 位处理器上，和控制寄存器有关的传送指令，其格式为：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00687.jpeg)

没错，最新的处理器内共有8 个控制寄存器，从CR0 到CR7，至于它们都有什么用，别好奇，等看完这本书后，你再慢慢学习吧。汇编语言的一个缺点是无法区分不同指令间的细微差别。在这里，尽管也使用了助记符号“mov”，但实际上，它和一般的传送指令有所区别。

看来全都准备停当了，现在就开启页功能。如图16-14 所示，控制寄存器CR0 的最高位，也就是位31，是PG（Page）位，用于开启或者关闭页功能。当该位清零时，页功能被关闭，从段部件来的线性地址就是物理地址；当它置位时，页功能开启。只能在保护模式下才能开启页功能，当PE 位清零时（实模式），设置PG 位将导致处理器产生一个异常中断。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00688.jpeg)

图16-14　控制寄存器CR0 的PG 位

第964～966 行，先读取控制寄存器CR0 的原始内容，然后，将其最高位置“1”，其他各位保持原来的数值不变。接着，将修改后的内容重新传回CR0 寄存器，这直接导致处理器工作在分页机制下。从这一瞬间开始，段部件产生的地址就不再被看成物理地址，而是要送往页部件进行变换，以得到真正的物理地址。

注意，现在内核工作在分页机制的一个特殊情况下，即，线性地址和经过页部件转换后的物理地址相同，这是精心安排后的结果。举个例子，如果要访问全局描述符表GDT 内的第2 个描述符。在开启页功能之前，GDT 的线性地址是0x00007E00，第2 个描述符的线性地址则是0x00007E08。在开启页功能之后，依然要保证转换后的物理地址和线性地址一样， 仍是0x00007E00 和0x00007E08。好，线性地址送到页部件，页部件用线性地址的高10 位在页目录中查找页表；再用线性地址的中间10 位在页表中查找页。经过转换，找到了包含该数据的页，页的物理地址是0x00007000。于是，将页地址和线性地址的低12 位（0xE08）拼凑在一起，形成最终的0x00007E00 和0x00007E08。

可以在Bochs 中用“creg”命令察看控制寄存器CR0 和CR3 的内容，具体方法请参见本章16.6.2 节；也可以输入一个线性地址，来察看它所对应的物理页，具体方法请参见本章16.6.3 节；要察看当前页表中的全部内容，可以用“info tab”命令，请参见本章16.6.4 节。
### 16.5.5　段描述符的创建（平坦模型）

第644～652 行，在内核的地址空间内分配内存，创建用户任务的TSS。任务是由内核管理的，为了能够访问得到它，必须将其创建在内核的虚拟地址空间里。为了后面的代码访问TSS，TSS 的线性基地址要登记到任务控制块（TCB）中。

第655～658 行，创建用户任务的局部描述符表（LDT）。LDT 是任务私有的，要在它自己的虚拟地址空间里分配所需要内存空间。为了后面的代码访问LDT，LDT 的线性基地址要登记到任务控制块（TCB）中。

第661～667 行，创建用户任务的代码段描述符，并登记到LDT 中。从程序中可见，代码段描述符中的基地址是0x00000000，段界限值是0x000FFFFF，粒度为4KB，因此，实际使用的界限值是0xFFFFFFFF。用户任务的特权级别是3，因此，代码段描述符的特权级别也是3，段选择子的特权级别也设置成3。

第669、670 行，将代码段描述符的选择子登记到任务状态段（TSS）中。TSS 的线性地址是从任务控制块（TCB）中取得的。

第673 ～ 679 行， 创建用户任务的数据段描述符。和代码段描述符一样， 基地址为0x00000000，段界限也是0x000FFFFF，粒度为4KB。描述符特权级和段选择子的特权级都是3。

在平坦模型下，段寄存器DS、ES、FS 和GS 都指向同一个4GB 数据段。因此，第681～685行，将刚才生成的数据段描述符选择子填写到TSS 的DS、ES、FS 和GS 寄存器域中。

在平坦模型下，段只是容器，很大的容器。之所以要将段定义成4GB 大小，是希望可以发出任何虚拟地址，而不会被段部件的检查机制阻挠。当然了，骗得过段部件，骗不了页部件。容器是很大，但是，能不能拿到东西，要看你手伸到的地方有没有东西。因此，访问一个虚拟内存位置之前，必须提前在那里分配页。

在平坦模型下，栈段也要和其他段共享4GB 的虚拟内存空间。用户任务的数据段是3 特权级别的，而该任务固有的栈也是3 特权级别的，可以把上面的数据段选择子赋给段寄存器SS，把数据段作为栈段来用。真的可以吗？答案是，完全可以。尽管一般来说数据段是向上扩展的，而栈段是向下扩展的，但是，向上和向下，并不是用来限制压栈和出栈操作，而是规定处理器段部件检查段界限的方法。如果把向上扩展的数据段作为栈来用，那么，每当执行隐式的栈操作指令时（push、pop、call、ret 和iret），处理器的段部件按向上扩展的段来检查段界限，指令的执行过程和栈的推进方向依然不变，是向低地址方向的。

我们说了，段是容器，有4GB 大小，但必须提前分配页给那些要访问到的地方才行。在我们的用户程序（代码清单16-2）中，仅有数据和代码，没有定义栈空间。所以，定义了4GB 的栈段后，还要分配实际的栈空间才行。第688～690 行，在用户任务自己的虚拟地址空间内分配内存，分配了4KB，所以用户任务的固有栈就是4KB。第692～695 行，将CX 寄存器中的数据段选择子填写到TSS 的SS 寄存器域中，同时，填写TSS 的ESP 寄存器域。由于栈从内存的高端向低端推进，所以，ESP 寄存器域的内容被指定为TCB 中的下一个可分配的线性地址。

接下来是创建0、1、2 特权级的栈。毫无疑问，这三个栈段的基地址也是0x00000000，也要创建为向上扩展的数据段，段界限为0x000FFFFF，粒度为4KB。当然，这三个栈段，其描述符的特权级别不同，段选择子也不一样。第698～749 行就是用来创建这三个栈段的代码的，很好懂，不再一一解释。

截至现在，用户程序已经加载，相关的段描述符已经创建，如图16-26 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00709.jpeg)

图16-26　用户任务的虚拟内存空间布局图
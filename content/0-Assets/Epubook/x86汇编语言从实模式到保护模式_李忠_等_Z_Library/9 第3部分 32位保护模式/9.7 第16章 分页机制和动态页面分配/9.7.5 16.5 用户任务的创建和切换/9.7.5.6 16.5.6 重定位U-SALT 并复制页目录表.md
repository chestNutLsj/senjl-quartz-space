### 16.5.6　重定位U-SALT 并复制页目录表

又到了重定位SALT 表的时候了，第753～794 行是重定位SALT 的代码。这段程序不管是在哪一章，都只有两行不一样，其余都一模一样，没有变化。具体到本章中，这两行是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00710.jpeg)

由于使用了平坦模型，而且启动了分页功能，所以，可以直接访问用户程序的虚拟内存空间，从中取得SALT 表的条目数和线性地址（4GB 段内偏移量）。

第797～803 行，创建LDT 描述符，并登记在GDT 中。处理器要求LDT 描述符必须登记在GDT 中。

第805～820 行，填写任务状态段（TSS）的其余部分。包括LDT 选择子域、I/O 位映射区的偏移地址、前一任务的TSS 链接域、TSS 的界限、EIP 和EFLAGS 寄存器域。特别要提到的是，EIP 域填写的是用户程序的入口点，这很重要，从内核任务切换到用户任务时，是用TSS 中的内容恢复现场的，所以这关系到任务应该从哪里开始执行。EFLAGS 域的内容是当前内核任务EFLAGS 寄存器的副本。

第823～828 行，创建TSS 描述符，并登记到GDT 中。处理器要求TSS 描述符必须登记在GDT 中。TSS 描述符的特权级DPL 必须是0，只有当前特权级别为0 的程序才能转换到该任务。因为任务切换应当由内核发起，而特权级为1、2 或3 的程序一般不允许主动发起任务切换。

现在，几乎所有的工作都完成了，剩下的事情，就是创建属于用户任务自己的页目录表。毕竟，你只是临时借用了内核任务的页目录表，当用户任务真正开始执行时，它不可能还使用内核的页目录表，那太不像话了。

我们说过，创建用户任务时，使用内核的页目录表，然后，再复制它，作为用户任务的页目录表。页目录表的复制工作是调用过程create_copy_cur_pdir 完成的。该过程位于第406 行，属于公共例程段。

第416～418 行，先令段寄存器DS 和ES 都指向0～4GB 数据段。说实话，如果内核也工作在平坦模型下，就不用这么麻烦了。

要创建页目录表，那当然先得分配一个空闲页。第420 行，首先调用过程allocate_a_4k_page分配一个页，页的物理地址由EAX 寄存器返回。第422 行，将页物理地址的低12 位改成属性，属性值为0x007，即，US＝1，允许特权级别为3 的用户程序访问该页；RW＝1，页是可读可写的；P＝1，页位于物理内存中。

为了能够访问到该页，我们把它的物理地址登记到当前页目录表的倒数第2 个目录项。我们知道，当前页目录表的线性地址是0xFFFFF000，它的倒数第2 个目录项在表内的偏移量为0xFF8。因此，页目录表内倒数第2 个目录项的线性地址是0xFFFFFFF8，第423 行，将附加了属性的页地址登记到该目录项。

要访问这个新的页目录表，必须知道它的线性地址。事实上，它的线性地址是0xFFFFE000。事情是这样的，让我们倒过来分析一下。首先，线性地址0xFFFFE000 的页目录索引值是0x3FF，指向当前页目录表的最后一项；页表索引值为0x3FE，是页表内倒数第2 项，存放的是页地址。要知道，当前页目录的最后一个目录项，存放的是页目录表自己的物理地址，页表就是当前页目录表自己，而倒数第2 个目录项，又是新页目录表的物理地址。这就证明了，0xFFFFE000 的确是新页目录表的线性地址。

既然两个表的线性地址都有了，那么，使用带rep 前缀的movsd 指令做表间复制工作最为方便。第425～429 行，按处理器的要求，设置好ESI 和EDI 寄存器，分别令它们指向当前页目录表和新页目录表；设置ECX 寄存器的内容为传送的次数（目录项数）；cld 指令设置传送的方向为正向，即，ESI 和EDI 在每次传送后递增。最后，执行movsd 指令，自动进行复制工作。

复制工作完成后，控制返回到第833 行。在那里，将新页目录表的物理地址填写到用户任务TSS 的CR3 寄存器域中。

最后，ret 8 指令从栈中弹出参数，并返回到第1069 行。

在多任务环境下，可以创建多个用户任务，使它们同时运行。如图16-27 所示，每个任务都拥有自己独立的4GB 虚拟地址空间，而且互相隔离。其中，前2GB 属于任务的私有地址空间，高2GB 是所有任务共有的全局地址空间，映射到内核的地址空间内。

每个任务都有自己独立的页目录表和页表，页目录表的前半部分对应着任务虚拟地址空间的前2GB，后半部分则映射到内核的页表。这样，当任务在自己独立的局部空间工作时，使用它自己的页表；当任务请求系统服务时，用的则是内核的页表，访问的是内核的代码和数据。

我相信，用这幅图作为最后的总结，可以使读者更清楚地在脑海中勾勒出分页机制下的虚拟内存分配全景，进一步加深对多任务、分页和虚拟内存分配原理的理解。
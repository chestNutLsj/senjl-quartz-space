### 16.5.4　用户程序的加载

要加载用户程序，并将其创建为一个任务，首先要做的事就是分配内存空间。

在分页机制下，每个任务都有自己的4GB 虚拟地址空间，内存分配是在任务自己的地址空间上进行的。当然，内核可以做这些事，它为用户任务创建页目录表和页表，然后看看用户程序有多大，需要多少内存空间，根据需要分配若干物理页，并将它们登记在页目录表和页表中，以便能够访问它们。最后，将用户程序的内容从硬盘读出后写进这些页中。

可是，我们忘了一件事。

在上面，内核可以为用户任务创建页目录表和页表，也能够根据用户程序的大小分配物理页，并修改页目录表和页表，这都没问题。但是，它修改的应当是用户任务的页目录表和页表，而不是它自己的。要知道，现在是在内核中执行，处理器使用的是内核的页目录表和页表，这是由控制寄存器CR3 所决定的。在内存的访问上，处理器是公平的，因为即使是操作系统，也不能访问未在当前页目录表和页表中登记的内存空间。

好吧，那我们可以让内核先创建用户任务的页目录表，然后，临时改变控制寄存器CR3 的内容，使其指向这个新的页目录表，并在这个新表上做那些事情。等用户程序加载完毕，新任务也创建成功，再切换到内核自己的页目录表。

然而这也会出问题。内核也要靠自己的页目录表和页表才能正常工作，一旦改变了页目录表，新页目录表还是空的，当内核访问自己的地址空间时，处理器的页部件突然发现自己熟悉的页目录项全不见了。于是，又一个处理器异常不可避免地发生了。

一个可行的方案是，创建用户任务的页目录表，并将内核页目录表中的内容复制过去。然后，切换到用户任务的页目录表上去工作。这样做是合理的，我们一直在说，每个任务都拥有4GB 的虚拟内存空间，但前2GB 是它私有的，后2GB 是全局部分，映射到内核的地址空间。也只有这样，才能使内核能够继续正常运行，同时还能在页目录表的前半部分创建任务自己私有的分页系统。

上面的方法已经足够好了，如果还要说些什么的话，那就是，还有更好的办法。即，依然在内核的地址空间上工作，或者说，依然使用内核自己的页目录表，但只修改它的前半部分，因为那里属于任务的局部地址空间。最后，再把内核的页目录表复制一份，作为用户任务的页目录表。

要做什么，现在已经清楚了。现在，回到代码清单16-1，来看看具体的实施步骤。

第585～590 行和上一章相同，做一些寄存器内容的保护工作，并为访问栈中的参数做准备。

第592～602 行，用于将当前页目录表的前半部分清空。在每次创建一个新任务时，都应当清空内核页目录表的前512 个目录项。当前页目录表的后半部分是由内核使用的，内核的虚拟地址空间被映射在每个任务的高地址端，即0x80000000 之后。我们已经知道，当前页目录表的线性地址是0xFFFFF000，这是它的起始地址，位于EBX 寄存器中。ESI 寄存器用于提供每个表项的索引号，将索引号乘以4，再和基地址相加，就能得到每个目录项的线性地址，一共要处理512 个表项。

接下来要计算用户程序的大小，为完全加载它做准备。

第605、606 行，使段寄存器DS 指向内核数据段，准备从硬盘上把用户程序的第一个扇区读入内核缓冲区。

第608～610 行，从栈中取得用户程序所在的逻辑扇区号，和内核缓冲区的首地址一起，作为参数调用过程read_hard_disk_0，读取用户程序的第一个扇区。

用户程序的第一个双字就是它的大小，这是约定好的，故，第613 行，直接将内核缓冲区的第一个双字传送到EAX 寄存器。

和以往不同，现在的内存分配是按页进行的，所以最好使程序的大小能被4096 整除。第615 行，强制使程序的大小为4096 的整倍数，如果一个数能被4096 整除，那么它的最低12 位必然全是零。如此处理之后，新数值可能比原数值小。因此，第616 行，为它增加4096 字节，多总比少好。

第617、618 行，看一下处理之前的程序大小，如果人家本来就是4096 的整倍数（低12 位全是零），那就不用新值，还用旧值；如果原先的低12 位不全是零，说明我们处理得对，应该用新值。

第620、621 行，将程序的大小右移12 次，相当于除以4096，这得到的是它占用的页数。为什么要先传送到ECX 寄存器呢？原因是，下面要用ECX 寄存器的内容来控制循环次数。

循环的目的是分配物理页，并以4KB 为单位读取用户程序来填充页。这里不是一个循环，而是两个，而且是嵌套的，即外循环和内循环。外循环负责分配4KB 页，框架如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00706.jpeg)

在循环开始之前，已经在第627 行把ESI 寄存器的内容置为用户程序TCB 的基地址。所以，外循环先访问用户任务的TCB，在它的虚拟内存空间上分配4KB 内存，并返回该段内存的线性地址。接着，用该线性地址分配一个4KB 的页。

以上就是外循环的功能，很简单。内循环嵌套在外循环中，也要用到ECX 寄存器，所以，在开始内循环之前，先将ECX 的内容压栈保存，内循环结束之后，立即将它出栈恢复，并开始下一次外循环。

内循环的代码如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00707.jpeg)

外循环每执行一次，内循环要完整地执行8 次。故，一开始就将ECX 寄存器的内容设为8。然后，反复调用过程read_hard_disk_0 从硬盘上读取用户程序。EAX 寄存器的内容是在第626 行设置的，是用户程序的起始逻辑扇区号，每读一个扇区后，inc 指令将其加一，指向下一个要读取的逻辑扇区。

过程read_hard_disk_0 需要两个参数，除了EAX 寄存器中的逻辑扇区号外，段寄存器DS 必须指向缓冲区所在的段，EBX 寄存器必须指向缓冲区的线性地址。EBX 寄存器中的线性地址在外循环中依靠内存分配得到，而段寄存器DS 是在第623、624 行设置的，在那里，令它指向0～4GB 的数据段。这就是为什么在ES 已经指向0～4GB 数据段的情况下，不用ES，而非得用DS的原因。

这段代码虽然简单，但有很多可说的地方。首先，分页机制下，内存是先登记，后使用的。内存在用户任务自己的虚拟地址空间上分配，过程alloc_inst_a_page 分配一个空闲的页，并登记到当前页目录表和页表中。只有这样做了之后，才能访问这段内存，才能把用户程序写进去。

其次，程序在编写和编译之后，都是连续的，在加载后不能保证这一点。页是随机分配的，在一个真实的系统中，两个页相邻的几率很小。但是，这不会影响到程序的正确执行。尽管页不是连续的，但线性地址必须是连续的，这就够了。处理器访问数据、取指令，用的是线性地址，只要线性地址从头至尾是连续的，页部件自会生成正确的物理地址。

最后，程序的加载必须从线性地址0x00000000 开始，也就是说，必须从整个虚拟地址空间的起始处开始加载。这是不合理的，但在本书中，只能这么做。原因是，首先，处理器始终要按段地址加偏移量的方法访问内存，这是不变的，在多段模型下，段内元素的偏移量都是相对于段的开始处。在程序加载后，段描述符中的基地址，就是段实际加载的位置。也正是因为如此，多段模型下，不管段加载到哪里，都不会影响到段内元素的访问，这就是多段模型下程序可以浮动和重定位的根本原因。

相反地，在平坦模型下，名义上是不分段，但实际上是只分一个大段。在这种情况下，不管程序实际上加载到哪里，代码段、数据段和栈段，其描述符的基地址都固定为0x00000000。这样一来，利用段机制实现程序的浮动和重定位就不可能了。

举个例子，在我们的代码清单16-2 中，程序的入口点位于程序内偏移量为0x04 的地方。要取得它的数值，需要使用指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00708.jpeg)

在多段模型下，数据段描述符中的基地址，就是数据段在内存中的起始地址。如果程序加载后，数据段的基地址是0x00200000，那么，这条指令执行时，处理器发出的地址就是0x00200004，这是没有问题的。

然而，在平坦模型下，代码段、数据段和栈段描述符的基地址固定为0x00000000，而不管程序实际上加载到哪里。因此，同样的指令执行时，处理器发出的地址是0x00000004，而不是正确的地址0x00200004。

在流行的操作系统上工作，编写的程序必须符合一定的规范才能实现浮动和重定位。比如，为了在平坦模型下实现数据和代码的重定位，很多系统要求用户程序提供一个标准的重定位表，列出所有需要动态重定位的元素。程序加载后，操作系统会找到此表，用实际的加载位置修正每一个表项。

这是非常复杂的，而且显然已经超出了本书的主题范围。因此，我们要求，程序必须加载到任务虚拟地址空间的起始处。

从多段模型转移到平坦模型上工作，一开始会不太适应。这没有什么好报怨的，等你有了一定的编程经验之后，会发现多段模型简直是非常糟糕的，要在多个段之间换来换去，一会儿就迷糊了。相比之下，平坦模型非常简单，编程思路非常清晰，用起来非常舒服。当然，代价就是需要额外的重定位处理。不过，那是操作系统和编译器的工作，而不是软件开发人员的。
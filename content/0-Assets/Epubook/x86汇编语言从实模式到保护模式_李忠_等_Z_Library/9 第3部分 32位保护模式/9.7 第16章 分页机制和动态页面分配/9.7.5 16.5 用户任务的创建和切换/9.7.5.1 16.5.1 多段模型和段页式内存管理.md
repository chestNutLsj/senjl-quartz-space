### 16.5.1　多段模型和段页式内存管理

一直以来，我们都工作在分段的内存管理模型上。如图16-22 所示，在保护模式下，首先按程序的结构分段，创建各个段的描述符，用描述符指向物理内存中的各个段。描述符中的基地址给出了段的起始物理地址，界限值给出了段的长度（边界），属性值指示了段的类型和特权级别等性质。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00702.jpeg)

图16-22　传统的多段模型示意图（未开启页功能）

传统的多段模型（Multi-Segment Model）适用于开启了页功能之后的系统环境。如图16-23 所示，首先依然是按程序的结构分段，创建各个段的描述符。但是，段是在任务自己的虚拟地址空间内分配的，而不是在物理内存中分配的。因此，段描述符中的基地址是段的线性地址，或者说是虚拟地址。

因为开启了页功能，虚拟地址空间上的段要映射到物理内存中的一个或多个页。段是连续的，但它所占用的页不要求是相邻的。在未开启页功能之前，段基地址和段偏移相加产生的线性地址就是物理地址，开启页功能之后，线性地址还要经页部件转换后，才能得到实际的物理地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00703.jpeg)

图16-23　分页机制下的多段模型示意图

为什么要分段？这是个问题。

分段的做法是随着8086 处理器的流行和广泛应用而兴起的。那个时候，处理器是16 位的，只能处理16 位的地址数据，因此，可访问的内存空间是64KB。为了访问1MB 的内存，只能分段。如此一来，可以将控制从一个段转移到另一个段，也可以通过将新段的基地址加载到数据段寄存器（DS 和ES），来访问另一个段中的数据。总之，通过这种笨拙的、变通的、迂回的方法，就能间接地获得访问1MB 内存的能力。

在8086 处理器上增加分段机制还有一个额外的好处，那就是可以用很简单的方法实现程序的重定位，让程序在内存中的位置自由浮动，而又不影响它的访问和执行。但是，这只是一个附加的礼物，因为即使不分段，也有办法实现程序的自由浮动和重定位，只是肯定会麻烦很多。

任何事情只要一流行，就会被认为是必然的，而不管它事实上有多不合理。到了32 位处理器时代，分段的方法依然被完整地保留下来了。也许是真的动了脑筋、花了心思，处理器的设计者居然找到了分段模型的好处，那就是可以防止一个程序访问不属于自己的段。

但是，由于分页功能的出现，弱化了人们关于分段机制是否合理的信心。内存的访问是通过页目录表和页表进行的，每个任务都有自己的页目录表和页表，操作系统控制着物理页的分配权，除非它把一个页分配给某个任务，并填写到那个任务的页目录表和页表里，否则，那个任务不可能拥有访问那个内存位置的能力。

尽管处理器的设计者一直在宣称，把分段和分页机制结合在一起，将获得最大强度的保护功能，但是，事实上，在现实的软件设计者那里，多段模型已经不那么吃香了。

典型地，32 位的处理器拥有32 根地址线和32/64 根数据线，这使得它不用将4GB 或多于4GB 的内存空间划分成多个段，就能完全控制它。如此一来，软件设计者就会倾向于不分段。当然，程序的浮动和重定位将不可能再依赖于分段机制，但并不是没有其他办法。
### 16.5.2　平坦模型和用户程序的结构

不分段的内存管理模型称为平坦模型（Flat Model）。尽管说是不分段，但你千万不要信以为真，分段是Intel 处理器的固有机制，处理器总是按“段地址＋偏移量”来形成线性地址，不可能绕开这种工作机制。

因此，如图16-24 所示，所谓的平坦模型，就是将全部4GB 内存整体上作为一个大段来处理，而不是分成小的区块。在这种模型下，所有段都是4GB，每个段的描述符都指向4GB 的段，段的基地址都是0x00000000，段界限都是0xFFFFF，粒度为4KB。

在这种基本的平坦模式下，程序在编写的时候不分段，即，只保留一个段，代码和数据都在这个段内，相互邻接，但一般并不交叉。很显然，在这种模式下，不能享受到段保护机制的好处，段界限和数据访问的检查仍然进行，但从不会产生违例的情况。原因很简单，每个段描述符的基地址都是0，实际使用的段界限都是0xFFFFFFFF，就任务内的地址空间而言，对任何内存位置的访问都是合法的。

一个使用基本平坦模式的实例是代码清单16-2，程序没有分段，或者说只有一个大的段。在程序中，指令和数据的偏移量只和它们出现的自然位置有关。

在这里，一个基本的特点是，所有内容都是按类型组织的。比如，一开始是和整个程序有关的统计数据，比如程序的大小、入口点、U-SALT 的大小和起始位置等，在往常，这就是用户程序头部段；然后，是程序中用到的数据，包括U-SALT。传统上，这就是数据段；最后，是可执行代码部分。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00704.jpeg)

图16-24　基本的平坦模型示意图

传统上，这几个部分是以段为自然分界的。但是现在，它们混合在一起，按类型划分，而不是段，类似于几种流行的可执行文件中的节。

程序本身不大，但编译之后却很大。这是因为，第23 行，保留了一个很大的空白区域。在那里，声明了标号reserved，并初始化了128000 字节。空白区的位置选择也很特别，位于U-SALT的中间，把U-SALT 表分为遥遥相望的两部分，就像牛郎和织女。这是有意的，不管是写程序，还是处理器执行程序，内存的访问都应该是线性的、连续的、连贯的，为程序分配内存时，每个页在物理上本就不相邻，现在，U-SALT 这么庞大，必定会被分散于各处。这么做，只是为了验证处理器和当前程序是否能在分页机制下正常工作。

需要注意的是，U-SALT 的大小是256 字节对齐的，因为每个表项占256 字节。因此，空白数据的大小也应当是256 的整倍数。否则，在程序的重定位阶段，内核将不能正确地处理USALT 表。
### 16.1.3　地址变换的具体过程

对于Intel 处理器来说，有关分页，最简单和最基本的机制就是这些：CR3 寄存器给出了页目录的物理基地址；页目录给出了所有页表的物理地址，而每个页表给出了它所包含的页的物理地址。好了，该清楚的都清楚了，唯一还不明白的，应该是如何用这种层次性的分页结构把线性地址转换成物理地址？

这里有个例子。

假如某个任务加载后，操作系统根据它的实际情况，在其4GB 虚拟地址空间里创建了一个段，段的起始地址为0x00800000，段界限值为0x5000，字节粒度。当该任务执行时，段寄存器DS 指向该段。又假设执行了下面一条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00678.jpeg)

此时，段部件会输出线性地址0x00801050。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了分页机制，所以，这是一个虚拟地址，要经过页部件的转换，才能得到物理地址。

如图16-8 所示，处理器的页部件专门负责线性地址到物理地址的转换工作。它首先将段部件送来的32 位线性地址截成3 段，分别是高10 位、中间的10 位和低12 位。高10 位是页目录的索引，中间10 位是页表的索引，低12 位则作为页内偏移来用。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00679.jpeg)

图16-8　页部件把线性地址转换为物理地址的例子

当前任务页目录的物理地址在处理器的CR3 寄存器中，假设它的内容为0x00005000。段管理部件输出的线性地址是0x00801050，其二进制的形式为0000 0000 1000 0000 0001 0000 0101 0000。高10 位为0000000010，也就是十六进制的0x002，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4 字节），作为偏移量访问页目录。最终，处理器从物理地址00005008 处取得页表的物理地址0x08001000。

线性地址的中间10 位为二进制的0000000001，即0x001，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。最终，处理器又从物理地址08001004 处取得页的物理地址，这就是我们一直努力寻找的那个页。

页的物理地址是0x0000C000，而线性地址的低12 位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址0x0000C050，这就是线性地址0x00801050 所对应的物理地址，要访问的数据就在这里。

注意，这种变换不是无缘无故的，而是事先安排好的。当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20 位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。

检测点16.1

在分页模式下，某程序运行时，段部件发出一个线性地址0x0C005032 访问内存数据。如果该线性地址对应的物理页是0x0000A000，页表的物理地址是0x00003000，那么，操作系统在此程序开始运行前，是如何安排与该线性地址相关的页目录项和页表项的？
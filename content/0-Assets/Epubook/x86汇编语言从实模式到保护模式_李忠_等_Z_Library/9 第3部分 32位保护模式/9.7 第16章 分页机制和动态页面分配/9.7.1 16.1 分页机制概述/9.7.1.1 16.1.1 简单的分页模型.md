### 16.1.1　简单的分页模型

分段的内存管理模式是我们再熟悉不过的了，因为这是我们一贯的工作方式。如图16-1 所示，在处理器中有负责分段管理的段部件。每个程序或任务都有自己的段，这些段都用段描述符定义。随着程序的执行，当要访问内存时，就用段地址加上偏移量，段部件就会输出一个线性地址。在单纯的分段模式下，线性地址就是物理地址。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00670.jpeg)

图16-1　分段机制下的线性地址就是物理地址

正如图16-1 所示，描述符中的段基地址为0x00200000，界限值为0x2007。因为段的粒度是字节，故该段的长度为8200 字节。当访问内存时，用段基地址0x00200000 加上段内偏移量0x1008，段部件就会形成线性地址0x00201008，这也是物理地址。

一旦决定采用页式内存管理，就应当把4GB 内存分成大小相同的页。但是，页在物理内存中位置是有讲究的，并不是在内存中随便找个位置，说：“来，页就从这里开始！”事实上，不是这样的。如图16-2 所示，页的最小单位是4KB，也就是4096 字节，用十六进制数表示就是0x1000。因此，第1 个页的物理地址是0x00000000，第2 个页的物理地址是0x00001000，第3 个页的物理地址是0x00002000，……，最后一个页的物理地址是0xFFFFF000。这样，可以将4GB内存划分为1048576（0x100000）个页。很显然，页的物理地址，其低12 位始终为全零。

段管理机制对于Intel 处理器来说是最基本的，任何时候都无法关闭。也就是说，即使启用页管理功能，分段机制依然是起作用的，段部件也依然工作。

分页机制也没有增加程序员的负担，程序依然是按段来组织的。问题在于，如何将较大的段，映射到大小相同的页面上呢？

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00671.jpeg)

图16-2　将4GB 内存划分成以4KB 为单位的页

如图16-3 所示，内存的分配涉及段空间的分配和页分配。请仔细看这幅图，左边是虚幻的，或者说虚拟的4GB 内存空间，称为虚拟内存；右边呢，是实实在在的内存，被分成1048576 个 4KB 页面。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00672.jpeg)

图16-3　段到页的映射

在分页模式下，操作系统可以创建一个为所有任务共用的4GB 虚拟内存空间，也可以为每一个任务创建独立的4GB 虚拟内存空间，这都是可行的。当一个程序加载时，操作系统既在要左边的虚拟内存中分配段空间，又要在右边的物理内存中分配相应的页面。因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序内的其他段使用。比如图16-3 所示，假设已经成功找到并分配了一个段空间，基地址为0x00200000，长度为8200 字节。

页的最小尺寸是4KB，也就是4096 字节。因此，8200 字节的段，需要占用3 个页面，其中最后一个页面只用了8 个字节，其余都浪费着，但这无关紧要，如果允许页共享，多个段或多个程序可以用同一个页来存放各自的数据。

在分段之后，操作系统的任务是把段拆开，并分别映射到物理页。注意，段必须是连续的，但不要求所分配的页都是连续的、挨在一起的。事实上，在开机之后，会运行不同的程序，这都要分配页。然后，有些程序关闭了，页面要回收。几个回合下来，空闲的页零零散散地分布在物理内存中，一般不会是连续的。分配页面时，操作系统会搜索那些空闲的页，并分配给程序使用，所分配页面的总长度要大于等于段长度。

作为一个具体的例子，操作系统为程序分配了一个段，段是在虚拟内存中分配的，起始地址为0x00200000。该段有8200 字节，需要分配3 个页面。为此，操作系统在物理内存中搜索可用的空闲页，还真找到了，这三个页面的物理地址分别是0x00002000、0x00004000 和0x00007000。接下来，要建立线性地址和页之间的对应关系，在图中，0x00200000～0x00200FFF 对应着物理地址为0x00002000 的页， 0x00201000 ～ 0x00201FFF 对应着物理地址为0x00004000 的页，0x00202000～0x00202007 对应着物理地址为0x00007000 的页。当然，这里只是示例，线性地址区间和页的对应关系可以随意。

4GB 虚拟内存空间不可能用来保存任何数据，因为它是虚拟的，它只是用来指示内存的使用情况。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。

从段部件输出的是线性地址，或者叫虚拟地址。为了根据线性地址找到页的物理地址，操作系统必须维护一张表，把线性地址转换成物理地址，这是一个反过程。

如图16-4 所示，因为有1048576 个页，所以转换表也有1048576 项。这是个一维表格，每个表项占4 字节，内容为页的物理地址。这个表格的用法是这样的：因为页的尺寸是4KB，故，线性地址的低12 位可用于访问页内偏移，高20 位可用于指定一个物理页。因此，把线性地址的高20 位当成索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。

如图16-4 所示，如果执行指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00673.jpeg)

那么，段部件用段地址0x00200000 加上指令中给出的偏移量0x2002，得到线性地址0x00202002。线性地址的高20 位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。

线性地址的低12 位是页内偏移量，用页物理地址加上页内偏移量，就是最终的物理内存地址。0x00007000 加上0x002，得到0x00007002，这就是实际要访问的物理内存地址。

问题在于，为什么在表内偏移量为0x00808 的地方，会恰好是页地址0x00007000，而不是其他页地址呢？问得好。当程序加载时，操作系统会首先在虚拟内存中分配段。然后，根据段需要分成多少页，来搜索空闲页面。当段较大时，要按页的尺寸分成好几个地址区段，操作系统用每个区段的首地址，取高20 位，乘以4，作为偏移量访问表格，并将分配给该区段的页的物理地址写入该表项。最后，把原本需要写入每个区段的程序数据，写到对应的页中。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00674.jpeg)

图16-4　从线性地址到页物理地址的映射

注意了，在页式内存管理中，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。很显然，也很重要的结论是，线性地址，包括线性地址空间，和页面分配机制没有关系。

基于以上特点，同时为了充分挖掘分页内存管理的潜力，一般来说，每个任务都可以拥有4GB 的虚拟内存空间；同时，每个任务都有自己的页映射表，如图16-5 所示。

尽管有很多任务，而且每个任务都有自己的4GB 虚拟内存空间，但是，很重要的是，在整个系统中，物理页面是统一调配的。考虑这样一种情景：任务A 有一个段，段基地址为0x00050000，段长度为3000 字节，操作系统为它分配了一个物理地址为0x08001000 的页。过了一会儿，另一个任务B 加载了，它也有一个段，段基地址也是0x00050000，段长度为4096 字节。此时，操作系统则分配另一个不同的、物理地址为0x00700000 的页。在这种情况下，在任务A 内访问线性地址0x00050006，访问的其实是物理地址0x08001006；在任务B 内访问同样的线性地址时，访问的其实是物理地址0x00700006。

另一个会被质疑的问题是，每个任务都有4GB 虚拟内存空间，而物理内存只有一个，最大也才4GB，根本不够分的。事实上，的确不够分配。但是，操作系统可以将暂时不用的页退避到磁盘，调入马上就要使用的页，通过这种手段来实现分页内存管理。这就是为什么内存容量较小时，程序越来越慢，硬盘工作指示灯不停地闪烁的原因。

以上，就是基本的段页式内存管理机制。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00675.jpeg)

图16-5　基本的段页式内存管理示意图
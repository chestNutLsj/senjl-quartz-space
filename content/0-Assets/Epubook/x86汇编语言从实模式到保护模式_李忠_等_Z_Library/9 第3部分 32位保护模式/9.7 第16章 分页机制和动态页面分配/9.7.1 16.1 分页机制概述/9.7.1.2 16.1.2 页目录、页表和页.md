### 16.1.2　页目录、页表和页

第一个支持分页内存管理模式的Intel 处理器是80386，那个时候，分页机制是很简单的。几十年弹指一挥间，处理器变得更为强大，而分页机制也变得复杂。任何事物都具有惯性，更何况IT 界的人常说，软件的发展速度远远跟不上硬件的前进步伐。说得好，虽然分页机制在最新的处理器上并非那么简单，但新机制毕竟用得很少，倒是早先的分页机制依然那么流行。另一方面，因为兼容方面的原因，最初的分页机制是所有处理器都支持的，从最初的分页机制开始学习，可以很容易进一步理解其他分页机制，毕竟它们是一脉相承的。

我们知道，为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务准备一张页映射表。因为任务的虚拟地址空间为4GB，可以分出1048576 个页，所以，映射表需要1048576 个表项，用于存放页的物理地址。又因为每个表项占4 字节，所以，映射表的总大小为4MB。

没错，这张表很大，要占用相当一部分内存空间，考虑到在实践中，没有哪个任务会真的用到所有表项，充其量只是很小一部分，这就很浪费了。

当然，你可能会建议先划出一小块内存给它，然后，根据需要再动态扩展。的确，这是可行的。但是，因为一个特殊的原因，这张表在实际使用的时候，它的前半部分和后半部分会被同时用到。具体是什么原因，马上就要讲到，也正是因为这个尚未说明的原因，这张表从一开始就必须完全定义，而且不可避免地要占用4MB 内存空间。为了解决这个问题，同时又不会浪费宝贵的内存空间，处理器设计了层次化的分页结构。

分页结构层次化的主要手段是不采用单一的映射表，取而代之的是页目录表和页表。如图16-6所示，首先，因为4GB 的虚拟内存空间对应着1048576 个4KB 的页，可以随机地抽取这些页，将它们组织在1024 个页表内，每个页表可以容纳1024 个页。页表内的每个项目叫做页表项，占4 字节，存放的是页的物理地址，故每个页表的大小是4KB，正好是一个标准页的长度。

注意，页在页表内的分布是随机的，哪个页位于哪个页表中，这是没有规律的。在一个真实的系统中，老任务不断被关闭，新任务不断被创建并投入运行，页面的回收和再分配没有什么规律可言。

由于页表中存放的是页的物理地址，故每个页表项占4 字节，这样，每个页表占4096 字节，正好是一个物理页的大小，可以很方便地用一个物理页来定义每个页表。

如图16-6 所示，在将1048576 个页归拢到1024 个页表之后，接着，再用一个表来指向1024个页表，这就是页目录表（Page Directory Table，PDT），和页表一样，页目录项的长度为4 字节，填写的是页表的物理地址，共指向1024 个表页，所以页目录表的大小是4KB，正好是一个标准页的长度。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00676.jpeg)

图16-6　页目录、页表和页的对应关系

这样的层次化分页结构是每个任务都拥有的，或者说，每个任务都有自己的页目录和页表。如图16-7 所示，在处理器内部，有一个控制寄存器CR3，存放着当前任务页目录的物理地址，故又叫做页目录基址寄存器（Page Directory Base Register，PDBR）。

每个任务都有自己的任务状态段（TSS），它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3 寄存器域，存放了任务自己的页目录物理地址。当任务切换时，处理器切换到新任务开始执行，而CR3 寄存器的内容也被更新，以指向新任务的页目录位置。相应地，页目录又指向一个个的页表，这就使得每个任务都只在自己的地址空间内运行。

从图16-7 中还可以看出，页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通页的不同之处仅仅在于功能不一样。当任务撤销之后，它们和任务所占用的普通页一样会被回收，并分配给其他任务。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00677.jpeg)

图16-7　整个分页系统的全局视图
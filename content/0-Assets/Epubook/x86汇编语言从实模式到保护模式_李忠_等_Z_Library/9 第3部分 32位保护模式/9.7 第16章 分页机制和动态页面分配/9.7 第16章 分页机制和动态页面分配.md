   

# 第16章　分页机制和动态页面分配

Intel 处理器访问内存的基本策略是分段。在16 位实模式下，段的起始位置必须对齐在16 字节边界上，而且段的长度最大为64KB。

进入32 位保护模式之后，进一步强化了分段功能，并提供了保护机制。此时，段可以起始于任何位置，段的长度可以扩展到处理器的最大寻址范围边界。典型地，早期的32 位处理器拥有32根地址线，因此，段的长度可以扩展到4GB。

在32 位保护模式下，对段的访问本着“先登记，后访问”的原则进行。登记就是在GDT 或LDT 中登记段的描述符，规定了段的地址和边界，以及访问权限；访问时，则需要拿着一个段描述符的选择子才行，这就是传说中的“虎符”。处理器用段界限和特权级别来审查对段的访问，任何非法的造访行为都会被处理器阻止，并立即拉响警报，也就是所谓的异常中断。

一般来说，人们使用计算机要先安装一个操作系统。在这种情况下，段是由操作系统负责管理的。操作系统加载应用程序，根据程序的要求，为它创建一个或多个段，然后把控制权交给它。

当同时运行的程序和任务很多时，内存可能就不够用了。这时，操作系统的价值就体现出来了。每个段描述符有A 位，每当访问一个段时，处理器会将其置位。A 位的清零由操作系统定时进行，它可以借此机会统计段的访问频度。当内存不够用时，它可以将那些较少访问的段换出到磁盘上，以腾出空间来给马上要运行的段使用。一旦某个段被挪到磁盘上，操作系统应当将其描述符的P 位清零。过一段时间，当这个段又被访问时，因其描述符的P 位是“0”，处理器引发段不存在异常（中断号为11）。这类中断通常是由操作系统负责处理的，它会用同样的方法腾出空间，将这个段的内容从磁盘调入内存。当这类中断返回时，处理器会再次执行引发异常的那条指令（而不是下一条指令），于是程序又能继续执行了。

但是，因为段的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的段，或者空闲区域远远大于要加载的段。在前一种情况下，需要另外寻找合适的空闲区域；在后一种情况下，分配会成功，但太过于浪费。为了解决这个问题，从80386 处理器开始，引入了分页机制。

分页功能从总体上说，是用长度固定的页来代替长度不一定的段，藉此解决因段长度不同而带来的内存空间管理问题。尽管操作系统也可以用软件来实施固定长度的内存分配，但太过于复杂，由处理器固件来做这件事，可以使速度和效率最大化。

本章的学习目标是：

1．了解页目录、页表的结构和作用，清楚为什么当我们访问一个段中的某单元时，处理器能准确地知道它在哪个页，以及页内位置的基本原理。

2．了解开启分页机制的方法和需要的准备工作。

3．了解任务的全局空间和局部空间是如何与它的页目录建立映射关系的。

4．学习按需分配页面（动态分配页面）的一般方法。

5．因为在分页机制下无法使用物理地址工作，因此，需要掌握用线性地址访问页目录表和页表，并修改目录项及页表项的手段。

6．了解什么是平坦内存模型，学习如何在平坦模型下创建程序的段描述符，知道向上扩展的数据段也能作为栈段。

7．学习用Bochs 调试分页机制下的程序。

8．学习若干新的x86 指令，包括bts、btr、btc 和bt 等。
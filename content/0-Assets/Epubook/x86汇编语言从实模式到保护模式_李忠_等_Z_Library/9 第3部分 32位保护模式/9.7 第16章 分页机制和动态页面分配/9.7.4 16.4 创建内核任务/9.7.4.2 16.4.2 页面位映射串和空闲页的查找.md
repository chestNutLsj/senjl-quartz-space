### 16.4.2　页面位映射串和空闲页的查找

尽管每个任务都拥有4GB 虚拟内存空间，也可以自由分配这些空间，但是，物理内存是有限的，或者用页的视角来说，物理页的数量是有限的。

写这本书的时候，拥有4GB 的物理内存并不是一件值得羡慕的事情。但是，所谓水涨船高，要知道，现在的程序也极其庞大，而且往往都在内存中同时运行着。为了分配页，需要跟踪哪些页已经分配，哪些页是空闲的，这对操作系统来说是必做的事情。

很容易想到，操作系统必须在刚刚获得计算机控制权的时候，就检测实际的物理内存数量，并建立一张表格，标明页的物理地址及其是否空闲。当有程序申请内存时，就寻找这样的空闲页，并将其标记为已分配。

内存空间来自于插在主板上的内存条，按照新的工业标准，每个内存条上焊有一个很小的只读存储器，用于标明该内存条的容量和工作参数。作为一个PCI(E)设备，软件可以读取它，以获得计算机上的物理内存容量。然后建立上述的页分配表。

如果你的计算机上真的有4GB 物理内存，那么，它可以划分为1048576（220）个页。如果每个表项占一字节，则需要1MB 内存来创建该表。显然，这有些不划算。为了简单，可以使用位串来指示页的分配情况。

如图16-21 所示，可以用一个长的比特串，叫做页映射位串，来指示每个页的位置及分配情况。取决于你所拥有的实际内存数量（页数），该串最多可以有1048576 比特，由于每字节包含8个比特，所以，共需要131072 字节，也就是128KB。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00698.jpeg)

图16-21　页映射位串示意图

比特在位串中的位置，决定了它所映射的页在哪里。如图16-21 所示，位0 对应的是物理地址为0x00000000 的页，位1 对应的是物理地址为0x00001000 的页，位2 对应的是物理地址为0x00002000 的页，……，最后一个比特对应的是最后一个页，即物理地址为0xFFFFF000 的页。

除了用比特所在的位置决定页的位置外，比特的值决定了页的分配情况。当某比特为“0”时，表示它所对应的页未分配，是可以分配的空闲页；否则，就表明那个页已经被占用了，不能再分配给任何程序。

在本章中，没有检测实际可用内存的代码，仅仅假定我们只有2MB 的物理内存可用。2MB的内存，可分为512 个页，需要512 个比特的位串。在实际的程序中，没有声明位串的方法，只能声明字节、字、双字等。因此，只能用连续的字节或字数据来形成位串。

回到代码清单16-1 中，第465 行，声明了标号page_bit_map，并初始化了64 字节的数据。这64 字节首尾相连，形成一个512 比特的位串。对照图16-21，第1 字节的位0 对应着物理地址为0x00000000 的页，第1 字节的位1 对应着物理地址为0x00001000 的页，……，第2 字节的位0 对应着物理地址为0x00008000 的页，以此类推。

耐心一点，仔细观察这个页映射位串，你会发现前32 字节的值差不多都是0xFF。这并不奇怪，它们对应着最低端1MB 内存的那些页（256 个页），它们已经整体上划归内核使用了，没有被内核占用的部分多数也被外围硬件占用了，比如ROM -BIOS。

当然，如果你眼很尖的话，也会发现其中混杂了两字节的0x55。这又是怎么回事呢？

回到前面，看图16-10，尽管画得不明显，但是依然能看出，在物理地址0x00030000～0x00040000 之间，是一段较为连续的空闲区，共64KB，可划分为16 个页，页的物理地址为0x00030000～0x00040000，就对应着这两字节。本来，这两字节都应当是0x00，以表明是可以分配的空闲页。不过，为了表明大的、连续的线性地址空间不必对应着连续的页，我们有意将空闲的页在物理上分开，因为0x55 的二进制形式是01010101。同样的做法也出现在后面的64 个页中。

当然，这么做未必合法，因为低端1MB 内存已经完整地分配给了内核，在内核的页表中，已经有页表项指向这16 个页。如果我们再把它分配给其他任务，那么，该任务的页表项也势必指向这16 个页，等于重复分配。不过，请放心，这16 个页内核是不会用到的，因此，分配给其他任务也无妨。

回到代码清单16-1 中，来看过程allocate_a_4k_page 是怎么搜索页映射位串并分配页的。

页映射位串位于内核数据段中。第332、333 行，先令段寄存器DS 指向内核数据段。

接着，第335～341 行，从头开始搜索位串，查找空闲的页。具体地说，就是找到第一个为“0”的比特，并记下它在整个位串中的位置。搜索位串用到了指令bts。

bts（Bit Test and Set）指令测试位串中的某比特，用该比特的值设置EFLAGS 寄存器的CF 标志，然后将该比特置“1”。它最基本的两种格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00699.jpeg)

在这里，目的操作数可以是16/32 位的通用寄存器，或者指向一个包含了16/32 位实际操作数的内存单元，用于指定位串；源操作数可以是16/32 位的通用寄存器，用于指定待测试的比特在位串中的索引（位置）。

如果目的操作数是通用寄存器，那么，指定的位串就是该寄存器的内容（长度为16 比特或者32 比特）。在这种情况下，根据操作数的长度，处理器先求得源操作数除以16 或者32 的余数，并把它作为要测试的比特的索引。然后，从位串中取出该比特，传送到EFLAGS 寄存器的CF 位。最后，将该比特置位。

则如果目的操作数是一个内存地址，那么，它给出的是位串在内存中的起始地址，或者说该位串第1 个字或者双字的地址。同样地，源操作数用于指定待测试的比特在串中的位置。因为串在内存中，所以其长度可以最大程度地延伸，具体的长度取决于源操作数的尺寸，毕竟它用于指定测试的位置。如果源操作数是16 位通用寄存器，位串最长可以达到216 比特；如果源操作数是32 位的通用寄存器，则位串最长可以达到232 比特。无论如何，在这种情况下，指令执行时，处理器会用目的操作数和源操作数得到被测比特所在的那个内存单元的线性地址。然后，取出该比特，传送到EFLAGS 寄存器的CF 位。最后，将原处的该比特置位。

除此之外，这两种指令格式的区别还在于具体操作时，处理器读取的数据的长度。挑选比特的工作是在处理器内部进行的，要先从内存中读取含有指定比特的字或双字。第一种指令格式进行的是16 位的内存操作，处理器读的是一个字；第二种指令格式进行的是32 位的内存操作，处理器读的是一个双字。

bts 指令并不孤独，同类型的指令还有btr、btc 和bt 它们的区别如表16-1 所示。

表16-1　bts/btr/btc/bt 指令对照表

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00700.jpeg)

回到代码清单16-1。

搜索空闲页是一个机械的工作，要先从位串的第1 个比特开始。第335 行，先将EAX 寄存器清零，这表明我们要从位串的第1 个比特开始搜索。

第337 行，执行bts 指令。这将使指定的比特被传送到标志寄存器的CF 位，同时那一位被置“1”。置“1”是必做的工作，如果它原本就是“1”，这也没什么影响；如果它原本是“0”，那么，它就是我们要找的比特，它对应的页将被分配，而将它置“1”是应该的。

第338 行，判断位串中指定的位是否原本为“0”。如果答案是肯定的，那么，太好了，于是转到第348 行执行，准备退出当前过程；如果不是，那么，第339～341 行，将EAX 的内容加一，准备测试位串中的下一比特。在此之前，要先判断是否已经测试了位串中的所有比特，以防止越界。page_map_len 是一个用伪指令equ 声明的常数，位于第473 行，它的值就是位串的字节数。将它乘以8，就是位串的比特数。在最坏的情况下，没有找到可以用于分配的空闲页，则显示一条错误消息，并停机。当然，对于一个流行的操作系统来说，这样做是不对的，正确的做法是看哪些已分配的页较少使用，然后将它换出到磁盘，腾出空间给当前需要的程序，到时候再换回来。不过，这已经超出了本书的主题范围。

情况乐观时，会找到一个可以分配的空闲页，也就是一个为“0”的比特。第348 行，将该比特在位串中的位置数值乘以页的大小0x1000（或者十进制数4096），就是该比特所对应的那个页的物理地址。

找到了可用的页，任务也就完成了。第355 行用于返回到当前过程的调用者。可以看出，这是公共例程段内的内部过程，仅供同一段内的其他过程使用。返回时，页的物理地址位于EAX 寄存器中。
### 16.4.3　创建页表并登记分配的页

返回点位于过程alloc_inst_a_page 内，本次调用allocate_a_4k_page 过程的目的是分配一个页作为页表。页表的地址要登记在页目录表内，仅高20 位有效，对应着页表物理地址的高20 位，页表地址的低12 位是页表属性。从第380 行可以看出，页的属性值是0x007，即，US＝1，特权级别为3 的程序也可以访问；RW＝1，页是可读可写的；P＝1，页已经位于内存中，可以使用。内核的页表为什么允许特权级别为3 的程序访问呢？当然了，原则上是不允许的，但是，这个例程既要用于为内核分配页面，也要用于为用户任务分配页面。对于前者，要求将所分配页面的U/S位清“0”；对于后者，要求将所分配页面的U/S 位置“1”，这两者难以兼顾。为了不把事情搞复杂而又能说明问题，用当前过程所分配的页面，US 位一概设置成“1”。

刚分配的页是作为页表使用的，它应当登记在页目录表内，作为目录项存在。现在，ESI 寄存器中的内容就是该目录项的线性地址。第381 行，将目录项的内容修改为页表的物理地址。

过程alloc_inst_a_page 的功能是根据给定的线性地址，设置页目录表和页表的内容。因此，只有当页表不存在的时候，才动态分配一个页表。无论如何，现在页表已经有了，剩下的工作就是为那个线性地址分配一个最终的页，并登记在页表内。为此，需要访问页表。这同样是一个两难的问题，在分页机制下，访问内存需要通过页目录表和页表，而我们访问的正是页表。

这可如何是好？

不管页表是原来就有，还是刚才创建的，程序的执行流程最终会到达第385 行。因为用于分配页的线性地址位于EBX 寄存器中，这一行用于在ESI 寄存器中制作它的一个副本。

因为是要修改页表内的页表项，所以，无论如何，必须要知道该页表项的线性地址才行，这可以分几步来完成：

首先，我们知道，ESI 寄存器中的线性地址，其高10 位决定了页表在页目录表中的登记位置；中间10 位，决定了页在页表中的登记位置。很显然，要访问页表，就得把页表当成普通页来访问。如此一来，那个页表项在页表中的位置，就相当于数据在页中的位置。为此，应当把ESI寄存器的中间10 位乘以4 之后，挪到该寄存器的低12 位，作为页内偏移量；

其次，既然把页表作为普通的页来对待，那么，页部件势必要先访问该“页”的“页表”。页表的物理地址是登记在页目录表中的，它在页目录表中的位置由ESI 寄存器的高10 位指定，因此，就得把页目录表当成该“页”的“页表”来用，并把ESI 寄存器的高10 位挪到中间10 位上，作为页表项的索引号。

最后，为了将页目录表作为页表来用，要将ESI 寄存器的高10 位置成0x3FF。这意味着，页目录表内最后一个目录项就是页表的物理地址。又因为该目录项又指向页目录表自身，故，等于是又把页目录表当成页表来用。至此，任务完成，ESI 寄存器中得到的新值，就是要修改的那个页表项的线性地址。下面结合代码清单来讲一讲具体的做法。

第386～388 行，将ESI 寄存器中的内容右移10 次，清除两边，只保留中间的10 位，同时，将高10 位的内容改成二进制的1111111111（0x3FF）。这样一来，当页部件进行地址转换时，它用高10 位的0x3FF 乘以4 去访问页目录表。由于此表项存放的是页目录表自己的物理地址，因此，此表项所指向的页表，正是当前页目录表自己，这实际上是把页目录表当成页表来用。

接着，页部件又用中间的10 位去访问页表，其实就是访问页目录表自己。于是，它就得到了页的物理地址，其实就是页表的物理地址。很好，现在只需要低12 位的偏移量就可以了。因为是把页表当成普通的页来访问，因此，需要把原线性地址的中间10 位当成页内偏移量来用。

这就是说，现在ESI 寄存器中的内容，就是页表的线性地址。

调用者传入的线性地址依然完好地保存在EBX 寄存器中，到了过程的最后，也不必制造它的副本了，直接用吧。第391 行，用and 指令只保留中间的10 位，两边清零；第392 行，将它右移12 次，再乘以4（左移2 次），作为表内偏移量。因为无关位都已清零，故可以直接写成

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00701.jpeg)

页表的线性地址位于ESI 寄存器中，现在，第393 行，将它和EBX 寄存器中的偏移量相加（合并），就是要修改的那个页表项的线性地址。

要修改的位置找到了，但页还没有分配呢。第394 行，调用过程allocate_a_4k_page 分配一个页，并在EAX 寄存器中返回页的物理地址。第395 行，为其添加属性值0x007。第396 行，将页表项的内容修改为页的物理地址。

至此，给出一个起始的线性地址，分配一个页，并登记在层次化的分页结构中，任务完成。第403 行，retf 指令将控制返回到调用者。
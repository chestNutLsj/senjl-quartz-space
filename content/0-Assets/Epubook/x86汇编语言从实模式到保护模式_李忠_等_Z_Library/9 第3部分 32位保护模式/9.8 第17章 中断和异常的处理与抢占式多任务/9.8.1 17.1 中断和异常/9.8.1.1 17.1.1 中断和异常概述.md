### 17.1.1　中断和异常概述

你应该对中断并不陌生，毕竟我们已经学习过它的知识，也用它来写过程序。中断和异常的作用是指示系统中的某个地方发生了一些事件，需要引起处理器（包括正在执行中的程序和任务）的注意。当中断和异常发生时，典型的结果是迫使处理器将控制从当前正在执行的程序或任务转移到另一个例程或者任务中去。该例程叫做中断处理程序，或者异常处理程序。如果是一个任务，则发生任务切换。

1．中断（Interrupt）

中断包括硬件中断和软中断。

硬件中断是由外围硬件设备发出的中断信号引发的，以请求处理器提供服务。当I/O 接口发出中断请求时，会被像8259A 和I/O APIC 这样的中断控制器收集，并发送到处理器。硬件中断完全是随机产生的，与处理器的执行并不同步。当中断发生时，处理器要先执行完当前的指令，然后才对中断进行处理。

软中断是由int n 指令引发的中断处理，n 是中断号或者叫类型码。

2．异常（Exception）

异常就是我们在介绍16 位汇编语言时所说的内部中断。它们是处理器内部产生的中断，表示在指令执行的过程中遇到了错误的状况。当处理器执行一条非法指令，或者因条件不具备，指令不能正常执行时，将引发这种类型的中断。以上所列的情况都是异常情况，所以内部中断又叫异常或者异常中断。比如，在执行除法指令div/idiv 时，遇到了被0 除的情况（除数是0）；再比如，使用jmp 指令发起任务切换时，指令的操作数不是一个有效的TSS 描述符选择子。

异常分为三种，第一种是程序错误异常，指处理器在执行指令的过程中，检测到了程序中的错误，并由此而引发的异常。

第二种是软件引发的异常。这类异常通常由into、int3 和bound 指令主动发起。这些指令允许在指令流的当前点上检查实施异常处理的条件是否满足。举个例子来说，into 指令在执行时，将检查EFLAGS 寄存器的OF 标志位，如果满足为“1”的条件，则引发异常。

第三种是机器检查异常。这种异常是处理器型号相关的，也就是说，每种处理器都不太一样。无论如何，处理器提供了一种对硬件芯片内部和总线处理进行检查的机制，当检测到有错误时，将引发此类异常。

根据异常情况的性质和严重性，异常又分为以下三种，并分别实施不同的处理。

●故障（Faults）。故障通常是可以纠正的，比如，当处理器执行一个访问内存的指令时，发现那个段或者页不在内存中（P＝0），此时，可以在异常处理程序中予以纠正（分配内存，或者执行磁盘的换入换出操作），返回时，程序可以重新启动并不失连续性。为了做到这一点，当故障发生时，处理器把机器状态恢复到引起故障的那条指令之前的状态，在进入异常处理程序时，压入栈中的返回地址（CS 和EIP 的内容）是指向引起故障的那条指令的，而不像通常那样指向下一条指令。如此一来，当中断返回时，将重新执行引起故障的那条指令，而且不再出错（如果引起异常的情况已经妥善处置）。这意味着，异常并不总是意味着坏消息，相反，很多时候，它是有益的，就像益虫。如果没有异常，虚拟内存管理将无从谈起。

●陷阱（Traps）。陷阱中断通常在执行了截获陷阱条件的指令之后立即产生，如果陷阱条件成立的话。陷阱通常用于调试目的，比如单步中断指令int3 和溢出检测指令into。陷阱中断允许程序或者任务在从中断处理过程返回之后继续进行而不失连续性。因此，当此异常发生时，在转入异常处理程序之前，处理器在栈中压入陷阱截获指令的下一条指令的地址。

●终止（Aborts）。终止标志着最严重的错误，诸如硬件错误、系统表（GDT、LDT 等）中的数据不一致或者无效。这类异常总是无法精确地报告引起错误的指令的位置，在这种错误发生时，程序或者任务都不可能重新启动。一个比较典型的终止类异常是“双重故障”（中断号为8），当发生一次异常后，处理器在转入该中断的处理程序时，又发生另外的异常（如该中断处理程序所在的段不在内存中，或者栈溢出）。对于中断处理程序来说，很难从栈中获得有关如何纠正此类错误的明确信息，往往是发生极为重大的错误时才伴随着这种异常，所以再继续执行引起此异常的程序或任务已相当困难，操作系统通常只能把该任务从系统中抹去。

中断和异常发生时，处理器将挂起当前正在执行的过程或者任务，然后执行中断和异常处理过程。返回时，处理器恢复程序或者任务的执行，而且被打断的程序或任务的执行不失连续性，除非遇到一个终止类型的异常。对于某些异常，处理器在转入异常处理程序之前，会在当前栈中压入一个称为错误代码的数值，帮助程序进一步诊断异常产生的位置和原因。

表17-1 列出了Intel 处理器在保护模式下的中断和异常。

表17-1　保护模式下的中断和异常向量分配

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00722.jpeg)

当中断和异常发生时，NMI 和异常的向量是由处理器自动给出的；硬件中断的向量是由I/O中断控制器芯片送给处理器的；软中断的向量是由指令中的操作数给出的。

从80486 之后开始，处理器内部一般集成了浮点运算部件x87 FPU，不再需要安装独立的数学协处理器，所以有些和浮点运算有关的异常可能不会产生（比如向量为9 的协处理器段超越故障）。wait 和fwait 指令用于主处理器和浮点处理部件（FPU）之间的同步，它们应当放在浮点指令之后，以捕捉任何浮点异常。

从1993 年的Pentium 处理器开始，引入了用于加速多媒体处理的多媒体扩展技术（Multi-Media eXtension，MMX），该技术使用单指令多数据（Single-Instruction，Multiple-Data，SIMD）执行模式，以便于在64 位的寄存器内实施并行的整数计算。在之后的岁月里，随着处理器的更新换代，该项技术也多次扩展，第一次扩展被称为SSE（SIMD Extension），第二次是SSE2，第三次是SSE3。和SIMD 有关的异常是从Pentium Ⅲ处理器开始引入的。

bound（Check Array Index Against Bounds）指令用于检查数组的索引是否在边界之内，其格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00723.jpeg)

其具有两个操作数，目的操作数是寄存器，包含了数组的索引；源操作数必须指向内存位置，在那里包含了两个成对出现的字或者双字，分别是数组索引的下限和上限。如果执行bound指令时，数组的索引小于下标的下限，或者大于下标的上限，则产生异常。

ud2（Undefined Instruction）指令是从Pentium Pro 处理器开始引入的，它只有操作码而没有操作数，机器代码为0F 0B。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00724.jpeg)

执行该指令时，会引发一个无效操作码异常。该指令没有别的用处，典型地用于软件测试。尽管异常是用该指令故意引发的，但是，在转入异常处理程序时，压入栈中的指令指针是指向该指令的，而非下一条指令。
### 17.5.1　准备加载用户程序

和往常一样，接下来的工作是加载用户程序，创建用户任务。创建和撤销任务，是内核任务的职责所在。为此，需要首先创建用户任务的TCB。我们知道，为了能够访问和控制所有的任务，每个任务的TCB 都必须创建在内核的地址空间内。第1043 行，宏alloc_core_linear 用于创建用户任务的TCB。

第1045～1047 行，初始化用户任务的TCB，主要包括初始的LDT 界限值，以及从哪个线性地址开始在用户任务的局部空间内分配内存（一般是0）。注意，任务的状态值是0x0000，即空闲。

第1049～1051 行，在当前栈中压入两个双字参数，并调用load_relocate_program 过程以加载和重定位用户程序。

过程load_relocate_program 是从第616 行开始的。

第620 行，保存栈指针寄存器ESP 的快照，为访问栈内的参数做准备。在第16 章，这条指令之前还有两个将段寄存器DS 和ES 压栈的指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00765.jpeg)

而在本章中，内核和用户任务都工作在平坦模型下，也就不必考虑分段，段寄存器压栈的指令也没有了，变成了这样：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00766.jpeg)

正因为如此，栈的状态也和上一章有所不同。如图17-18 所示，第一个参数的位置是SS:EBP+40；第二个参数的位置是SS:EBP+36。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00767.jpeg)

图17-18　执行mov ebp,esp 时的栈状态

这本来是不该成为一个问题的。想想看，要是当初把mov ebp,esp 指令放在pushad 指令之后，两个将段寄存器压栈的指令之前，就不至于在本章中做这样的修改工作了。
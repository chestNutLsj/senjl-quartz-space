### 17.5.3　用户任务的创建和初始化

从第637 行开始，到第760 行，这部分代码用于从硬盘上加载用户程序，并在LDT 内创建各个段的描述符。总体上，它们和第16 章相同，只有三点需要说明。

① 这段代码工作在平坦模式下，因此没有出现任何加载段寄存器和使用段超越前缀的指令。和用户任务有关的操作在虚拟地址空间的低端（0x00000000～0x7FFFFFFF）进行，和内核有关的操作在虚拟地址空间的高端（0x80000000～0xFFFFFFFF）进行。

② 在用户任务的局部地址空间分配内存时，用的是宏alloc_user_linear。该宏是在第18 行定义的。

③ 过程read_hard_disk_0 有所修改，主要是在首尾各增加了指令cli 和sti。在读硬盘时，应当屏蔽硬件中断，以防止对同一个硬盘控制器端口的交叉修改，这会产生很严重的问题。特别是在多任务环境下，当一个任务正在读硬盘时，会被另一个任务打断。如果另一个任务也访问硬盘，将破坏前一个任务对硬盘的操作状态。

第763～798 行，重定位U-SALT 表。这部分代码和第16 章相比，绝大多数是相同的，但也有差异。首先，去掉了一些指令，主要是那些加载段寄存器的指令，比如在第16 章中有如下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00769.jpeg)

在本章中，这些指令已经删除，因为内核和用户程序都工作在平坦模式下。

其次，同样的指令，在第16 章中的含义和本章不同。比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00770.jpeg)

这条指令用于获取内核SALT 表（C-SALT）的地址。如图17-20（a）所示，在第16 章中，内核工作在多段模型，因此，ESI 寄存器中的内容是C-SALT 表在内核数据段内的偏移量。如图17-20（b）所示，在本章中，由于内核工作在平坦模式，因此，ESI 寄存器中的内容是C-SALT 表在整个4GB 段内的线性地址。

同第16 章相比，用户程序的基本结构没有变化。用户程序是从其虚拟地址空间的开始处（0x00000000）加载的，偏移量为0x0000000C 和0x00000008 的地方分别是U-SALT 表的条目数及其线性地址。第765、766 行用于获取这两个数值。

第801～807 行，创建LDT 描述符，并安装到GDT 中。

第809～824 行，用前面的工作成果来填写任务状态段（TSS）。

第827～832 行，创建TSS 描述符，并安装到GDT 中。

第836～838 行，当前页目录表只是借用的，它属于内核。用户任务必须有自己的页目录表。为此，申请一个空闲页作为用户任务的页目录表，并将当前页目录表的内容复制过去。

具体的复制工作是由过程create_copy_cur_pdir 来完成的，该过程是从第381 开始的。和第16章相比，多加了一条指令，即，第394 行的invlpg 指令（Invalidate TLB Entry）。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00771.jpeg)

图17-20　U-SALT 和C-SALT 在两种内存模型下的布局视图

和刷新整个TLB 不同，invlpg 指令用于刷新TLB 中的单个条目。当然，要做到这一点，必须指定一个线性地址，处理器用给出的线性地址搜索TLB，找到那个条目，然后从内存中重新加载它。invlpg 指令的格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00772.jpeg)

也就是说，该指令的操作数是一个内存地址。指令执行时，处理器首先确定该线性地址位于哪个页内，然后刷新相应的TLB 条目。你可能会问，为什么它不接受一个立即数，像这样：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00773.jpeg)

而非得是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00774.jpeg)

我们知道，TLB 是一个附加的硬件机构，只有在处理器正常访问内存时才会导致它的填充和更新。因此，处理器用一个访问内存的操作来促使TLB 条目的更新会更方便。

0xFFFFFFF8 是当前（内核）页目录表内的倒数第2 个目录项，每次都用它来指向新任务的页目录表。当任务A 创建完毕后，它指向任务A 的页目录表；当任务B 创建时，它依然指向任务A的页目录表。虽然在第392 行改写了它，使它指向新任务的页目录表，但这个更改只在内存中有效，还没有反映到TLB 中。如果不刷新TLB 中的这个条目，那么，后面的所有操作，都是针对前一个任务的页目录表进行的，这就麻烦了。是的，我遇到过这个问题。

因此，第394 行，用invlpg 指令来明确地刷新TLB 的对应条目。invlpg 是特权指令，在保护模式下执行时，当前特权级CPL 必须为0。该指令不影响任何标志位。

继续回到过程load_relocate_program，第842 行，弹出并废弃栈中的两个参数，将控制转移到调用者。

第1052、1053 行，将刚刚创建的那个任务的TCB 附加到TCB 链上。

注意，此刻，任务切换也跟着开始了！在此之前，TCB 链上只有一个状态为忙的内核任务，0x70 号中断虽然每秒产生一次，但不会有任务切换。随着第一个空闲任务的加入，当中断产生时，会切换到刚才创建的那个用户任务去执行。

用户程序非常简单，基本框架和第16 章一样。本章提供了两个用户程序，分别对应着代码清单17-3 和17-4，这两个程序执行时，分别对应着用户任务A 和用户任务B。请分别浏览这两个代码清单，你会发现它们基本一样，唯一的区别是它们在屏幕上显示的内容。任务A 的功能是不停地在屏幕上显示

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00775.jpeg)

任务B 则显示的是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00776.jpeg)

第1056～1066 行，创建第二个用户任务。该任务对应着代码清单17-4，在虚拟硬盘上的起始逻辑扇区号为100。当该任务创建完毕，并加入TCB 链后，系统就会开始三个任务之间的切换。

第1068～1074 行是内核任务的主体，是反复执行的部分。它不做别的，就是在每次得到处理器控制权时，反复显示相同的信息“System core task running!”。理论上，作为任务的管理者，这里应该还有终止用户任务，并回收内存空间的代码。简单起见，这里予以省略，留给读者进行。
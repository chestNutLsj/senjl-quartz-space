### 17.5.2　转换后援缓冲器的刷新

第625～631 行，清空当前页目录表的前半部分，为创建用户任务的页表目录项做准备。在第16 章里已经说清楚了，我们是借用内核的页目录来创建用户任务的页目录，毕竟，对于每一个任务来说，页目录表的前半部分对应着它的局部空间，后半部分对应着全局空间，内核用的是其页目录表的后半部分，前半部可以临时用来创建只属于任务自己的页目录项。

第633、634 行，重新加载一遍控制寄存器CR3（页目录表基地址寄存器PDBR）。显然，这是用CR3 原有的内容再次加载一遍，来回一样远，这有什么用呢？

开启页功能时，处理器的页部件要把线性地址转换成物理地址，而访问页目录表和页表是相当费时间的。因此，把页表项预先存放到处理器中，可以加快地址转换速度。为此，处理器专门构造了一个特殊的高速缓存装置，叫做转换后援缓冲器（Translation Lookaside Buffer，TLB）。事实上，对该缓冲器的命名可谓五花八门，从“转换旁路缓冲器”、“转换后备缓冲区”到“快表”，不一而足。

如图17-19 所示，这是TLB 的结构。它分为两大部分，第一部分是标记，其内容为线性地址的高20 位；第二部分是页表数据，包括属性、访问权和页物理地址的高20 位。在分页模式下，当段部件发出一个线性地址时，处理器用线性地址的高20 位来查找TLB，如果找到匹配项（命中），则直接使用其数据部分的物理地址作为转换用的地址；如果检索不成功（不中），则处理器还得花时间访问内存中的页目录表和页表，找到那个页表项，然后将它填写到TLB 中，以备后用。TLB 容量不大，如果它装满了，则必须淘汰掉那些用得较少的项目。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00768.jpeg)

图17-19　转换后援缓冲器（TLB）的结构

TLB 中的属性位来自页表项，比如页表项中的D 位（脏位）等；访问权位来自页目录项和对应的页表项，比如RW 位和US 位，等等。问题是，就RW 位和US 位来说，页目录项和页表项都有这两位，以哪一个为准呢？在分页机制中，对页的访问控制按最严格的访问权执行。对于某个线性地址，如果其页目录项的RW 位是“0”而其页表项的RW 位是“1”，则按RW 位是“0”执行。也就是说，TLB 中的访问权，是页目录项和页表项中，对应访问权的逻辑与。

处理器仅仅缓存那些P 位是“1”的页表项，而且，TLB 的工作和CR3 寄存器的PCD 和PWT 位无关，不受这两位的影响。另外，对于页表项的修改不会同时反映到TLB 中。是的，这是很糟糕的，如果内存中的页表项已经修改，但TLB 中的对应条目还没有更新，那么，转换后的物理地址必定是错误的。

记得第一次在分页模式下写程序时，我遇到过这个问题。因为没有更新TLB，程序总是出错，总是产生异常（对这件事，网友周卫平应该是记得的）。在用bochs 软件单步跟踪程序的执行时，发现页目录项对应的页表项并不是我刚刚设置的。尽管你知道TLB，也知道它的原理，但是，很多时候，也许只有在花了几天工夫，熬了几夜之后，你才终于发现问题出在一个你明白，但却忽略了的地方。在第16 章里，只创建了一个用户任务，过程load_relocate_program 只被调用了一次，不会有什么问题。在本章里，起码创建了两个用户任务，如果不刷新TLB，是不行的。

TLB 是软件不可直接访问的，但却有其他办法来刷新它的内容（条目）。比如，将CR3 寄存器的内容读出，再原样写入，这样就会使得TLB 中的所有条目失效。当然，这是比较直接的做法。当任务切换时，因为要从新任务中的CR3 寄存器域加载页目录表基地址，也会隐式地导致TLB 中的所有条目无效。

注意，上述方法对于那些标记为全局（G 位为“1”）的页表项来说无效，不起作用。
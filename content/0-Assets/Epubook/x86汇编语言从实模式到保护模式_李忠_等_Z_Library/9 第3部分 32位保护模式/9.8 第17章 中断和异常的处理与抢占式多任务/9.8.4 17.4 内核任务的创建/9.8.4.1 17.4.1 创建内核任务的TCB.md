### 17.4.1　创建内核任务的TCB

回到第960～986 行，他往常一样，在屏幕上显示处理器的品牌信息，没有什么好说的。

第989～1007 行，在全局描述符表（GDT）中安装调用门，为用户任务提供系统服务。然后，通过调用门在屏幕上显示信息，以测试调用门的安装是否正确。

下面的工作是创建内核任务，也就是我们所说的程序管理器任务。内核任务需要一个任务控制块（TCB），毕竟它也要参与任务轮转。但是，该TCB 所需的内存不是动态分配的，而是一段静态的空间，是在内核程序编写的时候保留的。回到前面第519 行，在那里声明了标号core_tcb，并初始化了32 个为零的双字。TCB 不需要这么多空间，但多保留一些也没坏处。

第1010 行，首先设置内核任务的状态值为0xFFFF（忙）。实际上，当前正在执行的就是内核，从某种意义上来说就是内核任务，只不过没有办理将其TSS 描述符传送到任务寄存器TR 的手续而已。

内核占据着它自己的虚拟内存空间的高端，同时也映射到每个任务的虚拟内存空间的高端，具体的起始位置是线性地址0x80000000。从这里开始，前1MB（0x80000000～0x800FFFFF）已经被它自己用完了，实际可以继续分配的空间从线性地址0x80100000 开始。因此，第1011 行，在TCB 中设置这个可以分配的起始地址。

每个任务都可以有自己的LDT，如果没有也不要紧。第1013 行，设置内核任务的LDT 的初始界限值。就本章来看，这个值是用不上的，因为内核任务没有LDT。

对TCB 的初始化基本就是这些。第1015 行，将内核任务的TCB 追加到TCB 链表中，像从前一样，在TCB 链表中添加新的TCB 需要调用过程append_to_tcb_link，该过程位于第845 行，在本章已经做了修改，因此适合在平坦模型下工作。

当程序员不是一件容易的事，需要考虑的东西太多。访问和修改TCB 链原本不是多大的事情，可要是中断掺和进来，就得小心了。要知道，0x70 号实时时钟中断随时都在发生，那个中断处理过程也在不停地访问同一个TCB 链表。如果处理不当，很容易出现问题。请考虑一下，过程append_to_tcb_link 主要完成两件事：

① 遍历链表，找到最后一个TCB，修改它的“下一个TCB 线性地址”域，使它指向新的TCB；

② 清空新TCB 的“下一个TCB 线性地址”域，表明它是最后一个TCB。

假如现在已经完成了步骤1，新TCB 已经成为链表的最后一个节点。但是，在准备执行步骤2时，0x70 号中断发生了，该中断处理过程遍历链表。可想而知，因为新TCB 的“下一个TCB 线性地址”域还没有清零，所以，中断处理过程将无法找到链尾，而且会用那个非零的数作为地址，访问到它不该访问的区域（不存在的下一个TCB），处理器产生异常，程序很可能因此崩溃了！

因此，在过程append_to_tcb_link 的一开始，也就是第847 行，先用cli 指令屏蔽硬件中断。

和老版本相比，新版本的append_to_tcb_link 过程显然很简洁，毕竟它工作在平坦模型下。遍历链表找到最后一个TCB 的代码可以参考过程rtm_0x70_interrupt_handle，它们是相同的，不再赘述。

找到最后一个TCB 之后，第861 行，修改它的“下一个TCB 的线性地址”域，使其内容为新TCB 的线性地址；第862 行，将新TCB 的“下一个TCB 的线性地址”域清零。这两行很危险，在它们中间很容易发生中断。而一旦发生中断，麻烦就来了。cli 和sti 指令不必放在该过程的首尾，放到这两条指令的前后就行：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00755.jpeg)

实际上，这是更合理的做法。记住，CLI 指令只在最有必要的时候使用。在一个正常的系统中，大家都很忙，都需要马不停蹄地投入运行，不要让无谓的中断屏蔽指令影响到每个程序的正常执行。
### 17.4.2　宏汇编技术

接下来是创建内核任务的TSS。对于一个任务来说，任务状态段（TSS）是必不可少的。为此，需要在内核的虚拟地址空间内分配内存。

第1018 行的作用是分配创建TSS 所需要内存空间：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00756.jpeg)

这是非常奇怪的，因为，它既不是处理器指令，也不像标号，居然还能单独存在。事实上，在汇编语言里，这是合法的，因为它是宏。

宏（Macro）是一种简化汇编语言程序编写的强大手段，绝大多数汇编语言编译器都支持宏，因此，这些汇编语言称为宏汇编。

宏并不是处理器指令，但它也不同于编译器提供的伪指令，专业地说，它是预处理指令。我们知道，编译器在编译源程序时，要多遍扫描，每次都完成不同的工作，这些都可以称为预处理，最后才开始将语句翻译成机器指令。要想说明宏是什么，下面是一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00757.jpeg)

以上，%define 用来定义单行的宏，宏的名字叫vrm，带有一个参数x，参数要放在括号中。如果有多个参数，参数之间要用逗号分开。在宏的名字之后，要有空格，一个或者多个空格均可，然后，是一个表达式。从该表达式可以看出这个宏是用来做什么的，有什么意义。

宏的作用是可以代替复杂的表达式。在编译期间，编译器要先将宏展开，再编译成机器指令。因此，在编译期间，上面那条mov 指令将被展开为下面的形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00758.jpeg)

宏可以定义成任何形式，只要你觉得方便。因此，下面又是另一种定义宏和使用宏的例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00759.jpeg)

在编译阶段，这最后一条mov 指令编译时，将先被展开成如下的形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00760.jpeg)

注意，宏定义不占用程序的地址空间，它只是一种简化程序编写过程的手段，仅在编译之前有用，在编译之后，宏就消失了。

除了单行的宏，多行的宏可能用处更大。定义多行的宏应当使用关键字%macro。多行宏的形式是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00761.jpeg)

举个例子，假如有以下定义宏和使用宏的代码：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00762.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00763.jpeg)

注意，在定义宏的时候，宏名字后面只给出了参数个数，在宏体内使用参数时，第1 个参数是%1，第2 个参数是%2，依此类推。因此，以上代码编译时，最后一条语句将被展开成如下的形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00764.jpeg)

回到代码清单17-2 中来。

宏alloc_core_linear 是在第12 行定义的，具有0 个参数，也就是没有参数。该宏的作用是在内核的虚拟地址空间上分配内存，并返回起始的线性地址。下一个可分配的线性地址在内核任务的TCB 中。因此，第13 行，从内核任务的TCB 中取得该地址。

为了简单起见，每次在内核的空间中分配内存时，不管需要多少，都固定地分配一个页（的大小）。因此，第14 行，将TCB 中的那个数值在原来的基础上增加4096（0x1000），这就是下一个可分配的线性地址。

第15 行，调用过程alloc_inst_a_page 以分配一个物理页，并用页的物理地址和它所对应的线性地址去修改当前内核任务的页目录表和页表。

当然，你可能怀疑在这里使用宏的必要性。事实上，这是有必要的。分配内存需要访问TCB，分配之后还要更新原来的数据，以形成下一个可分配的线性地址。很多时候，由于一时马虎，会忘了更新那个数，以至于下次分配的线性地址还和上一次相同，这就是致命的问题。一个可能的办法是将它定义成过程。问题是，事情很简单，用过程调用的方法来做代价太大。考虑再三，宏是最好的选择。

当然，不能滥用宏。否则，代码将既难阅读，又难维护。

为内核TSS 分配的线性基地址在EBX 寄存器中。第1021～1026 行，初始化TSS 中的静态部分，包括CR3 寄存器域（内核的页目录表物理地址）、LDT 域、TSS 反向链、I/O 位映射表偏移量等。

第1029～1033 行，创建内核任务TSS 的描述符。

第1034 行，将过程set_up_gdt_descriptor 返回的TSS 选择子保存到内核任务的TCB 中，将来在任务切换时要用到。

第1038 行，用内核任务的TSS 选择子加载任务寄存器TR。这将导致处理器将指定TSS 的线性基地址和段界限值加载到TR 寄存器的描述符高速缓存器。至此，内核任务才名正言顺地成为一个合法的任务。
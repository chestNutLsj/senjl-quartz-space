### 17.3.3　用定时中断实施任务切换

刚才安装的那个0x70 号中断处理过程，主要目的是进行任务切换。

我们知道，计算机主板上有实时时钟芯片RTC，可以定时产生更新周期结束中断信号。可以设置RTC 芯片，使得它每次更新CMOS 中的时间信息后，便发出这个中断信号。在本书的前半部分，刚开始引入中断的概念时，我们用过这个中断。

RTC 芯片的中断线和8259A 从片的第1 个引脚相连，一般情况下，该引脚对应的中断向量为0x70。因此，它的处理过程就叫rtm_0x70_interrupt_handle，位于代码清单17-2 的第429 行。

由于是硬件中断，因此，第433～435 行，先要向8259A 芯片发送中断结束命令EOI，否则它不会再向处理器发送另一个中断“通知”。

说实在的，用实时时钟的更新周期结束中断来实施任务切换并不是一个好主意。和别的中断相比，它更啰嗦，因为必须读一下CMOS 芯片内的寄存器C，使它复位一下，才能使RTC 产生下一个中断信号。否则，它只产生一次中断信号。因此，第437～439 行就用来做这个工作。如果对此不熟悉，建议回到本书的前面复习一下。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00745.jpeg)

图17-9　TCB 链表示意图

在多任务系统中，同时有很多任务等待调度。为了记住都有哪些任务，我们使用了任务控制块（TCB），并把它们穿在一起，形成TCB 链，链上的每一个TCB 称为节点。在上一章里，图16-25 给出了TCB 的基本结构。在这一章里，我们继续使用这个版本的TCB。

学过数据结构的人都知道，链表用得很广泛，而它也拥有一套完整的算法，用来添加节点、插入节点、删除节点和遍历整个链表。很荣幸地，我们现在终于有机会用汇编语言实现这些算法了。

在我们这个链表中，有一个链表头，指向第一个TCB 的线性基地址。然后，在每个TCB 内偏移量为0x00 处，是下一个TCB 的线性地址。当此处为0 时，说明这是链上最后一个TCB。第517 行，声明了标号tcb_chain，并初始化了一个双字，这就是链表头。如图17-9所示， 链表头有自己的线性地址， 比如0x8005320 。它是一个双字， 内容是0x80006000 ， 这就是链上第一个TCB （TCB1）的线性地址。

在线性地址0x80006000 处，是TCB2，其内部偏移量为0x04 的地方，是当前任务的状态，这是一个字，若其值为0x0000，表示这是一个空闲的任务，或者一个挂起的任务；若其值为0xFFFF，则表明这是当前正在运行中的任务（当前任务，或者忙任务）。在任务时候，链表中只允许一个为忙的任务。

TCB1 内，偏移为0x00 处，是下一个TCB，即TCB2 的线性地址。于是，我们可以根据0x80009000 这个值，定位到TCB2。很显然，这是一个正在运行中的任务，状态为忙，下一个TCB，即TCB3 的线性地址是0x80001C00。再来看TCB3，它的状态为挂起或者空闲，而且内部偏移为0x00 的地方是0，它就是链上最后一个TCB。

在中断内实施任务切换，可以使用jmp 指令，从当前正在运行的任务切换到另一个空闲任务。中断的发生是随机的，但是，可以肯定的是，当中断发生时，必定有一个任务正在运行中。因此，中断总是在某个任务内发生的。

如图17-10 所示，当中断发生时，任务可能正在局部空间执行，也可能正在全局空间内执行，即在内核中执行，毕竟内核被映射到每个任务地址空间的高2GB。无论是在任务的局部空间执行，还是在全局空间执行，当中断发生时，因为中断处理过程位于内核中，因此，控制都会转移到任务的全局空间，去执行当前的中断处理过程rtm_0x70_interrupt_handle。

所有任务都共用同一个全局空间，因此，中断处理过程rtm_0x70_interrupt_handle 也只有一份。尽管如此，当某个任务成为正在执行的当前任务时，它便拥有了该中断处理过程。每个任务在执行该过程时都有自己独立的机器状态和寄存器状态，并使用自己私有的0 特权级栈段。所以，这里面不存在任何冲突和混乱的情况。

在图17-10 中，我们是假定中断发生在任务的局部空间。也就是说，任务正在自己的局部空间内执行。此时，将转到全局空间内执行内核的中断处理过程。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00746.jpeg)

图17-10　利用硬件中断实施任务切换的全过程

中断处理过程的主要功能是确定下一个应该被执行的任务，并切换到那个任务。整个过程如下：

① 遍历TCB 链，找到当前任务，也就是寻找那个状态值为0xFFFF 的节点。如果找不到，或者链表为空，则直接转到步骤⑥。

② 如果找到了，则将此节点移到链表的末端，使其成为最后一个节点。因为该任务刚刚执行完，所以，将它移到链尾，可以使其被调度的优先级别最低。

③ 再次遍历TCB 链，寻找链上第一个状态为空闲的任务，也就是寻找状态值为0x0000 的节点。如果找不到，则直接转到步骤⑥。

④ 如果找到了，将当前任务的状态置为0x0000，将找到的空闲任务的状态置为0xFFFF。

⑤ 使用jmp 指令从当前任务切换到空闲任务。

⑥ 执行iretd 指令，中断返回。

接着看图17-10，一旦找到了当前为忙的任务，以及那个空闲任务，则按图中所示，使用jmp指令发起任务切换，切换到空闲任务。因为用的是jmp 指令，故当前任务的TSS 描述符的B 位变成“0”，而新任务TSS 描述符的B 位变成“1”，当前任务和新任务之间是非嵌套的。

另外，非常明显的是，当中断发生，控制转移到其他任务的时候，当前（旧）任务的状态是停留在中断处理过程中的，该任务的TSS 可以保存这一状态。当下一次从其他任务切换到这个任务后，将继续执行未完成的中断处理过程，并在过程的最后执行iretd 指令，于是返回到当初发生中断的地方继续执行。在图17-10 中，是返回到任务的局部空间执行。

注意，其他任务的执行情况也和图17-10 中的这个任务相同。

一旦明白了我们要做什么，以及如何做，现在，来看看这个过程具体是怎么实现的。首先是在链表中找到当前任务，也就是那个状态为忙（0xFFFF）的节点（Node），这是代码清单17-2 第 442～450 行的功能。

第442 行，先把链表头tcb_chain 的线性地址传送到EAX 寄存器；第444 行，因为链表头的内容是第一个TCB 的线性地址，因此，EBX 寄存器的内容就是第一个TCB 的线性地址，如图17-11（a）所示。

第445、446 行，判断EBX 寄存器的内容是否为0。也就是说，链表是否为空。如果是仅有一个链表头的空表，就直接转移标号.irtn 处，那里是一个从中断返回的iretd 指令。否则，说明链表不空，于是EBX 寄存器的内容就是第一个TCB 的线性地址，如图17-11（b）所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00747.jpeg)

图17-11　链表遍历过程中的当前节点

第447、448 行，判断链上第一个TCB 是否为当前正在执行的任务。即，TCB 内的状态域是否为0xFFFF。如果不是，那么，将EBX 寄存器的内容传送到EAX，即，令EAX 寄存器指向第一个TCB 的线性地址，回到前面，重复执行第444～450 行的指令，顺着链表继续往后查找。

如图17-11（c）所示，无论在哪种情况下，EAX 寄存器总是指向当前节点（包括头节点tcb_chain），而EBX 寄存器总是指向下一个节点。要是能够在链表中找到一个状态值为0xFFFF（忙）的节点，那么，它必然是当前节点的下一个节点。也就是说，EAX 寄存器指向当前节点，EBX 寄存器指向那个状态值为0xFFFF 的节点。注意，这里的“当前节点”包括头节点tcb_chain 在内。

另一个值得回味的事情是，由于是在平坦模型下，链表头tcb_chain 和其他节点现在都位于同一个4GB 段内，所以才有了这段比较“流畅”、“自然”、“统一”的处理过程。要是在以前，头节点tcb_chain 位于一个较小的内核数据段；其他节点则在可用的物理内存中，或者任务的虚拟地址空间内动态创建，由于它们不在一个段内，无法用同一段代码进行处理。

只有在找到一个状态值为0xFFFF 的节点时，处理器的执行流程才会到达标号.b1 处。此处的任务是将该节点移到链表的末端，使它能够被再次调度执行的可能性降到最低，毕竟它刚刚执行过。

为此，第454、455 行，先将那个状态为忙的节点从链表中拆除。如图17-12 所示，该节点是当前节点的下一个节点，即节点A，其线性地址在EBX 寄存器中，故第454 行可以取得该节点的下一个节点，即节点B 的线性地址。然后，第455 行，把节点B 的线性地址填写到当前节点的“下一个TCB 线性地址”域中。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00748.jpeg)

图17-12　将状态为忙的节点从链上拆除

作为一个特别的例子，如图17-13 所示，如果链上只有一个TCB，而且是个状态值为0xFFFF的节点，那么，当前的算法也同样适用。在这种情况下，链表头将失去和这个唯一的节点的联系。不过，这只是暂时的。接着往下看，我们要将那个被拆除的节点挂到链表的末端。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00749.jpeg)

图17-13　从链上拆除节点的算法适用于只有一个TCB 的情况

第458～462 行，从当前节点开始，继续往后遍历链表，直到链表结束。当前节点的线性地址总是在EAX 寄存器中，而EDX 寄存器的内容总是下一个节点的线性地址。这段代码将反复执行，每次都把下一个节点作为当前节点来处理，就这样，最终会定位到链上最后一个节点。

如图17-14 所示，当执行流程到达标号.b3 处时，EAX 寄存器指向链上最后一个节点，其内容为该节点的线性地址；EBX 寄存器在这段代码中没有使用，故它还指向那个状态值为0xFFFF 的任务；EDX 寄存器的内容始终指向当前节点的下一个节点，遍历到链表末端时，其内容为0。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00750.jpeg)

图17-14　遍历链表，直到最后一个节点

第465、466 行，将状态值为0xFFFF 的节点挂到链表的末端，同时，将它的“下一个TCB 线性地址”域改为0，表明这是最后一个节点，如图17-15 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00751.jpeg)

图17-15　将状态为忙的任务挂在链表的末端

对于前面那个特别的例子来说，即使链上只有一个TCB，将它从链中拆除，并移到链尾的过程也同样适用。如图17-16 所示，当那个唯一的、状态值为0xFFFF 的节点从链中拆除后，链表头tcb_chain 中的内容为0。当执行遍历动作时，它会被当成链上最后一个节点对待。在这种情况下，最终的结果是又重新将那个被拆除的节点挂在链表上，前后的结果一样，来回一样远。

第469～475 行，从头开始遍历链表，直到发现第一个状态值为0x0000（空闲）的节点。这段代码没什么好说的，方法和前面一样。如果没有找到，就转到标号.irtn 处，直接从中断返回。原因是，如果没有状态为空闲的任务，任务切换就没办法进行。这种可能性是有的，比如，在内核刚刚加载，并做为第一个状态为忙的任务添加到链表中的时候。这时，链表中只有一个TCB，而且节点的状态值为0xFFFF。

不过，一旦发现有空闲的任务，那么此时EAX 寄存器指向这个状态值为0x0000（空闲）的节点，EBX 寄存器指向那个状态值为0xFFFF（忙）的节点。第478、479 行，分别用not 指令将它们的状态值取反。也就是说，原先为空闲的任务变忙；原先为忙的任务变为空闲。

在每个TCB 内偏移量为0x14 的地方，依次是该任务TSS 的线性地址和TSS 描述符选择子。第450 行，使用间接远转移指令jmp 发起任务切换，控制转移到被选中的那个新任务。

等下一次当前任务又获得执行权时，返回点是第483 行。于是，执行iretd 指令，从中断返回，正常执行任务的其他代码，直到下一个实时时钟中断发生。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00752.jpeg)

图17-16　将节点移到链尾的特别例子
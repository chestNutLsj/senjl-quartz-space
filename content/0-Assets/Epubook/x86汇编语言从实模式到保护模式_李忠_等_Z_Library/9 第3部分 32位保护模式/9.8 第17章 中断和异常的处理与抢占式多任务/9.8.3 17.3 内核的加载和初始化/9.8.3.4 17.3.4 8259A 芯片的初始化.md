### 17.3.4　8259A 芯片的初始化

看起来，和所有中断/异常相关的门描述符都已经安装好了，现在，应该把中断描述符表的基地址和界限值加载到中断描述符表寄存器（IDTR）中。

第916 行，将中断描述符表的界限值写入标号pidt 处的字单元。pidt 是在第513 行声明的，初始化了6 字节，其中，前面的字是IDT 的界限值，等于描述符的个数（255）乘以8 减去1；后一个双字保存的则是IDT 的线性基地址。IDT 的基地址已经定义为常量idt_linear_address，因此，第917 行，将这个数值写入该双字单元中。

第918 行，用lidt 指令加载IDTR 寄存器（Load Interrupt Descriptor Table Register）。该指令的格式和lgdt 相同：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00753.jpeg)

这就是说，该指令的操作数是一个内存地址，指向一个包含了48 位（6 字节）数据的内存区域。在16 位模式下，该地址是16 位的；在32 位模式下，该地址是32 位的。和lgdt 指令一样，该指令在实模式下也可以执行，以便于在进入保护模式之前就做好有中断有关的准备工作。

在这6 字节的内存区域中，前16 位是IDT 的界限值，高32 位是IDT 的线性基地址。在初始状态下（计算机启动之后），GDTR 的基地址被初始化为0x00000000；界限值为0xFFFF。

该指向不影响任何标志位。

一旦设置了中断描述符表（IDT），并加载了IDTR 寄存器，处理器的中断机制就开始起作用了。比如，要是有异常发生，就会调用相应的异常处理过程。如果EFLAGS 寄存器的IF 位处于置位状态，硬件中断也能得到相应的处理。不过，依目前的状态，还不宜开放硬件中断。

在保护模式下，如果计算机系统的可编程中断控制器芯片还是8259A，那就得重新进行初始化。事实上，8259A 并没有过时，在单处理器系统中，它依然健在。

重新初始化8259A 芯片的原因是其主片的中断向量和处理器的异常向量冲突。计算机启动之后，主片的中断向量为0x08～0x0F；从片的中断向量是0x70～0x77，在以8086 为处理器的系统中，这没有什么问题，在32 位处理器上，0x08～0x0F 已经被处理器用做异常向量。

好在8259A（以及I/O APIC）都是可编程的，允许重新设置中断向量。根据Intel 公司的建议，中断向量0x20～0xFF（32～255）是用户可以自由分配的部分。那么，我们可以设置8259A的主片，把它的中断向量改成0x20～0x27，这样就没问题了。

对8259A 编程需要使用初始化命令字（Initialize Command Word，ICW），以设置它的工作方式，共有4 个初始化命令字，分别是ICW1～ICW4，都是单字节命令。ICW1 用于设置中断请求的触发方式，以及级联的芯片数量；ICW2 用于设置每个芯片的中断向量；ICW3 用于指定用哪个引脚实现芯片的级联；ICW4 用于控制芯片的工作方式。

对8259A 芯片的编程不是本书的重点，因为这涉及它的内部构造和工作原理，说来话长。同时，这还是一个令人厌恶的芯片，只分配了两个端口，设置起来拐弯抹角，很麻烦。不像有些芯片，每个端口对应着一个命令字，比较简单。

主片的端口号是0x20 和0x21，从片的端口号是0xA0 和0xA1，要发送初始化命令字给8259A 芯片，对于主片来说，需要先向0x20 端口发送ICW1，而对于从片来说，这个端口是0xA0。这是一个标志，每次8259A 芯片接到ICW1 时，都意味着一个新的初始化过程开始了。

从0x20/0xA0 端口接受命令字ICW1 后，8259A 芯片期待从0x21/0xA1 端口接受命令字ICW2。但是，它是否期待ICW3 和ICW4，还要看ICW1 的内容。如图17-17 所示，ICW1 的位0决定了是否有ICW4 命令，位1 指示是否为多片级联。如果是多片级联，那么，必定有ICW3 命令。这样一来，8259A 芯片就知道，在接受了ICW2 命令之后，是否还要在相同的端口（0x21/0xA1）上依次再接受ICW3 和ICW4。

注意，在图17-17 中，深色的比特位表示它已被保留，或者不用，使用图中所标注的固定值（0 或1）；有些比特虽然不是深色，但也标注了固定值（0 或1），这些位是有意义的，可以设置或改变，具体的含义可参考芯片手册。但是，之所以在这里采用固定值，是因为就目前的应用环境来说，这是比较通用的合理设置。

来看代码清单17-2。

第921、922 行，先向8259A 主片发送ICW1，端口号是0x20。从命令上看，这里需要ICW4，而且指定了多芯片级联方式，中断信号的采集用的是边沿触发方式。因为是多芯片级联，故需要ICW3。

第923、924 行，通过另一个端口0x21 向主片发送ICW2 命令。如图17-17 所示，ICW2 命令用于设置芯片的中断向量号。芯片每个引脚的中断向量号不需要单独设置，只需要一个起始向量号即可。ICW2 的低3 位不用，固定为0，仅高5 位有效。在这里，ICW2 的值是0x20，对应着二进制数00100000，高5 位是00100。此时，该芯片的8 个中断引脚就分别对应着中断向量号0x20～0x27。

再举个例子，如果ICW2 的高5 位是01101，那么，加上低3 位的全“0”，它对应的二进制数就是01101000，即0x68，该芯片的中断向量为0x68～0x6F。

第925、926 行，依然通过端口0x21 向主片发送ICW3 命令。如图17-17 所示，发送给主片的命令和发送给从片的命令，是不相同的。因为这里是在设置主片，故该命令字的7 比特分别表示那个引脚是否连着从片。从命令字上看，是0x04，即二进制的00000100，也就是说，该芯片的第3 个引脚连着从片。

第927、928 行，依然通过端口0x21 向主片发送ICW4 命令。如图17-17 所示，我们发送的命令字是0x01，这表示要求采用非自动结束方式。对于单片使用的场合，采用自动结束方式较为方便，但多片级联的场合，应当采用非自动结束方式。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00754.jpeg)

图17-17　8259A 芯片的初始化命令字

第930～937 行，这些代码用于设置和主片相连的从片，方法大致相同，读者自行分析。

第940～952 行，这段代码专门用于设置和0x70 号时钟中断有关的硬件状态，包括RTC 和8259A。对RTC 的设置包括允许它产生哪些中断信号，并读一下它的寄存器C。寄存器C 在每次读取后自动清零，如果没有清零，RTC 将不会产生中断信号；对8259A 的设置主要是打通它和RTC 之间的中断信号通路。这段代码是从第9 章原封不动地抄来的，在那一章里已经做过讲解，这里不再赘述。

第954 行，用sti 指令设置EFLAGS 寄存器的IF 位，开放硬件中断。

中断是计算机系统中一个必不可少的恶魔，不用它便罢，一旦放出了它，就好比打开了潘多拉魔盒。从此之后，如果你处理不当，各种奇怪的程序问题都有可能出现，而且神出鬼没，不容易找到它发生的根源。

这是可以理解的。在一个顺序工作的程序中，很容易用调试工具找到错误指令和出错原因。但是，中断是随机发生的，而且不能确定在中断发生时，处理器将控制转移到了哪里。即使知道出错的位置，也不容易发现错误的原因。很多时候，中断处理过程和被中断的程序有着逻辑上的关联，包括状态的依赖和数据的共享和争用，等等。

说这些就扯远了，还是看看现在都会发生什么。因为执行了sti，硬件中断会随时得到处理。特别是我们最关注的实时时钟中断，它差不多会在1 秒钟内发生一次。当此中断发生后，过程rtm_0x70_interrupt_handle 就会被执行。它会遍历TCB 链，找到一个状态为忙的任务，和一个状态为空闲的任务，然后发起任务切换。

就目前的实际情况而言，该中断处理过程不会做太多的事，仅仅是给8259A 芯片发送中断结束命令EOI，并读一下RTC 芯片的寄存器C，然后执行iretd 指令返回，因为目前链表为空。
### 17.3.2　创建中断描述符表

现在转到代码清单17-2，这是内核程序的代码。

当内核开始执行时，执行点位于第872 行。此时，指令指针寄存器EIP 的内容必然大于0x80040000，因为内核程序已经被映射到虚拟地址空间的高端。

接下来的工作是准备保护模式下的中断系统。保护模式下的中断机制不同于实模式，因此，在进入保护模式之前，我们已经用CLI 指令关掉了外部硬件中断，以免出现错误。而且，只有在创建了中断描述符表，并安装了中断处理程序之后，能才使用STI 指令开放硬件中断，并享受中断的好处。

如图17-7 所示，我们把中断描述符表（IDT）定义在物理内存中从地址0x0001F000 开始的地方，这里紧挨着内核的页目录表，是一段没有用到的空间。要知道，目前是在分页模式下，低端1MB 内存已经被映射到高端，因此，中断描述符表的线性起始地址实际上是0x8001F000。该地址将多次在程序中引用，为了方便修改，在代码清单的第9 行，已经将它声明为一个常数idt_linear_address，以后可以直接将它作为数值使用。

常数定义仅仅在程序编译期间有用，在编译之后不占用任何地址空间。

表的线性地址已经确定，现在的工作是在其中安装门描述符。在这里，为每一个中断向量都定义独立的处理程序不太现实，最好是将它们归归类，比如将硬件中断归为一类，再将异常归为另一类，如此一来，只需要定义两个通用的中断处理程序即可。如果有某个中断或异常需要特殊处理，可以根据需要随时安装单独的程序。

异常的通用处理程序是在标号general_exception_handler 处定义的，位于第422 行，它只做两件事，先显示错误信息，然后停机。在屏幕上显示信息依然要使用过程put_string，在平坦模型下，调用该过程不需要使用远转移指令。但是，该过程还要被包装成调用门，以方便在用户任务内调用。通过调用门的控制转移属于远过程调用，因此，请看第59 行，put_string 过程是用retf 返回的。

这就是说，尽管过程put_string 是内核的家人，但还必须用远过程调用的方式使用：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00744.jpeg)

我们只为内核定义了两个段：4GB 的代码段和4GB 的数据段，为了方便引用，在代码清单17-2 的第7 行和第8 行，分别定义了两个常数flat_4gb_code_seg_sel 和flat_4gb_data_seg_sel，前者是4GB 代码段的选择子，后者是4GB 数据段的选择子。

对异常的处理很复杂，要分具体情况。有的异常发生后，只要纠正了错误，还可以再次执行产生异常的指令，比如页故障；有的异常发生后，当前任务不可能再恢复执行；有的异常有错误代码压栈，而有的则没有。前两种情况还好办，如果你愿意，还能用iretd 指令返回；但是对于有和没有错误代码的情况，就不好办了。没有还好，可以直接用iretd 返回；如果有，则必须先弹出错误代码。在一个通用的异常处理程序中，无法判断有没有错误代码压栈，因此，唯一的异常处理办法就是停机。

第877～880 行，调用make_gate_descriptor 过程创建中断门描述符。该过程不但可以用于创建调用门描述符，还可以用来创建中断门、陷阱门和任务门的描述符。在此处，描述符的目标代码段选择子是当前内核4GB 代码段选择子；段内偏移量是通用异常处理过程的线性地址，肯定大于0x80040000；描述符的属性值为0x8E00，指示这是一个32 位的中断门描述符，门的特权级别为零。

一般来说，内核不会允许3 特权级的用户任务使用make_gate_descriptor 过程。因此，它可以定义成用ret 指令返回的近过程，而不是现在的远过程。在内核中以近过程调用的方式使用它更方便，但我们也不想对它做任何改动，毕竟它一直是用retf 指令返回的。因此，在这里对它的调用还是远调用。

第882～889 行，在IDT 中安装前20 个描述符，它们都指向通用异常处理程序。EBX 寄存器指向IDT 的线性基地址；ESI 寄存器是IDT 内的索引，或者说是中断向量号。每个描述符占8 字节，因此，每个描述符的线性地址是EBX＋ESI×8。

第892～903 行，在IDT 内安装通用中断处理程序，中断向量20～255，对应着Intel 保留的中断向量，以及外部硬件中断。通用的中断处理过程general_interrupt_handler 是在第410 行定义的。第411～419 行，先是向8259A 芯片发送中断结束命令EOI（End Of Interrupt），然后执行iretd 指令从中断返回。很明显，通用的中断处理过程什么也不做。但是，如果没有这个什么也不做的过程，当中断发生时，就会出问题。

根据实际需要，中断或异常应当单独处理。第906～913 行，在IDT 中安装0x70 号中断的处理过程。这段代码很好理解，首先用make_gate_descriptor 过程创建一个指向0x70 号中断处理过程的中断门描述符，然后，将它写入相应的IDT 表项内。该表项的线性地址等于IDT 的线性起始地址，加上0x70 乘以8。
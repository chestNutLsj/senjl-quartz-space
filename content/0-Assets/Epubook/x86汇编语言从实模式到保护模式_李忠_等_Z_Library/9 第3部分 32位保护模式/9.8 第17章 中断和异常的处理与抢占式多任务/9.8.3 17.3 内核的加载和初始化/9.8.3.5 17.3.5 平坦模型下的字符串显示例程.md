### 17.3.5　平坦模型下的字符串显示例程

代码清单17-2 第956、957 行，在屏幕上显示字符串，表示内核正工作在保护和分页模式下，内核的地址空间已经被映射到地址0x80000000 以上。

在本章中，由于使用了平坦模型，put_string 过程也不得不做了大幅度修改，以适应这种变化。一直以来，该过程接受的参数是DS:EBX。此处，DS 是数据段寄存器，要显示的字符串位于它所指向的段中；EBX 寄存器的内容是字符串在段内的偏移量。显然，老版本的put_string 过程是面向多段模型的。

相反地，该过程的新版本只能工作在平坦模型下，它只需要用EBX 寄存器传入字符串的线性地址即可。在平坦模型下，字符串位于任务的4GB 虚拟地址空间内，它的线性地址是唯一的。

在字符串的显示期间，需要临时关闭硬件中断，即，用cli 指令清零EFLAGS 寄存器的IF位。如果不这么做，那么，在字符串显示期间，随时会被中断。如果切换到另外一个任务，那么，两个任务所显示的内容就有可能在屏幕上交替出现。当然，这还算不上是严重的问题，更严重的是写光标寄存器，举个例子，任务A 读光标位置，并在屏幕上写了一个字符。当它正准备用新的数值写光标寄存器时，中断发生，任务B 开始执行。任务B 也读光标位置并在那里写字符。因为任务A 实际上并没有完成推进光标的工作，故任务B 的字符会覆盖任务A 的字符。这种情况发生的几率较低，但并不是不会发生。

因此，第42 行，在开始显示字符串之前，先禁止硬件中断；第54 行，只有在整个字符串完整地显示完毕之后，才开放硬件中断。这样，每个任务的字符串都能完整地显示。同时，因为本例程中有sti 指令，因此，在整个中断系统没有初始化完成之前，不能调用。

在硬件中断关闭期间，put_string 过程实际上是调用另一个近过程put_char 来逐个显示字符的。put_char 过程是从第62 行开始的。

第68～81 行的工作是取当前光标位置。取得的光标位置数值位于BX 寄存器中，要用于寻址显示缓冲区。因为访问显示缓冲区时用的是32 位寻址方式，故必须使用EBX 寄存器。第81 行，用and 指令清除EBX 寄存器的高16 位，仅保留低16 位（BX）。

第101 行，写字符到显示缓冲区。显示缓冲区的线性基地址是0x800B8000，缓冲区内的偏移量是由EBX 寄存器提供的，0x800B8000 是32 位立即数，故必须和EBX 寄存器搭配，而不能用BX 寄存器。还有，之所以显示缓冲区的线性基地址是0x800B8000，是因为物理内存的低端1MB被完整地映射到从0x80000000 开始的高端。因此，线性地址0x800B8000 会被处理器的页部件转换成物理地址0x000B8000。

同样的道理，第111～121 行，在做屏幕上滚的操作时，要传送的内容在4GB 段内的偏移量为0x800B80A0；目标位置在4GB 段内的偏移量为0x800B8000。
### 14.3.2　调用门的安装和测试

第812～826 行用于安装调用门的描述符，其实也就等于是在安装调用门。

安装的调用门供其他特权级的程序使用，它们在本质上是一些例程，这些例程在上一章里使用过，相信都不会陌生。在上一章里，所有对外公开的例程都以字符串的形式定义在SALT 表中，该表位于内核数据段。

内核数据段中的SALT 表简称C-SALT，位于代码清单14-1 的第364～383 行，属于内核数据段。该表由多个条目组成，每个条目262 字节，其中，前256 字节是例程的名字，后6 字节是例程的地址（前4 字节是例程在目标代码段内的偏移量，后2 字节是例程所在代码段的选择子）。

所有例程都位于公共例程段中，而公共例程段的DPL 是0。为了使其他特权级的程序也能使用这些例程，必须将C-SALT 表中的例程地址转换成调用门。

转换过程使用了循环。转换时需要定位每一个条目，故，第812 行用于将C-SALT 表的起始偏移地址传送到EDI 寄存器，这是第一个条目的位置，以后每次加上262，就能对准下一个条目。

循环次数是由条目数量控制的，条目数是常数salt_items，位于第386 行，第813 行的指令用于将它作为立即数传送到ECX 寄存器。

循环的结构是这样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00595.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00596.jpeg)

因为在转换过程中要用到ECX 寄存器，所以在每次循环的一开始，要先压栈保存ECX 寄存器的值，然后，在loop 指令执行前恢复。

在循环体内，第816 行，用于将每个条目（例程）的32 位段内偏移地址传送到EAX 寄存器。每个条目的长度是262 字节，而它的偏移地址则位于256 字节处。第817 行，用于获取条目（例程）所在代码段的选择子，它位于条目内第260 字节处。

创建调用门描述符的工作实际上是调用过程make_gate_descriptor 来完成的。该过程位于第331 行，属于公共例程段。调用该过程时，需要传入三个参数，分别是EAX 寄存器中的32 位偏移地址、BX 寄存器中的代码段选择子，以及CX 寄存器中的门属性。调用门的属性字段是2 字节的长度，通过CX 寄存器传入门属性时，必须保证各属性位都在原始位置。在我们的代码中，每次通过CX 寄存器传入的值是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00597.jpeg)

很显然，P＝1，DPL＝3，即，只有特权级高于等于3 的代码段才能调用此门，参数的数量为0，也就是不需要通过栈传递参数。

下面我们来看一看例程make_gate_descriptor 都做了些什么。

第340～342 行，先在EDX 寄存器中得到32 位偏移地址的复制品，然后将低16 位清除，只留下32 位偏移地址的高16 位部分，并同CX 寄存器中的属性值一起，形成调用门描述符的高32 位。

第344～346 行，将EAX 寄存器的高16 位清除，只留下32 位偏移地址的低16 位。接着，将EBX 寄存器逻辑左移16 次，使得段选择子位于它的高16 位。最后，用or 指令将这两个寄存器合并，就得到了调用门描述符的低32 位。

第351 行，retf 指令使得控制返回调用者。注意，从这条指令可以看出，该过程必须以远调用的方式使用。

回到内核代码段。

第821 、822 行， 在调用了例程make_gate_descriptor 后， 立即调用了另一个例程set_up_gdt_descriptor 来安装刚才创建的调用门描述符。在GDT 中安装描述符的过程和前一章相同，不再讲述。显然，调用门描述符是在GDT 中创建的，并用CX 寄存器返回该描述符的选择子，即调用门选择子。

第823 行，将返回的调用门选择子回填到条目内，用以覆盖原先的代码段选择子。

取决于C-SALT 表的大小，循环过程会进行多次。在本章中，C-SALT 表中共有4 个条目，这4 个调用门安装之后，GDT 的布局如图14-11 所示。

第829、830 行对刚安装好的调用门进行测试，看它好不好用。测试的结果是在屏幕上显示一行文字，意思为“系统范围内的调用门已经安装”。

标号salt_1 指向C-SALT 表中第一个条目的起始处，在此基础上增加256，就是它的地址部分。现在我们已经知道，该条目对应着公共例程段中的put_string 过程，用于显示零终止的字符串。

表面上，这是一条普通的间接绝对远调用指令call far，通过指令中给出的地址操作数，可以间接取得32 位的偏移地址和16 位的代码段选择子，这样的指令我们太熟悉了。但是，处理器在执行这条指令时，会用该选择子访问GDT/LDT，检查那个选择子，看它指向的是调用门描述符，还是普通的代码段描述符。如果是前者，就按调用门来处理；如果是后者，还按一般的段间控制转移处理。

在这里，因为salt_1 条目的选择子已经被替换成调用门选择子，所以处理器按调用门的方式来执行控制转移。通过调用门实施控制转移时，处理器只用选择子部分，salt_1 条目中给出的32位偏移量部分被丢弃。原因很简单，通过调用门进行控制转移不需要偏移量，偏移量已经在调用门描述符中给出了。不单单是间接绝对远调用，直接绝对远调用也是这样，如果选择子指向的是调用门，偏移量也会被忽略，例如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00598.jpeg)

在这个例子中，因为是通过调用门实施控制转移，处理器将忽略偏移量0x0000c000。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00599.jpeg)

图14-11　安装调用门后的GDT 布局

借助调用门，当程序的执行流从低特权级的代码段转入高特权级的代码段时，如果那是个非依从的代码段，当前特权级也随之变为目标代码段的特权级。不过，如果调用者和被调用者的特权级相同，则特权级不会变化。在当前的例子中，是从内核代码段调用公共例程段的例程，尽管也是通过调用门，但它们的特权级都是0。所以，在控制转移的过程中不会发生栈切换，仅仅是把返回地址CS 和EIP 压入当前栈。当执行retf 指令后，处理器从栈中恢复CS 和EIP 的原始内容，于是又返回到原先的代码段接着执行。

事实上，能够通过调用门发起控制转移的指令还包括jmp，但只用在不需要从调用门返回的场合下，而且不改变当前特权级。也就是说，目标代码是在当前特权级上执行。

通过调用门进行控制转移的特权级检查，既要在转移前进行，而且，还要在控制返回时进行。完整的特权级检查过程将在本章的后面进一步说明。

检测点14.2

1． 通过调用门转移控制时，CPL、RPL 和目标代码段描述符的DPL 必须在数值上符合____________ 的条件； CPL 、RPL 和调用门描述符的DPL 必须在数值上符合____________的条件。即，只能通过调用门将控制转移到与当前特权级相同或者更高的代码段。

2． 调用门描述符只能安装在GDT 中吗？如果某调用门描述符的值是0x0000CC0000552FC0，那么，目标代码段的选择子是_____，段内偏移量为_____，描述符的特权级是_____，目标代码段的特权级是_____，要通过此门转移控制，CPL和RPL要符合什么条件才行？
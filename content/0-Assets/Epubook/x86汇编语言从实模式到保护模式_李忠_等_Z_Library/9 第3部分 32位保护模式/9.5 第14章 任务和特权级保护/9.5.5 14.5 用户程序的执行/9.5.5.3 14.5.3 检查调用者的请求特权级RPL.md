### 14.5.3　检查调用者的请求特权级RPL

在本章的最后，我们回过头来聊一聊与请求特权级RPL 有关的问题。通过这个话题的深入，你会更进一步了解处理器引入RPL 的原因和意义。

为了访问一个段，首先需要将段选择子代入段寄存器，这也是处理器进行特权级检查的大好机会：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00643.jpeg)

在绝大多数情况下，请求访问一个段的程序也是段选择子的提供者。就是说，当前特权级和请求特权级是相同的，即，RPL＝CPL。

一般来说，用户程序的特权级别很低，而且不能执行I/O 操作。假设操作系统提供了一个例程，可以从用户程序那里接受三个参数：逻辑扇区号、数据段选择子和段内偏移量，然后读硬盘，并把数据传送到用户程序的缓冲区内。为了使用户程序可以调用此例程，操作系统把它定义成调用门。

一般来说，用户程序会提供一个RPL 为3 的段选择子给操作系统例程。通过调用门实施控制转移后，当前特权级CPL 变成0，实际的请求者是用户程序，选择子的请求特权级RPL 为3，要访问的段属于用户程序，其描述符的DPL 为3，在数值上符合CPL≤DPL，并且RPL≤DPL 的条件，可以正常执行。

人类的可恶之处无孔不入，总爱钻空子。想象一下，用户程序的编写者通过钻研，知道了内核数据段的选择子，而且希望用这个选择子访问内核数据段。当然，他不可能在用户程序里访问内核数据段，因为那个数据段的DPL 为0，而用户程序工作时的当前特权级为3，处理器会很机警地把来访者拒之门外。

但是，他可以借助于刚才那个调用门。特别是，他提供的是一个RPL 为0 的选择子，而且该选择子指向操作系统的段描述符。此时，当前特权级CPL 为0，请求特权级RPL 为0，目标数据段描述符的DPL 为0，同样符合在数值上符合CPL≤DPL，并且RPL≤DPL 的条件，并且允许向内核数据段写入扇区数据，他得逞了！

我知道，有人会说，通过调用门进入内核例程时，用户程序的代码段选择子就作为返回地址压在栈中，代码段选择子的低2 位就是用户程序的特权级。因此，可以改造处理器固件，使它能够访问栈，用这个特权级来进行特权级检查。

但是，有这种认识的朋友们忘了，处理器的智商很低，它不可能知道谁是真正的请求者。你当然可以通过分析程序的行为来区分它们，但处理器不能。因此，当指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00644.jpeg)

或者

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00645.jpeg)

执行时，AX 或者CX 寄存器中的选择子可能是内核自己提供的，也可能来自于恶意的用户程序，是不是合法，这两种情况要区别对待，不能一棍子打死。所以，这已经超出了处理器的能力和职权范围。

怎么办？

还记得在本章的前面，在讨论RPL 时，我是怎么说的？我说的是，RPL 只是在原来的基础上多增加了一种检查机制，并把如何能够通过这种检查的自由裁量权交给软件（的编写者）。

引入请求特权级RPL 的原因是处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁。但是，引入RPL 本身并不能完全解决这个问题，这只是处理器和操作系统之间的一种协议，处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL；内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符，因为这是处理器无能为力的。

因此，在引入RPL 这件事上，处理器的潜台词是，仅依靠现有的CPL 和DPL，无法解决由请求者不同而带来的安全隐患。那么，好吧，再增加一道门卫，但前提是，操作系统只将通行证发放给正确的人。

为了帮助内核或者操作系统核查请求者的身份，并提供正确的RPL 值，处理器提供了arpl 指令。arpl 指令的作用是调整段选择子RPL 字段的值（Adjust RPL Field of Segment Selector），其格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00646.jpeg)

该指令比较两个段选择子的RPL 字段，目的操作数可以是包含了16 位段选择子的通用寄存器，或者指向一个16 位单元的内存地址，该字单元里存放的是段选择子；源操作数只能是包含了段选择子的16 位通用寄存器。

该指令执行时，处理器检查目的操作数的RPL 字段，如果它在数值上小于源操作数的RPL 字段，则设置ZF 标志，并增加目的操作数RPL 字段的值，使之和源操作数RPL 字段的值相同。否则，ZF 标志清零，而且除此之外什么也不会发生。

arpl 是典型的操作系统指令，它通常用于调整应用程序传递给操作系统的段选择子，使其RPL 字段的值和应用程序的特权级相匹配。在这种情况下，传递给操作系统的段选择子是作为目的操作数出现的；而应用程序的段选择子是作为源操作数出现的（可以从栈中取得）。arpl 也可以在应用程序中使用。

这样，为了防止恶意的数据访问，操作系统应该从当前栈中取得用户程序的代码段选择子（调用者代码段寄存器CS 的内容）作为源操作数，并把作为参数传递进来的数据段选择子作为目的操作数，来执行arpl 指令，把数据段选择子的请求特权级RPL 调整（恢复）到调用者的特权级别上。

一旦调整了请求特权级，那么，当前特权级CPL 为0，请求特权级RPL 为3，数据段描述符特权级DPL 为0，数值上并不符合CPL≤DPL，并且RPL≤DPL 的条件，禁止访问，并引发处理器异常中断。

引入RPL 检查机制和arpl 指令，主要是防止对段的不安全访问，不管是恶意的，还是因为编程疏漏而引起的。不管怎么说，一旦引入了RPL 检查机制，它就会处处起作用，同时也就成了编写程序时不得不考虑和妥善处理的问题。
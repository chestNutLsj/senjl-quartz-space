### 14.5.2　进入3 特权级的用户程序的执行

接着回到代码清单14-1 中。

任务寄存器TR 总是指向当前任务的任务状态段（TSS），而LDTR 寄存器也总是指向当前任务的LDT。TSS 是任务的主要标志，因此要使TR 寄存器指向任务；而使用LDTR 的原因是可以在任务执行期间加速段的访问。

在多任务环境中，随着任务的切换，每当一个任务开始运行时（成为前台活动任务），TR 和LDT 寄存器的内容都会更新，以指向新的当前任务。

现在的问题是，我们只有一个任务，而且是个3 特权级的任务，不能用任务切换的方法使它开始运行。这个问题可以表述为：如何从任务的0 特权级全局空间转移到它自己的3 特权级空间正常执行？

答案是先确立身份，即，使TR 和LDTR 寄存器指向这个任务，然后假装从调用门返回。和当前任务有关的信息都在它的任务控制块（TCB）中。因此，第832、833 行，先令段寄存器DS指向4GB 的内存段。

第851、852 行，加载任务寄存器TR 和局部描述符表寄存器（LDTR）。

如图14-23 所示，TR 和LDTR 寄存器都包括16 位的选择器部分，以及的描述符高速缓存器部分。选择器部分的内容是TR 和LDT 描述符的选择子；描述符高速缓存器部分的内容则指向当前任务的TSS 和LDT，以加速这两个段（表）的访问。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00636.jpeg)

图14-23　LDTR 和TR 寄存器

加载任务寄存器TR 需要使用ltr 指令。这条指令的格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00637.jpeg)

这条指令的操作数可以是16 位通用寄存器，也可以是指向一个16 位单元的内存地址。但不管是寄存器还是内存单元，其内容都是16 位的TSS 选择子。

在将TSS 选择子加载到TR 寄存器之后，处理器用该选择子访问GDT 中对应的TSS 描述符，将段界限和段基地址加载到任务寄存器TR 的描述符高速缓存器部分。同时，处理器将该TSS 描述符中的B 位置“1”，也就是标志为“忙”，但并不执行任务切换。

该指令不影响EFLAGS 寄存器的任何标志位，但属于只能在0 特权级下执行的特权指令。

加载局部描述符表寄存器（LDTR）使用的是lldt 指令，其格式和ltr 是一样的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00638.jpeg)

其操作数也和ltr 指令一样，但是，指向的是16 位LDT 选择子。ltr 和lldt 指令执行时，处理器首先要检查描述符的有效性，包括审查它是不是TSS 或者LDT 描述符。在将LDT 选择子加载到LDTR 寄存器之后，处理器用该选择子访问GDT 中对应的LDT 描述符，将段界限和段基地址加载到LDTR 的描述符高速缓存器部分。CS、SS、DS、ES、FS 和GS 寄存器的当前内容不受该指令的影响，包括TSS 中的LDT 选择子字段。

如果执行这条指令时，代入LTR 选择器的选择子，其高14 位是全零，LDTR 寄存器的内容被标记为无效，而该指令的执行也将不声不响地结束（即不会引发异常中断）。当然，后续那些引用LDT 的指令都将引发处理器异常中断（对描述符进行校验的指令除外），例如，将一个指向LDT的段选择子代入段寄存器。

最后，如图14-24 所示，这是一个任务的全景图，给出了与一个任务相关的各个组成部分。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00639.jpeg)

图14-24　与任务相关的各部分逻辑关系示意图

注意了，现在，局部描述符表（LDT）已经生效，可以通过它访问用户程序的私有内存段了。

第854、855 行，访问任务的TCB，从中取出用户程序头部段选择子，并传送到段寄存器DS。该选择子RPL 字段的值为3，即，请求特权级为3；TI 位是“1”，指向任务自己的LDT。这两条指令执行后，段寄存器DS 就指向用户程序头部段。

第858～862 行，从用户程序头部内取出栈段选择子和栈指针，以及代码段选择子和入口点，并将它们顺序压入当前的0 特权级栈中。这部分内容要结合第13 章的用户程序头部来分析（代码清单13-3）。

第864 行，执行一个远返回指令retf，假装从调用门返回。于是控制转移到用户程序的3 特权级代码开始执行。注意，这里所用的0 特权级栈并非是来自于TSS。不过，处理器不会在意这个。下次，从3 特权级的段再次来到0 特权级执行时，就会用到TSS 中的0 特权级栈了。

现在回到上一章，看代码清单13-3。

用户程序现在是工作在它的局部空间里。它可以通过调用门请求系统服务来显示字符串，或者读取硬盘数据，这都没有问题。这些指令可以再次加深我们对调用门的理解，请读者自行分析。

唯一的问题是，当它最后用jmp far 指令将控制权返回到内核时，可能行不通了。这条指令是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00640.jpeg)

这确实是一个调用门。而且，通过jmp far 指令使用调用门也没有任何问题。问题在于，当控制转移到内核时，当前特权级没有变化，还是3，因为使用jmp far 指令通过调用门转移控制是不会改变当前特权级别的。

再回到本章，看代码清单14-1。

返回点是在第866 行。因为当前特权级是3，以这样低的特权级别来执行第867、868 行的指令，一定会引发处理器异常中断:

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00641.jpeg)

在这里，当前特权级CPL 为3，选择子core_data_seg_sel 的请求特权级RPL 为0，目标代码段的特权级DPL 为0，因为当前特权级CPL 低于目标代码段的DPL，就算请求特权级RPL 和目标代码段的DPL 相同，也不可能通过特权级检查。

异常和异常中断的处理将在第17 章讲述，我们现在还没有任何接管和处理异常中断的机制，所以，这个异常可能不会明显地被你观察到。

还需要特别提醒的是，进入3 特权级的用户程序局部空间时，任务的I/O 特权级IOPL 是0，任务没有I/O 操作的特权。

最后，将本章的源代码编译，并从第1 个逻辑扇区开始，将编译后的文件写入虚拟硬盘。如果你用的虚拟硬盘文件还是第13 章用过的那个，这就是唯一要做的工作；否则，还要写入第13章的主引导程序、用户程序和数据文件。具体方法参见上一章。最后，启动虚拟机，应该能观察到如图14-25 所示的画面。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00642.jpeg)

图14-25　本章程序的运行结果
### 14.5.1　通过调用门转移控制的完整过程

现在我们转到代码清单14-1 的第845、846 行，在调用过程load_relocate_program 创建任务之后，显示一条成功的消息。

接下来的工作是将控制转到用户程序那里。我们创建的是一个3 特权级的任务，所以这是一个从0 特权级到3 特权级的控制转移。或者，换一种更体面的说法，是从任务自己的0 特权级全局空间转移到3 特权级局部空间执行。通常情况下，这既不允许，也不太可能。

办法总还是有的，只不过稍微有一点曲折，那就是假装从调用门返回。先来看看完整的调用门控制转移和返回过程是怎样的。

首先，通过调用门实施控制转移，可以使用jmp far 和call far 指令。指令执行时，描述符选择子必须指向调用门，32 位偏移量被忽略。但，无论采用哪种控制转移指令，都会使用表14-1 的特权检查规则。注意，表中的比较关系都是数值上的。

表14-1　调用门的特权级检查规则

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00628.jpeg)

从表15-1 中可以看出，当使用jmp far 指令通过调用门转移控制时，要求当前特权级和目标代码段的特权级相同。原因是用jmp far 指令通过调用门转移控制时，不改变当前特权级CPL。

相反，使用call far 指令可以通过调用门将控制转移到较高特权级别的代码段。之所以说“可以”，是因为，如果目标代码段是依从的，则和jmp far 指令一样，不改变当前特权级别；否则，如果目标代码段是非依从的，则在目标代码段的特权级别上执行。

其次，当使用call far 指令通过调用门转移控制时，如果改变了当前的特权级别，则必须切换栈。即，从当前任务的固有栈切换到与目标代码段特权级相同的栈上。栈的切换是由处理器固件自动进行的。

当前栈是由段寄存器SS 和栈指针寄存器ESP 的当前内容指示的；要切换到的新栈位于当前任务的TSS 中，处理器知道如何找到它。在栈切换前，处理器要检查新栈是否有足够的空间完成本次控制转移。栈切换过程如下：

① 使用目标代码段的DPL（也就是新的CPL）到当前任务的TSS 中选择一个栈，包括栈段选择子和栈指针。

② 从TSS 中读取所选择的段选择子和栈指针，并用该选择子读取栈段描述符。在此期间，任何违反段界限检查的行为都将引发处理器异常中断（无效TSS）。

③ 检查栈段描述符的特权级和类型，并可能引发处理器异常中断（无效TSS）。

④ 临时保存当前栈段寄存器SS 和栈指针ESP 的内容。

⑤ 把新的栈段选择子和栈指针代入SS 和ESP 寄存器，切换到新栈。

⑥ 将刚才临时保存的SS 和ESP 的内容压入当前栈，如图14-21 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00629.jpeg)

图14-21　特权级间控制转移时的栈切换

⑦ 依据调用门描述符“参数个数”字段的指示，从旧栈中将所有参数都复制到新栈中。如果参数个数为0，不复制参数，如图14-21 所示。

⑧ 将当前段寄存器CS 和指令指针寄存器EIP 的内容压入新栈，如图14-21 所示。通过调用门实施的控制转移一定是远转移，所以要压入CS 和EIP。

⑨ 从调用门描述符中依次将目标代码段选择子和段内偏移传送到CS 和EIP 寄存器，开始执行被调用过程。

相反，如果没有改变特权级别，则不切换栈，继续使用调用者的当前栈，只在原来的基础上压入当前段寄存器CS 和指令指针寄存器EIP 的内容，如图14-22 所示。

再次，如果通过调用门的控制转移是使用jmp far 指令发起的，结果就是肉包子打狗，有去无回。而且，没有特权级的变化，也不需要切换栈。相反，如果通过调用门的控制转移是使用call far指令发起的，那么，可以使用远返回指令retf 把控制返回到调用者。

从同一特权级返回时，处理器将从栈中弹出调用者的代码段选择子和指令指针。尽管它们通常是有效的，但是，为了安全起见，处理器依然会进行特权级检查。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00630.jpeg)

图14-22　相同特权级控制转移前后的栈变化

要求特权级变化的远返回，只能返回到较低的特权级别上。控制返回的全部过程如下：

① 检查栈中保存的CS 寄存器的内容，根据其RPL 字段决定返回时是否需要改变特权级别。

② 从当前栈中读取CS 和EIP 寄存器的内容，并针对代码段描述符和代码段选择子的RPL 字段实施特权级检查。

③ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过栈中的参数部分。最后的结果是ESP 寄存器指向调用者SS 和ESP 的压栈值。注意，retf 指令的字节计数值必须等于调用门中的参数个数乘以参数长度。

④ 如果返回时需要改变特权级，从栈中将SS 和ESP 的压栈值代入段寄存器SS 和指令指针寄存器ESP，切换到调用者的栈。在此期间，一旦检测到有任何界限违例的情况都将引发处理器异常中断。

⑤ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过调用者栈中的参数部分。最后的结果是调用者的栈恢复到平衡位置。

⑥ 如果返回时需要改变特权级，检查DS、ES、FS 和GS 寄存器的内容，根据它们找到相应的段描述符。要是有任何一个段描述符的DPL 高于调用者的特权级（返回后的新CPL），即，在数值上，那么，处理器将把数值0 传送到该段寄存器。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00631.jpeg)

那么，这是为什么呢？

特权级检查不是在实际访问内存时进行的，而是在将选择子代入段寄存器时进行的。下面这两条指令可以非常清楚地说明这一点：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00632.jpeg)

要想访问内存中的数据，必须先指定一个段。即，将选择子代入某个段寄存器。正是因为如此，处理器只在将选择子代入段寄存器时进行一次特权级检查，而在此之后的普通内存访问时，不进行特权级检查。处理器的意思是，只要你能进入大门，就证明你的确是这里的主人，随后你干什么它都不会干涉。

现在做一个假设，假设一个3 特权级的应用程序通过调用门请求0 特权级的操作系统服务。在进入操作系统例程后，当前特权级CPL 变成0。在该例程内，操作系统可能会访问自己的0 特权级数据段以进行某些内部操作。当然，它也必须先执行将选择子代入段寄存器的操作：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00633.jpeg)

按道理，安全的做法是先将旧的DS 值压栈，用完后再出栈。像这样：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00634.jpeg)

但是，如果操作系统例程没有这么做，一定有它的道理，而处理器也无权干涉。唯一可以预料的是，当控制返回到应用程序时，段寄存器DS 依然指向操作系统数据段。因此，应用程序就可以直接在3 特权级下访问操作系统的数据段：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00635.jpeg)

这是因为，特权级检查只在引用一个段的时候进行。即，只在将选择子传送到段寄存器的时候进行。只要通过了这一关，后面那些使用这个段寄存器的内存访问就都是合法的。

为了解决这个问题，在执行retf 指令时，要检查数据段寄存器，根据它们找到相应的段描述符。要是有任何一个段描述符的DPL 高于调用者的特权级（返回后的新CPL），那么，处理器将把数值0 传送到该段寄存器。使用这样的段寄存器访问内存，会引发处理器异常中断。

特别需要注意的是，任务状态段（TSS）中的SS0、ESP0、SS1、ESP1、SS2、ESP2 域是静态的，除非软件进行修改，否则处理器从来不会改变它们。举个例子，当处理器通过调用门进入0特权级的代码段时，会切换到0 特权级栈。返回时，并不把0 特权级栈指针的内容更新到TSS 中的ESP0 域。下次再次通过调用门进入0 特权级代码段时，使用的依然是ESP0 的静态值，从来不会改变。这就是说，如果你希望通过0 特权级栈返回数据，就必须自己来做这件事，比如，在返回到低特权级别的代码段之前，手工改写TSS 中的ESP0 域。
### 14.1.2　全局空间和局部空间

现代的计算机，如果没有操作系统支持，它也可以在编程爱好者的操作下运行得很好，但恐怕不太可能像比尔·盖茨所认为的那样，每个桌子上一台。

在多任务系统中，操作系统肩负着任务的创建，以及在任务之间调度和切换的工作。不过，更为繁重和基础的工作是对处理器、设备及存储器的管理。

从程序编写者的角度看，操作系统是他们可以信赖的朋友。首先，他们不必关心自己的程序是如何加载到内存并开始运行的，操作系统自然会处理好这些事情；其次，对设备的访问涉及大量的硬件细节，而且极为烦琐，操作系统能够肩负起设备管理的职责，并提供大量的例程和数据供应用程序调用。使用操作系统提供的这些服务，可以极大地简化程序的编写，并能够在访问设备时消除潜在的竞争和冲突。

比如说，当中断发生时，不可能由某个任务来进行处理，而只能由操作系统来提供中断处理过程，并采取适当的操作，以进行一些和所有任务都有关系的全局性管理工作，如空闲内存的查找和分配、回收已终止任务的内存空间、设备访问的排队和调度，等等。

这就是说，如图14-3 所示，每个任务实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00566.jpeg)

图14-3　任务的全局空间和局部空间

任务实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。

地址空间的访问是依靠分段机制来进行的。具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。

从程序员的角度来看，任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供的服务时，转入全局空间执行。

我们知道，段寄存器（CS、SS、DS、ES、FS 和GS）由16 位的选择器和不可见的描述符高速缓存器组成。选择器的位2 是表指示器TI，若TI＝0，指向GDT，表示当前正在访问的段描述符位于GDT 中；否则指向LDT，表示当前正在访问的段描述符位于LDT 中。选择器的高13 位指定描述符的索引号，也就是描述符在描述符表中的编号，从0 开始。

每个段描述符都对应着一个内存段。很显然，在一个任务的全局地址空间上，可以划分出213个段，也就是8192 个段。因为GDT 的0 号描述符不能使用，故实际上是8191 个段，但这无关紧要。又因为段内偏移是32 位的，段的长度最大的4GB，因此，一个任务的全局地址空间，其总大小为213×232＝245 字节，即32TB。

同样的道理，局部描述符表LDT 可以定义213 个，也就是8192 个描述符，每个段的最大长度也是4GB，故，一个任务的局部地址空间为213×232＝245 字节，同样是32TB。

这样一来，每个任务的总地址空间为245＋245＝245×2＝245×21＝246 字节，即64TB。在一个只有32 根地址线的处理器上，无论如何也不可能提供这样巨大的存储空间，但是，不要紧张，这只是虚假的，或者说虚拟的地址空间。操作系统允许程序的编写者使用该地址空间来写程序，即，使用虚拟地址或者逻辑地址来访问内存，就像他真的拥有这么巨大的地址空间一样。

上面一段话可以这样理解：编译器不考虑处理器可寻址空间的大小，也不考虑物理内存的大小，它只是负责编译程序。当程序编译时，编译器允许生成非常巨大的程序。但是，当程序超出了物理内存的大小时，或者操作系统无法分配这么大的物理内存空间时，怎么办呢？

同一块物理内存，可以让多个任务，或者每个任务的不同段来使用。当执行或者访问一个新的段时，如果它不在物理内存中，而且也没有空闲的物理内存空间来加载它，那么，操作系统将挑出一个暂时用不到的段，把它换出到磁盘中，并把那个腾出来的空间分配给马上要访问的段，并修改段的描述符，使之指向这段内存空间。下一次，当被换出的那个段马上又要用到时，再按相同的办法换回到物理内存。所有这一切，任务（如果它有思维的话）和程序的编写者是不必关心的，这就是虚拟内存管理的一般方法。
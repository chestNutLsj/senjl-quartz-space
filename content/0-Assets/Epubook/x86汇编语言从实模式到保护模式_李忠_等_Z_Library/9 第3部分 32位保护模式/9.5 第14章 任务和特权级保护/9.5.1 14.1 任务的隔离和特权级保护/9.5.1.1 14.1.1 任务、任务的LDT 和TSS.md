### 14.1.1　任务、任务的LDT 和TSS

程序（Program）是记录在载体上的指令和数据，总是为了完成某个特定的工作，其正在执行中的一个副本，叫做任务（Task）。这句话的意思是说，如果一个程序有多个副本正在内存中运行，那么，它对应着多个任务，每一个副本都是一个任务。在上一章里，用户程序就是任务，而内核程序就是操作系统的缩影。

一直以来，我们把所有的段描述符都放在GDT 中，而不管它属于内核还是用户程序。如图14-1 所示，为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，称为局部描述符表LDT（Local Descriptor Table），并且把专属于自己的那些段放到LDT 中。

和GDT 一样，LDT 也是用来存放描述符的。不同之处在于，LDT 只属于某个任务。或者说，每个任务都有自己的LDT，每个任务私有的段，都应当在LDT 中进行描述。另外，LDT 的第1 个描述符，也就是0 号槽位，也是有效的、可以使用的。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00562.jpeg)

图14-1　多任务系统的组成示意图

为了追踪全局描述符表（GDT），访问它内部的描述符，处理器使用了GDTR 寄存器。这是可以理解的，正如其名称所暗示的那样，全局描述符表（GDT）是全局性的，为所有任务服务，是它们所共有的，我们只需要一个全局描述符表（GDT）就够了。

和GDT 不同，局部描述符表（LDT）的数量则不止一个，具体有多少，视任务的多少而定。为了追踪和访问这些LDT，处理器使用了局部描述符表寄存器（LDT Register：LDTR）。

在一个多任务的系统中，会有很多任务在轮流执行，正在执行中的那个任务，称为当前任务（Current Task）。因为LDTR 寄存器只有一个，所以，它只用于指向当前任务的LDT。每当发生任务切换时，LDTR 的内容被更新，以指向新任务的LDT。和GDTR 一样，LDTR 包含了32位线性基地址字段和16 位段界限字段，以指示当前LDT 的位置和大小。

我们知道，在访问内存之前需要先指定一个段，方法是向段寄存器的选择器传送一个段选择子，这称为“引用一个段”，像这样：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00563.jpeg)

回到第11 章，看一下图11-10，段选择子的位2 是表指示器（Table Indicator：TI），若TI＝0，表示从GDT 中加载描述符；TI＝1，表示从当前任务的LDT 中加载描述符。

很显然，0x0008 的二进制形式为0000 0000 0000 1000，其TI 位是“0”，所以，处理器将访问GDT，从1 号槽位取得描述符，并传送到段寄存器DS 的描述符高速缓存器。

再看这个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00564.jpeg)

0x005C 的二进制形式为0000 0000 0101 1100，这很容易看出TI 位是“1”，索引号为11（十进制）。处理器执行以上指令时，必然会访问当前任务的LDT（该LDT 在内存中的位置由LDTR指定），从它的11 号槽位取出描述符，并传送到段寄存器DS 的描述符高速缓存器中去。

很显然，因为段选择子是16 位的，而且只有高13 位被用做索引号来访问GDT 或者LDT，所以，每个LDT 所能容纳的描述符个数为213，即8192 个。或者换句话说，每个LDT 只能定义8192 个段。又因为每个描述符的长度是8 字节，LDT 的长度最大为64KB。

在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，或者说是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。否则的话，等下次该任务又恢复执行时，一切都会变得茫然而毫无头绪。

为了保存任务的状态，并在下次重新执行时恢复它们，每个任务都应当用一个额外的内存区域保存相关信息，这叫做任务状态段（Task State Segment：TSS）。如图14-2 所示，任务状态段TSS 具有固定的格式，最小尺寸是104 字节，图中所标注的偏移量是十进制的。处理器固件能够识别TSS 中的每个元素，并在任务切换的时候读取其中的信息，具体的细节将在后面讲述。

和LDT 一样，处理器用TR 寄存器来指向当前任务的TSS。和GDTR、LDTR 一样，TR 寄存器在处理器中也只有一个。当任务切换发生的时候，TR 寄存器的内容也会跟着指向新任务的TSS。这个过程是这样的：首先，处理器将当前任务的现场信息保存到由TR 寄存器指向的TSS；然后，再使TR 寄存器指向新任务的TSS，并从新任务的TSS 中恢复现场。

比较奇怪的是，为什么这个寄存器叫TR，而不是TSSR。原因很简单，TSS 是一个任务存在的标志，用于区别一个任务和其他任务。所以，这个寄存器叫做任务寄存器（Task Register：TR）。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00565.jpeg)

图14-2　32 位的任务状态段
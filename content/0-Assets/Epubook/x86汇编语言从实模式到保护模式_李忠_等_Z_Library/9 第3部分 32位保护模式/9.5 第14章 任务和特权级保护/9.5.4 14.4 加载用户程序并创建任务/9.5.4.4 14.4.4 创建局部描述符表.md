### 14.4.4　创建局部描述符表

用户程序已被加载到内存中，现在该是在LDT 中创建段描述符的时候了。

第521 行，从TCB 中取得用户程序在内存中的基地址。早在第478 行，我们就已经让ESI寄存器指向了TCB 的基地址。当然，TCB 的基地址位于栈中，也可以从栈中取得。

第524～528 行，因为用户程序头部的起始地址就是整个用户程序的起始地址，故将EDI 寄存器的内容传送到EAX 寄存器，作为过程sys_routine_seg_sel:make_seg_descriptor 的第一个参数，即段的起始地址。接着，从头部中取得用户程序头部段的长度，作为第二个参数传送到EBX 寄存器。因为段界限是段的长度减一，故还要将EBX 寄存器的内容减1。最后，作为第三个参数，在ECX 寄存器中置入段的属性。请参考段描述符的格式，可以知道，这是一个32 位的可读写数据段，字节粒度，尤其重要的是，其描述符特权级DPL 为3，即最低的特权级。这是可以理解的，谁也不愿意使自己的特权级为3，但这由不得你，谁让你落在操作系统的手上，由它来负责加载呢！

调用过程sys_routine_seg_sel:make_seg_descriptor 后，会在EDX:EAX 中返回64 位的段描述符。第531、532 行用于调用另一个过程fill_descriptor_in_ldt 把刚才创建的描述符安装到LDT 中。

fill_descriptor_in_ldt 是当前内核代码段的内部（近）过程，位于第421 行，用于在当前任务的LDT 中安装描述符。它需要传入两个参数，一个是要安装的描述符，由EDX:EAX 共同提供；另一个是当前任务控制块的基地址，由EBX 寄存器提供。它用这个地址来访问TCB 以获得LDT 的基地址和当前的大小（界限值），并在安装描述符后更新LDT 的界限值。

第425～428 行，执行例行的现场保护工作，将过程中用到的各个寄存器压栈保护。

第430～433 行，先使段寄存器DS 指向4GB 的内存段；然后，访问TCB，从中取出LDT 的基地址传送到EDI 寄存器。

新描述符的线性地址可以用LDT 的基地址加上LDT 的总字节数得到。第435～440 行，计算用于安装新描述符的线性地址，并把它安装到那里。在这里，ECX 寄存器有两个相关联的用途，一个是在第439 和440 行寻址内存，以安装描述符；另一个是在第436、437 行用于计算LDT 的大小，但只能使用其16 位的CX 部分。想想看，当第一次在LDT 中安装描述符时，LDT 的界限值是0xFFFF，加1 之后，总大小是0x0000，进位部分要丢弃。对CX 寄存器的操作不会影响到ECX 寄存器的高16 位。即使CX 寄存器产生了进位，进位也会丢弃，而决不会跑到ECX 寄存器的高16 位。注意以下指令执行结果的不同：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00606.jpeg)

和GDT 不同，LDT 的0 号槽位也是可用的。原因在于，其选择子的TI 位是“1”，所以不可能会有一个全零的选择子指向LDT。这就是说，一个指向LDT 的选择子代入段寄存器时，它不可能是因程序员粗心大意而未初始化的。

第442、443 行，将LDT 的总大小（字节数）在原来的基础上增加8 字节，再减去1，就是新的界限值。第445 行，将这个新的界限值更新到TCB 中。

第447～450 行，将描述符的界限值除以8，余数丢弃不管，所得的商就是当前新描述符的索引号。

第452～454 行，将CX 寄存器中的索引号逻辑左移3 次，并将TI 位置1，表示指向LDT，这就得到了当前描述符的选择子。

接着回到过程load_relocate_program 中。

过程fill_descriptor_in_ldt 在LDT 中安装描述符后，用CX 寄存器返回一个选择子。第534～536 行，用于将选择子的请求特权级RPL 设置为3，登记到TCB，并回填到用户程序头部。在LDT 中安装的描述符，通常只由用户程序自己使用，即，在请求访问这些段时，请求者是用户程序自己。因此，其选择子的RPL 和用户程序的特权级始终一致。
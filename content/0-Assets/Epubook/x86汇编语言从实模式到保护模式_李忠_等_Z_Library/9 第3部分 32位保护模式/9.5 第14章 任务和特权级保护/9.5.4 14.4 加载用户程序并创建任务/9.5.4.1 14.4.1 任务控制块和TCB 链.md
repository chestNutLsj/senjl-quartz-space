### 14.4.1　任务控制块和TCB 链

继续讲解代码清单14-1。

第832、833 行是以传统的方式调用内核例程显示字符串。即使不通过调用门，特权检查也是照常进行的，而且更为严格。把控制从较低的特权级转移到较高的特权级，通过调用门尚有可能，但直接控制转移则在任何时候都是不允许的。当然，在这里，是从0 特权级的内核代码段进入同样是0 特权级的公共例程段，能够通过特权级检查。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00600.jpeg)

图14-12　任务控制块TCB 的结构

在内核初始化完成后，和第13 章一样，接下来的工作就是加载和重定位用户程序（ 应用程序），并移交控制权。按处理器的要求标准，要使一个程序成为“任务”，并且能够参与任务切换和调度，那不是简简单单就能行的，必须要有LDT 和TSS。而为了创建这两样东西，又需要更多的东西。所以，加载和执行用户程序的活儿，比起从前是麻烦了不少。不信？一会儿就要做这件事，到时候你就知道了。

加载程序并创建一个任务，需要用到很多数据，比如程序的大小、加载的位置，等等。当任务执行结束，还要依据这些信息来回收它所占用的内存空间（在本书中没有体现，但一个合格的操作系统必须实现该功能）。还有，多任务系统是多个任务同时运行的，特别是在一个单处理器（核）的系统中，为了在任务之间切换和轮转，必须能追踪到所有正在运行的任务，记录它们的状态，或者根据它们的当前状态来采取适当的操作（在本书的第16 章，将学习任务的切换和轮转技术）。

为了满足以上的要求，内核应当为每一个任务创建一个内存区域，来记录任务的信息和状态，称为任务控制块（Task Control Block，TCB）。任务控制块不是处理器的要求，是我们自己为了方便而发明的。如图14-12 所示，这是任务控制块的结构，很明显，这里有两种大小的方格，较窄的格子代表16位的数据宽度，即1 个字；而较宽的格式代表32 位的数据宽度，即2 个字。注意，不要纠结于表中的内容和细节，有个大概印象即可。

为了能够追踪到所有任务，应当把每个任务控制块TCB 串起来，形成一个链表（链表是一种数据结构，有一门计算机课程就叫做《数据结构》）。

代码清单14-1 的第414 行，声明了标号tcb_chain 并初始化为一个双字，初始的数值为零。实际上，它是一个指针，用来指向第一个任务的TCB 线性基地址。当它为零时，表示任务的数量为0，也就是没有任务。在创建了第一个任务后，应当把该任务的TCB 线性基地址填写到这里。

每个TCB 的第一个双字，也是一个双字长度的指针，用于指向下一个任务的TCB。如果该位置是零，表示后面没有任务，这是链上的最后一个任务；否则，它的数值就是下一个任务的TCB线性基地址。如图14-13 所示，所有任务都按照被创建的先后顺序链接在一起，从tcb_chain 开始，可以依次找到每一个任务。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00601.jpeg)

图14-13　任务控制块链

第836～838 行，用于分配创建TCB 所需要的内存空间，并将其挂在TCB 链上。如图14-12所示，当前版本的TCB 结构需要0x46 字节的内存空间。

将新TCB 追加到链表上的工作是由过程append_to_tcb_link 来完成的，位于代码清单14-1 的第735～772 行，属于内核代码段的内部（近）过程，图14-14 是它的整个流程图。

过程append_to_tcb_link 的工作思路是遍历整个链表，找到最后一个TCB，在它的TCB 指针域里填写新TCB 的首地址。它需要用ECX 作为传入的参数，ECX 的内容应当为新TCB 的线性地址。

这里有一个小小的麻烦。链首指针tcb_chain 是在内核数据段声明并初始化的，只能知道它在段内的偏移，而不知道它的线性地址，因此，只能通过内核数据段访问，而无法通过线性地址来访问；相反地，链上的每个TCB，其空间都是动态分配的，只能通过线性地址来访问。

因此，在将两个段寄存器和两个通用寄存器压栈保护之后，第742～745 行，我们令段寄存器DS 指向内核数据段以读写链首指针tcb_chain，而ES 指向整个4GB 内存空间，用于遍历和访问每一个TCB。

第747 行，要追加的TCB 一定是链表上最后一个TCB，故其用于指向下一个TCB 的指针域必须清零，以表明自己是链上最后一个TCB。每个TCB 的空间都是动态分配的，其首地址都是线性地址，只能用由段寄存器ES 所指向的4GB 段来访问。

第750～752 行，观察链首指针tcb_chain 是否为零。若为零，则表明整个链表为空，直接转移到第763 行的标号.notcb 处，在那里，直接将链首指针指向新的TCB，恢复现场后直接返回调用者。

第754～758 行，若链首指针不为零，表明链表非空，需要顺着整个链找到最后一个TCB。和链首指针tcb_chain 不同，每个TCB 需要用4GB 的段来访问，即使用段寄存器ES。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00602.jpeg)

图14-14　向TCB 链上追加任务控制块的流程图

首先，将链表中要访问的那个TCB 的线性地址传送到EDX 寄存器；然后，访问它的TCB 指针域，看它是否为零。如果不为零，表明它不是链中最后一个TCB，后面还有其他TCB，于是将控制转移到.searc，令EDX 寄存器指向下一个TCB，继续搜寻。

若为零，表明它就是链上最后一个TCB，第760 行，用ECX 的内容填写其TCB 指针域，让它指向新的TCB。完成后，第761 行，直接转移到标号.retpc 处，恢复现场并返回调用者。
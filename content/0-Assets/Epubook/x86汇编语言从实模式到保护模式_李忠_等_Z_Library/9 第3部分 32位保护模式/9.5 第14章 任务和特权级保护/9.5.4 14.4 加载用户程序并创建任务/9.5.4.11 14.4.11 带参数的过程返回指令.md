### 14.4.11　带参数的过程返回指令

至此，任务创建完毕，可以从过程load_relocate_program 返回了。

在过程返回之前，即，在执行ret 指令之前，需要恢复现场，也就是按相反的顺序将刚进入过程时压入栈的内容出栈。这是第727～730 行的工作。

如图14-20 所示，当执行ret 指令时，栈恢复到刚进入过程时的状态，即，只有返回地址和调用者传递给过程的参数。因为当初是采用32 位相对近调用进入过程load_relocate_program 的，故仅将EIP 压栈，没有压入段寄存器CS 的内容。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00622.jpeg)

图14-20　执行ret 指令时的栈状态

再来看，一旦ret 指令执行完毕，控制将返回到调用者，且栈中只剩下两个参数。按道理，这两个参数是由调用者压入的，应该再由调用者弹出即可：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00623.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00624.jpeg)

不过，最好的解决办法是在过程返回时，顺便弹出参数。这样做是可行的，过程的编写者最清楚栈中有几个参数。如果希望过程在返回时弹出参数，使ESP 寄存器指向调用过程前的栈位置（使栈平衡），可以使用带操作数的过程返回指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00625.jpeg)

这两条指令都允许16 位的立即数作为操作数，不同之处仅仅在于，前者是近返回，后者是远返回。立即数是16 位的，而且一般总是偶数，原因是栈操作总是以字或者双字进行，它指示在将控制返回到调用者之前，应当从栈中弹出多少字节的数据。

因此，第732 行，当该指令执行时，除了将控制返回到过程的调用者之外，还要调整栈的指针，即

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00626.jpeg)

之所以指令的操作数是8，是因为要弹出2 个双字。

这条指令给高级语言带来的好处是增加了它们的复杂性。比如这样一个C 语言函数：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00627.jpeg)

因为一般是通过栈传递参数，所以，哪个参数先入栈，哪个后入栈，栈平衡的事情由调用者来做，还是由过程来做，就需要一个标准，即所谓的调用转换规则。特别是在开发一些大软件时，需要用不同的高级语言来开发各个独立的、但能够协同工作的模块，尤其需要注意这个问题。

一个典型的调用转换标准是stdcall，它规定，参数从右往左进栈，且由过程在返回前出栈。
### 14.4.2　使用栈传递过程参数

下面的工作是加载和重定位用户程序，依然是在过程load_relocate_program 中进行。该过程需要传入两个参数，分别是用户程序的起始逻辑扇区号，以及它的任务控制块TCB 线性地址。和上一章不同的是，参数不是用寄存器传入的，而是采用栈。事实上，这是更为流行和标准的做法。原因很简单，寄存器数量有限，况且还要在过程内部使用，当传入的参数很多时，栈是最好的选择。

第840～843 行，先以双字的长度将立即数50 压入当前栈，这是用户程序的起始逻辑扇区号。在第10 章里，我们已经知道push 指令可以压入立即数。因此，在这里，压入到栈中的内容将是双字0x00000032（十进制数50）。接着，再压入当前任务控制块TCB 的32 位线性地址。最后，进入过程load_relocate_program 内部执行。该过程位于第464 行，是（当前）内核代码段的内部过程。

第468～473 行，先做一些保护现场的工作，然后将栈指针寄存器ESP 的内容复制到EBP 寄存器，以访问栈中的参数。栈的访问有两种，一种是隐式的，由处理器在执行诸如push、pop、call、ret 等指令时自动进行。隐式地访问栈需要使用指令指针寄存器ESP。另一种访问栈的方式不依赖于先进后出机制，而是把栈看成是一般的数据段，直接访问其中的任何内容。在这种方式下，需要使用栈基址寄存器EBP。这里有个例子，比如，从栈中读取一个双字，该数据在栈中的偏移量是由EBP 寄存器指向的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00603.jpeg)

在32 位模式下，处理器执行这条指令时，用段寄存器SS 描述符高速缓存器中的32 位基地址，加上EBP 寄存器提供的32 位偏移量，形成32 位线性地址，访问内存取得一个双字，传送到EDX 寄存器。很显然，用EBP 寄存器来寻址时，不需要使用段超越前缀“SS:”，因为EBP 寄存器出现在指令中的地址部分时，默认使用段寄存器SS。

如图14-15 所示，这是用ESP 寄存器的内容初始化EBP 后，栈的状态。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00604.jpeg)

图14-15　执行mov ebp,esp 指令后的栈状态

当前的栈顶位置是SS:EBP，指向一个双字，是段寄存器ES 的内容，因为最近一次的压栈操作是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00605.jpeg)

在32 位模式下，访问栈用的是栈指针寄存器ESP，而且，每次栈操作的默认操作数大小是双字。处理器在执行压栈指令时，如果发现指令的操作数是段寄存器（CS、SS、DS、ES、FS、GS），那么，将先执行一个内部的零扩展操作，将段寄存器中的16 位值扩展成32 位，高16 位是全零，然后再执行压栈操作。当然，出栈指令pop 会执行相反的操作，将32 位的值截短为16位，并传送到相应的段寄存器。

相应地，SS∶EBP＋4 的位置是段寄存器DS 的压栈值。因为栈是向下推进的，故较早压入的内容反而位于高地址方向，回溯它们需要增加EBP 的值。

从SS∶EBP＋8 的位置开始，是pushad 指令压入的8 个双字，其中就包括EBP 在压栈时的原始内容。

再往上，是调用者的返回地址。因为load_relocate_program 是一个内部过程，是用32 位相对近调用（第843 行）进入的，故只压入了EIP 的内容，而没有压入段寄存器CS 的内容。

好了，现在终于到了我们感兴趣的地方。当初调用load_relocate_program 过程的时候，压入了两个参数，分别是任务控制块TCB 的线性地址，以及用户程序的起始扇区号。从图15-15 中可以看出，TCB 线性地址是栈中的第11 个双字（从0 开始算起）。也正是因为如此，TCB 线性地址在栈中的位置是SS∶EBP＋44。

同样的道理，用户程序起始逻辑扇区号在栈中的位置是SS∶EBP＋48。记好这两个数的位置，一会儿我们就要多次从栈中访问它们。
### 14.4.8　任务状态段TSS 的格式

到目前为止，任务的所有内存段都已创建完毕，除了任务状态段（TSS）。现在就来创建TSS。在此之前，先来全面了解一下TSS 的各个组成部分。

如图14-2 所示，TSS 内偏移0 处是前一个任务的TSS 描述符选择子。和LDT 一样，必须在全局描述符表（GDT）中创建每个TSS 的描述符。当系统中有多个任务同时存在时，可以从一个任务切换到另一个任务执行，此时称任务是嵌套的。被嵌套的任务用这个指针指向前一个任务，即嵌套它的那个任务，当控制返回前一个任务时，处理器需要这个指针来识别前一个任务。创建TSS 时，可以为0。

SS0、SS1 和SS2 分别是0、1 和2 特权级的栈段选择子，ESP0、ESP1 和ESP2 分别是0、1和2 特权级栈的栈顶指针。这些内容应当由任务的创建者填写，且属于填写后一般不变的静态部分，当通过门进行特权级之间的控制转移时，处理器用这些信息来切换栈。

CR3 和分页有关，有关分页的知识将在第16 章讲述。此处一般由任务的创建者填写，如果没有使用分页，可以为0。

偏移为32～92 的区域是处理器各个寄存器的快照部分，用于在进行任务切换时，保存处理器的状态以便将来恢复现场。在一个多任务环境中，每次创建一个任务时，操作系统或者内核至少要填写EIP、EFLAGS、ESP、CS、SS、DS、ES、FS 和GS，当该任务第一次获得执行时，处理器从这里加载初始执行环境，并从CS:EIP 处开始执行任务的第一条指令。在此之后的任务运行期间，该区域的内容由处理器固件进行更改。 在本章中，只有一个任务，而且自进入保护模式时就开始运行了，只不过一开始是在0 特权级的全局空间执行。所以，这部分内容不需要填写。

LDT 段选择子是当前任务的LDT 描述符选择子。由内核或者操作系统填写，以指向当前任务的LDT。该信息由处理器在任务切换时使用，在任务运行期间保持不变。

T 位用于软件调试。在多任务的环境中，如果T 位是“1”，每次切换到该任务时，将引发一个调试异常中断。这是有益的，调试程序可以接管该中断以显示任务的状态，并执行一些调试操作。现在只需要将这一位清零即可。

I/O 映射基地址用于决定当前任务是否可以访问特定的硬件端口，对它的解释说来话长。

是这样的，我们知道，特权指令是只有0 特权级的程序才可以执行的指令，执行这些指令会影响整个机器的状态。

现有的特权指令也许是处理器的设计者精心挑选的，因为即使较低特权级的程序不使用它们，这些程序也能运行得很好，简直是非常好。不过，另外一些候选的指令就没那么幸运了，尽管它们也适合作为特权指令，但其他特权级的程序同样需要它们。

一个典型的例子是硬件端口的输入输出指令in 和out，它们应该对特权级别为1 的程序开放，因为设备驱动程序就工作在这个特权级别。不过，这样做依然是不合理的，因为即使是特权级为3的程序，在需要快速反应的场合，也需要直接访问某些硬件端口。所以，如果需要，它们也可以向2、3 特权级的程序开放。

处理器可以访问65536 个硬件端口。如果只对应用程序开放那些它们需要的端口，而禁止它们访问另一些敏感的端口，操作系统肯定会对此持欢迎态度，因为这有利于设备的统一管理，同时也很安全。

每个任务都有EFLAGS 寄存器的副本，其内容在任务创建的时候由内核或者操作系统初始化，在多任务系统中，每次当任务恢复运行时，就由处理器固件自动从TSS 中恢复。

EFLAGS 寄存器的IOPL 位决定了当前任务的I/O 特权级别。如果当前特权级CPL 高于，或者和任务的I/O 特权级IOPL 相同时，即，在数值上，

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00610.jpeg)

时，所有I/O 操作都是允许的，针对任何硬件端口的访问都可以通过。

相反，如果当前特权级CPL 低于任务的I/O 特权级IOPL，也并不意味着所有的硬件端口都对当前任务关上了大门。事实上，处理器的意思是总体上不允许，但个别端口除外。至于个别端口是哪些端口，要找到当前任务的TSS，并检索I/O 许可位串。

如图14-17 所示，I/O 许可位串（I/O Permission Bit String）是一个比特序列，或者说是一个比特串，最多允许65536 比特，即8KB。从第1 比特开始，各比特用它在串中的位置代表一个端口号。因此，第1 个比特代表0 号端口，第2 个比特代表1 号端口，第3 个比特代表2 号端口，……，第65536 比特代表第65535 号端口。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00611.jpeg)

图14-17　最大长度的I/O 许可位串示意图

每个比特的取值决定了相应的端口是否允许访问。为1 时，禁止访问；为0 时，允许访问。

处理器检查I/O 许可位的方法是先计算它在I/O 许可位映射区的字节编号，并读取该字节，然后进行测试。比如，当执行指令

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00612.jpeg)

时，处理器通过计算就可以知道，该端口对应着I/O 许可位映射区第2 个字节的第2 个比特（位1）。于是，它读取该字节，并测试那一位。

同其他和任务相关的信息一样，I/O 许可位串位于任务的TSS 中。如图14-18 所示，任务状态段TSS 的最小长度是104 字节，保存着最基本的任务信息，但这并不是它的最大长度。

事实上，整个TSS 还可以包括一个I/O 许可位串，它所占用的区域称为I/O 许可位映射区。如图14-18 所示，在TSS 内偏移为102 的那个字单元，保存着I/O 许可位串（I/O 许可位映射区）的起始位置，从TSS 的起始处（0）算起。因此，如果该字单元的内容大于或者等于TSS 的段界限（在TSS 描述符中），则表明没有I/O 许可位串。在这种情况下，如果当前特权级CPL 低于当前的I/O 特权级IOPL，执行任何硬件I/O 指令都会引发处理器异常中断。说明一下，和LDT 一样，必须在GDT 中创建TSS 的描述符，TSS 描述符中包括了TSS 的基地址和界限，该界限值包括I/O 许可位映射区在内。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00613.jpeg)

图14-18　TSS 中的I/O 许可位映射区

非常重要的一点是，I/O 端口是按字节编址的。这句话的意思是，每个端口仅被设计用来读写一个字节的数据，当以字或者双字访问时，实际上是访问连续的2 个或者4 个端口。比如，当从端口n 读取一个字时，相当于同时从端口n 和端口n＋1 各读取一个字节。即，

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00614.jpeg)

相当于同时执行

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00615.jpeg)

由于这个原因，当处理器执行一个字或者双字I/O 指令时，会检查许可位串中的2 个，或者4个连续位，而且要求它们必须都是“0”，否则引发异常中断。麻烦在于，这些连续的位可能是跨字节的。即，一些位于前一字节，另一些位于后一字节。为此，处理器每次都要从I/O 许可位映射区读两个连续的字节。

这种操作方式直接导致了另一个问题。即，如果要检查的比特在最后一字节中，那么，这个两字节的读操作将会越界。为防止这种情况，处理器要求I/O 许可位映射区的最后必须附加一个额外的字节，并要求它的所有比特都是“1”，即0xFF。当然，它必须位于TSS 的界限之内。

处理器不要求为每一个I/O 端口都提供位映射。对于那些没有在该区域内映射的位，处理器假定它对应的比特是“1”。例如，要是I/O 许可位映射区的长度是11 字节，那么，除去最后一个所有比特都是“1”的字节，前10 字节映射了80 个端口，分别是端口0 到端口79，访问更高地址的端口将引发异常中断。

显然，EFLAGS 寄存器中的IOPL 位对于控制任务的I/O 特权来说是很重要的。通常，IOPL位由内核或者操作系统根据任务的实际需要进行初始化。尽管不存在对EFLAGS 寄存器整体写入或者读出的指令，但存在将标志寄存器入栈和出栈的指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00616.jpeg)

pushf 并不是一条新指令。事实上，早在8086 处理器的时代就已经有了，用于将16 位的标志寄存器FLAGS 压栈，机器指令码为9C。在8086 处理器上执行时，SP 寄存器的内容减去2，然后将FLAGS 的内容保存到栈段，操作数的大小是1 个字。同样地，popf 指令把当前栈中的栈顶内容弹出到FLAGS 寄存器。

到了32 位处理器时代，pushf 指令既可以工作在16 位模式下，也可以工作在32 位模式下。在16 位模式下，pushf 压入的是EFLAGS 的低16 位。如果要压入整个32 位的EFLAGS，需要指令前缀66，即

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00617.jpeg)

在32 位模式下，pushf 压入的是整个32 位的EFLAGS，即使有指令前缀，也不会只压入低16位，多总比少好，只压入低16 位没有太大意义，徒增处理器的负担。

为了区分EFLAGS 寄存器在16 位模式下的两种压栈方式，编译器引入了符号pushfd。本质上，它们对应着同一条指令，当你使用pushf 时，编译器就知道，应当编译成无前缀的机器码9C；当使用pushfd 时，编译器会编译成66 9C。下面的例子很好地展示了它们之间的区别：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00618.jpeg)

可见，在32 位模式下，pushf 和pushfd 是相同的。上面的讨论同样适用于popf 和popfd 指令。

通过将EFLAGS 寄存器的内容压入栈，局部修改后，再弹出到EFLAGS，可以间接地改变它的各种标志位。对多数标志位的修改不会威胁到整个系统的安全，比如，你修改了ZF 标志，这有什么用呢？唯一的后果可能是搬石头砸自己程序的脚。

但是，如果修改了IOPL 位和IF 位，就不同了。能够修改这两个标志的指令是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00619.jpeg)

注意，没有包括pushf 指令，原因来自一个阴险的想法：你可以执行pushf 指令，但我不允许你执行popf 和iret 指令，你就生气吧！另外，中断是由操作系统或者内核统一管理的，cli 和sti指令不能由低特权级的程序随便执行。遗憾的是，这些指令并不是特权指令，原因很简单，其他特权级的程序也离不开它们。

最好的办法是用IOPL 本身来控制它们。如果当前特权级CPL 高于，或者和当前I/O 特权级IOPL 相同，即，在数值上

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00620.jpeg)

则允许执行以上4 条指令，也允许访问所有的硬件端口。否则，如果当前特权级CPL 低于当前的I/O 特权级IOPL，则执行popf 和iret 指令时，会引发处理器异常中断；执行cli 和sti 时，不会引发异常中断，但不改变标志寄存器的IF 位。同时，是否能访问特定的I/O 端口，要参考TSS中的I/O 许可位映射串。
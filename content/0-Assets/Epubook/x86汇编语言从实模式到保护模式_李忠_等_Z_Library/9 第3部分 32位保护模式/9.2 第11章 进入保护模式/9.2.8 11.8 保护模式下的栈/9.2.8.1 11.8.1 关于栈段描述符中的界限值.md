### 11.8.1　关于栈段描述符中的界限值

第77～79 行用于初始化保护模式下的栈。栈段描述符是GDT 中的第4 个（3 号）描述符，栈的32 位线性基地址是0x00000000，段界限为0x07a00，粒度为字节，属于可读可写、向下扩展的数据段。

栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。对于向上扩展的段，段内偏移量是从0 开始递增，偏移量的最大值是界限值和粒度的乘积；而对于向下扩展的段来说，因为它经常用做栈段，而栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。在32 位代码中，是用ESP 作为栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP 寄存器所能具有的最小值。即，栈操作时，必须符合条件：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00446.jpeg)

对于描述符中G 位是“0”的段来说，粒度值是1（字节）；而对于G 位是“1”的段来说，粒度值是4096（4KB）。

在当前代码中，ESP 寄存器的内容被初始化为0x00007c00。假如此时执行以下指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00447.jpeg)

那么，因为要压入一个32 位数，所以处理器先将ESP 的内容减去4，再压入数据。此时，ESP 寄存器的内容为（扩展到32 位）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00448.jpeg)

在当前栈段的描述符中，段界限为0x07a00，粒度是字节，故作为栈的界限，实际使用的数值是（扩展到32 位）：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00449.jpeg)

对于栈段来说，段界限的值加一，就是段内偏移量的最小值。因为要访问的段内偏移量0x00007BFC 大于实际使用的段界限值0x00007A00，故处理器允许执行该操作，并用描述符高速缓存中的32 位基地址0x00000000 加上这里的偏移量0x00007BFC，共同形成32 位线性地址访问栈，将寄存器EDX 的内容压入。否则，处理器阻止当前操作，引发一个异常中断。

你可能觉得当前的栈段很完美。但不得不说，这是一个非常糟糕的栈定义。结合本章的程序，很明显，我们的本意是要定义一个只有512 字节的栈空间，从物理地址0x00007A00 开始，到物理地址0x00007C00 结束，如图11-14 所示。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00450.jpeg)

图11-14　栈段的界限和栈的安全访问

尽管我们的本意是定义一个只有512 个字节的栈，但是，从该段的描述符来看，这个段的空间却是非常巨大的。假如一切正常，特别是指令执行正常，那不会有什么问题。但是，在程序失控的情况下，ESP 的内容可能会是任何预料不到的值，比如0xFFFFFFFF。即使是这样，它也是合法的值，毕竟它大于0x00007A00。因为当前栈段的线性基地址为0x00000000，所以，实际可以访问的空间是从物理地址0xFFFFFFFF 到0x00007A00。显然，这超出了我们的预期。在下一章里，我们将继续讨论如何用更好的方法来创建栈。
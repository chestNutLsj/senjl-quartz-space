### 11.8.2　检验32 位下的栈操作

代码清单11-1 中，最后的指令用于演示保护模式下的栈操作。我们已经知道，对于存储器的段来说，其描述符的D/B 位，对于代码段来说，是D 位；对于栈段来说，是B 位。

隐式的栈操作（push、pop、call、ret 和iret）涉及两个段：一个是指令所在的代码段；另一个是指令执行时，所使用的栈段。正如上一章所述，16 位下的栈操作，其默认的操作数大小是16 位的，而且使用的栈指针寄存器是SP；32 位下的隐式栈操作，其默认的操作数大小是32 位的，使用ESP 寄存器。

在本章里，当前程序的代码段，其描述符的D 位是“1”，所以，当进行隐式的栈操作时，默认地，每次压栈操作时，压入的是双字；当前程序所使用的栈段，其符述符的B 位也是“1”，默认地，使用栈指针寄存器ESP 进行操作。为此，从第81 行开始的指令用于检验这个事实。

因此，第81 行，先保存当前栈指针的内容到EBP 寄存器；接着，第82 行，向栈中压入立即数。该立即数为字符“.”的ASCII 码，这个值是在编译阶段计算的。

因为当前正在执行的代码段是32 位的，其描述符的D 位是“1”，故push 指令默认的操作数大小是32 位。正如在上一章里所讲的，关键字“byte”仅仅是给编译器用的，告诉它，该指令对应的格式为push imm8，必须使用操作码0x6A，而不是用来在编译后的机器指令前添加指令前缀。因此，该指令实际在处理器上执行时，压入栈中的是一个双字，也就是4 字节，高24 位是该字节符号的扩展。

当前指令执行时，所访问的栈，其描述符的B 位也是“1”，故处理器在进行栈操作时，用的是32 位栈指针寄存器ESP。它首先将ESP 的内容减去4，再写入数值，数据保存的位置是SS:ESP。

现在，理论上，将EBP 的内容减去4 之后，应该和ESP 的内容相同。为了证实这一点，第84～86 行，将原先保存的EBP 内容减去4，再和现行的ESP 比较，看是否相等。如果相等，则立即将刚才压入的字符出栈，并显示在前面的字符串后。不存在从栈中弹出字节的指令，因为名义上可以压入字节，但实际上它们是作为16 位或者32 位有符号数压入的。

当然，如果经过验证，EBP 和ESP 不相等，那么，将不会显示句点，直接转移到程序的最后，执行停机指令。因为现在已经禁止了中断，故除了NMI，没有任何原因会导致处理器被激活。

检测点11.2

1． 用Bochs 调试本章的程序，在第84 行，即sub ebp,4 处设置断点，观察栈的状态。此时，栈顶的双字数据是（　　　）。

2．以下说法，哪些是正确的（可多选）？

A．在x86 处理器的实模式下，可以在栈中压入16 位或者32 位数据。

B．在x86 处理器的32 位保护模式下，可以在栈中压入16 位或者32 位数据。

C．在x86 处理器的32 位保护模式下，如果栈段描述符的B 位是0，则使用SP 寄存器。压入16 位数据时，是SP 先减去2；压入32 位数据时，是SP 先减去4。

D．在x86 处理器的32 位保护模式下，如果栈段描述符的B 位是1，则使用ESP 寄存器。压入16 位数据时，是ESP 先减去2；压入32 位数据时，是ESP 先减去4。

E．在x86 处理器的32 位保护模式下，只能在栈中压入32 位数据。
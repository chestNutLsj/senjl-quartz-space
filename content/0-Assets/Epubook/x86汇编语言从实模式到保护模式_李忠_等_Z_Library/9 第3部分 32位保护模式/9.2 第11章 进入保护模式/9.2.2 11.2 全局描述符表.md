   

## 11.2　全局描述符表

我们知道，为了让程序在内存中能自由浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。

这种情况好有一比。就像是开公司做生意，在实模式下，开公司不需要登记，卖什么都没有人管，随时都可以开张。但在保护模式下就不行了，开公司之前必须先登记，登记的信息包括住址（段的起始地址）、经营项目（段的界限等各种访问属性）。这样，每当你做的买卖和你的注册项目不符时，就会被阻止。对段的访问也是一样，当你访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断。

和一个段有关的信息需要8 个字节来描述，所以称为段描述符（Segment Descriptor），每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放的，这就构成一个描述符表。

最主要的描述符表是全局描述符表（Global Descriptor Table，GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。

如图11-1 所示，为了跟踪全局描述符表，处理器内部有一个48 位的寄存器，称为全局描述符表寄存器（GDTR）。该寄存器分为两部分，分别是32 位的线性地址和16 位的边界。32 位的处理器具有32 根地址线，可以访问的地址范围是0x00000000 到0xFFFFFFFF，共232 字节的内存，即4GB 内存。所以，GDTR 的32 位线性基地址部分保存的是全局描述符表在内存中的起始线性地址，16 位边界部分保存的是全局描述符表的边界（界限），其在数值上等于表的大小（总字节数）减一。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00418.jpeg)

图11-1　全局描述符表寄存器GDTR

换句话说，全局描述符表的界限值就是表内最后1 字节的偏移量。第1 字节的偏移量是0，最后1 字节的偏移量是表大小减一。如果界限值为0，表示表的大小是1 字节。

因为GDT 的界限是16 位的，所以，该表最大是216 字节，也就是65536 字节（64KB）。又因为一个描述符占8 字节，故最多可以定义8192 个描述符。实际上，不一定非得这么多，到底有多少，视需要而定，但最多不能超过8192 个。

理论上，全局描述符表可以位于内存中的任何地方。但是，如图11-2 所示，由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，必须在进入保护模式之前定义GDT。但是，由于在实模式下只能访问1MB 的内存，故GDT 通常都定义在1MB 以下的内存范围中。当然，允许在进入保护模式之后换个位置重新定义GDT。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00419.jpeg)

图11-2　GDT 和GDTR 的关系示意图

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00420.jpeg)

图11-3　进入保护模式前的内存映象
   

## 11.6　保护模式下的内存访问

一路披荆斩棘之后，你已经到达实模式和保护模式的分界线了。同时，你也会发现，控制这两种模式切换的开关原是在一个叫CR0 的寄存器。

CR0 是处理器内部的控制寄存器（Control Register，CR）。之所以有个“0”后缀，是因为还有CR1、CR2、CR3 和CR4 控制寄存器，甚至还有CR8。

CR0 是32 位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。如图11-8 所示，它的第1 位（位0）是保护模式允许位（Protection Enable，PE），是开启保护模式大门的门把手，如果把该位置“1”，则处理器进入保护模式，按保护模式的规则开始运行。你可能会问，为什么只标识了一个PE 位，还把图画那么大。很简单，随着讲解的深入，我们还要接触其他标志位，把图的比例画得一致更好一些。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00432.jpeg)

图11-8　控制寄存器CR0 的PE 位

保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用，而且，必须要知道的是，在保护模式下，BIOS 中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断，这就是第44 行的用意。

第46 行，将CRO 寄存器中的原有内容传送到寄存器EAX，准备修改它；第47 行，将它的第1 位（位0）置“1”，其他各位保持原来的状态不变；第48 行，将修改之后的内容重新写回CR0，这直接导致处理器的运行变成保护模式。

可以在Bochs 调试窗口中察看各个控制寄存器的内容，具体方法参见本章11.9.6 节。你可以在mov cr0,eax 指令执行前和执行后各察看一次，重点关注CR0 寄存器PE 位的前后变化。

我们知道，在实模式下，处理器访问内存的方式是将段寄存器的内容左移4 位，再加上偏移地址，以形成20 位的物理地址。

8086 处理器的段寄存器是16 位的，共有4 个：CS、DS、ES 和SS。而在32 位处理器内，在原先的基础上又增加了两个段寄存器FS 和GS。

如图11-9 所示，32 位处理器的这6 个段寄存器又分为两部分，前16 位和8086 相同，在实模式下，它们用于按传统的方式寻址1MB 内存，使用方法也没有变化，所以使得8086 的程序可以继续在32 位处理器上运行。同时，每个段寄存器还包括一个不可见的部分，称为描述符高速缓存器，用来存放段的线性基地址、段界限和段属性。既然不可见，那就是处理器不希望我们访问它。事实上，我们也没有任何办法来访问这些不可见的部分，它是由处理器内部使用的。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00433.jpeg)

图11-9　32 位处理器内的段寄存器

在实模式下，访问内存用的是逻辑地址，即将段地址乘以16，再加上偏移地址。下面是一个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00434.jpeg)

以上，首先将段寄存器DS 的内容置为0x2000，这是逻辑段地址。接着，向该段内偏移地址为0x00c0 的地方写入1 字节（在寄存器AL 中），写入时，处理器将DS 的内容左移4 位，加上偏移地址，实际写入的物理地址是0x200c0。

在8086 处理器上，这是正确的。但是，在32 位处理器上，这个过程稍有不同。首先，每当引用一个段时，处理器自动将段地址左移4 位，并传送到描述符高速缓存器。此后，就一直使用描述符高速缓存器的内容作为段地址。所谓引用一个段，就是执行将段地址传送到段寄存器的指令。如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00435.jpeg)

以上是引用代码段的一个例子，因为代码段的修改通常是用转移和调用指令进行的。如果是引用数据段，则一般采用以下形式：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00436.jpeg)

只要不改变段寄存器DS 的内容，以后每次内存访问都直接使用DS 描述符高速缓存器中的内容。但是，在实模式下只能向段寄存器传送16 位的逻辑段地址（即，处理器不把它看成是描述符选择子），故，处理器仍然只能访问1MB 内存。也就是说，在实模式下，段寄存器描述符高速缓存器的内容仅低20 位有效，高12 位全部是零。

实模式下的6 个段寄存器CS、DS、ES、FS、GS 和SS，在保护模式下叫做段选择器。和实模式不同，保护模式的内存访问有它自己的方式。在保护模式下，尽管访问内存时也需要指定一个段，但传送到段选择器的内容不是逻辑段地址，而是段描述符在描述符表中的索引号。

如图11-10 所示，在保护模式下访问一个段时，传送到段选择器的是段选择子。它由三部分组成，第一部分是描述符的索引号，用来在描述符表中选择一个段描述符。TI 是描述符表指示器（Table Indicator），TI＝0 时，表示描述符在GDT 中；TI＝1 时，描述符在LDT 中。LDT 的知识将在后面进行介绍，它也是一个描述符表，和GDT 类似。RPL 是请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别，也将在后面慢慢介绍，现在只需要将这两位置成“00”即可。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00437.jpeg)

图11-10　段选择子的组成

为了说明保护模式下的内存访问，让我们回到代码清单11-1。前面已经创建了全局描述符表（GDT），而且在表中定义了4 个段描述符。数据段描述符在GDT 中的顺序是第3 个，因为编号都是从0 开始的，所以它的索引号（或者叫编号、槽位号）是2。

代码清单11-1 第56、57 行，将描述符选择子0x0010（二进制数0000_0000_ 00010_0_00）传送到段选择器DS 中。从选择子的二进制形式可以看出，指定的描述符索引号是2，指定的描述符表是GDT，请求特权级RPL 是00。

GDT 的线性基地址在GDTR 中，又因为每个描述符占8 字节，因此，描述符在表内的偏移地址是索引号乘以8。如图11-11 所示，当处理器在执行任何改变段选择器的指令时（比如pop、mov、jmp far、call far、iret、retf），就将指令中提供的索引号乘以8 作为偏移地址，同GDTR 中提供的线性基地址相加，以访问GDT。如果没有发现什么问题（比如超出了GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00438.jpeg)

图11-11　段选择器和描述符高速缓存器的加载过程

加载的部分包括段的线性基地址、段界限和段的访问属性。在当前的例子中，线性基地址是0x000b8000，段界限是0x0ffff，段的属性是向上扩展，可读写的数据段，粒度为字节。

此后，每当有访问内存的指令时，就不再访问GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。因此，第60 行，因为指令中没有段超越前缀，故默认使用数据段寄存器DS。如图11-12 所示，执行这条指令时，处理器用DS 描述符高速缓存中的线性基地址加上指令中给出的偏移量0x00，形成32 位物理地址0x000b8000，并将字符“P”的ASCII 码写入该处。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00439.jpeg)

图11-12　保护模式下的内存访问示意图

不单单是访问数据段，即使是处理器取指令执行时，也采用了相同的方法。如图11-13 所示，在32 位保护模式下，处理器使用的指令指针寄存器是EIP。假设已经从描述符表中选择了一个段描述符，CS 描述符高速缓存器已经装载了正确的32 位线性基地址，那么，当处理器取指令时，会自动用描述符高速缓存器中的32 位线性基地址加上指令指针寄存器EIP 中的32 位偏移量，形成32 位物理地址，从内存中取得执令并加以执行。同时，EIP 的内容自动增加以指向下一条指令。当前指令执行完毕之后，处理器接着按上述方式取下一条指令加以执行。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00440.jpeg)

图11-13　保护模式下处理器取指令的过程示意图
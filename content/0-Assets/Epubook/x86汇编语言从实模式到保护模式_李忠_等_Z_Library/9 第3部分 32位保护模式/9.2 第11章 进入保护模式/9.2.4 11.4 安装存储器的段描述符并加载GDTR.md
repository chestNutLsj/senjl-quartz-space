   

## 11.4　安装存储器的段描述符并加载GDTR

现在开始安装各个描述符，让我们回到代码清单11-1。

不要忘了，我们现在还处于实模式下。因此，在GDT 中安装描述符，必须将GDT 的线性地址（物理地址）转换成逻辑段地址和偏移地址。

GDT 的线性地址是我们直接给出的，放在程序中的标号gdt_base 处。第12 行，将GDT 线性基地址的低16 位传送到寄存器AX 中。和从前一样，这里使用了段超越前缀“cs：”，表明是访问代码段中的数据；又因为主引导程序的实际加载位置是逻辑地址0x0000:0x7c00，故标号gdt_base处的偏移地址是gdt_base+0x7c00。

同样地，第13 行将GDT 线性基地址的高16 位传送到寄存器DX。

第14～17 行将线性基地址转换成逻辑地址，方法是将DX:AX 除以16，得到的商是逻辑段地址，余数是偏移地址。接着，将AX 中的逻辑段地址传送到数据段寄存器DS 中，将偏移地址传送到寄存器BX 中。

处理器规定，GDT 中的第一个描述符必须是空描述符，或者叫哑描述符或NULL 描述符，相信后者对于有C 语言经历的读者来说更容易接受。

很多时候，寄存器和内存单元的初始值会为0，再加上程序设计有问题，就会在无意中用全0的索引来选择描述符。因此，处理器要求将第一个描述符定义成空描述符。

为此，第20、21 行将两个全0 的双字分别写入偏移地址为BX 和BX+4 的地方。

进入保护模式之后必然要从一个代码段开始执行。现在就来定义代码段描述符。

第24、25 行，接着安装代码段描述符，该描述符的低32 位是0x7c0001ff，高32 位是0x00409800。结合图11-4 可以分析出，该段的基本情况为：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00423.jpeg)

很明显，该描述符所指向的段，就是现在正在执行的主引导程序所在的区域。如图11-5 所示，这是描述符各字节在内存中的映象。Intel 处理器是低端字节序的，所以低双字在低地址端，高双字在高地址端；低字在低地址端，高字在高地址端；低字节在低地址端，高字节在高地址端。

第28、29 行，用于安装一个数据段的描述符。对照图11-4，很明显，这个段具有以下性质：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00424.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00425.jpeg)

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00426.jpeg)

图11-5　描述符各个字节在内存中的映象

我们用程序在屏幕上显示内容已经不是一次两次了，很容易看出，线性地址0x000b8000 就是显存的起始地址，看起来，我们要用这个段来显示字符。

第32、33 行，用于安装栈段的描述符。对照图11-4，该段的性质如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00427.jpeg)

在这里，段界限的值0x07a00 加上1（0x07a01），就是ESP 寄存器所允许的最小值。当执行push、call 这样的隐式栈操作时，处理器会检查ESP 寄存器的值，一旦发现它小于等于这里指定的数值，会引发异常中断。关于栈界限的讨论将在本章的后面接着进行。

好了，现在所有的描述符都已经安装完毕，接下来的工作是加载描述符表的线性基地址和界限到GDTR 寄存器，这要使用lgdt 指令，该指令的格式为

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00428.jpeg)

这就是说，该指令的操作数是一个48 位（6字节）的内存区域。在16 位模式下，该地址是16 位的；在32 位模式下，该地址是32 位的。该指令在实模式和保护模式下都可以执行。

在这6 字节的内存区域中，要求前（低）16 位是GDT 的界限值，后（高）32 位是GDT 的基地址。在初始状态下（计算机启动之后），GDTR 的基地址被初始化为0x00000000；界限值为0xFFFF。

该指向不影响任何标志位。

为此，代码清单11-1 第36 行，将GDT 表的界限值31 写入标号gdt_size 所在的内存单元。这里共有4 个描述符（包括空描述符），每个描述符占8 字节，一共是32 字节。GDT 表的界限值是表的总字节数减去一，所以是31。

接着，第38 行，把从标号gdt_size 开始的6 字节加载到GDTR 寄存器：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00429.jpeg)

因为gdt_size 和gdt_base 是连续声明的，紧挨在一起，所以，从gdt_size 处读取6 个字节，就包括了gdt_base。注意，到目前为止，我们依然工作在实模式下，而且不要忘了，指令中的偏移地址都要加上0x7c00。可以在Bochs 中察看全局描述符表GDT 的内容，具体方法参见本章11.9.5 节。

检测点11.1

1． 某描述符是64 位的0x004F9AFFFFFFFFFF，请问，段基地址是多少？段界限是多少？G、D、L、AVL、P、DPL、S 和TYPE 各是什么？

2． 32 位保护模式下，某段为数据段，基地址为0x002FC0F0，段的长度为2MB，粒度为4KB，已经位于物理内存中，请给出其描述符的低32 位和高32 位。
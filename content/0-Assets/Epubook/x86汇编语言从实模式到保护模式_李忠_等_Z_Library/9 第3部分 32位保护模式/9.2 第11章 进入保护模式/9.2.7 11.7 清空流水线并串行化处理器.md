   

## 11.7　清空流水线并串行化处理器

看起来我们所讲的内容有些超前了，毕竟前面刚刚设置了控制寄存器CR0 的PE 位，处理器刚刚切换到保护模式下。看起来一切都很简单，拧一下钥匙，汽车就发动了，不是吗？

不是这样的。这里有两个亟待解决的问题。

第一，正如上一节所述，即使是在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，仅低20 位有效，高12 位是全零。当处理器进入保护模式后，这些内容依然残留着，但不影响使用，程序可以继续执行。但是，这些残留的内容在保护模式下是无效的，迟早会在执行某些指令的时候出问题。因此，比较安全的做法是尽快刷新CS、SS、DS、ES、FS 和GS 的内容，包括它们的段选择器和描述符高速缓存器。

第二，在进入保护模式前，有很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按16 位操作数和16 位地址长度进行译码的，即使是那些用bits 32 编译的指令。进入保护模式后，受CS 段描述符高速缓存器中实模式残留内容的影响，处理器进入16 位保护模式工作。如果保护模式下的代码是16 位的，影响可能不大，但如果是用bits 32 编译的，那么，由于对对操作数和默认地址大小的解释不同，指令的执行结果可能会不正确，所以必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。

怎么办呢？这里有一个两全其美的方案，那就是使用远转移指令jmp 或者远过程调用指令call。处理器最怕转移指令，遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段选择器CS，并刷新描述符高速缓存器中的内容。一个建议的方法是在设置了控制寄存器CR0 的PE 位之后，立即用jmp 或者call 转移到当前指令流的下一条指令上。为此，代码清单11-1 第51 行，用32 位远转移指令来转移到紧挨着当前指令的下一条指令：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00441.jpeg)

这条指令和位于它前面的指令一样，默认地是用“bits 16”编译的，而且使用了关键字“dword”，该关键字修饰偏移地址，意思是要求使用32 位的偏移量。因此，会有指令前缀0x66，编译之后的结果是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00442.jpeg)

实际上，因为处理器现在处于16 位保护模式，说到底还是16 位模式，因此，使用以下的16位远转移指令可能更自然一些：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00443.jpeg)

如果使用这条指令，那么，同样用“bits 16”编译，生成的机器指令是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00444.jpeg)

16 位的绝对远转移指令只有5 个字节，使用16 位的偏移量。因此，它会使标号flush 的汇编地址相应地变小，变成0x007B，而不是从前的0x0080。

16 位保护模式是从80286 处理器开始引入的，80286 没有对8086 的寄存器进行扩展，依然使用AX、BX、CX、DX、SI、DI、BP、SP，等等。所以，在16 位保护模式下，段可以起始于任何地方，但每个段的最大长度是64KB，只使用16 位的偏移量。16 位保护模式并不重要，为了绕开它，我们才在这里使用了32 位的远转移指令。

注意，不管你用的是16 位远转移，还是32 位远转移，因为现在已经处于保护模式下，处理器都将把第一个操作数0x0008 视为段选择子，而不是实模式下的逻辑段地址。

因为处理器实际上是在保护模式下执行该指令的，因此，它会重新解释这条指令的含义。我们知道，操作数的默认大小（16 位还是32 位）是由描述符的D 位决定的，确切地说，是由段寄存器的描述符高速缓存器中的D 位决定的，毕竟，要访问一个段，必须首先将它的描述符传送到段寄存器的描述符高速缓存器中。当它刚进入保护模式时，CS 的描述符高速缓存器依然保留着实模式时的内容，其D 位是“0”，因此，在那个时刻，处理器运行在16 位保护模式下。

因为处理器已经进入保护模式，所以，0x0008 不再是逻辑段地址，而是保护模式下的段描述符选择子。在前面定义GDT 的时候，它的第2 个（1 号）描述符对应着保护模式下的代码段。因此，其选择子为0x0008（索引号为1，TI 位是0，RPL 为00）。当指令执行时，处理器加载段选择器CS，从GDT 中取出相应的描述符加载到CS 描述符高速缓存。

保护模式下的代码段，基地址为0x00007c00，段界限为0x1ff，长度为0x200，正好对应着当前程序在内存中的区域。在这种情况下，上面那条指令执行时，目标位置在段内的偏移量就是标号flush 的汇编地址，处理器用它的数值来代替指令指针寄存器EIP 的原有内容。

在16 位保护模式下执行带前缀0x66 的指令，那么，很好，处理器会按32 位的方式执行，使用32 位的偏移量。于是，它将0x0008 加载到CS 选择器，并从GDT 中取出对应的描述符，加载CS 描述符高速缓存器；同时，把指令中给出的32 位偏移量传送到指令指针寄存器EIP。很自然地，处理器就从新的位置开始取指令执行了。

可以在Bochs 中观察段寄存器在各个阶段的状态，包括计算机加电后、设置CR0 寄存器的PE位后和执行JMP 指令后的状态。具体方法请参见本章11.9.2、11.9.3 和11.9.4 节。通过了解这些状态变化，可以进一步加深对处理器如何进入保护模式的理解。

从进入保护模式开始，之后的指令都应当是按32 位操作数方式编译的。因此，第53 行，使用了伪指令[bits 32]。当处理器执行到这里时，它会按32 位模式进行译码，这正是我们所希望的。

代码清单11-1 第56～74 行，用于把描述符选择子0x10 加载到段选择器DS，并自动加载描述符高速缓存器。因为该数据段实际上是文本模式下的显示缓冲区，故大部分指令都用于在屏幕上显示字符串“Protect mode OK”。保护模式下的数据段访问已经在上一节里讨论过了，这里不再赘述。另外，处理器模式的变化对外围设备没有影响，它们是无法感知的，而且只按自己的方式工作。

注意，在保护模式下，不允许使用mov 指令改变段寄存器CS 的内容，比如：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00445.jpeg)

企图这样做将导致处理器产生一个无效操作码的异常中断。
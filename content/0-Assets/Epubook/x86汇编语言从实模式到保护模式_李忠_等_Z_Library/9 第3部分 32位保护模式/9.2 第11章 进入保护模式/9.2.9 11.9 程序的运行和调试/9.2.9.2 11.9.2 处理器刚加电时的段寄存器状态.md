### 11.9.2　处理器刚加电时的段寄存器状态

在x86 处理器加电后，它的固件会对自身进行初始化，可选地，还可以执行一个内置的自测试（Build-In Self-Test，BIST）。如果执行了BIST，那么，当测试通过后，EAX 寄存器被清零，否则，EAX 的内容为非零。如果不执行BIST，那么，EAX 寄存器的内容默认地也是0。在这些工作完成后，才开始取指令和执行指令。

不管怎样，当处理器初始化完成后，它内部的各个寄存器，包括通用寄存器、段寄存器、控制寄存器、指令指针寄存器EIP、栈指针寄存器ESP，以及我们尚未接触过的其他寄存器，都会有一个预置的值。至于它们的初始值是什么，可以查阅相关资料，比如INTEL 公司的手册Intel® 64 and IA-32 Architectures Software Developer’s Manual，它和本书一起，是你案头必备的资料（网上有大量的下载链接）。当然，如果不想查阅手册，Bochs 也能帮上你的忙。

Bochs 是用软件来模拟处理器的工作，所以它有这个能力。要想知道处理器加电后，各个寄存器都预置了什么内容，可以选择在它执行第一条指令之前，使用调试命令来显示它们。比如，可以用“r”命令显示各个通用寄存器的初始内容。当然，我们现在只想知道各个段寄存器中都有些什么。

如图11-16 所示，在处理器开始执行它本次加电以来的第一条指令前，可以用“sreg”命令察看各个段寄存器此时的状态。显然，段寄存器CS 的内容是0xF000，而其他段寄存器都是0。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00452.jpeg)

图11-16　x86 处理器加电后的段寄存器状态

图中还显示了段寄存器描述符高速缓存器的内容，这些内容也是加电之后预置的。首先，“dh”是段描述符的高32 位；“dl”是段描述符的低32 位。因为是加电预置的内容，并非来自于描述符表，所以，“dh”和“dl”的内容是Bochs 根据段寄存器描述符高速缓存器的内容构造的。

与此同时，Bochs 还根据各个段寄存器描述符高速缓存器的内容，给出了摘要信息。其中，“ Data segment ” 表示该段是数据段；“ base ” 指示段的基地址；“ limit ” 指示段的界限；“Read/Write”表示段可读可写；“Accessed”指示段曾经被访问过。

8086 处理器访问内存时，是把16 位段寄存器的内容左移4 位，加上16 位偏移地址，比如

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00453.jpeg)

在32 位处理器上，每次向段寄存器传送逻辑段地址时，处理器即在段寄存器描述符高速缓存器中存放一个左移后的20 位基地址。一个典型的例子是

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00454.jpeg)

因此，即使在实模式下，处理器也是用段寄存器描述符高速缓存器的32 位基地址加上16 位偏移地址访问内存，只不过基地址的高12 位通常是0。当然，也有一个例外，那就是在处理器刚电加时，CS 段描述符高速缓存器中的基地址被预置为0xFFFF0000，这使得处理器取第一条指令时，地址线的高位部分被强制为“1”。又因为加电后，EIP 的预置内容是0x0000FFF0，故，处理器第一次取指令时发出的地址是0xFFFFFFF0。之所以这样做，是因为处理器的设计者希望把ROM-BIOS 放到4GB 可寻址内存范围的最高端，这样，4GB 以下，连同传统的低端1MB 都是连续的RAM 区，连续的、不间断的RAM 能为操作系统管理内存带来方便。

问题在于，计算机制造商们会考虑很多现实问题。老的硬件和软件依赖于低端1MB 的ROMBIOS 来工作，这涉及到兼容性。最终，这两个地址区段都指向同一块ROM 芯片。

从图中可以看到，即将执行的第一条指令是jmp far f000:e05b（jmp 0xf000:0xe05b）。当这条指令执行后，处理器用0xF000 的值左移4 位，存放到段寄存器描述符高速缓存器。于是，处理器地址线的高位部分不再为“1”，这又转到低地址端的BIOS 执行了。如图11-17 所示，当执行远转移指令后，CS 描述符高速缓存器中的基地址变为0x000F0000，下一条指令xor ax,ax 的物理地址是0x000FE05B。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00455.jpeg)

图11-17　处理器加电并执行第一个远转移指令后的段寄存器内容

图中还显示了全局描述符表寄存器GDTR 的内容。很显然，GDT 的基地址是0，表界限是0xFFFF。

注意，在进入主引导程序时，这些段寄存器的内容（包括GDTR）和处理器刚加电时不再相同。原因很简单，BIOS 的加电自检程序在执行期间要进入保护模式进行测试，这将改变相关段寄存器的内容。
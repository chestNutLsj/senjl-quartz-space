   

## 15.3　任务切换的方法

对多任务的支持是现代处理器的标志之一。为此，Intel 处理器提供了多种方法，以灵活地在各个任务之间实施切换。

尽管如此，处理器并没有提供额外的指令用于任务切换。事实上，用的都是我们熟悉的老指令和老手段，但是扩展了它们的功能，使之除了能够继续执行原有的功能外，也能用于实施任务切换操作。

第一种任务切换的方法是借助于中断，这也是现代抢占式多任务的基础。原因很简单，只要中断没有被屏蔽，它就能随时发生。特别是定时器中断，能够以准确的时间间隔发生，可以用来强制实施任务切换。毕竟，没有哪个任务愿意交出处理器控制权，也没有哪个任务能精确地把握交出控制权的时机。

我们知道，在实模式下，内存最低地址端的1KB 是中断向量表，保存着256 个中断处理过程的段地址和偏移地址。当中断发生时，处理器把中断号乘以4，作为表内索引号访问中断向量表，从相应的位置取出中断处理过程的段地址和偏移地址，并转移到那里执行。

在保护模式下，中断向量表不再使用，取而代之的，是中断描述符表。不要害怕，它和GDT、LDT 是一样的，用于保存描述符。唯一不同的地方是，它保存的是门描述符，包括中断门、陷阱门和任务门。如果你觉得这些术语太过于陌生，那就回忆一下调用门，这些门和调用门是非常类似的。当中断发生时，处理器用中断号乘以8（因为每个描述符占8 字节），作为索引访问中断描述符表，取出门描述符。门描述符中有中断处理过程的代码段选择子和段内偏移量，这和调用门是一样的。接着，转移到相应的位置去执行。

一般的中断处理可以使用中断门和陷阱门。回忆一下调用门的工作原理，它只是从任务的局部空间转移到更高特权级的全局空间去执行，本质上是一种任务内的控制转移行为。与此相同，中断门和陷阱门允许在任务内实施中断处理，转到全局空间去执行一些系统级的管理工作，本质上，也是任务内的控制转移行为。

但是，在中断发生时，如果该中断号对应的门是任务门，那么，性质就截然不同了，必须进行任务切换。即，要中断当前任务的执行，保护当前任务的现场，并转换到另一个任务去执行。

如图15-2 所示，这是任务门（Task-Gate）描述符的格式。从图中可见，相对于其他各种描述符，任务门描述符中的多数区域没有使用，所以显得特别简单。

任务门描述符中的主要成份是任务的TSS 选择子。任务门用于在中断发生时执行任务切换，而执行任务切换时必须找到新任务的任务状态段（TSS）。所以，任务门应当指向任务的TSS。为了指向任务的TSS，只需要在任务门描述符中给出任务的TSS 选择子就可以了。

任务门描述符中的P 位指示该门是否有效，当P 位为“0”时，不允许通过此门实施任务切换；DPL 是任务门描述符的特权级，但是对因中断而发起的任务切换不起作用，处理器不按特权级施加任何保护。但是，这并不意味着DPL 字段没有用处，当以非中断的方式通过任务门实施任务切换时，它就有用了，关于这一点，你马上就会看到。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00651.jpeg)

图15-2　任务门描述符的格式

这样，当中断发生时，处理器用中断号乘以8 作为索引访问中断描述符表。当它发现这是一个任务门（描述符）时，就知道应当发起任务切换。于是，它取出任务门描述符；再从任务门描述符中取出新任务的TSS 选择子；接着，再用TSS 选择子访问GDT，取出新任务的TSS 描述符。在转到新任务执行前，处理器要先把当前任务的状态保存起来。当前任务的TSS 是由任务寄存器TR 的当前内容指向的，所以，处理器把每个寄存器的“快照”保存到由TR 指向的TSS 中。然后，处理器访问新任务的TSS，从中恢复各个寄存器的内容，包括通用寄存器、标志寄存器EFLAGS、段寄存器、指令指针寄存器EIP、栈指针寄存器ESP，以及局部描述符表寄存器（LDTR）等。最终，任务寄存器TR 指向新任务的TSS，而处理器旋即开始执行新的任务。一旦新任务开始执行，处理器固件会自动将其TSS 描述符的B 位置“1”，表示该任务的状态为忙。

当中断发生时，可以执行常规的中断处理过程，也可以进行任务切换。尽管性质不同，但它们都要使用iret 指令返回。前者是返回到同一任务内的不同代码段；后者是返回到被中断的那个任务。问题是，处理器如何区分这两种截然不同的返回类型呢？

如图15-3 所示，32 位处理器的EFLAGS 有NT 位（位14），意思是嵌套任务标志（Nested Task Flag）。每个任务的TSS 中都有一个任务链接域（指向前一个任务的指针，参见上一章TSS的结构），可以填写为前一个任务的TSS 描述符选择子。如果当前任务EFLAGS 寄存器的NT 位是“1”，则表示当前正在执行的任务嵌套于其他任务内，并且能够通过TSS 任务链接域的指针返回到前一个任务。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00652.jpeg)

图15-3　标志寄存器EFLAGS 的NT 位

因中断而引发任务切换时，取决于当前任务（旧任务）是否嵌套于其他任务内，其EFLAGS寄存器的NT 位可能是“0”，也可能是“1”。不过这无关紧要，因为处理器不会改变它，而是和其他寄存器一道，写入TSS 中保护起来。另外，当前任务（旧任务）肯定处于“忙”的状态，其TSS 描述符的B 位一定是“1”，在任务切换后同样保持不变。

对新任务的处理是，要把老任务的TSS 选择子填写到新任务TSS 中的任务链接域，同时，将新任务EFLAGS 寄存器的NT 位置“1”，以允许返回（转换）到前一个任务（老任务）继续执行。同时，还要把新任务TSS 描述符的B 位置“1”（忙）。

可以使用iret 指令从当前任务返回（转换）到前一个任务，前提是当前任务EFLAGS 寄存器的NT 位必须是“1”。无论任何时候处理器碰到iret 指令，它都要检查NT 位，如果此位是0，表明是一般的中断过程，按一般的中断返回处理，即，中断返回是任务内的（中断处理过程虽然属于操作系统，但属于任务的全局空间）；如果此位是1，则表明当前任务之所以能够正在执行，是因为中断了别的任务。因此，应当返回原先被中断的任务继续执行。此时，由处理器固件把当前任务EFLAGS 寄存器的NT 位改成“0”，并把TSS 描述符的B 位改成“0”（非忙）。在保存了当前任务的状态之后，接着，用新任务（被中断的任务）的TSS 恢复现场。

除了因中断引发的任务切换之外，还可以用远过程调用指令CALL，或者远跳转指令JMP 直接发起任务切换。在这两种情况下，CALL 和JMP 指令的操作数是任务的TSS 描述符选择子或任务门。以下是两个例子：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00653.jpeg)

当处理器执行这两条指令时，首先用指令中给出的描述符选择子访问GDT，分析它的描述符类型。如果是一般的代码段描述符，就按普通的段间转移规则执行；如果是调用门，按调用门的规则执行；如果是TSS 描述符，或者任务门，则执行任务切换。此时，指令中给出的32 位偏移量被忽略，原因是执行任务切换时，所有处理器的状态都可以从TSS 中获得。注意，任务门描述符可以安装在中断描述符表中，也可以安装在全局描述符表（GDT）或者局部描述符表（LDT）中。

如果是用于发起任务切换，call 指令和jmp 指令也有不同之处。使用call 指令发起的任务切换类似于因中断发起的任务切换。这就是说，由call 指令发起的任务切换是嵌套的，当前任务（旧任务）TSS 描述符的B 位保持原来的“1”不变，EFLAGS 寄存器的NT 位也不发生变化；新任务TSS 描述符的B 位置“1”，EFLAGS 寄存器的NT 位也置“1”，表示此任务嵌套于其他任务中。同时，TSS 任务链接域的内容改为旧任务的TSS 描述符选择子。

如图15-4 所示，假设任务1 是整个系统中的第一个任务。当任务1 开始执行时，其TSS 描述符的B 位是“1”，EFLAGS 寄存器的NT 位是“0”，不嵌套于其他任务。

当从任务1 转换到任务2 后，任务1 仍然为“忙”，EFLAGS 寄存器的NT 位不变（在其TSS中）；任务2 也变为“忙”，EFLAGS 寄存器的NT 位变为“1”，表示嵌套于任务1 中。同时，任务1 的TSS 描述符选择子也被复制到任务2 的TSS 中（任务链接域）。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00654.jpeg)

图15-4　任务嵌套示意图

最后是从任务2 转换到任务3 执行。和从前一样，任务2 保持“忙”的状态，EFLAGS 寄存器的NT 不变（在其TSS 中）；任务3 成为当前任务，其TSS 描述符的B 位变成“1”（忙），EFLAGS 寄存器的NT 位也变成“1”，同时，其TSS 的任务链接域指向任务2。

用CALL 指令发起的任务切换，可以通过iret 指令返回到前一个任务。此时，旧任务TSS 描述符的B 位，以及EFLAGS 寄存器的NT 位都恢复到“0”。

和call 指令不同，使用jmp 指令发起的任务切换，不会形成任务之间的嵌套关系。执行任务切换时，当前任务（旧任务）TSS 描述符的B 位清零，变为非忙状态，EFLAGS 寄存器的NT 位不变；新任务TSS 描述符的B 位置“1”，进入忙的状态，EFLAGS 寄存器的NT 位保持从TSS 中加载时的状态不变。

任务是不可重入的。

任务不可重入的本质是，执行任务切换时，新任务的状态不能为忙。这里有两个典型的情形：

第一种情形，执行任务切换时，新任务不能是当前任务自己。试想一下，如果允许这种情况发生，处理器该如何执行现场的保护和恢复操作？

第二种情形，如图15-4 所示，不允许使用CALL 指令从任务3 切换到任务2 和任务1 上。如果不禁止这种情况的话，任务之间的嵌套关系将会因为TSS 任务链接域的破坏而错乱。

处理器是通过TSS 描述符的B 位来检测重入的。因中断、iret、call 和jmp 指令发起任务切换时，处理器固件会检测新任务TSS 描述符的B 位，如果为“1”，则不允许执行这样的切换。
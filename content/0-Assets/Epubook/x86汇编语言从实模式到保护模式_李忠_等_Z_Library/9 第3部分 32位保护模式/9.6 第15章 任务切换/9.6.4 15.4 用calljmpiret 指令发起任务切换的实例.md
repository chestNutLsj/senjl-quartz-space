   

## 15.4　用call/jmp/iret 指令发起任务切换的实例

保护模式下的中断和异常中断处理要在第17 章才能详细阐述；和中断有关的任务切换也将在第17 章介绍。在本章，我们重点关注的是用call、jmp 和iret 指令发起的任务切换。

前面所讲的一切，都是纸上谈兵，或者说是在纸上谈任务切换。要想加深对任务切换的理解，具体的实例是必不可少的，而正在执行中的代码最能说明问题。为此，让我们回到代码清单15-1 中。

第938～945 行是用来加载用户程序的。先分配一个任务控制块（TCB），然后将它挂到TCB链上。接着，压入用户程序的起始逻辑扇区号及其TCB 基地址，作为参数调用过程load _relocate_program。

过程load_relocate_program 的工作和上一章相比没有太大变化，仅仅是对TSS 的填写比较完整。注意，这是任务切换的要求，从一个任务切换到另一个任务时，处理器要从新任务的TSS 中恢复（加载）各个寄存器的内容。尽管这是任务的第一次执行，但处理器并不知道，这是它的例行工作，你得把任务执行时，各个寄存器的内容放到TSS 中供处理器加载。

新增加的指令是从第766 行开始，到790 行结束的。首先，从栈中取出TCB 的基地址；然后，通过4GB 的内存段访问TCB，取出用户程序加载的起始地址，这也是用户程序头部的起始地址。

接着，依次登记指令指针寄存器EIP 和各个段寄存器的内容。因为这是用户程序的第一次执行，所以，TSS 中的EIP 域应该登记用户程序的入口点，CS 域应该登记用户程序入口点所在的代码段选择子。

第787～790 行，先将EFLAGS 寄存器的内容压入栈，再将其弹出到EDX 寄存器，因为不存在将标志寄存器的内容完整地传送到通用寄存器的指令。接着，把EDX 中的内容写入TSS 中EFLAGS 域。注意，这是当前任务（程序管理器）EFLAGS 寄存器的副本，新任务将使用这个副本作为初始的EFLAGS。一般来说，此时EFLAGS 寄存器的IOPL 字段为00，将来新任务开始执行时，会用这个副本作为处理器EFLAGS 寄存器的当前值，并因此而没有足够的I/O 特权。

好，回到第947 行。

这是一条32 位间接远调用指令CALL，操作数是一个内存地址，指向任务控制块（TCB）内的0x14 单元。这样的指令我们非常熟悉，一般来说，转移到的目标位置可以由16 位的代码段选择子和32 位段内偏移量组成，也可以由16 位的调用门选择子和32 位偏移量组成。所以，从TCB内偏移量为0x14 的地方，应当先是一个32 位的段内偏移量，接着是一个16 位的代码段或者调用门选择子。

但是，回到前一章，看图14-12，TCB 内偏移为0x14 的地方，是任务的TSS 基地址。再往后，是TSS 选择子。这很奇怪，是吗？但却是合法的。当处理器发现得到的是一个TSS 选择子，就执行任务切换。和通过调用门的控制转移一样，32 位偏移部分丢弃不用。这就是为什么我们可以把TSS 基地址作为32 位偏移量使用的原因。

当执行任务切换时，处理器用得到的选择子访问GDT，一旦它发现那是一个TSS 描述符，就知道应该执行任务切换的操作。首先，因为当前正在执行的任务是由任务寄存器TR 指示的，所以，它要把每个寄存器的“快照”保存到由TR 指向的TSS 中。

然后，处理器用指令中给出的TSS 选择子访问GDT，取得新任务的TSS 描述符，并从该TSS中恢复各个寄存器的内容，包括通用寄存器、标志寄存器EFLAGS、段寄存器、指令指针寄存器EIP、栈指针寄存器ESP，以及局部描述符表寄存器（LDTR）等。最终，任务寄存器TR 指向新任务的TSS，而处理器旋即开始执行新的任务。

谢天谢地，幸亏我们已经在load_relocate_program 过程内完整地设置了新任务的TSS，尤其是它的LDT 域、EIP 域、CS 域和DS 域，LDT 域指向用户程序的局部描述符表，EIP 域指向用户程序的入口点，CS 域指向用户程序的代码段，DS 域指向用户程序头部段。

程序管理器是计算机启动以来的第一个任务，在任务切换前，其TSS 描述符的B 位是“1”，EFLAGS 寄存器的NT 位是“0”。因为本次任务切换是用CALL 指令发起的，因此，任务切换后，其TSS 描述符的B 位仍旧是“1”，EFLAGS 寄存器的NT 位不变。当任务切换完成，用户任务成为当前任务，其TSS 描述符的B 位置“1”，表示该任务的状态为忙；EFLAGS 寄存器的NT位置“1”，表示它嵌套于程序管理器任务；TSS 的任务链接域被修改为前一个任务（程序管理器任务）的TSS 描述符选择子。

现在，用户程序作为任务开始执行了。所以，让我们转到代码清单15-2。

总体上，用户程序的结构和上一章相比没有变化，而且功能非常简单，大部分工作都是通过调用门来完成的。程序的入口点在第55 行。

当用户任务开始执行时，段寄存器DS 指向头部段。第57、58 行，令段寄存器FS 指向头部段。其主要目的是保存指向头部段的指针以备后用，同时，腾出段寄存器DS 来完成后续操作。毕竟 ，访问数据段时，不加段超越前缀会方便很多。

第60、61 行，令段寄存器DS 指向当前任务自己的数据段。

接下来的工作是显示问候语，并报告自己的当前特权级别。因为当前特权级别是计算出来的，所以，字符串要分成两个部分显示。第63～64 行，先显示前一部分：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00655.jpeg)

这句的意思是“嗨，很高兴遇到你，我运行的特权级别CPL=”。话没有说完，因为这个CPL还需要经过计算才能知道。

第66～69 行，计算当前特权级别，转换成ASCII 码后填写到数据段中，作为第二个字符串的第1 个字符。当前特权级别是由段寄存器CS 当前内容的低2 位指示的，因此，先将CS 的内容传送到AX 寄存器；接着，清除AL 寄存器的高6 位，只保留低2 位的原始内容；最后，将这个数字加上0x30，转换成可显示和打印的ASCII 码，并填写到数据段中由标号message_2 所指示的字节单元中。

第71、72 行，显示包括特权级数值在内的第二个字符串。据我们所知，当前任务的特权级别是3，因此，在屏幕上显示的完整内容是：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00656.jpeg)

意思是，“嗨，很高兴遇到你，我运行的特权级别CPL=3。现在，必须退出喽……”。

通过在中断描述符表中安装任务门，可以在中断信号的驱使下周期性地发起任务切换。否则，每个任务都应该在适当的时候主动转换到其他任务，以免计算机的操作者发现别的任务都僵在那里没有任何反应。如果每个任务都能自觉地做到这一点，那么，这种任务切换机制被称为是协同式的。

一般来说，可以在任务内的任何地方设置一条任务切换指令，以发起任务切换。当然，如果你是为某个流行的操作系统写程序，必须听从操作系统设计者的建议，他们的软件开发指南上会告诉你怎么做。

当前任务的做法稍有些特殊，它很简单，在显示了信息之后，第74 行，通过调用门转到全局空间执行。从该调用门的符号名“TerminateProgram”上看，意图是终止当前任务的执行，而不是临时转换到其他任务。

不管怎样，让我们回到代码清单15-1 中去，看看该任务在进入全局空间之后都做了些什么。

用户程序通过调用门进入任务的全局空间后， 实际的入口点在354 行， 即名字为terminate_current_task 的过程。该过程用来结束当前任务的执行，并转换到其他任务。

不要忘了，我们现在仍处在用户任务中，要结束当前的用户任务，可以先切换到程序管理器任务，然后回收用户程序所占用的内存空间，并保证不再转换到该任务。为了切换到程序管理器任务，需要根据当前任务EFLAGS 寄存器的NT 位决定是采用iret 指令，还是jmp 指令。

第358～360 行，先将EFLAGS 寄存器的当前内存压栈，然后，用ESP 寄存器作为地址操作数访问栈，取得EFLAGS 的压栈值，并传送到EDX 寄存器。接着，将ESP 寄存器的内容加上4，使栈平衡，保持压入EFLAGS 寄存器前的状态。

你可能会奇怪，为什么不直接使用下面两条指令来完成以上功能：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00657.jpeg)

的确，这两种做法的效果是一样的，之所以采用3 条指令，是因为想演示如何通过ESP 寄存器直接访问栈。在16 位模式下，不能使用SP 作为基址，所以下面的指令是错误的：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00658.jpeg)

注意，使用ESP 寄存器作为指令的地址操作数时，默认使用的段寄存器是SS，即访问栈段。

第362、363 行，令段寄存器DS 指向内核数据段，以方便后面的操作。

DX 寄存器包含了标志寄存器EFLAGS 的低16 位，其中，位14 是NT 位。第365、366 行，测试DX 寄存器的位14，看NT 标志位是0 还是1，以决定采用哪种方式（iret 或者call）回到程序管理器任务。因为当前任务是嵌套在程序管理器任务内的，所以NT 位必然是“1”，应当转到标号.b1 处继续执行。

第372、373 行，也就是标号.b1 处，先显示字符串

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00659.jpeg)

该字符串位于第448 行，是在内核数据段，用标号core_msg0 声明并初始化的。该字符串的内容显示，消息来源同样是系统内核，该消息的意思是“唔……该任务是用CALL 指令，或者由一个中断/异常发起的，应当使用IRETD 指令切换回去……”。

第374 行，通过iretd 指令转换到前一个任务，即程序管理器任务。执行任务切换时，当前用户任务的TSS 描述符的B 位被清零，EFLAGS 寄存器的NT 位也被清零，并被保存到它的TSS 中。

注意，在此处，我们用的是iretd，而不是iret。实际上，这是同一条指令，机器码都是CF。在16 位模式下，iret 指令的操作数默认是16 位的，要按32 位操作数执行，须加指令前缀0x66，即66 CF。为了方便，编译器创造了iretd。当在16 位模式下使用iretd 时，编译器就知道，应当加上指令前缀0x66。在32 位模式下，iret 和iretd 是相同的，下面的示例展示了它们之间的区别：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00660.jpeg)

当程序管理器任务恢复执行时，它的所有原始状态都从TSS 中加载到处理器，包括指令指针寄存器EIP，它指向第952 行的那条指令，紧接着当初发起任务切换的那条指令。

对于刚刚被挂起的那个旧任务，如果它没有被终止执行，则可以不予理会，并在下一个适当的时机再次切换到它那里执行。不过，现在的情况是它希望自己被终止。所以，理论上，接下来的工作是回收它所占用的内存空间，并从任务控制块TCB 链上去掉，以确保不会再切换到该任务执行（当然，现在TCB 链还没有体现出自己的用处）。遗憾的是，我们并没有提供这样的代码。所以，这个任务将一直存在，一直有效，不会消失，在整个系统的运行期间可以随时切换过去。

接下来，我们再创建一个新任务，并转移到该任务执行。

第952、953 行，程序管理器先显示一条消息。标号prgman_msg2 的位置是在第439 行，位于内核数据段，在那里初始化了字符串

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00661.jpeg)

这是程序管理器在说话，方括号中的文字显示了消息的来源。该消息的大意是“我很高兴又获得了控制，现在，创建其他用户任务，并使用JMP 指令切换到它那里”。

第955～964 行，创建新的用户任务并发起任务切换。与上次相比，这次的任务切换有几个值得注意的特点。首先，可以看出，该任务也是从硬盘的50 号逻辑扇区开始加载的，就是说，它和上一个用户任务一样，来自同一个程序。这就很清楚地说明了，一个程序可以对应着多个运行中的副本，或者说多个任务。尽管如此，它们彼此却没有任何关系，在内存中的位置不同，运行状态也不一样。

其次，这次是用JMP 指令发起的任务切换，新任务不会嵌套于旧任务中。任务切换之后，程序管理器任务TSS 描述符的B 位被清零，EFLAGS 寄存器的NT 位不变；新任务TSS 描述符的B位置位，EFLAGS 寄存器的NT 位不变，保持它从TSS 加载时的状态；任务链接域的内容不变。

由于两个任务来自于同一个程序，故完成相同的工作，最终都会通过调用门进入任务的全局空间执行。而且，在执行到第365、366 行时，EFLAGS 寄存器NT 位的测试结果必定是零，即NT＝0，当前任务并未嵌套于其他任务中，于是执行第367～369 行，首先显示字符串：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00662.jpeg)

方括号内显示了消息的来源，即系统内核。该消息的意思是，“唔……该任务是用JMP 指令发起的，应当直接用JMP 指令转换到程序管理器……”。

然后，使用32 位间接远转移指令JMP 转换到程序管理器任务。指令中的标号prgman_tss 位于内核数据段（第431 行），在那里初始化了6 字节，即16 位的TSS 描述符选择子和32 位的TSS基地址。按道理，这里不应该是TSS 基地址，而应当是一个32 位偏移量。不过，这是无所谓的，当处理器看到选择子部分是一个TSS 描述符选择子时，它将偏移量丢弃不用。

从第二个任务返回程序管理器任务时，执行点在第966 行。从这一行开始，一直到第969行，用于显示一条消息，然后停机。消息的内容是：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00663.jpeg)

消息的来源是程序管理器任务，它说：“我又获得了控制，停机……”

最后，处理器执行halt 指令，终于变消停了。
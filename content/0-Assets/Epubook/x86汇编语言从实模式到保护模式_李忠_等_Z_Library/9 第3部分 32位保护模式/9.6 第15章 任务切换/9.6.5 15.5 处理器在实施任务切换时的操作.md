   

## 15.5　处理器在实施任务切换时的操作

处理器用以下四种方法将控制转换到其他任务：

●当前程序、任务或者过程执行一个将控制转移到GDT 内某个TSS 描述符的jmp 或者call指令；

●当前程序、任务或者过程执行一个将控制转移到GDT 或者当前LDT 内某个任务门描述符的jmp 或者call 指令；

●一个异常或者中断发生时，中断号指向中断描述表内的任务门；

●在EFLAGS 寄存器的NT 位置位的情况下，当前任务执行了一个iret 指令。

jmp、call、iret 指令或者异常和中断，是程序重定向的机制，它们所引用的TSS 描述符或者任务门，以及EFLAGS 寄存器NT 标志的状态，决定了任务切换是否，以及如何发生。

在任务切换时，处理器执行以下操作：

① 从JMP 或者CALL 指令的操作数、任务门或者当前任务的TSS 任务链接域取得新任务的TSS 描述符选择子。最后一种方法适用于以iret 发起的任务切换。

② 检查是否允许从当前任务（旧任务）切换到新任务。数据访问的特权级检查规则适用于jmp 和call 指令，当前（旧）任务的CPL 和新任务段选择子的RPL 必须在数值上小于或者等于目标TSS 或者任务门的DPL。异常、中断（除了以int n 指令引发的中断）和iret 指令引起的任务切换忽略目标任务门或者TSS 描述符的DPL。对于以int n 指令产生的中断，要检查DPL。

③ 检查新任务的TSS 描述符是否已经标记为有效（P=1），并且界限也有效（大于或者等于0x67，即十进制的103）。

④ 检查新任务是否可用，不忙（B=0，对于以CALL、JMP、异常或者中断发起的任务切换）或者忙（B=1，对于以iret 发起的任务切换）。

⑤ 检查当前任务（旧任务）和新任务的TSS，以及所有在任务切换时用到的段描述符已经安排到系统内存中。

⑥ 如果任务切换是由jmp 或者iret 发起的，处理器清除当前（旧）任务的忙（B）标志；如果是由call 指令、异常或者中断发起的，忙（B）标志保持原来的置位状态。

⑦ 如果任务切换是由iret 指令发起的，处理器建立EFLAGS 寄存器的一个临时副本并清除其NT 标志；如果是由call 指令、jmp 指令、异常或者中发起的，副本中的NT 标志不变。

⑧ 保存当前（旧）任务的状态到它的TSS 中。处理器从任务寄存器中找到当前TSS 的基地址，然后将以下寄存器的状态复制到当前TSS 中：所有通用寄存器、段寄存器中的段选择子、刚才那个EFLAGS 寄存器的副本，以及指令指针寄存器EIP。

⑨ 如果任务切换是由call 指令、异常或者中断发起的，处理器把从新任务加载的EFLAGS 寄存器的NT 标志置位；如果是由iret 或者jmp 指令发起的，NT 标志位的状态对应着从新任务加载的EFLAGS 寄存器的NT 位。

⑩ 如果任务切换是由call 指令、jmp 指令、异常或者中断发起的，处理器将新任务TSS 描述符中的B 位置位；如果是由iret 指令发起的，B 位保持原先的置位状态不变。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00664.jpeg)用新任务的TSS 选择子和TSS 描述符加载任务寄存器TR。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00665.jpeg)新任务的TSS 状态数据被加载到处理器。这包括LDTR 寄存器、PDBR（控制寄存器CR3）、EFLAGS 寄存器、EIP 寄存器、通用寄存器，以及段选择子。载入状态期间只要发生一个故障，架构状态就会被破坏（因为有些寄存器的内容已被改变，而且无法撤销和回退）。所谓架构，是指处理器对外公开的那一部分的规格和构造；所谓架构状态，是指处理器内部的各种构件，在不同的条件下，所建立起来的确定状态。当处理器处于某种状态时，再施加另一种确定的条件，可以进入另一种确定的状态，这应当是严格的、众所周知的、可预见的。否则，就意味着架构状态遭到了破坏。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00666.jpeg)与段选择子相对应的描述符在经过验证后也被加载。与加载和验证新任务环境有关的任何错误都将破坏架构状态。注意，如果所有的检查和保护工作都已经成功实施，处理器提交任务切换。如果在从第1 步到第11 步的过程中发生了不可恢复性的错误，处理器不能完成任务切换，并确保处理器返回到执行发起任务切换的那条指令前的状态。如果在第12 步发生了不可恢复性的错误，架构状态将被破坏；如果在提交点（第13 步）之后发生了不可恢复性的错误，处理器完成任务切换并在开始执行新任务之前产生一个相应的异常。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00667.jpeg)开始执行新任务。

在任务切换时，当前任务的状态总要被保存起来。在恢复执行时，处理器从EIP 寄存器的保存值所指向的那条指令开始执行，这个寄存器的值是在当初任务被挂起时保存的。

任务切换时，新任务的特权级别并不是从那个被挂起的任务继承来的。新任务的特权级别是由其段寄存器CS 的低2 位决定的，而该寄存器的内容取自新任务的TSS。因为每个任务都有自己独立的地址空间和任务状态段TSS，所以任务之间是彼此隔离的，只需要用特权级规则控制对TSS 的访问就行，软件不需要在任务切换时进行显式的特权级检查。

任务状态段TSS 的任务链接域和EFLAGS 寄存器的NT 位用于返回前一个任务执行，当前EFLAGS 寄存器的NT 位是“1”表明当前任务嵌套于其他任务中。无论如何，新任务的TSS 描述符的B 位都会被置位，旧任务的B 位取决于任务切换的方法。表15-1 给出了不同条件下，B 位、NT 位和任务链接域的变化情况。

表15-1　不同任务切换方法对B 位、NT 位和任务链接域的影响

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00668.jpeg)
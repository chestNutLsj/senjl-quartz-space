### 2.5.4　8086 的内存分段机制

前面讲了如何从逻辑地址转换到物理地址，以使得程序的运行和它在内存中的位置无关。这种策略在很多处理器中得到了支持，包括8086 处理器。但是，由于8086 自身的局限性，它的做法还要复杂一些。

如图2-12 所示，8086 内部有8 个16 位的通用寄存器，分别是AX、BX、CX、DX、SI、DI、BP、SP。其中，前四个寄存器中的每一个，都还可以当成两个8 位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00023.jpeg)

图2-12　8086 处理器内部组成框图

在进行数据传送或者算术逻辑运算的时候，使用算术逻辑部件（ALU）。比如，将AX 的内容和CX 的内容相加，结果仍在AX 中，那么，在相加的结果返回到AX 之前，需要通过一个叫数据暂存器的寄存器中转。

处理器能够自动运行，这是控制器的功劳。为了加快指令执行速度，8086 内部有一个6 字节的指令预取队列，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达6 个字节的指令流可以排队等待解码和执行。

8086 内部有4 个段寄存器。其中，CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段（Extra Segment）寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS 指向一个，ES 指向另一个。可以在指令中指定使用DS 和ES 中的哪一个，如果没有指定，则默认是使用DS。SS 是栈段寄存器，以后会讲到，而且非常重要。

IP 是指令指针（Instruction Pointer）寄存器，它只和CS 一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS 指向代码段的起始地址，IP 则指向段内偏移。这样，由CS 和IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP 的值，使它指向下一条指令。

当然，如果在指令的执行过程中需要访问内存单元，那么，处理器将用DS 的值和指令中提供的偏移地址相加，来形成访问内存所需的物理地址。

8086 的段寄存器和IP 寄存器都是16 位的，如果按照原先的方式，把段寄存器的内容和偏移地址直接相加来形成物理地址的话，也只能得到16 位的物理地址。麻烦的是，8086 却提供了20根地址线。换句话说，它提供的是20 位的物理地址。

提供20 位地址线的原因很简单，16 位的物理地址只能访问64KB 的内存，地址范围是0000H～FFFFH，共65536 个字节。这样的容量，即使是在那个年代，也显得捉襟见肘。注意，这里提到了一个表示内存容量的单位“KB”。为了方便，我们通常使用更大的单位来描述内存容量，比如千字节（KB）、兆字节（MB）和吉字节（GB），它们之间的换算关系如下：

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00024.jpeg)

所以，65536 个字节就是64KB，而20 位的物理地址则可以访问多达1MB 的内存，地址范围从00000H 到FFFFFH。问题是，16 位的段地址和16 位的偏移地址相加，只能形成16 位的物理地址，怎么得到这20 位的物理地址呢？

为了解决这个问题，8086 处理器在形成物理地址时，先将段寄存器的内容左移4 位（相当于乘以十六进制的10，或者十进制的16），形成20 位的段地址，然后再同16 位的偏移地址相加，得到20 位的物理地址。比如，对于逻辑地址F000H:052DH，处理器在形成物理地址时，将段地址F000H 左移4 位，变成F0000H，再加上偏移地址052DH，就形成了20 位的物理地址F052DH。

这样，因为段寄存器是16 位的，在段不重叠的情况下，最多可以将1MB 的内存分成65536个段，段地址分别是0000H、0001H、0002H、0003H，……，一直到FFFFH。在这种情况下，如图2-13 所示，每个段正好16 个字节，偏移地址从0000H 到000FH。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00025.jpeg)

图2-13　1MB 内存可以划分为65536 个16 字节的段

同样在不允许段之间重叠的情况下，每个段的最大长度是64KB，因为偏移地址也是16 位的，从0000H 到FFFFH。在这种情况下，1MB 的内存，最多只能划分成16 个段，每段长64KB，段地址分别是0000H、1000H、2000H、3000H，…，一直到F000H。

以上所说的只是两种最典型的情况。通常情况下，段地址的选择取决于内存中哪些区域是空闲的。举个例子来说，假如从物理地址00000H 开始，一直到82251H 处都被其他程序占用着，而后面一直到FFFFFH 的地址空间都是自由的，那么，你可以从物理内存地址82251H 之后的地方加载你的程序。

接着，你的任务是定义段地址并设置处理器的段寄存器，其中最重要的是段地址的选取。因为偏移地址总是要求从0000H 开始，而82260H 是第一个符合该条件的物理地址，因为它恰好对应着逻辑地址8226H:0000H，符合偏移地址的条件，所以完全可以将段地址定为8226H。

但是，举个例子来说，如果你从物理内存地址82255H 处加载程序，由于它根本无法表示成一个偏移地址为0000H 的逻辑地址，所以不符合要求，段不能从这里开始划分。这里面的区别在于，82260H 可以被十进制数16（或者十六进制数10H）整除，而82255H 不能。通过这个例子可以看出，8086 处理器的逻辑分段，起始地址都是16 的倍数，这称为是按16 字节对齐的。

段的划分是自由的，它可以起始于任何16 字节对齐的位置，也可以是任意长度，只要不超过64KB。比如，段地址可以是82260H，段的长度可以是64KB。在这种情况下，该段所对应的逻辑地址范围是8226H:0000H～8226H:FFFFH，其所对应的物理地址范围是82260～9225FH。

同时，正是由于段的划分非常自由，使得8086 的内存访问也非常随意。同一个物理地址，或者同一片内存区域，根据需要，可以随意指定一个段来访问它，前提是那个物理地址位于该段的64KB 范围内。也就是说，同一个物理地址，实际上对应着多个逻辑地址。

检测点2.3

1． INTEL 8086 处理器有（ ）个16 位通用寄存器，分别是（　　　　　）。其中，有些还可以分开来作为两个独立的8 位寄存器来用，这几个8 位寄存器分别是（　　　　）。

2． 选择题（可多选）：INTEL 8086 处理器取指令时，使用段寄存器（ ）和指令指针寄存器（ ）。方法是，将段寄存器的值（ ），加上指令指针寄存器的当前值，形成物理地址访问内存。

A.CS　B.DS　C.IP　D.左移4位　E.右移4位　F.乘以1　G.除以10H

3． 物理地址132FEH 对应的逻辑地址是（可多选）：

A.132FH:000EH　　　B.1300H:02FEH　　　C.1000H:32FEH　　　D.1320H:00FEH

E.102FH:03E0H　　　F.0FE0H:34FEH
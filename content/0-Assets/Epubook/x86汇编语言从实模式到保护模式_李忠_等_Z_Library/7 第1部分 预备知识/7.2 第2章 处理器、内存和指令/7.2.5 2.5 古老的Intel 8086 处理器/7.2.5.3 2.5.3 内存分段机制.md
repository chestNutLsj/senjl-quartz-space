### 2.5.3　内存分段机制

如图2-10 所示，整个内存空间就像长长的纸条，在内存中分段，就像从长纸条中裁下一小段来。根据需要，段可以开始于内存中的任何位置，比如图中的内存地址A532H 处。

在这个例子中，分段开始于地址为A532H 的内存单元处，这个起始地址就是段地址。

这个分段包含了6 个存储单元。在分段之前，它们在整个内存空间里的物理地址分别是A532H、A533H、A534H、A535H、A536H、A537H。

但是，在分段之后，它们的地址可以只相对于自己所在的段。这样，它们相对于段开始处的距离分别为0、1、2、3、4、5，这叫做偏移地址。

于是，当采用分段策略之后，一个内存单元的地址实际上就可以用“段：偏移”或者 “段地址：偏移地址”来表示，这就是通常所说的逻辑地址。比如，在图2-10 中，段内第1 个存储单元的地址为A532H:0000H，第3 个存储单元的地址为A532H:0002H，而本段最后一个存储单元的地址则是A532H:0005H。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00021.jpeg)

图2-10　段地址和偏移地址示意图

为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器（Code Segment，CS）和数据段寄存器（Data Segment，DS）。

对CS 内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好DS 寄存器，使之指向数据段。

除此之外，最重要的是，当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址，而不是物理地址。这样，一旦处理器遇到一条访问内存的指令，它将把DS 中的数据段起始地址和指令中提供的段内偏移相加，来得到访问内存所需要的物理地址。

如图2-11 所示，代码段的段地址为1020H，数据段的段地址为1000H。在代码段中有一条指令A1 02 00，它的功能是将地址0002H 处的一个字传送到寄存器AX。在这里，处理器将0002H 看成是段内的偏移地址，段地址在DS 中，应该在执行这条指令之前就已经用别的指令传送到DS 中了。

当执行指令A1 02 00 时，处理器将把DS 中的内容和指令中指定的偏移地址0002H 相加，得到1002H。这是一个物理地址，处理器用它来访问内存，就可以得到所需要的数00A0H。

如果一下次执行这个程序时，代码段和数据段在内存中的位置发生了变化，只要把它们的段地址分别传送到CS 和DS，它也能够正确执行。

![img](../0-Assets/Epubook/x86汇编语言从实模式到保护模式_李忠_等_Z_Library/images/00022.jpeg)

图2-11　从逻辑地址到物理地址的转换过程
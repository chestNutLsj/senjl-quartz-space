## 流水线概述
### 流水线执行效率与特点
![[24-Pipeline-phase.png]]
特点：
- 流水线并没有缩短单个任务的延迟，但提高了整个系统的吞吐率。
- 多个任务同时运行，占用不同的资源。
- 理想的加速比 = 流水段数
- 流水线效率受限于用时最长的阶段
- 若每个阶段的用时不同，将降低流水线效率
- 装入和排空流水线也可降低加速比
- 冲突将引起流水线的暂停

作用：
- 提高处理机内部的并行性 
	- 空间并行性，即在一个处理机内设置多个独立的操作部件，并且使这些部件并行工作；
	- 时间并行性，就是采用流水线技术。流水线技术是一种非常经济、对提高计算机的运算速度非常有效的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，成为计算机中普遍使用的一种并行处理技术。

流水线分类：计算机各个部分几乎都可以采用流水线技术
- 指令流水线：指令的执行过程采用流水线
- 操作部件流水线：运算器中的操作部件，如浮点加法器、浮点乘法器等可以采用流水线
- 宏流水线：多个计算机之间，通过存储器连接，可以采用流水线



### 适合流水线的指令集特征

1. 指令长度应尽量一致
2. 指令格式应尽量规整，尽量保证源寄存器的位置相同
3. 采用 load/store 风格，可以保证除 load/store 外的指令都不访问存储器
4. 数据和指令在存储器中对齐存放

### 流水线执行方式与性能比较

![[24-Pipeline-operate-kinds.png]]
- 如果取指令、分析指令、执行指令的时间都相等，每段的时间都为 t，则 n 条指令所用的时间为：
	- 顺序执行：   `T=3nt`
	- 一次重叠执行：`T=(1+2n)t`
	- 两次重叠执行：`T=(n+2)t`

### 流水线的表示方法

- 流水线的每一个阶段完成一条指令的一部分， 不同阶段并行完成不同指令的不同部分。
- 流水线中的每一个阶段称为一个流水阶段，一个流水阶段与另一个流水阶段相连接形成流水线。
- 指令从流水线的一端进入，经过流水线的处理，从另一端流出。
- 目前大部分处理机的指令流水线在 3~12 段之间。

流水线常用的两种表示方法：
- 流水线连接图表示法，各个流水段顺序连接在一起
- 流水线时空图表示法，直观描述流水线工作过程

![[24-Pipeline-connection-chart.png]]

![[24-Pipeline-time-space-chart.png]]

### 流水线各阶段的要求

- 把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个**专门的功能部件**来实现。
- 流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的结果。
	- ![[24-Pipeline-storage.png]]
- 流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。
- 要求流水线的时钟周期不能短于最慢的流水段。 只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。
- 流水线需要有装入时间和排空时间。
	- 装入时间是指第一个任务进入流水线到输出流水线的时间。
	- 排空时间是指第 n 个（最后一个）任务进入流水线到输出流水线的时间。

### 流水线性能指标

1. 吞吐率：单位时间执行指令的数量
2. 加速比：与串行执行时速度提高的比率

## 流水线的实现

指令执行步骤
- 取指令（IF）
- 指令译码（ID/RF）
- 指令执行（EXE）
- 读存储器（MEM）
- 写回（WB）


各步骤占用的资源
- IF：IM、PC、总线
- ID/RF：寄存器组、控制信号生成部件 EXE：ALU MEM：DM、总线 WB：寄存器组

### 划分流水段
![[24-Pipeline-segments.png]]

### 增加流水段寄存器

![[24-Pipeline-datapath-segment-registers.png]]

各阶段寄存器保存的值：
- IF/ID
	- PC+4
	- IR
- ID/EXE
	- A、B、imm、PC+4、func
	- rt/rd
- EXE/MEM
	- 运算结果：PC、ALU 结果、结果状态
	- 中间结果：B、目的寄存器
- MEM/WB
	- 目的寄存器、ALU 结果、存储器读出的结果

### 每条指令的流水段分析

下文中，lw 指令占据流水段最多，因此其它指令的流水段向 lw 看齐——添加空段以达到 5 流水段，这有两个原则：
1. 每个功能部件每条指令只能使用一次
2. 每个功能部件必须在相同的阶段被使用（如寄存器写入口总是在第五段）

#### R-type
![[24-Pipeline-R-type.svg]]
- R 型指令都只涉及在 ALU 中对 rs1 和 rs2 的内容进行计算，最终将结果写入 rd；


#### I-type

与 R 型指令完全相同

#### lw

![[24-Pipeline-lw.svg]]
- `R[Rt]<-M[R[Rs]+SignExt(imm16)]`
- Exec 计算存储器的地址，Mem 段访问存储器，Write 段写入数据到寄存器

#### S-type

![[24-Pipeline-S-type.svg]]
- `M[R[Rs]+SignExt(imm16)]<-R[Rt]`
- 将寄存器的内容写入存储器中，少了一步写寄存器的工作，只需要四段功能段；
- Mem 功能段写回到存储器中；

#### B-type

![[24-Pipeline-B-type.svg]]

- 以 beq 为例： `if(R[Rs]=R[Rt]) then PC<-PC+4+SignExt(imm16)*4 else PC<-PC+4`
- Exec 段用于比较是否相等，同时用一个加法器计算转移地址
- WrPC 功能段用于将比较相等的情况下将转移目标地址写入 PC 中
- WrPC 功能类似 Mem，但用时更短，根据流水线的木桶原理，将 WrPC 归入 Mem 流水段的时间中；

#### J-type

![[24-Pipeline-J-type.svg]]

- 无条件跳转指令，只需要取指、译码、写回 PC 即可；

### 流水线的数据通路

![[24-Pipeline-datapath.png]]

段间寄存器用于存放从当前流水段传到后面所有流水段的信息。这也是数据转发的基础。

#### IF 段

- 功能：将 PC 的值作为地址到指令存储器 IM 中取指令，并自增 4 写回 PC 输入端

![[24-Pipeline-IF-segment.svg]]
- 当前指令地址若为 12，则 Clk 时钟下降沿到来时，在 PC 输入端的值 12 经过 `Clk-to-Q` 时延后，传送到 IM 的地址输入端 Addr，并同时送到加法器 Adder，进行 4 个字节的地址自增；
- 在 IM 中经过一个存取时间后，指令送到 IM 的指令输出端，指令随后到达 IF/ID 的段间寄存器；
- 加法器 Adder 自增后会经过多路选择器，若顺序执行则指令自增 4 成功，若跳转或分支执行，则根据其他信号对多路选择器的控制实现；
- 另外，若分支或跳转指令需要返回，则以 PC+4 作为返回地址，因此也需要存入 IF/ID 寄存器中；

段间寄存器需要保存什么？
- 指令 IR
- PC+4 的返回地址

#### ID 段

- 功能是：根据指令中的 rs1 和 rs2 的值到寄存器堆中取出相应寄存器的值，同时对指令中的操作码 opcode 字段进行译码，生成相应的控制信号；
- 寄存器堆是寄存器读口和写口两个功能部件，ID 段的功能由寄存器读口和控制器完成；
- ID 段执行的结果被送到 ID/Exec 寄存器的输入端，下一个时钟到来时，在 ID/Exec 寄存器输入端的信息送入 Exec 段开始处理；

ID/Exec 段间寄存器需要保存什么数据？
- Reg[rs1], Reg[rs2], imm, PC+4, func
- rs2, rd

#### Exec 段

- 功能：由具体指令经过译码后确定，通过不同的控制信号执行不同的操作
- Ex/Mem 段间寄存器存储 ALU 计算的结果和标志位信息 ZF、OF 等

#### Mem 段

- 也由具体指令确定操作
- Mem/Wr 段间寄存器存储 lw 写入 Reg 中的数据

#### Wr 段

### 流水线控制器

控制信号需要精确到每个功能部件，但是，每个部件执行的不是同一条指令
- 解决方案：把控制信号也和数据一样流动起来
- 为区分起见，可以把控制信号前面加上标记，如 `_IF` 等
- 每个时钟周期往下一步骤传递控制信号，使正确的控制信号到达正确的位置

![[24-Pipeline-flow-control.png]]

- 因此每个段间寄存器要存储的信息有两类：
	1. 后面阶段要用到的所有数据信息，包括 PC+4、指令、imm、目的寄存器、ALU 计算结果、flags 等
	2. 前面传递过来、后面阶段需要使用的信号

### 单周期、多周期、流水线的比较

![[24-Pipeline-compare.png]]
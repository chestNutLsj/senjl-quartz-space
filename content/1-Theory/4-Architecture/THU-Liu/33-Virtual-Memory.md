## 为什么需要虚拟内存？

![[33-Virtual-Memory-VA2PA.png]]

- 虚拟地址（逻辑地址）：程序员编程使用的地址
- 物理地址（实地址）：物理存储器的地址

### 虚拟内存解决的问题及思路

1. 如果程序的工作集大小大于物理内存大小，程序还能执行吗？
	- 缓存的思想（虚拟化）

2. 如果多个程序共享使用，那么
	- 程序员在编程时，怎么知道在哪儿分配内存？
	- 多个程序需要共享时，怎么办？
	- 多个程序同时执行时，某进程（程序）不想让另一个进程看到或者修改本进程的内容，怎么办？
	- 思想：程序员编程使用的空间与程序运行空间相互独立

1) 独立的逻辑地址空间: 通过页表将虚地址转换为实地址
![[33-Virtual-Memory-page-table.png]]

2) 每个进程有独立的逻辑地址空间，建立逻辑地址和物理地址的转换机制
![[33-Virtual-Memory-memor-share.png]]

3) 页表中存放有访问权限：通过硬件来保证权限（操作系统的“陷阱”操作）
![[33-Virtual-Memory-protect.png]]

### 虚拟存储器的目的

- 容量
	- 获得运行比物理存储器更大空间程序的能力
- 存储管理
	- 内存的分配以及虚实地址转换
- 保护
	- 操作系统可以对虚拟存储空间进行特定的保护
- 灵活
	- 程序的某部分可以装入主存的任意位置
- 提高存储效率
	- 只在主存储器中保留最重要的部分
- 提高并行度
	- 在进行段页替换的同时可以执行其它进程
- 可扩展
	- 为对象提供了扩展空间的能力.

### 虚拟内存与高速缓存的比较

![[33-Virtual-Memory-compare.png]]

## 页式内存管理

- 将主存和虚存划分为固定大小的页
- 以页为单位进行管理和数据交换
- 虚地址=虚页号+页内地址偏移
- 实地址=实页框号+页内地址偏移
- 通过页表进行管理
	- 页表基地址寄存器 PTBR
	- 实页号
	- 控制位

![[33-Virtual-Memory-ptbr.png]]
- 控制位：包括修改位、替换位
- 有效位：表示该页是否已装入主存

页式虚拟存储器的访问过程
1. 得到程序给出的虚地址；
2. 由虚地址得到虚页号；
3. 访问页表，得到对应的实页号；
4. 若该页已在内存中，则根据实页号得到实地址，访问内存；
5. 否则，启动输入输出系统，读出对应页装入主存，再进行访问。

> 为了加快找页表、找页的多次访存时间，引入 TLB。

### 页表大小

- 与虚页数直接相关，但是
	- 虽然理论上每个进程的逻辑空间很大，但其实大部分应该是不活跃的
	- 实际调入到内存的内容不可能超过物理存储空间
- 如何减少页表本身所占的空间？而且还要实现简单（页表访问频繁）
	- 两种途径
		- 层次页表（hierarchical page table） 
		- 反转页表（inverted page table

### TLB

![[33-Virtual-Memory-TLB.png]]

TLB 缺失将造成：
- 流水线停止
- 通知操作系统
- 读页表
- 将页表项写入 TLB
- 返回到用户程序
- 重新访问

因此，应尽量减少缺失: 
- 多路组相连
- 再尽量提高 TLB 的容量

![[33-Virtual-Memory-TLB-cache.png]]

### 页面大小

减少内部碎片
- 缩小页面大小可以减少内部碎片
- 但是：需要更大的页表

趋势：增大页面大小
- RAM 价格下降，内存储器容量增大
- 内存和外存性能差距增大
- 程序员需要更大的地址空间

目前：页面大小为4K 左右
- 但也并非不可以（1MB, 2MB, 4MB, 1GB) 
- Linux 内核的 Huge Page 机制

### 页面替换算法

- 最近最少使用（LRU）
	- 将页帧按照最近最多使用到最近最少使用进行排序，再次访问一个页帧时，将该页帧移到表头，替换时将表尾的页帧换出。
	- 改进：替换出其中一个“干净”的页帧。

## 例子：RISC-V 页表管理

基于页面的虚拟内存
- 分页命名模式：SvX，其中 X 是以位为单位的虚拟地址长度
- 内存划分为固定大小的页面进行地址转换和对内存内容的保护（页面大小通常为 4KB，也有大页面粒度）
- 启用分页的时候，大多数地址（包括 load 和 store 的有效地址和 PC 中的地址）都是虚拟地址
- 要访问物理内存，虚拟地址必须被转换为真正的物理地址
- 通过页表的结构来进行转换
- 权限位指示那些权限模式和通过哪种类型的访问可以操作这个页
- 访问未被映射的页或者访问权限不足会导致页面错误异常 （page fault exception）

### SV32

![[A0-Privileged-architecture#基于分页的虚拟内存]]

![[33-Virtual-Memory-SV32.png]]

## 段式内存管理与段页式内存管理

### 段式存储管理

设置段表进行管理
- 段表基地址
- 段起始地址 (段表中表项的位置)
- 段长
- 装入位
- 保护、共享等标志

![[33-Virtual-Memory-STBR.png]]

#### 特点

- 段的分界与程序和数据的自然分界相对应
- 易于编译、管理、修改和保护，便于多道程序共享
- 段长动态可变
- 段起点、终点不定：由段上界寄存器解决
- 空间分配困难，容易产生碎片（外碎片）

![[33-Virtual-Memory-linux-process.png]]

### 段页式虚拟存储管理

段页式虚拟存储管理是段式虚拟存储器和页式虚拟存储器的综合。
- 它先把程序按逻辑单位分为段，再把每段分成固定大小的页。
- 操作系统对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，可以兼取页式和段式系统的优点。
- 其缺点是需要在地址映射过程中多次查表。
- 其地址映射通过一个段表和一组页表来进行。

## 例子：x86 虚存管理

### 模式分类

- 不分段也不分页模式：
	- 在这种模式下，虚拟存储的地址空间 和物理存储空间大小相同，可以用在复杂度较低但对性能有较 高要求的场合。

- 页式管理模式：
	- 这种模式将主存分成固定长度的页，通过页 进行存储保护和管理。

- 段式管理模式：
	- 段式管理模式按程序本身的逻辑段来划分主 存空间，与页式管理相比，段的长度可变

- 段页式管理模式：
	- 为了兼容旧的模式，在 x86 中段式内存管理 和页式内存管理都是支持的。
	- 程序地址首先经过段式内存转换， 再通过页式内存转换，最终转换为物理地址

### 32 位 x86 虚实地址转换

- 虚地址（逻辑地址）：
	- 程序员给出的虚拟地址，格式为段号+段内偏移（16 位 +32 位），每段大小不超过 4GB，一共不超过 2^14 段。（段号中有两位用来表示段优先级）
- 实地址：32 位的实际内存地址

![[33-Virtual-Memory-segment-table.png]]

![[33-Virtual-Memory-x86-segment.png]]

![[33-Virtual-Memory-x86-segment-translation.png]]

![[33-Virtual-Memory-x86-segment-addressing.png]]

![[33-Virtual-Memory-x86-four-level-page-table.png]]


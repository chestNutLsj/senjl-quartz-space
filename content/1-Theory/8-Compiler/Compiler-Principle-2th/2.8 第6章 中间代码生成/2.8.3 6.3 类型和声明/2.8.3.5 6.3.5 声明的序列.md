### 6.3.5　声明的序列

像C和Java这样的语言支持将单个过程中的所有声明作为一个组进行处理。这些声明可能分布在一个Java过程中，但是仍然能够在分析该过程时处理它们。因此，我们可以使用一个变量，比如offset，来跟踪下一个可用的相对地址。

图6-17中的翻译方案处理形如T id的声明的序列，其中的T如图6-15所示产生一个类型。在考虑第一个声明之前，offset被设置为0。每处理一个变量x时，x被加入符号表，它的相对地址被设置为offset的当前值。随后，x的类型的宽度被加到offset上。

![256-2](../Images/image04403.jpeg)

图6-17　计算被声明变量的相对地址

产生式D→T id；D1中的语义动作首先执行top.put（id.lexeme，T.type，offset），创建一个符号表条目。这里的top指向当前的符号表。方法top.put为id.lexeme创建一个符号表条目，该条目的数据区中存放了类型T.type和相对地址offset。

如果我们把第一个产生式写在同一行中：

P→{offset=0；} D　（6.1）

则图6-17中对offset的初始化处理就变得更容易理解。生成∈的非终结符号称为标记非终结符号，其作用是重写产生式，使得所有的语义动作都出现在产生式右部的尾端，具体方法见5.5.4节。使用标记非终结符号M，（6.1）可以被改写为：

P→ M D

M→∈ {offset=0；}
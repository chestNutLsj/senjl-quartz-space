### 6.3.6　记录和类中的字段

图6-17中对声明的翻译方案还可以用于处理记录和类中的字段。要把记录类型加入到图6-15所示的文法中，只需要加上下面的产生式：

T → record ′{ ′ D ′}′

这个记录类型中的字段由D生成的声明序列描述。图6-17中的方法可以用来确定这些字段的类型和相对地址，当然我们需要小心地处理下面两件事：

- 一个记录中各个字段的名字必须是互不相同的。也就是说，在由D生成的声明中，同一个名字最多出现一次。
- 字段名的偏移量，或者说相对地址，是相对于该记录的数据区字段而言的。

例6.10　在一个记录中，把名字x用作字段名并不会和记录外对该名字的其他使用产生冲突。因此下列声明中对x的三次使用是不同的，互相之间并不冲突。

![257-1](../Images/image04404.jpeg)

这些声明之后的一个赋值语句`x=p.x+q.x`；把变量`x`的值设置为记录`p`和`q`中`x`字段的值的和。请注意，`p`中`x`的相对地址和`q`中`x`的相对地址是不同的。

为方便起见，记录类型将使用一个专用的符号表，对它们的各个字段的类型和相对地址进行编码。记录类型形如record（t），其中record是类型构造算子，t是一个符号表对象，它保存了有关该记录类型的各个字段的信息。

图6-18中的翻译方案包含一个产生式，该产生式将加入到图6-15中关于T的产生式中。这个产生式有两个语义动作。在D之前嵌入的动作首先保存top指向的已有符号表，然后让top指向新的符号表。该动作还保存了当前offset值，并将offset重置为0。D生成的声明会使类型和相对地址被保存到新的符号表中。D之后的语义动作使用top创建一个记录类型，然后恢复早先保存好的符号表和偏移值。

![257-2](../Images/image04405.jpeg)

图6-18　处理记录中的字段名

为了使翻译方案更加具体，图6-18中的动作给出了某个实现的伪代码。令Env类实现符号表。对Env.push（top）的调用将top所指的当前符号表压入一个栈中。然后，变量top被设置为指向一个新的符号表。类似的，offset被推入名为Stack的栈中，offset变量被重置为0。

在D中的声明被翻译之后，符号表top保存了这个记录中所有字段的类型和相对地址。而且，offset还给出了存放所有字段所需的存储空间。第二个动作将T.type设为record（top），并将T.width设为offset。然后，变量top和offset将被恢复为原先被压入栈中的值，以完成这个记录类型的翻译。

有关记录类型存储方式的讨论还可以被推广到类，因为我们无需为类中的方法保留存储空间。见练习6.3.2。
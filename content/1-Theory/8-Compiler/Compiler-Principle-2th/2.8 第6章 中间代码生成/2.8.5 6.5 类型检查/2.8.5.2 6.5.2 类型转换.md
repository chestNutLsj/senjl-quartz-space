### 6.5.2　类型转换

考虑类似于x+i的表达式，其中x是浮点数类型而i是整型。因为整数和浮点数在计算机中有不同的表示形式，而且使用不同的机器指令来完成整数和浮点数运算。编译器需要把+的某个运算分量进行转换，以保证在进行加法运算时两个运算分量具有相同的类型。

假定在必要的时候可以使用一个单目运算符（`float`）将整数转换成浮点数。例如，整数2在表达式`2*3.14`对应的代码中被转换成浮点数：

![264-1](../Images/image04417.jpeg)

我们可以扩展这样例子，考虑运算符的整型和浮点型版本。比如，`int*`表示作用于整型运算分量的运算符，而`float*`表示作用于浮点型运算分量的运算符。

我们将扩展6.4.2节中的用于表达式翻译的翻译方案，以说明如何进行类型综合。我们引入另一个属性E.type，该属性的值可以是integer或float。和E→E1+E2相关的规则可用如下的伪代码给出：

![264-2](../Images/image04418.jpeg)

随着需要转换的类型的增多，需要处理的不同情况也急剧增多。因此，在处理大量的类型时，精心组织用于类型转换的语义动作就变得非常重要。

不同语言具有不同的类型转换规则。图6-25中的Java的转换规则区分了拓宽（widening）转换和窄化（narrowing）转换。拓宽转换可以保持原有的信息，而窄化转换则可能丢失信息。拓宽规则通过图6-25a中的层次结构给出：在该层次结构中位于较低层的类型可以被拓宽为较高层的类型。因此，char类型可以被拓宽为int型和float型，但是不可以被拓宽为short类型。窄化转换的规则如图6-25b所示：如果存在一条从s到t的路径，则可以将类型s窄化为类型t。可以看出，char、 short、byte之间可以两两相互转换。

![265-1](../Images/image04419.jpeg)

图6-25　Java中简单类型的转换

如果类型转换由编译器自动完成，那么这样的转换就称为隐式转换。隐式转换也称为自动类型转换（coercion）。在很多语言中，自动类型转换仅仅限于拓宽转换。如果程序员必须写出某些代码来引发类型转换运算，那么这个转换就称为显式的。显式转换也称为强制类型转换（cast）。

检查E→E1+E2的语义动作使用了两个函数：

1）max（t1，t2）接受t1和t2两个类型的参数，并返回拓宽层次结构中这两个类型中的最大者（或者最小上界）。如果t1或t2之一没有出现在这个层次结构中，比如有个类型是数组类型或指针类型，那么该函数返回一个错误信息。

2）如果需要将类型为t的地址a中的内容转换成w类型的值，则函数widen（a，t，w）将生成类型转换的代码。如果t和w是相同的类型，则该函数返回a本身。否则，它会生成一条指令来完成转换工作并将转换结果放置到临时变量temp中。这个临时变量将作为结果返回。函数widen的伪代码如图6-26所示，这里假设只有integer和float两种类型。

![265-2](../Images/image04420.jpeg)

图6-26　widen函数的伪代码

图6-27中E→E1+E2的语义动作说明了如何把类型转换加入到图6-20所示的翻译表达式的方案中。在这个语义动作中，如果E1的类型不需要被转换成E的类型，那么临时变量a1就是E1.addr。如果需要进行这样的转换，则a1就是widen函数返回的一个新的临时变量。类似地，a2可能是E2.addr，也可能是一个新临时变量，用于存放转换后的E2的值。如果两个变量都是整型或者都是浮点型，就不需要进行任何转换。我们会发现，将两个不同类型的值相加的唯一方法是把它们都转换成为第三种类型。

![265-3](../Images/image04421.jpeg)

图6-27　在表达式求值中引入类型转换
### 6.5.3　函数和运算符的重载

依据符号所在的上下文不同，被重载（overloaded）的符号会有不同的含义。如果能够为一个名字的每次出现确定其唯一的含义，该名字的重载问题就得到了解决。在本节中，我们仅考虑那些只需要查看函数参数就能解决的函数重载。Java中的重载即是如此。

例6.13　根据其运算分量的类型，Java中的+运算符既可以表示字符串的连接运算，也可以表示加法运算。用户自定义的函数同样可以重载，例如

![265-4](../Images/image04422.jpeg)

请注意，我们可以根据函数err的参数来确定选择该函数的哪一个版本。

以下是针对重载函数的类型综合规则：

if f可能的类型为si→ti（1≤i≤n），其中，si≠sj（i≠j）

and x的类型为sk（1≤k≤n）　（6.10）

then表达式f（x）的类型为tk

6.1.2节中的值编码方法同样可以用于类型表达式，以便根据参数类型高效地解决重载问题。在表示类型表达式的一个DAG上，我们给每个结点赋予一个被称为值编码的整数序号。使用算法6.3，我们可以构造出每个结点的范型，该范型由该结点的标号及其从左到右的子结点的值编码组成。一个函数的范型由其函数名和它的参数的类型组成。根据函数的参数类型解决重载的问题就等价于基于范型解决重载的问题。

仅仅通过查看一个函数的参数类型不一定能够解决重载问题。在Ada中，一个子表达式会有一组可能的类型，而不是只有一个确定的类型。它所在的上下文必须提供足够的信息来缩小可选范围，最终得到唯一的可选类型（见练习6.5.2）。
### 6.5.4　类型推导和多态函数

类型推导常用于像ML这样的语言。ML是一个强类型语言，但是它不要求名字在使用前先进行声明。类型推导保证了名字使用的一致性。

术语“多态”指的是任何可以在不同的参数类型上运行的代码片段。在本节中，我们考虑参数多态（parametric polymorphism），这种多态通过参数和类型变量来刻划。我们使用图6-28中的ML程序作为一个贯穿本节的例子。该程序定义了一个函数length。函数length的类型可以描述为：“对于任何类型α，length函数将元素类型为α的列表映射为整型”。

![266-1](../Images/image04423.jpeg)

图6-28　计算一个列表长度的ML程序

例6.14　在图6-28中，关键字fun引出了一个函数定义，被定义的函数可以是递归的。这个程序片段定义了带有单个参数x的函数length。这个函数的函数体包含了一个条件表达式。预定义的函数null测试一个列表是否为空。预定义函数tl（tail的缩写）移除列表中的第一个元素，然后返回列表的余下部分。

函数length确定一个列表x的长度，或者说x中元素的个数。列表中的所有元素必须具有相同的类型。不管列表元素是什么类型，都可以用length函数来求出这个列表的长度。在下面的表达式中，length被应用到两种不同类型的列表中（列表元素用“［”和“］”括起来）：

length（［"sun"，"mon"，"tue"］）+length（［10，9，8，7］）　（6.11）

字符串列表的长度为3，整数列表的长度为4，因此表达式（6.11）的值为7。

使用符号∀（读作“对于任意类型”）以及类型构造算子list，length的类型可以写作：

∀α.list（α）→integer　（6.12）

符号∀是全称量词（wiversal quantifier），它所作用的类型变量称为受限的（bound）。受限变量可以被任意地重命名，但是需要把这个变量的所有出现一起重命名。因此，类型表达式∀β.list（β）→integer和式（6.12）等价。其中带有∀符号的类型表达式被称为“多态类型”。

在多态函数的各次应用中，函数的受限的类型变量可以表示不同的类型。在类型检查中，每次使用多态类型时，我们将受限变量替换为新的变量，并去掉相应的全称量词。

下一个例子对length类型进行了非正式的推导，推导过程中隐式地使用了公式（6.9）中的推导规则。这里再重复一下：

if f（x）是一个表达式

then对某些α和β，f的类型为α→β且x的类型为α

例6.15　图6-29中的抽象语法树表示图6-28中对length的定义。这棵树的根的标号为fun，它表示函数定义。其他的非叶子结点可以看作是函数应用。标号为+的结点表示对两个子结点应用运算符+。类似的，标号为if的结点表示将运算符if应用于它的三个子结点组成的三元组上（对于类型检查，究竟是then分支还是else分支被求值并不是问题。它们不会被同时计算）。

![267-1](../Images/image04424.jpeg)

图6-29　图6-28中的函数定义对应的抽象语法分析树

我们可以根据函数length的函数体推导出它的类型。从左到右考虑标号为if的结点的子结点。因为null要被应用在列表上，所以x必须是一个列表。我们使用变量α作为列表元素类型的占位符，也就是说，x的类型为“α的列表”。

如果null（x）为真，则length（x）为0。因此，length的类型一定是“从α的列表到整型的函数”。这个推导得到的类型和在else分支length（tl（x））+1中对length的使用是一致的。

因为在类型表达式中可能出现变量，所以我们必须重新审视一下类型等价的概念。设想将类型为s→s′的E1应用到类型为t的E2上。我们不能简单地确定s和t是否等价，而是必须将这两种类型“合一”。非正式地讲，我们将确定是否可以将类型变量s和t替换为特定的类型表达式，从而使得s和t在结构上等价。

置换（substitution）是一个从类型变量到类型表达式的映射。我们把对类型表达式t中的变量应用置换S后得到的结果写作S（t），详细信息请参见“置换、实例和合一”部分。两个类型表达式t1和t2可以合一（unify）的条件是存在某个置换S使得S（t1）=S（t2）。在实践中，我们感兴趣的是最一般化的合一置换，这种合一置换对表达式中的变量施加的约束最少。6.5.5节给出了一个合一算法。

置换、实例和合一

如果t是一个类型表达式，且S是一个置换（即一个从类型变量到类型表达式的映射），那么我们用S（t）来表示将t中的每个类型变量α的所有出现替换为S（α）后得到的结果。S（t）被称为t的一个实例（instance）。例如，list（integer）是list（α）的一个实例，因为它是将list（α）中的α替换为integer后的结果。然而，请注意integer→float不是α→α的实例，因为置换必须将α的所有出现替换为相同的类型表达式。

对于类型表达式t1和t2，如果S（t1）=S（t2），那么置换S就是一个合一替换（unifier）。如果对于t1和t2的任何合一替换，比如说S′，下面的条件成立：对于任意的t，S′（t）是S（t）的一个实例，那么我们就说S是t1和t2的最一般化的合一替换（most general unifier）。换句话说，S′对t施加的限制比S施加的限制更多。

算法6.16　多态函数的类型推导。

输入：一个由一系列函数定义以及紧跟其后的待求值表达式组成的程序。一个表达式由多个函数应用和名字构成。这些名字具有预定义的多态类型。

输出：推导出的程序中名字的类型。

方法：为简单起见，我们只考虑一元函数。对于带有两个参数的函数f（x1，x2），我们可以将其类型表示为s1×s2→t，其中s1和s2分别是x1和x2的类型，而t是函数f（x1，x2）的结果类型。通过检查s1是否和a的类型匹配，s2是否和b的类型匹配，就可以检查表达式f（a，b）的类型。

检查输入序列中的函数定义和表达式。当一个函数在其后的表达式中被使用时，就使用推导得到的该函数的类型。

- 对一个函数定义fun id1（id2）=E，创建一个新的类型变量α和β。将函数id1与类型α →β相关联，参数id2和类型α相关联。然后，推导出表达式E的类型。假设在对E进行类型推导之后，α表示类型s而β表示类型t。推导得到的函数id1的类型就是s→t。使用∀量词来限制s→t中任何未受约束的类型变量。
- 对于函数应用E1（E2），推导出E1和E2的类型。因为E1被用作一个函数，它的类型一定具有s→s′的形式（从技术上来说，E1的类型必须和β→γ合一，其中β和γ是新的类型变量）。假定推导得到的E2的类型为t。对s和t进行合一处理。如果合一失败，表达式返回类型错误，否则推导得到的E1（E2）的类型为s′。
- 对一个多态函数的每次出现，将它的类型表达式中的受限变量替换为互不相同的新变量，并移除∀量词。替换得到的类型表达式就是这个多态函数的本次出现所对应的推导类型。
- 对于第一次碰到的变量，引入一个新的类型变量来代表它的类型。

例6.17　在图6-30中，我们为函数length推导出一个类型。图6-29中语法树的根表示一个函数定义，因此我们引入变量β和γ，并将类型β→γ关联到函数length，将β关联到x。见图6-30的1～2行。

在根的右子结点上，我们把if看作一个应用到三元组上的多态函数，这个三元组包括一个布尔型变量以及两个分别代表then和else分支的表达式。函数if的类型是∀α.boolean×α×α→α。

多态函数的每次应用可能作用于不同的类型，因此我们构造一个新的临时变量αi（i取自if），并移除∀，见图6-30中的第三行。函数if的左子结点的类型必须和boolean类型合一，其他两个子结点的类型必须和αi合一。

![268-1](../Images/image04425.jpeg)

图6-30　推导图6-28中的函数length的类型

预定义函数null的类型为∀α.list（α）→boolean。我们使用一个新的类型变量αn（其中n表示null）来替换受限变量α，见第4行。因为null被应用于x，我们推导出x的类型β必须和list（αn）匹配，见第5行。

在if的第一个子结点上，null（x）的类型boolean和if函数预期的类型相匹配。在第二个子结点上，类型αi与integer进行合一，见第6行。

现在考虑子表达式length（tl（x））+1。我们为tl类型中的约束变量α建立新的临时变量αt（其中t表示“tail”），见第8行。根据tl（x）的应用，我们推导出list（αt）= β=list（αn），见第9行。

因为length（tl（x））是+的一个运算分量，它的类型γ必须和integer合一，见第10行。可以推出length的类型为list（αn）→integer。在检查完这个函数定义之后，类型变量αn仍然保留在length的类型中。因为没有对αn作出任何假设，当使用该函数时αn可以被替换为任何类型。因此，我们可以把它变成一个受限变量，并把length的类型写作：

∀αn.list（αn）→integer
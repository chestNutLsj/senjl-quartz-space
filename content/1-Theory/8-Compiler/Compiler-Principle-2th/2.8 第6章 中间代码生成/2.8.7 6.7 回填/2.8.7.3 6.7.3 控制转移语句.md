### 6.7.3　控制转移语句

现在我们使用回填技术在一趟扫描中完成控制流语句的翻译。考虑由下列文法产生的语句：

![281-2](../Images/image04455.jpeg)

这里S表示一个语句，L是一个语句的列表，A是一个赋值语句，B是一个布尔表达式。请注意，一定还存在一些其他的产生式，比如那些关于赋值语句的产生式。然而，这里给出的这些产生式已经足以用来说明在控制流语句的翻译中用到的技术。

语句if、if-else和while的代码布局和6.6节中的描述一样。我们给出一个隐含的假设，即指令数组中的代码顺序反映了控制流的自然流动，即控制从一条语句到达下一条语句。假如没有这个假设，那么我们就必须明确插入跳转指令来实现自然的顺序控制流。

图6-46中的翻译方案保留了多个跳转指令的列表，当确定了这些跳转指令的目标序号后就会回填列表。如图6-43所示，由非终结符号B生成的布尔表达式有两个跳转指令列表：B.truelist和B.falselist。它们分别对应于B的代码的真假出口。由非终结符号S和L生成的语句也有一个待回填的跳转指令列表，由属性nextlist表示。列表S.nextlist中包含了所有跳转到按照运行顺序紧跟在S代码之后的指令的条件或无条件转移指令。L.nextlist的定义与此类似。

考虑图6-46中的语义动作（3）。产生式S→while（B）S1的代码布局如图6-35c所示。标记非终结符号M在产生式

S→while M1（B）M2 S1

中的两次出现分别记录了B的代码和S1的代码的开始处的指令编号。它们分别对应于图6-35c中的标号begin和B.true。

M还是只有唯一的产生式M→∈。图6-46中的动作（6）将属性M.instr的值设为下一条指令的序号。在while语句的循环体S1执行之后，控制流回到此语句的起始位置。因此，在将while M1（B）M2 S1归约为S的时候，我们对S1.nextlist中的所有跳转指令进行回填，使得该列表中所有指令的目标为序号M1.instr。在S1的代码之后显式地插入了一条跳转到B的代码的开始处的指令，这是因为控制流也有可能“穿越底部”。通过将B.truelist中的指令设置为转向M2.instr，我们将B.truelist回填为S1代码的起始位置。

![282-1](../Images/image04456.jpeg)

图6-46　语句的翻译

在为条件语句if（B）S1 else S2生成代码时，我们可以看到更加有说服力的使用S.nextlist和L.nextlist的理由。如果控制流“穿越”了S1的代码的底部，比如当S1是一个赋值语句时就会发生这样的事情，我们必须在S1的代码之后增加一条越过S2代码的跳转指令。我们使用位于S1之后的另一个标记非终结符号来生成这个跳转指令。假定这个标记非终结符号为N，且其产生式为N→∈。N有属性N.nextlist，它是一个由N的语义动作（7）生成的跳转指令`goto _`的序号组成的列表。

图6-46中的语义动作（2）处理满足下列语法的if-else语句：

S→if（B）M1 S1 N else M2 S2

我们将对应于B为真的跳转指令回填为M1.instr，也就是S1的代码的开始位置。类似地，我们将回填那些对应于B为假的跳转指令，使它们跳转到S2的代码的开始位置。列表S.nextlist包含了所有从S1和S2中跳出的指令，也包括由N产生的跳转指令。（变量temp是仅用于合并列表的临时变量。）

语义动作（8）和（9）处理语句序列。在

L→L1 M S

中，按照执行顺序紧跟在L1的代码之后的是S的开始指令。因此，列表L1.nextlist被回填为S代码的开始位置，该位置由M.instr给出。在L→S中，L.nextlist和S.nextlist相同。

请注意，除了语义规则（3）和（7）之外，这些语义规则中的任何地方都没有产生新的指令。其他所有的代码都是由赋值语句和表达式相关的语义动作产生的。我们根据控制流进行了正确的回填，因此赋值语句和布尔表达式的求值过程被正确地连接了起来。
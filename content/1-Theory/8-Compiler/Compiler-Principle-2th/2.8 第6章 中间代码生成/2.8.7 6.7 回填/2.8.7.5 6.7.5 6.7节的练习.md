### 6.7.5　6.7节的练习

练习6.7.1：使用图6-43中的翻译方案翻译下列表达式。给出每个子表达式的truelist和falselist。你可以假设第一条被生成的指令的地址是100。

![283-2](../Images/image04458.jpeg)

练习6.7.2：图6-47a中给出了一个程序的摘要。6-47b概述了使用图6-46中的回填翻译方案生成的三地址代码的结构。这里，i1～i8是每个code区域的第一条被生成指令的标号。当我们实现这个翻译时，我们为每个布尔表达式E维护了两个列表，表中给出E的代码中的一些位置。我们分别用E.true和E.false来表示这两个列表。对于E.true列表中的那些指令位置，我们最终要加入当E为真时控制流应该到达的语句的标号。E.false是类似的存放特定位置号的列表，我们要在这些位置上加入当发现E为假时控制流应该到达的标号。同时，我们还为语句S维护了一个位置的列表。我们必须在这些位置上加入当S执行完毕之后控制流应该到达的标号。请给出最终将代替下列各个列表中的位置的值（即i1～i8中的某个标号）。

（1）E3.false　（2）S2.next　（3）E4.false　（4）S1.next　（5）E2.true

练习6.7.3：当使用图6-46中的翻译方案对图6-47进行翻译时，我们为每条语句创建S.next列表。一开始是赋值语句S1、S2、S3，然后逐步处理越来越大的if语句、if-else语句、while语句和语句块。在图6-47中有5个这种类型的结构语句：

![284-1](../Images/image04459.jpeg)

图6-47　练习6.7.2的程序的控制流结构

S4：while（E3）S1。

S5：if（E4）S2。

S6：包含S5和S3的语句块。

S7：语句if（E2）S4 else S6。

S8：整个程序。

对于这些结构语句，我们可以通过一个规则用其他的Sj.next列表以及程序中的表达式的列表Ek.true和Ek.false构造出Si.next。给出计算下列next列表的规则：

（1）S4.next　（2）S5.next　（3）S6.next　（4）S7.next　（5）S8.next
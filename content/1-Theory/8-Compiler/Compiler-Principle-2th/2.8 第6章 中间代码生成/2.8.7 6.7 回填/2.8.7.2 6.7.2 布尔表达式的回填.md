### 6.7.2　布尔表达式的回填

现在我们构造一个可以在自底向上语法分析过程中为布尔表达式生成目标代码的翻译方案。这个文法中有一个标记非终结符号M。它引发的语义动作在适当的时刻获取将要生成的下一条指令的下标。该文法如下：

![279-1](../Images/image04445.jpeg)

翻译方案如图6-43所示。

![279-2](../Images/image04446.jpeg)

图6-43　布尔表达式的翻译方案

考虑上述文法中对应于规则B→B1‖MB2的语义动作（1）。如果B1为真，那么B也为真，这样B1.truelist中的跳转指令就成为B.truelist的一部分。然而，如果B1为假，我们下一步必须测试B2。因此B1.falselist中的跳转指令的目标必定是B2的代码的起始位置。这个位置使用标记非终结符号M获得。在即将生成B2代码之前，M生成了下一条指令的序号，存放在综合属性M.instr中。

为了获得指令序号，我们将产生式M→∈和语义动作

{M.instr=nextinstr；}

关联起来。变量nextinstr保存了紧跟着的下一条指令的序号。当我们已经看到了产生式B→B1‖M B2的余下部分时，这个值将被回填到B1.falselist中的指令上（即B1.falselist中的每条指令都把M.instr当作目标标号）。

B→B1&& M B2的语义动作（2）和动作（1）类似。B→！B的语义动作（3）对换真假列表。动作（4）只是忽略括号。

为简单起见，语义动作（5）生成了两条指令：一个条件转移指令goto和一个无条件转移指令。它们的目标标号都未填写。这两个指令被放入新的分别由B.truelist和B.falselist指向的列表中。

例6.24　再次考虑表达式

![280-1](../Images/image04447.jpeg)

它的一棵注释语法分析树如图6-44所示。为了增加可读性，属性truelist、falselist和instr分别用它们的第一个字母表示。在对这棵语法树进行深度优先遍历时执行语义动作。因为所有的动作都出现在规则右部的最后，因此它们可以和自底向上语法分析过程中的归约动作同时进行。在根据产生式（5）将x<100归约为B时，语义动作相应地产生两条指令：

![280-2](../Images/image04448.jpeg)

![280-7](../Images/image04449.jpeg)

图6-44　x<100 ‖ x>200 && x！=y 的注释语法分析树

我们任意地从100开始为指令编号。产生式

![280-3](../Images/image04450.jpeg)

中的标记非终结符号M记录了nextinstr的值，此时这个值为102。使用产生式（5）将x>200归约为B产生下面两条指令

![280-4](../Images/image04451.jpeg)

子表达式x>200对应于下面产生式中的B1：

![280-5](../Images/image04452.jpeg)

标记非终结符号M记录了nextinstr的当前值，现在是104。使用产生式（5）将x！=y归约为B产生下列指令

![280-6](../Images/image04453.jpeg)

我们现在使用B→B1 &&M B2进行归约。相应的语义动作调用backpatch（B1.truelist，M.instr）将B1的真值出口绑定到B2的第一条指令处。因为B1.truelist是{102}，M.instr是104，这次对backpatch的调用将序号104填写到102指令中。至今为止产生的六条指令如图6-45a所示。

![281-1](../Images/image04454.jpeg)

图6-45　回填的步骤

和最后一次归约使用的产生式B→B1‖M B2相关联的语义动作调用backpatch（{101}，102），得到的指令如图6-45b所示。

整个表达式为真当且仅当控制流到达100和104位置上的跳转指令；表达式为假当且仅当控制流到达103和105位置上的跳转指令。在后续的编译过程中，当已知表达式为真或假时分别应该做什么的时候，这些指令的目标将会被填写完整。
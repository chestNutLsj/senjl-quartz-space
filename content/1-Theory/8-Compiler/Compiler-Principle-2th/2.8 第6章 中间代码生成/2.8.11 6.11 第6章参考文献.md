## 6.11　第6章参考文献

本章中的大部分技术来自于围绕Algol60进行的设计和实现活动。在Pascal［11］和C［6，9］产生的时候，生成中间代码的语法制导翻译技术已经很成熟了。

从20世纪50年代开始，人们就开始寻求一种虚构的中间语言 ——UNCOL（面向所有编译器的语言）。如果有一个UNCOL，我们可以把针对一种给定的源语言的前端和针对一种给定目标语言的后端连接起来，构建出一个编译器［10］。报告［10］中的指导性技术常常用于将编译器重定向。

人们用很多种方法来实现UNCOL思想，即将多个前端和后端混合并相互匹配。一个可重定目标的编译器包括一个前端，该前端可以和不同的后端结合起来，以便在不同机器上实现同一种给定的语言。Neliac语言是一个带有重定目标编译器［5］的早期例子，这个编译器是使用Neliac本身编写的。另一种方法是为一个新的语言建立一个前端，将其翻译到一个已有的编译器上。Fedman［2］描述了在C编译器上加入Fortran的前端的方法［6］［9］。GCC，即GNU的编译器集合［3］，支持包括C、C++、Objective-C、Fortran、Java、Ada等语言的前端。

值编码方法及其基于散列技术的实现来自于Ershov［1］。

在Java字节码中使用类型信息来提高安全性的技术由Gosling［4］描述。

使用合一方法求解方程组的类型推导技术被人们多次重复发现；它在ML上的应用由Milner［7］描述。要对类型进行更全面的处理，可参见Pierce［8］。

![288-1](../Images/image04467.jpeg)

---

[^1]: 参见Aho，A.V.、J.E.Hopcroft和J.D.Ullman所著的《数据结构与算法》（Data Structures and Algorithms，Addison-Wesley出版社1983年出版）。其中有关于支持词典功能的数据结构的讨论。

[^2]: 2.8.3节曾经提出，左值和右值分别表示赋值左/右部。

[^3]: 类型名代表类型表达式，因此可能形成隐式的环，见“类型名和递归类型”部分。如果到达类型名的边被重定向到该名字对应的类型表达式，那么得到的图中就可能因为存在递归类型而出现环。

[^4]: 在C或C++中，如果所有的指针具有相同的宽度，那么指针的存储分配就比较简单。其原因是我们可以在知道它所指向对象的类型之前就为它分配存储空间。

[^5]: 在语法制导定义中，gen构造出一条指令并返回它。在翻译方案中，gen构造出一条指令，并增量地将它添加到指令流中去。

[^6]: 即使我们在确定类型时需要某些上下文信息，我们仍将使用“综合”这个术语。使用重载函数时（多个函数可能被赋予同一个名字），在某些语言中，我们还需要考虑E1+E2的上下文才能确定其类型规则。

[^7]: 在有些应用中，对一个变量和一个包含该变量的表达式进行合一是错误的。算法6.19允许这种替换。

[^8]: 如果严格地按照上面的语义规则来实现，这些语义规则将产生很多标号，并可能在一个三地址指令上附加多个标号。6.7节中介绍的回填技术只在必要的时候创建标号。处理这个问题的另一种方法是在后续的优化步骤中消除不必要的标号。

[^9]: 在C和Java中，表达式中可能包含赋值语句，因此即使B.true和B.false都为fall，也必须为子表达式E1和E2生成代码。如果必要，无用代码可以在优化阶段被清除。
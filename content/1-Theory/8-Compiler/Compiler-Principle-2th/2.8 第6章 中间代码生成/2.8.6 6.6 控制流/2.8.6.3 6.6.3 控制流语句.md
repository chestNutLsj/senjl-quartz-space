### 6.6.3　控制流语句

现在我们考虑在按下列文法生成的语句的上下文中，如何把布尔表达式翻译成为三地址代码。

S→ if（B）S1

S→ if（B）S1 else S2

S→ while（B）S1

在这些产生式中，非终结符号B表示一个布尔表达式，非终结符号S表示一个语句。

这个文法将例5.19中介绍的关于while表达式的连续使用的例子进行了推广。和那个例子一样，B和S有综合属性code，该属性给出了翻译得到的三地址指令。为简单起见，我们使用语法制导定义来构造得到翻译结果B.code和S.code，结果值是字符串。定义了code属性的语义规则还可以按照下面的方法实现：首先构造语法树，并在遍历树的过程中产生目标代码。这些规则还可以通过5.5节中列出的任何方法来实现。

如图6-35a所示，对if（B）S1的翻译结果中包含了B.code，其后是S1.code。B.code中存在基于B值的跳转。如果B为真，控制流转向S1.code的第一条指令；如果B为假，控制流立即转向紧跟在S1.code之后的指令。

![273-1](../Images/image04432.jpeg)

图6-35　if、if-else、while语句的代码

B.code和S.code中的跳转标号使用继承属性来处理。我们将布尔表达式B和两个标号：B.true和B.false相关联。当B为真时控制流转到B.true；当B为假时控制流转到B.false。我们将语句S和继承属性S.next相关联，这个属性表示紧跟在S代码之后的指令的标号。在某些情况下，紧跟在S.code之后的指令是一个跳转到某个标号L的跳转指令。使用S.next可以避免在S.code中出现这样的一个跳转指令，它的目标又是一个以L为目标的跳转指令。

图6-36和图6-37给出的语法制导定义可以为在if、if-else及while语句的上下文中的布尔表达式生成三地址代码。

![273-2](../Images/image04433.jpeg)

图6-36　控制流语句的语法制导定义

我们假定每次调用newlabel()都会产生一个新的标号，并假设label（L）将标号L附加到即将生成的下一条三地址指令上[^8]。

一个程序包含一条由产生式P→S生成的语句。和这个产生式关联的语义规则将S.next初始化为一个新标号。P.code包含S.code，S.code之后是新标号S.next。产生式S→assign中的词法单元assign是一个表示赋值语句的占位符。赋值语句的翻译和6.4节中讨论的方法相同。在这里对控制流的讨论中，S.code就是assign.code。

在翻译S→if（B）S1时，图6-36中的语义规则创建一个新的标号B.true，并将其关联到为语句S1生成的第一条三地址指令中，如图6-35a所示。因此，B的代码中跳转到B.true的指令将跳转到语句S1对应的代码处。不仅如此，通过将B.false设为S.next，我们保证了当B的值为假时，控制流将跳过S1的代码。

在翻译if-else语句S→if（B）S1 else S2时，布尔表达式B的代码中有一些向外跳转的指令，它们在B为真时跳转到S1的代码的第一条指令；在B为假时跳转到S2的代码的第一条指令，如图6-35b所示。然后，控制流从S1或S2转到紧跟在S的代码之后的三地址指令——该指令的标号由继承属性S.next指定。在S1的代码之后有一条goto S.next指令，使得控制流越过S2的代码。S2的代码之后不需要goto语句，因为S2.next就是S.next。

如图6-35c所示，S→while（B）S1的代码由B.code和S1.code组成。我们使用一个局部变量begin来存放附加在这个while语句的第一条指令上的标号。这个while语句的第一条指令也是B的第一条指令。我们在这里使用变量而不是属性，是因为begin对于这个产生式的语义规则而言是局部的。继承属性S.next标记了当B为假时控制流必须转向的标号。因此，B.false被设置为S.next。在S1的第一条指令上附加了一个新标号B.true。B的指令中的跳转指令在B为真时跳转到这个标号。我们在S1的代码之后放置了一条指令`goto` begin，它跳回到布尔表达式的代码的开始处。请注意，S1.next被设置为标号begin，因此从S1.code中跳出的指令可以直接跳转到begin。

S→S1S2的代码包含了S1的代码，然后是S2的代码。相应的语义规则主要处理标号。S1的代码之后的第一条指令就是S2的代码的起始指令。紧跟在S2的代码之后的指令也是跟在S的代码之后的指令。

我们将在6.7节中进一步讨论控制流语句的翻译。在那里我们将使用另一种被称为回填的方法，它可以在一次扫描中生成各个语句的代码。
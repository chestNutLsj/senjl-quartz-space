### 6.6.4　布尔表达式的控制流翻译

图6-37中针对布尔表达式的语义规则是图6-36中语句的语义规则的一个补充。如图6-35中的代码布局方案所示，一个布尔表达式B被翻译为一个三地址指令，它将使用条件或无条件跳转指令来对B求值。这些跳转指令的目标是两个标号之一：当B为真时是B.true；当B为假时是B.false。

![275-1](../Images/image04434.jpeg)

图6-37　为布尔表达式生成三地址代码

图6-37中的第四个产生式，即B→E1 rel E2，直接被翻译成三地址比较指令，跳转到正确的位置。例如，a<b被翻译成：

![274-1](../Images/image04435.jpeg)

B的其余产生式按照下面的方法翻译：

1）假定B形如B1‖B2。如果B1为真，那么我们立刻知道B本身也为真，因此B1.true和B.true相同。如果B1为假，那么就必须对B2求值，因此我们将B1.false设置为B2的代码的第一条指令的标号。B2的真假出口分别等于B的真假出口。

2）B1&&B1的翻译方法类似于1。

3）不需要为B→！B1产生新的代码，只需要将B中的真假出口对换，就可分别得到B1的真假出口。

4）将常量true和false分别翻译成目标为B.true和B.false的跳转指令。

例6.22　重新考虑例6.21中的下列语句：

`if（x<100 ‖ x>200 && x！=y）x=0；`　（6.13）

使用图6-36和图6-37中的语法制导定义，我们可以得到图6-38中的代码。

![275-2](../Images/image04436.jpeg)

图6-38　一个简单的if语句的控制流翻译结果

语句（6.13）是图6-36中的产生式P→S生成的一个程序。这个产生式的语义规则生成了S的代码之后的第一条指令的新标号L1。语句S的形式为if（B）S1，其中S1是x=0。因此，图6-36中的规则生成了一个新标号L2，并将它附加到S1.code的第一条（在这个例子中也是唯一的）指令，即x=0处。

因为‖的优先级低于&&，所以式（6.13）中的布尔表达式的形式为B1‖B2，其中B1是x<100。按照图6-37中的规则，B1.true是L2，即语句x=0的标号；B1.false是一个新的标号L3，它附加在B2的代码的第一条指令上。

值得注意的是，生成的代码不是最优的，因为这个翻译结果比例6.21中的代码多三条（goto）指令。指令`goto L3`是冗余的，因为L3恰巧就是下一条指令的标号。如果像例6.21中那样使用`ifFalse`指令，而不使用if指令，那么两条`goto L1`指令也可以被消除。
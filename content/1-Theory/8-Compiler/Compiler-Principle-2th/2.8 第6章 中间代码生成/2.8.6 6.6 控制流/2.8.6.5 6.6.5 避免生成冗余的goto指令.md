### 6.6.5　避免生成冗余的goto指令

在例6.22中，比较表达式x>200被翻译成如下代码片段：

![276-1](../Images/image04437.jpeg)

可以将上面的指令替换为如下指令：

![276-2](../Images/image04438.jpeg)

`ifFlase`指令利用了控制流在指令序列中会从一个指令自然流动到下一个指令的性质，因此当x>200时，控制流直接“穿越”到标号L4，从而减少了一个跳转指令。

在图6-35中所示的if和while语句的代码布局中，S1的代码紧跟在布尔表达式B的代码之后。通过使用一个特殊标号“fall”（即“不要生成任何跳转指令”），我们可以修改图6-36和图6-37中的语义规则，支持控制流从B的代码直接穿越到S1的代码。图6-36中的产生式S→if（B）S1；的新语义规则将B.true设为fall：

![276-3](../Images/image04439.jpeg)

类似地，if-else和while语句的规则也将B.true设为fall。

现在我们将修改布尔表达式的语义规则，使之尽可能地允许控制流穿越。在B.true和B.false都是显式的标号时，也就是说它们都不等于fall时，图6-39中的B→E1 rel E2的新规则将产生两条指令（和图6-37一样）。否则，如果B.true是显式的标号，那么B.false一定是fall，因此它们产生一条`if`指令，使得当条件为假时控制流穿越到下一条指令。反过来，如果B.false是显式的标号，那么它们产生一条`ifFalse`指令。在其余情况中，B.true和B.false都是fall，因此不产生任何跳转指令[^9]。

![276-4](../Images/image04440.jpeg)

图6-39　B→E1 rel E2的语义规则

在图6-40中显示的B→B1‖B2的新规则中，请注意B的fall标号和B1的fall标号具有不同的含义。假定B.true为fall，即如果B为真时控制流穿越B。虽然当B1为真时B的值必然为真，但B1.true必须保证控制流跳过B2的代码，直接到达B之后的下一条指令。

![276-5](../Images/image04441.jpeg)

图6-40　B→B1‖B2的语义规则

另一方面，如果B1的值为假，B的真假值就由B2的值决定。因此，图6-40中的规则保证B1.false对应于控制流穿越B1直接到达B2的代码的情况。

B→B1&&B2的语义规则和图6-40中的语义规则类似，我们将其留作练习。

例6.23　使用了特殊标号fall的语义规则将例6.21中的程序（6.13）

`if（x<100 ‖ x>200 && x！=y）x=0；`

翻译成图6-41所示的代码。

![277-1](../Images/image04442.jpeg)

图6-41　使用控制流穿越技术翻译的if语句

和例6.22一样，产生式P→S的语义规则创建标号L1。和例6.22不同的是，当应用B→B1‖B2的语义规则时，继承属性B.true是fall（B.false为L1）。图6-40中的规则创建一个新标号L2，使得当B1为真时有一个跳转指令可以跳过B2的代码。因此，B1.true为L2而B1.false为fall，因为B1为假时必须计算B2的值。

当开始处理生成了表达式x<100的产生式B→E1 rel E2时，B.true=L2且B.false=fall。图6-39中的规则使用这些继承到的标号生成了一条指令`if x<100 goto L2。`
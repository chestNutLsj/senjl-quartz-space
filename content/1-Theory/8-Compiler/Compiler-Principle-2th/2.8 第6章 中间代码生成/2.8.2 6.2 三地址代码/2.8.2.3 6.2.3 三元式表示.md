### 6.2.3　三元式表示

一个三元式（triple）只有三个字段，我们分别称之为op、arg1和arg2。请注意，图6-10b中的result字段主要被用于临时变量名。使用三元式时，我们将用运算x op y的位置来表示它的结果，而不是用一个显式的临时名字表示。例如，在三元式表示中将直接用位置（0），而不是像图6-10b中那样用临时名字`t1`来表示对相应运算结果的引用。带有括号的数字表示指向相应三元式结构的指针。在6.1.2节中，位置或指向位置的编码被称为值编码。

三元式基本上和算法6.3中的结点范型等价。因此，表达式的DAG表示和三元式表示是等价的。当然这种等价关系仅对表达式成立，因为语法树的变体和三地址代码分别以完全不同的方式来表示控制流。

例6.7　图6-11中给出的语法树和三元式表示对应于图6-10中的三地址代码及四元式序列。在图6-11b给出的三元式表示中，复制语句`a=t5按照下列方式表示为一个三元式：在字段arg1中放置a，而在字段arg2`中放置三元式位置的值编码（4）。

![251-1](../Images/image04390.jpeg)

图6-11　a=b*-c+b*-c的表示

像x［i］=y这样的三元运算在三元式结构中需要两个条目。例如，我们可以把x和i置于一个三元式中，并把y置于另一个三元式中。类似的，我们可以把x=y［i］看成是两条指令t=y［i］和x=t，从而用三元式实现这个语句。其中的t是编译器生成的临时变量。请注意，实际上t是不会出现在三元式中的，因为在三元式结构中是通过相应三元式结构的位置来引用临时值的。

为什么我们需要复制指令？

如图6-10a所示，一个简单的翻译表达式的算法往往会为赋值运算生成复制指令。在该图中，我们将`t5`复制给`a`，而不是直接将`t2+t4`赋给`a`。通常，每个子表达式都会有一个它自己的新临时变量来存放运算结果。只有当处理赋值运算符=时，我们才知道将把整个表达式的结果赋到哪里。一个代码优化过程将会发现`t5`可以被替换为`a`。这个优化过程可能使用6.1.1节中描述的DAG作为中间表示形式。

在优化编译器中，由于指令的位置常常会发生变化，四元式相对于三元式的优势就体现出来了。使用四元式时，如果我们移动了一个计算临时变量t的指令，那些使用t的指令不需要做任何改变。而使用三元式时，对于运算结果的引用是通过位置完成的，因此如果改变一条指令的位置，则引用该指令的结果的所有指令都要做相应的修改。使用下面将要介绍的间接三元式时就不会出现这个问题。

间接三元式（indirect triple）包含了一个指向三元式的指针的列表，而不是列出三元式序列本身。例如，我们可以使用数组instruction按照适当的顺序列出指向三元式的指针。这样，图6-11b中的三元式序列就可以表示成为图6-12所示的形式。

![251-2](../Images/image04391.jpeg)

图6-12　三地址代码的间接三元式表示

使用间接三元式表示方法时，优化编译器可以通过对instruction列表的重新排序来移动指令的位置，但不影响三元式本身。在用Java实现时，一个指令对象的数组和间接三元式表示类似，因为Java将数组元素作为对象引用来处理。
### 6.2.1　地址和指令

三地址代码基于两个基本概念：地址和指令。按照面向对象的说法，这两个概念对应于两个类，而各种类型的地址和指令对应于相应的子类。另一种方法是用记录的方式来实现三地址代码，记录中的字段用来保存地址。6.2.2节将简要介绍被称为四元式和三元式的记录表示方式。

地址可以具有如下形式之一：

- 名字。为方便起见，我们允许源程序的名字作为三地址代码中的地址。在实现中，源程序名字被替换为指向符号表条目的指针。关于该名字的所有信息均存放在该条目中。
- 常量。在实践中，编译器往往要处理很多不同类型的常量和变量。6.5.2节将考虑表达式中的类型转换问题。
- 编译器生成的临时变量。在每次需要临时变量时产生一个新名字是必要的，在优化编译器中更是如此。当为变量分配寄存器的时候，我们可以尽可能地合并这些临时变量。

下面我们介绍本书的其余部分常用的几种三地址指令。改变控制流的指令将使用符号化标号。每个符号化标号表示指令序列中的一条三地址指令的序号。通过一次扫描，或者通过回填技术就可以把符号化标号替换为实际的指令位置。回填技术将在6.7节中讨论。下面给出几种常见的三地址指令形式：

1）形如x=y op z的赋值指令，其中op是一个双目算术符或逻辑运算符。x、y、z是地址。

2）形如x=op y的赋值指令，其中op是单目运算符。基本的单目运算符包括单目减、逻辑非和转换运算。将整数转换成浮点数的运算就是转换运算的一个例子。

3）形如x=y的复制指令，它把y的值赋给x。

4）无条件转移指令goto L，下一步要执行的指令是带有标号L的三地址指令。

5）形如`if` x `goto` L或`if False` x `goto` L的条件转移指令。分别当x为真或为假时，这两个指令的下一步将执行带有标号L的指令。否则下一步将照常执行序列中的后一条指令。

6）形如`if` x relop y `goto` L的条件转移指令。它对x和y应用一个关系运算符（<、==、>=等）。如果x和y之间满足relop关系，那么下一步将执行带有标号L的指令，否则将执行指令序列中跟在这个指令之后的指令。

7）过程调用和返回通过下列指令来实现：`param` x进行参数传递，`call` p，n和y=`call` p，n分别进行过程调用和函数调用；`return` y是返回指令，其中y表示返回值，该指令是可选的。这些三地址指令的常见用法见下面的三地址指令序列

![249-1](../Images/image04386.jpeg)

它是过程p（x1，x2，…，xn）的调用的一部分。“`call` p，n”中的n是实在参数的个数。这个n并不是冗余的，因为存在嵌套调用的情况。也就是说，前面的一些`param`语句可能是p返回之后才执行的某个函数调用的参数，而p的返回值又成为这个后续函数调用的另一个参数。过程调用的实现将在6.9节中加以介绍。

8）带下标的复制指令x=y［i］和x［i］=y。x=y［i］指令将把距离位置y处i个内存单元的位置中存放的值赋给x。指令x［i］=y将距离位置x处i个内存单元的位置中的内容设置为y的值。

9）形如x=&y、x=*y或*x=y的地址及指针赋值指令。指令x=&y将x的右值设置为y的地址（左值）[^2]。这个y通常是一个名字，也可能是一个临时变量。它表示一个诸如`A［i］［j］`这样具有左值的表达式。x是一个指针名字或临时变量。在指令x=*y中，假定y是一个指针，或是一个其右值表示内存位置的临时变量。这个指令使得x的右值等于存储在这个位置中的值。最后，指令*x=y则把y的右值赋给由x指向的目标的右值。

例6.5　考虑语句

![249-3](../Images/image04387.jpeg)

图6-9给出了这个语句的两种可能的翻译。在图6-9a的翻译中，第一条指令上附加了一个符号化标号L。图6-9b中的翻译显示了每条指令的位置号，我们在图中选择以100作为开始位置。在两种翻译中，最后一条指令都是目标为第一条指令的条件转移指令。乘法运算`i*8`适用于每个元素占8个存储单元的数组。

![249-2](../Images/image04388.jpeg)

图6-9　给三地址指令指定标号的两种方法

选择使用哪些运算符是中间表示形式设计的一个重要问题。显然，这个运算符集合中的运算符要足够丰富，以便实现源语言中的所有运算。接近机器指令的运算符可以使在目标机器上实现中间表示形式更加容易。然而，如果前端必须为某些源语言运算生成很长的指令序列，那么优化器和代码生成器就需要花费更多的时间去重新发现程序的结构，然后才能为这些运算生成高质量的目标代码。
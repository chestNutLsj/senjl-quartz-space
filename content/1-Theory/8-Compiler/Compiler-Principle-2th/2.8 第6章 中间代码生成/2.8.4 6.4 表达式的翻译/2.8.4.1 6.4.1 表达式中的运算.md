### 6.4.1　表达式中的运算

图6-19中的语法制导定义使用S的属性code以及表达式E的属性addr和code，为一个赋值语句S生成三地址代码。属性S.code和E.code分别表示S和E对应的三地址代码。属性E.addr则表示存放E的值的地址。回忆一下6.2.1节，一个地址可以是变量名字、常量或编译器产生的临时量。

![258-2](../Images/image04407.jpeg)

图6-19　表达式的三地址代码

考虑图6-19中语法制导定义的最后一个产生式E→id。若表达式只是一个标识符，比如说x，那么x本身就保存了这个表达式的值。这个产生式对应的语义规则把E.addr定义为指向该id的实例对应的符号表条目的指针。令top表示当前的符号表。当函数top.get被应用于id的这个实例的字符串表示id.lexeme时，它返回对应的符号表条目。E.code被设置为空串。

当规则为E→（E1）时，对E的翻译与对子表达式E1的翻译相同。因此，E.addr等于E1.addr，E.code等于E1.code。

图6-19中的运算符+和单目-是典型语言中的运算符的代表。E→E1+E2的语义规则生成了根据E1和E2的值计算E的值的代码。计算得到的值存放在新生成的临时变量中。如果E1的值计算后被放入E1.addr，E2的值被放到E2.addr中，那么E1+E2就可以被翻译为t=E1.addr+E2.addr，其中t是一个新的临时变量。E.addr被设为t。连续执行new Temp()会产生一系列互不相同的临时变量t1，t2，…。

为方便起见，我们使用记号gen（x ′=′ y′+′ z）来表示三地址指令x=y+z。当被传递给gen时，变量x、y、z的位置上出现的表达式将首先被求值，而像′=′这样的引号内的字符串则按照字面值传递[^5]。其他的三地址指令的生成方法类似，也是将gen作用于表达式和字符串的组合。

当我们翻译产生式E→E1+E2时，图6-19中的语义规则首先将E1.code和E2.code连接起来，然后再加上一条将E1和E2的值相加的指令，从而生成E.code。新增加的这条指令将求和的结果放入一个为E生成的临时变量中，用E.addr表示。

产生式E→-E1的翻译过程与此类似。这个规则首先为E创建一个新的临时变量，并生成一条指令来执行单目-运算。

最终，产生式S→id =E；所生成的指令将表达式E的值赋给标识符id。和规则E→id中一样，这个产生式的语义规则使用函数top.get来确定id所代表的标识符的地址。S.code包含的指令首先计算E的值并将其保存到由E.addr指定的地址中，然后再将这个值赋给这个id实例的地址top.get（id.lexeme）。

例6.11　图6-19中的语法制导定义将赋值语句`a=b+-c`；翻译成如下的三地址代码序列：

![259-1](../Images/image04408.jpeg)
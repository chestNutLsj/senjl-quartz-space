### 6.4.3　数组元素的寻址

将数组元素存储在一块连续的存储空间里就可以快速地访问它们。在C和Java中，一个具有n个元素的数组中的元素是按照0，1，…，n-1编号的。假设每个数组元素的宽度是w，那么数组A的第i个元素的开始地址为

base+i×w　（6.2）

其中base是分配给数组A的内存块的相对地址。也就是说，base是A［0］的相对地址。

式（6.2）可以被推广到C语言中的二维或多维数组上。对于二维数组，我们在C中用A［i1］［i2］来表示第i1行的第i2个元素。假设一行的宽度是w1，同一行中每个元素的宽度是w2。A［i1］［i2］的相对地址可以使用下面的公式计算

base+i1×w1+i2×w2　（6.3）

对于k维数组，相应的公式为

base+i1×w1+i2×w2+…+ik×wk　（6.4）

其中，wj（1≤j≤k）是对式（6.3）中的w1和w2的推广。

另一种计算数组引用的相对地址的方法是根据第j维上的数组元素的个数nj和该数组的每个元素的宽度w=wk进行计算。在二维数组中（即k=2，w=w2），A［i1］［i2］的地址为

base+（i1×n2+i2）×w　（6.5）

对于k维数组，下列公式计算得到的地址和公式（6.4）所得到的地址相同：

base+（（…（（i1×n2+i2）×n3+i3）…）×nk+ik）×w　（6.6）

在更一般的情况下，数组元素下标并不一定是从0开始的。在一个一维数组中，数组元素的编号方式如下：low，low+1，…，high，而base是A［low］的相对地址。计算A［i］的地址的式（6.2）就变成：

base+（i-low）×w　（6.7）

式（6.2）和式（6.7）都可以改写成i×w+c的形式，其中的子表达式c=base-low×w可以在编译时刻预先计算出来。请注意，当low为0时c=base。我们假定c被存放在A对应的符号表条目中，那么只要把i×w加到c上就可以计算得到A［i］的相对地址。

编译时刻的预先计算同样可以应用于多维数组元素的地址计算，见练习6.4.5。然而，有一种情况下我们不能使用编译时刻预先计算的技术：当数组大小是动态变化的时候。如果我们在编译时刻无法知道low和high（或者它们在多维数组情况下的泛化）的值，我们就无法提前计算出像c这样的常量。因此在程序运行时，像（6.7）这样的公式就需要按照公式所写进行求值。

上面的地址计算是基于数组的按行存放方式的，C语言都使用这种数据布局方式。一个二维数组通常有两种存储方式，即按行存放（一行行地存放）和按列存放（一列列地存放）。图6-21显示了一个2×3的数组A的两种存储布局方式，图6-21a中是按行存放方式，图6-21b中是按列存放方式。Fortran系列语言使用按列存放方式。

![260-1](../Images/image04410.jpeg)

图6-21　二维数组的存储布局

我们可以把按行存放策略和按列存放策略推广到多维数组中。按行存放方式的推广形式按照如下方式来存储元素：当我们扫描一块存储区域时，就像汽车里程表中的数字一样，最右边的下标变化最为频繁。而按列存放方式则被推广为相反的布局方式，最左边的下标变化最频繁。
### 6.4.4　数组引用的翻译

为数组引用生成代码时要解决的主要问题是将6.4.3节中给出的地址计算公式和数组引用的文法关联起来。令非终结符号L生成一个数组名字再加上一个下标表达式的序列：

L → L［E］| id［E］

与C和Java中一样，我们假定数组元素的最小编号是0。我们使用式（6.4），基于宽度来计算相对地址，而不是像式（6.6）中那样使用元素的数量来计算地址。图6-22所示的翻译方案为带有数组引用的表达式生成三地址代码。它包括了图6-20中给出的产生式和语义动作，同时还包括了涉及非终结符号L的产生式。

![261-1](../Images/image04411.jpeg)

图6-22　处理数组引用的语义动作

非终结符号L有三个综合属性：

1）L.addr指示一个临时变量。这个临时变量将被用于累加公式（6.4）中的ij×wj项，从而计算数组引用的偏移量。

2）L.array是一个指向数组名字对应的符号表条目的指针。在分析了所有的下标表达式之后，该数组的基地址，也就是L.array.base，被用于确定一个数组引用的实际左值。

3）L.type是L生成的子数组的类型。对于任何类型t，我们假定其宽度由t.width给出。我们把类型（而不是宽度）作为属性，是因为无论如何类型检查总是需要这个类型信息。对于任何数组类型t，假设t.elem给出了其数组元素的类型。

产生式S→id=E；代表一个对非数组变量的赋值语句，它按照通常的方法进行处理。S→L=E；的语义动作产生了一个带下标的复制指令，它将表达式E的值存放到数组引用L所指的内存位置。回顾一下，属性L.array给出了数组的符号表条目。数组的基地址（即0号元素的地址）由L.array.base给出。属性L.addr表示一个临时变量，它保存了L生成的数组引用的偏移量。因此，这个数组引用的位置是L.array.base［L.addr］。这个指令将地址E.addr中的右值放入L的内存位置中。

产生式E→E1+E2和E→id与以前相同。新的产生式E→L的语义动作生成的代码将L所指位置上的值复制到一个新的临时变量中。和前面对产生式S→L=E；的讨论一样，L所指的地址就是L.array.base［L.addr］。其中，属性L.array仍然给出了数组名，L.array.base给出了数组的基地址。属性L.addr表示保存偏移量的临时变量。数组引用的代码将存放在由基地址和偏移量给出的位置中的右值放入E.addr所指的临时变量中。

例6.12　令`a`表示一个2×3的整数数组，`c、i、j`都是整数。那么`a`的类型就是aray（2，array（3，integer））。假定一个整数的宽度为4，那么`a`的类型的宽度就是24。`a［i］`的类型是array（3，integer），宽度w1为12。`a［i］［j］`的类型是整型。

图6-23给出了表达式`c+a［i］［j］`的注释语法分析树。该表达式被翻译成图6-24中给出的三地址代码序列。这里我们仍然使用每个标识符的名字来表示它们的符号表条目。

![262-1](../Images/image04412.jpeg)

图6-23　`c+a［i］［j］`的注释语法分析树

![262-2](../Images/image04413.jpeg)

图6-24　表达式`c+a［i］［j］`的三地址代码
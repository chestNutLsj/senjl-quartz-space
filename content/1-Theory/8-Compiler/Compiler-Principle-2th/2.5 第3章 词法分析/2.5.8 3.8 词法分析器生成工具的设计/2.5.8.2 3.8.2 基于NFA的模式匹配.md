### 3.8.2　基于NFA的模式匹配

如果词法分析器模拟了像一个图3-52所示的NFA，那么它必须从它的输入中lexemeBegin所指的位置开始读取输入。当它在输入中向前移动forward指针时，它在每个位置上根据算法3.22计算当前的状态集。

在这个模拟NFA运行的过程中，最终会到达一个没有后续状态的输入点。那时，不可能有任何更长的输入前缀使得这个NFA到达某个接受状态，此后的状态集将一直为空。于是，我们就可以判定最长前缀（与某个模式匹配的词素）是什么。

我们沿着状态集的顺序回头寻找，直到找到一个包含一个或多个接受状态的集合为止。如果集合中有多个接受状态，我们就选择和在Lex程序中位置最靠前的模式相关联的那个接受状态pi。我们将forward指针移回到词素末尾，同时执行与pi 相关联的动作Ai。

例3.27　假设我们有例3.26所示的模式，并且输入字符串以aaba开头。如果图3.52中的NFA从初始状态0的∈-闭包，即{0，1，3，7}，开始处理输入，那么它进入的状态集合的序列如图3-53所示。在读入第四个输入符号之后，我们处于一个空状态集中，因为在图3-52中没有在输入a上离开状态8的转换。

![122-1](../Images/image04121.jpeg)

图3-53　在处理输入aaba时进入的状态集的序列

因此，我们要向回寻找一个包含了某个接受状态的状态集。请注意，如图3-53所示，在读入a之后，我们所在的状态集包含状态2，这表明模式a已经被匹配。然而在读入aab之后，我们在状态8中，这表明模式a*b+被匹配；前缀aab是最长的使我们到达某个接受状态的前缀。因此我们选择aab作为被识别的词素，并且执行A3。这个动作应该包含一个返回语句，向语法分析器指明已经找到了一个模式为p3=a*b+的词法单元。
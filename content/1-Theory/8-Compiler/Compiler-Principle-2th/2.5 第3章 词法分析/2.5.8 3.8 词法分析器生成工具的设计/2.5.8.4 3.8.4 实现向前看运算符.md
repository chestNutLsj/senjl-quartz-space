### 3.8.4　实现向前看运算符

回顾3.5.4节可知，Lex模式r1/r2中的Lex向前看运算符/是必不可少的。因为有时为了正确地识别某个词法单元的实际词素，我们需要指明在这个词法单元的模式r1之后必须跟着模式r2。在将模式r1/r2转化成NFA时，我们把/看成∈，因此我们实际上不会在输入中查找/。然而，如果NFA发现输入缓冲区的一个前缀xy和这个正则表达式匹配时，这个词素的末尾并不在这个NFA进入接受状态的地方。实际上，这个末尾是在此NFA进入满足如下条件的状态s的地方：

1）s在（假想的）/上有一个∈转换。

2）有一条从NFA的开始状态到状态s（相应标号序列为x）的路径。

3）有一条从状态s到NFA的接受状态（相应标号序列为y）的路径。

4）在所有满足条件1～3的xy中，x尽可能长。

如果这个NFA中只有一个在假想的/上的∈转换状态，那么就如例3.30所示，词素的末尾出现在最后一次进入该状态的地方。如果NFA在假想的/上有多个∈转换状态，那么如何寻找正确的状态s的问题就会变得困难得多。

例3.30　图3-55的NFA识别例3.13中给出的`IF`模式。这个模式使用了向前看运算符。请注意，从状态2到状态3的∈转换就代表这个向前看运算符。状态6表明关键字IF的出现。然而，当进入状态6时，我们需要向回扫描到最晚出现的状态2才可以找到词素`IF`。

![123-1](../Images/image04123.jpeg)

图3-55　识别关键字`IF`的NFA

DFA中的死状态

从技术上讲，图3-54中的自动机并不是一个真正的DFA。因为DFA中的每个状态在它的输入字母表中的每个符号上都有一个离开转换。这里我们省略了到达死状态Ø的转换，并且我们也省略了从这个死状态出发、在所有输入符号上到达其自身的转换。前面的NFA到DFA转换的例子中不存在从开始状态到达Ø的路径，但是图3-52中的NFA有这样的路径。

然而，当我们构造一个用于词法分析器的DFA时，重要的是，我们必须用不同的方式来处理死状态，因为我们必须知道什么时候已经不可能识别到更长的词素了。因此我们建议省略到达死状态的转换，并消除死状态本身。实际上这个问题要比看起来困难一些，因为一个NFA到DFA 的构造过程可能会产生多个不可能到达接受状态的DFA状态。我们必须知道何时到达了一个这样的状态。3.9.6节讨论了如何将这些状态合并为一个死状态，这使得识别这些状态变得容易。还要指出的是，如果我们使用算法3.20和3.23根据一个正则表达式构造出一个DFA，那么得到在DFA中除Ø之外的所有状态都可到达某个接受状态。
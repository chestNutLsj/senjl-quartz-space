### 3.2.2　哨兵标记

如果我们采用上一节中描述的方案，那么在每次向前移动`forward`指针时，我们都必须检查是否到达了缓冲区的末尾。若是，那么我们必须加载另一个缓冲区。因此每读入一个字符，我们需要做两次测试：一次是检查是否到达缓冲区的末尾，另一次是确定读入的字符是什么（后者可能是一个多路分支选择语句）。如果我们扩展每个缓冲区，使它们在末尾包含一个“哨兵”（sentinel）字符，我们就可以把对缓冲区末端的测试和对当前字符的测试合二为一。这个哨兵字符必须是一个不会在源程序中出现的特殊字符，一个自然的选择就是字符eof。

图3-4显示的缓冲区安排与图3-3一致，只是加入了“哨兵标志”字符。请注意，eof仍然可以用来标记整个输入的结尾。任何不是出现在某个缓冲区末尾的eof都表示到达了输入的结尾。图3-5总结了前移`forward`指针的算法。请注意，我们在大部分情况下只需要进行一次测试就可以根据forward所指向的字符完成多路分支跳转。只有当我们确实处于缓冲区末尾或输入末尾时，才需要进行更多的测试。

![088-1](../Images/image04053.jpeg)

图3-4　各个缓冲区末端的“哨兵标记”

![088-2](../Images/image04054.jpeg)

图3-5　带有哨兵标记的forward指针移动算法
### 3.7.4　从正则表达式构造NFA

现在我们给出一个算法，它可以将任何正则表达式转变为接受相同语言的NFA。这个算法是语法制导的，也就是说它沿着正则表达式的语法分析树自底向上递归地进行处理。对于每个子表达式，该算法构造一个只有一个接受状态的NFA。

算法3.23　将正则表达式转换为一个NFA的McMaughton-Yamada-Thompson算法。

输入：字母表Σ上的一个正则表达式r。

输出：一个接受L（r）的NFA N。

方法：首先对r进行语法分析，分解出组成它的子表达式。构造一个NFA的规则分为基本规则和归纳规则两组。基本规则处理不包含运算符的子表达式，而归纳规则根据一个给定表达式的直接子表达式的NFA构造出这个表达式的NFA。

基本规则：对于表达式∈，构造下面的NFA。

![116-1](../Images/image04103.jpeg)

这里，i是一个新状态，也是这个NFA的开始状态；f是另一个新状态，也是这个NFA的接受状态。

对于字母表Σ中的子表达式a，构造下面的NFA。

![116-2](../Images/image04104.jpeg)

同样，i和f都是新状态，分别是这个NFA的开始状态和接受状态。请注意，在这两个基本构造规则中，对于∈或某个a的作为r的子表达式的每次出现，我们都会使用新状态分别构造出一个独立的NFA。

归纳规则：假设正则表达式s和t的NFA分别为N（s）和N（t）。

1）假设r=s|t，r的NFA，即N（r），可以按照图3-40中的方式构造得到。这里i和f是新状态，分别是N（r）的开始状态和接受状态。从i到N（s）和N（t）的开始状态各有一个∈转换，从N（s）和N（t）到接受状态f也各有一个∈转换。请注意，N（s）和N（t）的接受状态在N（r）中不是接受状态。因为从i到f的任何路径要么只通过N（s），要么只通过N（t），且离开i或进入f的∈转换都不会改变路径上的标号，因此我们可以判定N（r）识别L（s）∪L（t），也就是L（r）。也就是说，图3-40中的NFA是一个正确的处理并运算符的构造。

![116-3](../Images/image04105.jpeg)

图3-40　两个正则表达式的并的NFA

2）假设r=st，然后按照图3-41所示构造N（r）。N（s）的开始状态变成了N（r）的开始状态。N（t）的接受状态成为N（r）的唯一接受状态。N（s）的接受状态和N（t）的开始状态合并为一个状态，合并后的状态拥有原来进入和离开合并前的两个状态的全部转换。图3-41中一条从i到f的路径必须首先经过N（s），因此这条路径的标号以L（s）中的某个串开始。然后，这条路径继续通过N（t），因此这条路径的标号以L（t）中的某个串结束。就像我们很快要论证的，没有转换离开构造得到的接受状态，也没有转换进入开始状态，因此一个路径不可能在离开N（s）后再次进入N（s）。因此，N（r）恰好接受L（s）L（t），它是r=st的一个正确的NFA。

![116-4](../Images/image04106.jpeg)

图3-41　两个正则表达式的连接的NFA

3）假设r=s*，然后为r构造出图3-42所示的NFA N（r）。这里，i和f是两个新状态，分别是N（r）的开始状态和唯一的接受状态。要从i到达f，我们可以沿着新引入的标号为∈的路径前进，这个路径对应于L（s）0中的一个串。我们也可以到达N（s）的开始状态，然后经过该NFA，再零次或多次从它的接受状态回到它的开始状态并重复上述过程。这些选项使得N（r）可以接受L（s）1、L（s）2等集合中的所有串，因此N（r）识别的所有串的集合就是L（s）*。

![117-1](../Images/image04107.jpeg)

图3-42　一个正则表达式的闭包的NFA

4）最后，假设r=（s），那么L（r）=L（s），我们可以直接把N（s）当作N（r）。

算法3.23中描述的方法包含了一些提示，说明为什么这个归纳性构造方法能够得到正确的解答。我们不会给出正式的正确性证明。但除了最重要的性质，即N（r）接受语言L（r）之外，我们还在下面列出一些由该算法构造得到的NFA所具有的性质。这些性质本身也很有趣，并且有助于正式证明这个方法的正确性。

1）N（r）的状态数最多为r中出现的运算符和运算分量的总数的2倍。得出这个上界的原因是算法的每一个构造步骤最多只引入两个新状态。

2）N（r）有且只有一个开始状态和一个接受状态。接受状态没有出边，开始状态没有入边。

3）N（r）中除接受状态之外的每个状态要么有一条其标号为Σ中符号的出边，要么有两条标号为∈的出边。

例3.24　让我们用算法3.23为正则表达式r=（a|b）*abb构造一个NFA。图3-43显示了r的一棵语法分析树，这棵树和2.2.3节中构造的算术表达式的语法分析树相似。对于子表达式r1，即第一个a，我们构造如下的NFA：

![117-2](../Images/image04108.jpeg)

![117-4](../Images/image04109.jpeg)

图3-43　（a|b）*abb的语法分析树

我们在选择这个NFA中的状态编号时考虑了和接下来生成的NFA的状态编号之间的一致性。对r2构造如下NFA：

![117-3](../Images/image04110.jpeg)

现在我们可以使用图3-40中的构造方法，将N（r1）和N（r2）合并，得到r3 = r1|r2 的NFA。这个NFA显示在图3-44中。

子表达式r4 =（r3）的NFA和r3的NFA相同。子表达式r5=（r3）*的NFA的构造如图3-45所示。我们使用图3-42所示的方法根据图3-44中的NFA构造出这个NFA。

![117-5](../Images/image04111.jpeg)

图3-44　r3的NFA

![118-2](../Images/image04112.jpeg)

图3-45　r5的NFA

现在考虑r6，它是表达式中的另一个a。我们再次对a使用基本构造法，但是必须使用新的状态。虽然r1和r6是相同的表达式，但这个构造方法不允许我们复用那个为r1构造的NFA。r6的NFA如下：

![118-1](../Images/image04113.jpeg)

要得到r7 =r5r6的NFA，我们应用图3-41中的构造方法，将状态7和7’合并，得到如图3-46所示的NFA。按照这个方法继续构造出两个分别名为r8和r10、对应于子表达式b的新NFA，最后构造出如图3-34所示的（a|b）*abb的NFA。

![118-3](../Images/image04114.jpeg)

图3-46　rT的NFA
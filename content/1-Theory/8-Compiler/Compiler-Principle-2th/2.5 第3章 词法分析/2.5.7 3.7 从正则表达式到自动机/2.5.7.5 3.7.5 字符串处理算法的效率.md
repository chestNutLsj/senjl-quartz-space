### 3.7.5　字符串处理算法的效率

我们看到，算法3.18能在O（|x|）时间内处理字符串x，而在3.7.3节中我们提到，要模拟一个NFA的运行所需的时间与|x|和该NFA的转换图的大小的乘积成正比。很明显，用DFA来模拟比用NFA模拟更快，因此我们可能会怀疑模拟一个NFA到底有没有意义。

支持使用NFA模拟的论据之一是子集构造法在最坏的情况下可能会使状态个数呈指数增长。虽然原则上DFA的状态数不会影响算法3.18的运行时间，但是假如状态数大到一定程度，以至于转换表超过了主存容量时，那么真正的运行时间就必须加上磁盘读写时间，从而使运行时间显著增加。

例3.25　考虑形如Ln=（a|b）*a（a|b）n-1的正则表达式所描述的语言族。也就是说，每个语言Ln包含了所有由a和b组成且从右端向左数第n个符号是a的串。很容易构造出一个具有n+1个状态的NFA。它在任何输入符号上都可以停留在其初始状态，但是当输入为a时也可以到达状态1。在处于状态1时，它在任何输入符号上都会转到状态2，以此类推，当到达状态n时它接受输入串。图3-47给出了这个NFA。

![118-4](../Images/image04115.jpeg)

图3-47　一个NFA，它的状态数量远小于等价的最小DFA的状态数

然而，Ln的任何一个DFA都至少有2n个状态。我们不证明这个结论，只说明其基本思想。假设两个长度均为n的串到达DFA的同一个状态，必然存在一些位置使得两个串在这些位置上的符号不同（必然一个是a而另一个是b）。我们考虑最后一个这样的位置。我们可以不断把相同的符号同时添加到这两个串的后面，直到它们的最后n-1个位置上的符号串相同，但是倒数第n个位置上的符号不同。那么这个DFA在处理这两个（经过扩展的）符号串时会到达同一个状态（因为根据假设，此DFA在处理未经扩展的两个串时到达同一个状态，而对这两个串的扩展方法相同——译者注）。此时这个DFA要么同时接受这两个符号串，要么都不接受这两个符号串。（注意这两个符号串的倒数第n个符号是不同的，它们应该有且只有一个串在这个语言中，由此得出矛盾。这说明任意两个长度为n的不同符号串应该到达不同的状态。而长度为n的符号串共有2n个，也就是说至少要有2n个状态——译者注。）幸运的是，如我们前面提到的，词法分析很少需要处理这种类型的模式，我们也不用担心会遇到状态数量出奇多的DFA。

然而，词法分析器生成工具和其他字符串处理系统经常以正则表达式作为输入。我们面临着将正则表达式转换成DFA还是NFA的问题。转换成DFA的额外开销是在将算法3.20应用于转换得到的NFA而产生的开销（也可以将一个正则表达式直接转化为DFA，但工作量实质上是一样的）。如果字符串处理器被频繁使用，比如词法分析器，那么转换到DFA时付出的任何代价都是值得的。然而在另一些字符串处理应用中，例如grep，用户指定一个正则表达式，并在一个或多个文件中搜索这个表达式所描述的模式，那么跳过构造的DFA步骤直接模拟NFA可能更加高效。

现在我们考虑用算法3.23把正则表达式r转换成相应的NFA的代价。其关键步骤是构造r的语法分析树。在第4章中我们会看到几种可以在线性时间内构造语法分析树的方法，即在O（|r|）时间内完成语法分析树的构造，其中|r|表示r的大小，也就是r中运算符和运算分量的总和。我们也很容易发现每次应用算法3.23中的基本规则和归纳规则只需要常数时间，因此转换得到一个NFA所花费的全部时间是O（|r|）。

此外，如我们在3.7.4节中观察到的，构造得到的NFA最多有2|r|个状态和4|r|个转换。也就是说，根据3.7.3节中的分析，可以得到n≤2|r|和m≤4|r|。因此，模拟这个NFA处理输入字符串x的过程所花费时间是O（|r|×|x|）。这个时间远远超过构造NFA所用的时间O（|r|）。因此，我们得到，对于正则表达式r和字符串x，能够在O（|r|×|x|）时间内判断x是否属于L（r）。

子集构造法所花费的时间很大程度上取决于构造得到的DFA的状态数。首先注意在图3-22所示的子集结构法中，算法的关键步骤，即根据状态集T和输入符号a构建状态集U的过程与算法3.22的NFA模拟方法中根据旧状态集构造新状态集的过程类似。我们已经知道，如果实现得当，这个步骤所花的时间最多和NFA状态数与转换数之和成正比。

假设我们要从一个正则表达式r开始，并将它构造成一个NFA。这个NFA最多有2|r|个状态和4|r|个转换，并且最多有2|r|个输入符号。因此，对于每个构造得到的DFA状态，我们最多必须构造|r|个新状态，构造每个新状态最多花费O（2|r|+4|r|）时间。因此，构造一个有s个状态的DFA所用的时间为O（|r|2s）。

在通常情况下，s大约等于|r|，上面的子集构造法需要的时间为O（|r|3）。然而，在如例3.25所示的最坏情况下，这个时间是O（|r|22|r|）。当我们需要构造一个识别器来指明一个或多个串x是否在一个给定的正则表达式r所定义的L（r）中时，我们有多个选项。图3-48对这些选项作了总结。

![119-1](../Images/image04116.jpeg)

图3-48　识别一个正则表达式所表示的语言的不同方法所具有的初始开销和单个串的开销

如果处理各个字符串所花的时间多很多，比如我们构造词法分析器时面临的情况，我们显然倾向于使用DFA。然而，在像grep这样的命令中，我们只会对一个符号串运行这个自动机。此时我们通常倾向于使用NFA方式。只有当|x|接近|r|3的时候，我们才会考虑转换到DFA。

还有一种混合策略可以做到对每个正则表达式r和输入串x，它的效率总是和DFA和NFA方法中较好的一个差不多。这个策略从模拟NFA开始，但是在计算出各个状态集（也就是DFA的状态）和转换的同时把它们记录下来。在模拟中每次处理此NFA的当前状态集合和当前输入符号之前，首先查看我们是否已经计算了这个转换。如果是，就直接使用这个信息。
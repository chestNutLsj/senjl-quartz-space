### 3.7.3　NFA模拟的效率

如果精心实现，算法3.22可以相当高效。因为这些高效实现的思想可以用于许多涉及图搜索的算法。我们将更详细地介绍这个实现。我们需要的数据结构包括：

1）两个堆栈，其中每一个堆栈都存放了一个NFA状态集合。其中的一个堆栈oldStates存放“当前状态集合”，即图3-37的第4行中右边的S的值。另一个堆栈newStates存放了“下一个”状态集合，即第4行中左边的S的值。在我们运行第3行到第6行的循环时，中间的一个步骤没有在图3-37中列出，即把newStates的值转移到oldStates中去的步骤。

2）一个以NFA状态为下标的布尔数组alreadyOn。它指示出哪个状态已经在newStates中。虽然这个数组存放的信息和栈中存放的信息相同，但查询alreadyOn［s］要比在栈newStates中查询s快很多。我们同时保持两种表示方法的原因就是为了获得这个效率。

3）一个二维数组move［s，a］，它保存这个NFA的转换表。这个表中的条目是状态的集合，它们用链表表示。

为了实现图3-37的第一行，我们需要将alreadyOn数组中的所有条目都设置为FALSE，然后对于∈-closure（s0）中的每个状态s，将s压入oldStates并设置alreadyOn［s］为`TRUE`。这个对状态s的操作以及图3-37第4行中的操作，都可以使用函数addState（s）来实现。这个函数将s压入newStates，将alreadyOn［s］设置为`TRUE`，并使用move［s，∈］作为参数递归地调用自身，继续计算∈-closure（s）的值。然而，为了避免重复工作，我们必须小心，不要对一个已经在栈newStates中的状态调用addState。图3-38给出了这个函数的概要。

![114-3](../Images/image04101.jpeg)

图3-38　加入一个不在newStates中的新状态s

我们通过查看oldStates中的每个状态s来实现图3-37的第4行。我们首先找出状态集合move［s，c］，其中c是下一个输入字符。对于那些不在newStates栈中的状态，我们应用函数addState。注意，addState还计算了一个状态的∈-closure值，并把其中的状态一起加入到newStates中（如果这些状态不存在的话）。这一系列处理步骤如图3-39所示。

![115-1](../Images/image04102.jpeg)

图3-39　图3-37中第4步的实现

假定一个NFA N 有n个状态和m个转换，即m是离开各个状态的转换数的总和。如果不包括第19行中对addState的调用，在第16行到第21行的循环上花费的时间是O（n）。也就是说，我们最多需要运行这个循环n遍，且如果不考虑调用addState所花费的时间，每一遍的工作量都是常数。对于第22行到第26行的循环，这个结论也成立。

在图3-39的一次执行中（即图3-37的第4行），对于任意给定的状态最多只能调用addState一次。原因在于每次调用addState（s）时都会在图3-38的第11行上把alreadyOn［s］置为`TRUE`。一旦alreadyOn［s］设为`TRUE`，图3-38的第13行和图3-39的第18行就会禁止再次调用addState（s）。

如果不考虑第14行中的递归调用所花费的时间，第10行、第11行对addState的一次调用所花的时间为O（1），第12、13行的时间取决于有多少∈转换离开s。对于一个给定的状态，我们不知道这个数目是多少，但是我们知道最多只有m个离开各个状态的转换。因此，在图3-39中代码的一次执行中，在第12行和13行上用于调用addState的累计时间为O（m）。花费在addState的其他步骤的累计时间为O（n），因为每一次调用的时间是一个常数，且最多只有n次调用。

因此我们可以得出如下结论，即只要实现方法得当，执行图3-37的第4行的时间是O（n+m）。从第3行到第6行的while循环的其余部分在每次迭代时花费O（1）时间。如果输入x的长度为k，那么该循环的总工作量为O（k（n+m））。图3-37的第1行的执行时间为O（n+m），因为它实际上就是图3-39中的各个步骤，只不过oldStates中只包含状态s0。第2、7、8行都花费O（1）时间。因此，如果实现正确，算法3.22的运行时间为O（k（n+m））。也就是说，该算法所需时间和输入串的长度和转换图的大小（结点数加上边数）的乘积成正比。

大O表示法

形如O（n）的表达式是“最多某个常数乘以n”的缩写。从技术上讲，我们说一个函数f（n）是O（g（n））的条件是存在常量c和n0使得当n≥n0时必然有f（n）≤cg（n）。这里的f（n）可能是一个算法的某些步骤的运行时间。一个有用的写法是“O（1）”，它表示“某个常量”。使用大O表示法可以使得我们不需要过多地考虑使用什么样的运行时间单位来进行度量，而仍然可以表示一个算法的运行时间的增长速度。
### 3.4.4　基于状态转换图的词法分析器的体系结构

有几种方法可以根据一组状态转换图构造出一个词法分析器。不管整体的策略是什么，每个状态总是对应于一段代码。我们可以想象有一个变量`state`保存了一个状态转换图的当前状态的编号。有一个switch语句根据`state`的值将我们转到对应于各个可能状态的相应代码段，我们可以在那里找到该状态需要执行的动作。一个状态的代码本身常常也是一条switch语句或多路分支语句。这个语句读入并检查下一个输入字符，由此确定下一个状态。

例3.10　在图3-18中，我们可以看到`getRelop()`方法的一个概述。它是一个C++函数，其任务是模拟图3-13中的状态转换图，并返回一个TOKEN类型的对象。该对象由一个词法单元名（在该例中必定是relop）和一个属性值（在该例中是6个比较运算符之一的编码）组成。函数`getRelop()`首先创建一个新的对象`retToken`，并将该对象的第一个分量初始化为`RELOP`，即词法单元relop的编码。

在case 0中，我们可以看到一个典型的状态行为。函数`nextChar()`从输入中获取下一个字符，并将它赋给局部变量c。然后我们检查c是否为我们期望找到的三个字符，并在每种情况下根据图3-13所示的状态转换图完成状态转换。例如，如果下一输入字符是=，那么就转换到状态5。

如果下一个输入字符不是某个比较运算符的首字符，`getRelop()`就会调用函数`fail()`。函数`fail()`的具体操作依赖于词法分析器的全局错误恢复策略。它应该将`forward`指针重置为`lexemeBegin`的值，使得我们可以使用另一个状态转换图从尚未处理的输入部分的真实开始位置开始识别。然后，它还需要将变量`state`的值改为另一状态转换图的初始状态，该转换图将寻找另一个词法单元。在另一种情况下，如果所有的转换图都已经用过，则`fail()`可以启动一个错误纠正步骤，按照3.1.4节中讨论的方法来纠正输入并找到一个词素。

在图3-18中，我们还展示了状态8的行为。由于状态8带有一个*号，我们必须将输入指针回退一个位置（也就是把c放回输入流）。该任务由函数`retract()`完成。因为状态8代表了对词素>的识别，我们把返回对象中的第二个分量设置成GT，即这个运算符的编码。我们假设这个分量的名字是`attribute`。

![100-1](../Images/image04073.jpeg)

图3-18　relop的转换图的概要实现

为了在适当的地方模拟适当的状态转换图，我们考虑几种将如图3-18所示的代码集成到整个词法分析器中的方法。

1）我们可以让词法分析器顺序地尝试各个词法单元的状态转换图。然后，在每次调用例3.10中的函数`fail()`时，它重置`forward`指针并启动下一个状态转换图。这个方法使我们可以像图3-15中所建议的那样，为各个关键字使用各自的状态转换图。我们只需要在使用id的状态转换图之前使用这些关键字的转换图，就可以使得关键字被识别为保留字。

2）我们可以“并行地”运行各个状态转换图，将下一个输入字符提供给所有的状态转换图，并使得每个状态转换图作出它应该执行的转换。如果我们采用这个策略，就必须谨慎地解决如下的问题：一个状态转换图已经找到了一个与它的模式相匹配的词素，但另外的一个或多个状态转换图仍然可以继续处理输入。解决这个问题的常见策略是取最长的和某个模式相匹配的输入前缀。举例来说，该规则让我们识别出标识符thenext而不是关键字then，识别出->而不是-。

3）有一个更好的方法，也是我们将在下面各节中采用的方法，就是将所有的状态转换图合并为一个图。我们允许合并后的状态转换图尽量读取输入，直到不存在下一个状态为止；然后像上面的2中讨论的那样取最长的和某个模式匹配的最长词素。在我们的例子中，进行这种合并很简单，因为没有两个词法单元以相同的字符开头。也就是说，根据第一个字符就可以知道我们正在寻找的是哪个词法单元。因此，我们可以直接将状态0、9、12及22合并成一个开始状态，并保持其他转换不变。但一般而言，正如我们不久将看到的那样，合并几个词法单元的状态转换图的问题会更加复杂。
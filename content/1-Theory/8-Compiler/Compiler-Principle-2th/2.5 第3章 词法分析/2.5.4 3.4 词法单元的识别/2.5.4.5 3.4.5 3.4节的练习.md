### 3.4.5　3.4节的练习

练习3.4.1：给出识别练习3.3.2中各个正则表达式所描述的语言的状态转换图。

练习3.4.2：给出识别练习3.3.5中各个正则表达式所描述的语言的状态转换图。

从下面的练习开始到练习3.4.12介绍了Aho-Corasick算法。该算法可以在文本串中识别一组关键字，所需时间和文本长度以及所有关键字的总长度成正比。该算法使用了一种称为“trie”的特殊形式的状态转换图。trie是一个树型结构的状态转换图，从一个结点到它的各个子结点的边上有不同的标号。Trie的叶子结点表示识别到的关键字。

Knuth、Morris和Pratt提出了一种在文本串中识别单个关键字b1b2…bn的算法。这里的trie是一个包含了从0～n共n+1个状态的状态转换图。状态0是初始状态，状态n表示接受，也就是发现关键字的情形。从0到n-1之间的任意一个状态s出发，存在一个标号为bs+1的到达状态s+1的转换。例如，关键字`ababaa`的trie树为：

![101-1](../Images/image04074.jpeg)

为了快速处理文本串并在这些串中搜索一个关键字，针对关键字b1b2…bn以及该关键字中的位置s（对应于关键字的trie中的状态s）定义失效函数f（s），该函数的计算方法如图3-19所示。

![102-1](../Images/image04075.jpeg)

图3-19　计算关键字b1b2…bn的失效函数的算法

该函数的目标是使得b1b2…bf（s）是最长的既是b1b2…bs的真前缀又是b1b2…bs的后缀的子串。f（s）之所以重要，原因在于如果我们试图用一个文本串匹配b1b2…bn，并且我们已经匹配了前s个位置，但此时匹配失败（也就是说文本串的下一个位置并不是bs+1），那么f（s）就是可能和以我们的当前位置为结尾的文本串相匹配的最长的b1b2…bn的前缀。当然，文本串的下一个字符必须是bf（s）+1，否则仍然有问题，必须考虑一个更短的前缀，即bf（f（s））。

看一个例子，根据`ababaa`构造的trie的失效函数是：

![101-2](../Images/image04076.jpeg)

例如，状态3和1分别表示前缀`aba`以及`a`。因为`a`是最长的既是`aba`的真前缀，同时也是`aba`的后缀的串，因此f（3）=1。同样，因为最长的既是`ab`的真前缀又是它的后缀的字符串是空串，因此f（2）=0。

练习3.4.3：构造下列串的失效函数。

1）`abababaab`

2）`aaaaaa`

3）`abbaabb`

！练习3.4.4：对s进行归纳，证明图3-19的算法正确地计算出了失效函数。

！！练习3.4.5：说明图3-19中第4行的赋值语句t=f（t）最多被执行n次。进而说明整个算法的时间复杂度是O（n），其中n是关键字的长度。

计算得到关键字b1b2…bn的失效函数之后，我们就可以在O（m）时间内扫描字符串a1a2…am以判断该关键字是否出现在其中。图3-20中所展示的算法使关键字沿着被匹配字符串滑动，不断尝试将关键字的下一个字符与被匹配字符串的下一个字符匹配，逐步推进。如果在匹配了s个字符后无法继续匹配，那么该算法将关键字“向右滑动”s-f（s）个位置，也就是认为只有该关键字的前f（s）个字符和被匹配字符串匹配。

练习 3.4.6：应用KMP算法判断关键字`ababaa`是否为下面字符串的子串：

1）`abababaab`

2）`abababbaa`

！！练习 3.4.7：说明图3-20中的算法可以正确地指出输入关键字是否为一个给定字符串的子串。提示：对i进行归纳。说明对于所有的i，在第四行运行后s的值是那些既是a1a2…ai的后缀又是该关键字的前缀的字符串中最长字符串的长度。

![102-2](../Images/image04077.jpeg)

图3-20　KMP算法在O（m+n）时间内检测字符串a1a2…am 中是否包含单个关键字b1b2…bn

！！练习 3.4.8：假设已经计算得到函数f且它的值存储在一个以s为下标的数组中，说明图3-20中算法的时间复杂度为O（m+n）。

练习 3.4.9：Fibonacci字符串的定义如下：

1）s1＝`b`。

2）s2＝`a`。

3）当k>2时，sk=sk-1sk-2。

例如，s3=`ab`，s4=`aba`，s5=`abaab`。

1）sn的长度是多少？

2）构造s6的失效函数。

3）构造s7的失效函数。

！！4）说明任何sn的失效函数都可以被表示为：f（1）=f（2）=0，且对于2<j≤|sn|，f（j）=j-sk-1，其中k是使得|sk|≤j+1的最大的整数。

！！5）在KMP算法中，当我们试图确定关键字sk是否出现在字符串sk+1中时，最多会连续多少次调用失效函数？

Aho和Corasick对KMP算法进行了推广，使它可以在一个文本串中识别一个关键字集合中的任何关键字。在这种情况下，trie是一棵真正的树，从其根结点开始就会出现分支。如果一个字符串是某个关键字的前缀（不一定是真前缀），那么在trie中就有一个和该字符串对应的状态。串b1b2…bk-1对应的状态是串b1b2…bk对应的状态的父结点。如果一个状态对应于某个完整的关键字，那么该状态就是接受状态。例如，图3-21显示了对应于关键字`he、she、his`和`hers`的trie树。

![103-1](../Images/image04078.jpeg)

图3-21　关键字`he、she、his`和`hers`的trie树

通用trie树的失效函数的定义如下。假设s是对应于串b1b2…bn的状态，那么状态f（s）对应于最长的、既是串b1b2…bn的后缀又是某个关键字的前缀的字符串。例如，图3-21中trie树的失效函数为：

![103-2](../Images/image04079.jpeg)

！练习 3.4.10：修改图3-19中的算法，使它可以计算通用trie树的失效函数。提示：主要的不同在于，在图3-19的第4、5行上，我们不能简单地测试bs+1和bt+1是否相等。从任何一个状态出发，都可能存在多个在不同字符上的转换。比如在图3-21中，存在从状态1出发、分别在字符`e`和`i`上的两个转换。这些转换都可能进入代表了最长的既是后缀又是前缀的字符串的状态。

练习 3.4.11：为下面的关键字集合构造trie以及失效函数。

1）`aaa、abaaa`和`ababaaa`。

2）`all、fall、fatal、llama`和`lame`。

3）`pipe、pet、item、temper`和`perpetual`。

！练习 3.4.12：说明练习3.4.10中所设计的算法的运行时间和所有关键字长度的总和成线性关系。
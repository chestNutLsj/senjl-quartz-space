### 3.9.1　NFA的重要状态

在讨论如何根据一个正则表达式直接生成DFA之前，我们必须首先深入分析算法3.23构建NFA的过程，并考虑各种状态所扮演的角色。如果一个NFA状态有一个标号非∈的离开转换，那么我们称这个状态是重要状态（important state）。请注意，子集构造法（算法3.20）在计算∈-closure（move（T，a））（即可以从T出发在输入a上到达的状态的集合）的时候，它只使用了集合T中的重要状态。也就是说，只有当状态s是重要的，状态集合move（s，a）才可能是非空的。在子集构造法的应用过程中，两个NFA状态集合可以被认为是一致的（即把它们当作同一个集合来处理）条件是它们：

1）具有相同的的重要状态，且

2）要么都包含接受状态，要么都不包含接受状态。

如果这个NFA是使用算法3.23根据一个正则表达式生成的，那么我们还可以指出更多的关于重要状态的性质。重要状态只包括在基础规则部分为正则表达式中某个特定符号位置引入的初始状态。也就是说，每个重要状态对应于正则表达式中的某个运算分量。

此外，构造得到的NFA只有一个接受状态，但该接受状态（没有离开转换）不是重要状态。我们可以在一个正则表达式r的右端连接一个独特的右端结束标记符#，使得r的接受状态增加一个在#上的转换，使之成为（r）#的NFA的重要状态。换句话说，通过使用扩展的（augment）正则表达式（r）#，我们可以在构造过程中不考虑接受状态的问题。当构造过程结束后，任何在#上有离开转换的状态必然是一个接受状态。

NFA的重要状态直接对应于正则表达式中存放了字母表中符号的位置。使用抽象语法树来表示扩展的正则表达式是非常有用的。该语法分析树的叶子结点对应于运算分量，内部结点表示运算符。标号为连接运算符（。）、并运算符｜、星号运算符*的内部结点分别称为cat结点、or结点和star结点。我们可以使用2.5.1节中处理算术表达式的方法来构造一个正则表达式对应的抽象语法树。

例3.31　图3-56是一个正则表达式的抽象语法树。其中的小圆圈表示cat结点。

![125-1](../Images/image04124.jpeg)

图3-56　（a|b）*abb#的抽象语法树

抽象语法树的叶子结点可以标号为∈，也可以用字母表中的符号作为标号。对于每一个标号不为∈的叶子结点，我们赋予一个独有的整数。我们将这个整数称为叶子结点的位置（position），同时也表示和它对应的符号的位置。请注意，一个符号可以有多个位置。比如，在图3-56中，a有位置1和位置3。抽象语法树中的这些位置对应于构造出的NFA中的重要状态。

例3.32　图3-57显示了对应于图3-56中的正则表达式的NFA，其中的重要状态已经被编号，而其他状态则用字母表示。我们很快就会看到，NFA的编号状态和抽象语法树中的位置是如何对应的。

![125-2](../Images/image04125.jpeg)

图3-57　使用算法3.23构造得到的（a|b）*abb#的NFA
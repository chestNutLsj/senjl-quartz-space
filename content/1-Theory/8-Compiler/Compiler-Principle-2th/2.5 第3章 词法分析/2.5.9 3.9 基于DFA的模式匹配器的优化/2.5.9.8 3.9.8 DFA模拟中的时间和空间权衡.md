### 3.9.8　DFA模拟中的时间和空间权衡

最简单和最快捷的表示一个DFA的转换函数的方法是使用一个以状态和字符为下标的二维表。给定一个状态和下一个输入字符，我们访问这个数组就可以找出下一个状态以及我们必须执行的特殊动作，比如将一个词法单元返回给语法分析器。由于词法分析器的DFA中通常包含数百个状态，并且涉及ASCII字母表中的128个输入字符，因此这个数组需要的空间少于一兆字节。

但是，在一些小型的设备中也可能使用编译器。对于这些设备来说，即使一兆内存也显得太大了。对于这种情况，可以应用很多方法来压缩转换表。比如，我们可以用一个转换链表来表示每个状态，这个转换链表由字符-状态对组成。我们在链表的最后存放一个默认状态：对于没有出现在这个链表中的字符，我们总是选择这个状态作为目标状态。

还有一个更加巧妙的数据结构，它既利用了数组表示法的访问速度，又利用了带默认值的链表的压缩特性。我们可以把这个结构看作四个数组，如图3-66所示[^5]。其中的base数组用于确定状态s的条目的基准位置。这些条目位于数组next和check中。如果数组check告诉我们由base［s］给出的基准位置不正确，那么我们就使用数组default来确定另一个基准位置。

![132-1](../Images/image04135.jpeg)

图3-66　表示转换表的数据结构

在计算nextstate（s，a）时，即计算状态s在输入a上的后继状态时，我们首先查看数组next和check中在位置l = base［s］+ a上的条目，其中a被当作0～127之间的整数。如果check［l］= s，那么这个条目是有效的，状态s在输入a上的后继状态就是next［l］；如果check［l］≠ s，那么我们得到另一个状态t = default［s］，并把t当作当前的状态重复这个过程。函数nextState的定义如下：

![132-2](../Images/image04136.jpeg)

使用图3-66中所示数据结构的目的是利用状态之间的相似性来缩短next-check数组。例如，s状态的默认状态t可能是一个“正在处理一个标识符”的状态，就像图3-14中的状态10。而状态s可能是在读入字母`th`之后进入的状态。这里`th`既是关键字`then`的一个前缀，同时也可能是一个标识符的词素的前缀。当输入字符为`e`时，我们必须从状态`s`到达一个特别的状态。该状态记住我们已经看到了`the`；当输入字符不等于e时，状态s的动作和状态t的动作相同。因此，我们将check［base［s］+e］的值设置为s（以确认这个条目对于状态s有效），并将next［base［s］+e］的值置为前面提到的特殊状态。同时default［s］被设置为t。

虽然我们可能无法选择适当的base值，使next-check的所有条目都被充分利用。经验表明，采用下述简单策略就可以有很好的效果：按照顺序将base值赋给各个状态，将各个base［s］的值设置为最小的、能够使得状态s的特殊条目的位置都尚未被占用的值。这个策略需要的空间只比最小可能值多一点点。
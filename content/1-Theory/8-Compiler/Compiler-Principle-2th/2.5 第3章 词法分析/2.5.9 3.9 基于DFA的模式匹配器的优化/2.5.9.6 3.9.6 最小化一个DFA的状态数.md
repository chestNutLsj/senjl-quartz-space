### 3.9.6　最小化一个DFA的状态数

对于同一个语言，可以存在多个识别此语言的DFA。例如，图3-36和图3-63中的DFA都识别语言L（（a|b）*abb）。这两个DFA不但各个状态的名字不同，就连它们的状态个数也不一样。如果我们使用DFA来实现词法分析器，我们总是希望使用的DFA的状态数量尽可能地少，因为描述词法分析器的转换表需要为每个状态分配条目。

状态名字的问题是次要的。如果我们只需改变状态名字就可以将一个自动机转换成为另一个自动机，我们就说这两个自动机是同构的。图3-36和图3-63中的两个自动机不是同构的。然而，这两个自动机的状态之间有很紧密的关系。图3-36中的状态A和C实际上是等价的，因为它们都不是接受状态，且对任意输入，它们总是转到同一个状态——在输入a上转到B，在输入b上转到C。不仅如此，状态A和C的行为都和图3-63中的状态123相似。类似地，图3.36中状态B的行为和图3-63中状态1234的行为相似，状态D的行为和状态1235的行为相似，状态E的行为和状态1236的行为相似。

可以得出一个重要的结论：任何正则语言都有一个唯一的（不计同构）状态数目最少的DFA。而且，从任意一个接受相同语言的DFA出发，通过分组合并等价的状态，我们总是可以构建得到这个状态数最少的DFA。对于L（（a|b）*abb），图3-63就是状态最少的DFA，将图3-36中DFA的状态划分为{A，C}{B}{D}{E}然后合并等价状态就可以得到这个最小DFA。

我们将给出一个将任意DFA转化为等价的状态最少的DFA的算法。该算法首先创建输入DFA的状态集合的分划。为了理解这个算法，我们要了解输入串是如何区分各个状态的。如果分别从状态s和t出发，沿着标号为x的路径到达的两个状态中只有一个是接受状态，我们说串x区分状态s和t。如果存在某个能够区分状态s和状态t的串，那么它们就是可区分的（distinguishable）。

例3.38　空串∈可以区分任何一个接受状态和非接受状态。在图3-36中，串bb区分状态A和B，因为从A出发经过标号为bb的路径会到达非接受状态C，而从B出发则到达接受状态E。

DFA状态最小化算法的工作原理是将一个DFA的状态集合分划成多个组，每个组中的各个状态之间相互不可区分。然后，将每个组中的状态合并成状态最少DFA的一个状态。算法在执行过程中维护了状态集合的一个分划，分划中的每个组内的各个状态尚不能区分，但是来自不同组的任意两个状态是可区分的。当任意一个组都不能再被分解为更小的组时，这个分划就不能再进一步精化，此时我们就得到了状态最少的DFA。

最初，该分划包含两个组：接受状态组和非接受状态组。算法的基本步骤是从当前分划中取一个状态组，比如A = {s1，s2，…，sk}，并选定某个输入符号a，检查a是否可以用于区分A中的某些状态。我们检查s1，s2，…，sk在a上的转换，如果这些转换到达的状态落入当前分划的两个或多个组中，我们就将A分割成为多个组，使得si和sj在同一组中当且仅当它们在a上的转换都到达同一个组的状态。我们重复这个分割过程，直到无法根据某个输入符号对任意个组进行分割为止。这个思想体现在下面的算法中。

状态最小化算法的原理

我们需要证明两个性质：仍然位于Πfinal的同一组中状态不可能被任意串区分，以及最后存在于不同子集中的状态之间是可区分的。要证明第一个性质，需要对算法3-39中步骤2的迭代次数进行归纳。如果在步骤2 的第i次迭代之后s和t在同一子组中，那么就不存在长度小于等于i的串可以将s和t区分开。请读者自行完成这个归纳证明。

第二个性质的证明也是通过对迭代次数的归纳来完成的。如果在步骤2的第i次迭代时状态s和t被放在不同的组中，那么必然存在一个串可以区分它们。归纳的基础很容易证明：当s和t放在初始分划的不同组中时，它们必然一个是接受状态，另一个是非接受状态。因‴此∈就可以区分它们。归纳步骤如下：必然存在一个输入符号a和状态p、q，使得s和t在输入a上分别进入状态p和q。并且p和q必定已经被放到不同的组中了。那么根据归纳假设，必然存在某个串x可以区分p和q。因此可知ax能够区分s和t。

算法3.39　最小化一个DFA的状态数量。

输入：一个DFA D，其状态集合为S，输入字母表为Σ，开始状态为s0，接受状态集为F。

输出：一个DFA D′，它和D接受相同的语言，且状态数最少。

方法：

1）首先构造包含两个组F和S-F的初始划分Π，这两个组分别是D的接受状态组和非接受状态组。

2）应用图3-64的过程来构造新的分划Πnew。

![130-1](../Images/image04132.jpeg)

图3-64　Πnew的构造

3）如果Πnew = Π，令Πfinal = Π并接着执行步骤4；否则，用Πnew替换Π并重复步骤2。

4）在分划Πfinal的每个组中选取一个状态作为该组的代表。这些代表构成了状态最少DFA D′的状态。D′的其他部分按如下步骤构建：

（a）D′的开始状态是包含了D的开始状态的组的代表。

（b）D′的接受状态是那些包含了D的接受状态的组的代表。请注意，每个组中要么只包含接受状态，要么只包含非接受状态，因为我们一开始就将这两类状态分开了，而图3-64中的过程总是通过分解已经构造得到的组来得到新的组。

（c）令s是Πfinal中某个组G的代表，并令DFA D中在输入a上离开s的转换到达状态t。令r为t所在组H的代表。那么在D’中存在一个从s到r在输入a上的转换。注意，在D中，组G中的每一个状态必然在输入a上进入组H中的某个状态，否则，组G应该已经被图3-64的过程分割成更小的组了。

消除死状态

这个最小化算法有时会产生带有一个死状态的DFA。所谓死状态就是在所有输入符号上都转向自己的非接受状态。从技术上来讲，这个状态是必须的，因为在一个DFA中，从每个状态出发在每个输入符号上都必须有一个转换。然而，如3.8.3节所讨论的，我们需要知道在什么时候已经不存在被这个DFA接受的可能性了，这样我们才能知道已经识别到了正确的词素。因此，我们希望消除死状态，并使用一个缺少某些转换的自动机。这个自动机的状态比状态最少DFA的状态少一个，但是因为缺少了一些到达死状态的转换，所以严格地讲它并不是一个DFA。

例3.40　让我们重新考虑图3-36中给出的DFA。初始分划包括两个组{A，B，C，D}，{E}，它们分别是非接受状态组和接受状态组。构造Πnew时，图3-64中的过程考虑这两个组和输入符号a和b。因为组{E}只包含一个状态，不能再被分割，所以{E}被原封不动地保留在Πnew中。

另一个组{A，B，C，D}是可以被分割的，因此我们必须考虑各个输入符号的作用。在输入a上，这些状态中的每一个都转到B，因此使用以a开头的串无法区分这些状态。但对于输入b，状态A、B和C都转换到组{A，B，C，D}的某个成员上，而D转到另一个组中的成员E上。因此在Πnew中，组{A，B，C，D}被分割为{A，B，C}和{D}。这一轮得到的Πnew是{A，B，C}{D}{E}。

在下一轮中，我们可以把{A，B，C}分割为{A，C}{B}，因为A和C在输入b上都到达{A，B，C}中的元素，但B却转到另一个组中的元素D上。因此在第二轮之后，Πnew={A，C}{B}{D}{E}。在第三轮中，我们不能够再分割当前分划中唯一一个包含多个状态的组{A，C}，因为A和C在所有输入上都进入同一个状态（因此也就在同一组中）。因此我们有Πfinal = {A，C}{B}{D}{E}。

现在我们将构建出状态最少DFA。它有4个状态，对应于Πfinal中的四个组。我们分别挑选A、B、D和E作为这四个组的代表。其中，状态A是开始状态，状态E是唯一的接受状态。它的转换函数如图3-65所示。例如，在输入b上离开状态E的转换到达状态A，因为在原来的DFA中，E在输入b上到达C，而A是C所在组的代表。因为同样的原因，在输入b上离开A的状态回到A本身，而其他的转换都和图3-36中的相同。

![131-1](../Images/image04133.jpeg)

图3-65　状态最少DFA的转换表
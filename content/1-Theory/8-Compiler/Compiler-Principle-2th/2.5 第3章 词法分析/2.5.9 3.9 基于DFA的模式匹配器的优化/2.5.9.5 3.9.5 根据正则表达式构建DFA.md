### 3.9.5　根据正则表达式构建DFA

算法3.36　从一个正则表达式r构造DFA。

输入：一个正则表达式r。

输出：一个识别L（r）的DFA D。

方法：

1）根据扩展的正则表达式（r）#构造出一棵抽象语法树T。

2）使用3.9.3节和3.9.4节的方法，计算得到T的函数nullable、firstpos、lastpos和followpos。

3）使用图3-62中所示的过程，构造出D的状态集Dstates和D的转换函数Dtran。D的状态就是T中的位置集合。每个状态最初都是“未标记的”，当我们开始考虑某个状态的离开转换时，该状态变成“已标记的”。D的开始状态是firstpos（n0），其中结点n0是T的根结点。这个DFA的接受状态集合是那些包含了和结束标记#对应的位置的状态。

![128-3](../Images/image04130.jpeg)

图3-62　从一个正则表达式直接构造一个DFA

例3.37　现在我们可以把我们的连续使用的例子的各个步骤综合起来，为正则表达式r=（a|b）*abb构造一个DFA。（r）#的语法分析树如图3-56所示。我们观察到，在这棵语法分析树中，只有star结点使nullable为真。我们将函数firstpos和lastpos显示在图3-59中。函数followpos的值显示在图3-60中。

这棵树的根结点的firstpos的值是{1，2，3}，因此D的开始状态就是这个集合。我们称这个集合为A。我们必须计算Dtran［A，a］和Dtran［A，b］。在A的位置中，1和3对应于a，而2对应于b。因此Dtran［A，a］= followpos（1）∪followpos（3）= {1，2，3，4}；Dtran［A，b］= followpos（2）= {1，2，3}。后一个集合就是A，因此不需要加入到Dstates中。但是前一个状态集B={1，2，3，4}是新状态，因此我们将它加入到Dtrans中并计算它的转换。完整的DFA如图3-63所示。

![129-1](../Images/image04131.jpeg)

图3-63　根据图3-57构造得到的DFA
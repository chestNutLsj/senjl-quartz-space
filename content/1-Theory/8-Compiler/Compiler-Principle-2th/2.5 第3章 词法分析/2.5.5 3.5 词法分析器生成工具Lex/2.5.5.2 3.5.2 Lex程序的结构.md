### 3.5.2　Lex程序的结构

一个Lex程序具有如下形式：

声明部分

---

%%
转换规则
%%
辅助函数

---

声明部分包括变量和明示常量（manifest constant，被声明的表示一个常数的标识符，如一个词法单元的名字）的声明和3.3.4节中描述的正则定义。

Lex程序的每个转换规则具有如下形式：

模式 { 动作 }

其中，每个模式是一个正则表达式，它可以使用声明部分中给出的正则定义。动作部分是代码片段。虽然人们已经创建了很多能使用其他语言的Lex的变体，但这些代码片段通常是用C语言编写的。

Lex程序的第三个部分包含各个动作需要使用的所有辅助函数。还有一种方法是将这些函数单独编译，并与词法分析器的代码一起装载。

由Lex创建的词法分析器和语法分析器按照如下方式协同工作。当词法分析器被语法分析器调用时，词法分析器开始从余下的输入中逐个读取字符，直到它发现了最长的与某个模式Pi匹配的前缀。然后，词法分析器执行相关的动作Ai。通常Ai会将控制返回给语法分析器。然而，如果它不返回控制（比如Pi描述的是空白符或注释），那么词法分析器就继续寻找其他的词素，直到某个动作将控制返回给语法分析器为止。词法分析器只向语法分析器返回一个值，即词法单元名。但在需要时可以利用共享的整型变量`yylval`传递有关这个词素的附加信息。

例3.11　图3-23是一个Lex程序，它能够识别图3-12中的各个词法单元，并返回找到的词法单元。观察这段代码可以发现Lex的很多重要特点。

我们在声明部分看到一对特殊的括号：`%{`和`%}`。出现在括号内的所有内容都被直接复制到文件`lex.yy.c`中。它们不会被当作正则定义处理。我们一般将明示常量的定义放置在该括号内，并利用C语言的`#define`语句给每个明示常量赋予一个唯一的整数编码。在我们的例子中，我们在一个注释中列出了LT、IF等明示常量，但没有显示它们被赋予哪些特定的整数。[^3]

在声明部分还包含一个正则定义的序列。这些定义使用了3.3.5节中描述的正则表达式的扩展表示方法。那些将在后面的定义中或某个转换规则的模式中使用的正则定义用花括号括起来。例如，delim被定义为表示一个包含了空格、制表符及换行符的字符类的缩写。后两个字符分别用反斜线再跟上t及n来表示。这个表示法和UNIX命令使用的方法相同。于是，ws通过正则表达式`{delim}`+定义为一个或多个分隔符组成的序列。

注意，在id和number的定义中，圆括号是用于分组的元符号，并不代表圆括号自身。相反，在number定义中的`E`代表其自身。如果我们希望Lex的某个元符号（比如括号、+、*或？等）表示其自身，我们可以在它们前面加上一个反斜线。例如，我们在number的定义中看到的\.就表示小数点本身。在它前面加上反斜线的原因是，和在UNIX正则表达式中一样，该字符在Lex中是一个代表“任一字符”的元符号。

在辅助函数部分，我们可以看到这样两个函数： `installID()`和`installNum()`。和位于`%{…%}`中的声明部分一样，出现在辅助部分中的所有内容都被直接复制到文件`lex.yy.c`中。虽然它们位于转换规则部分之后，但这些函数可以在规则部分的动作定义中使用。

最后，让我们看一下图3-23的中间部分的一些模式和规则。首先，在第一部分中定义的标识符ws有一个相关的空动作。如果我们发现了一个空白符，我们并不把它返回给语法分析器，而是继续寻找另一个词素。第二词法单元有一个简单的正则表达式模式`if`。如果我们在输入中看到两个字母`if`，并且`if`之后没有跟随其他字母或数位（如果有的话，词法分析器会去寻找一个和id模式匹配的最长输入前缀），然后词法分析器从输入中读入这两个字符，并返回词法单元名`IF`，也就是明示常量`IF`所代表的整数值。关键字`then`和`else`的处理方法与此类似。

![106-1](../Images/image04081.jpeg)

图3-23　识别图3-12中的词法单元的Lex程序

第五个词法单元的模式由id定义。注意，虽然像if这样的关键字既和这个模式匹配，也和之前的一个模式匹配，但是当最长匹配前缀和多个模式匹配时，Lex总是选择最先被列出的模式。当id被匹配时，相应的处理动作分为三步：

1）调用函数`installID()`将找到的词素放入符号表中。

2）该函数返回一个指向符号表的指针。这个指针被放到全局变量`yylval`中，并可被语法分析器或编译器的某个后续组件使用。注意，函数`installID()`可以使用以下两个由Lex生成的、由词法分析器自动赋值的变量：

- `yytext`是一个指向词素开头的指针，与图3-3中的lexemeBegin类似。
- `yyleng`存放刚找到的词素的长度。

3）将词法单元名ID返回到语法分析器。

当一个词素与模式number匹配时，执行的处理与此类似，它使用辅助函数`installNum()`完成处理。
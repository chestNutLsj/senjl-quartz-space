### 3.5.4　向前看运算符

Lex自动地向前读入一个字符，它会读取到形成被选词素的全部字符之后的那个字符，然后再回退输入，使得只有词素本身从输入中消耗掉。但是在某些时候，我们希望仅当词素的后面跟随特定的其他字符时，这个词素才能和某个特定的模式相匹配。在这种情况下，我们可以在模式中用斜线来指明该模式中和词素实际匹配的部分的结尾，斜线/之后的内容表示一个附加的模式，只有附加模式和输入匹配之后，我们才可以确定已经看到了要寻找的词法单元的词素，但是和第二个模式匹配的字符并不是这个词素的一部分。

例3.13　在Fortran和一些其他语言中，关键字并不是保留字。这种情形会产生一些问题，比如下面的语句

`IF（I，J）＝3`

其中，IF是一个数组的名字，而不是关键字。与这条语句形成对比的是下面形式的语句：

`IF（condition）THEN …`

在这里，IF是一个关键字。幸运的是，我们可以确定关键字`IF`后面总是跟着一个左括号，然后是一些可能包含在括号中的文本，即条件表达式，接着是一个右括号和一个字母。那么，我们可以为关键字`IF`写出如下的Lex规则：

`IF / \（. * \）{letter}`

这条规则是说和这个词素匹配的模式仅仅是两个字母`IF`。斜线表示后面会有一个附加的模式，但是这个模式并不和词素匹配。在这个附加模式中，第一个字符是左括号。由于左括号是Lex的一个元符号，因此我们必须在它的前面加上一个反斜线，说明它表示的是其字面含义。其中的.*与“任何不包含换行符的字符串”匹配。请注意，点号是一个Lex的元符号，表示“除换行符外的任何字符”。接下来是一个右括号，同样也加一个反斜线使得该字符表示其字面含义。该附加模式的最后是符号letter，该符号是一个正则定义，表示代表所有字母的字符类。

注意，为了使该模式简单可靠，我们必须对输入进行预处理，消除其中的空白符。在该模式中，我们既没有考虑到空白符，也不能处理条件表达式跨行的情形，因为点号不能和一个换行符匹配。

例如，假设该模式被用来匹配下面的输入前缀：

`IF（A<（B+C）*D）THEN…`

前两个字符和IF匹配，下一字符和\（匹配，接下来的九个字符和.* 匹配，再接下来的两个字符分别和\）及letter匹配。请注意，第一个右括号（在C的后面）后面跟的不是一个字母，这个事实与问题不相关，因为我们只需要找到某种方式将输入与模式相匹配。最后我们得出结论，字符IF组成一个词素，并且它们是词法单元if的一个实例。
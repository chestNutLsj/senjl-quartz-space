## 3.11　第3章参考文献

正则表达式首先由Kleene在20世纪50年代开始研究［9］。McCullough和Pitts［12］提出了一种描述神经活动的有穷自动机模型，而Kleene的兴趣就是描述那些可以用这些模型表示的事件。从那以后，正则表达式和有穷自动机在计算机科学中得到了广泛应用。

各种各样的正则表达式已经应用于很多流行的UNIX工具中，比如awk、ed、egrep、grep、lex、sed、sh和vi等。可移动操作系统接口（Portable Operating System Interface，POSIX）的标准文档IEEE 1003和ISO/IEC 9945中定义了POSIX扩展正则表达式，它们和最初的UNIX正则表达式非常相近，只有少量例外，比如字符类的助记表示方式。许多脚本语言，像Perl、Python和Tcl，都采用了正则表达式，但常常使用不兼容的扩展表示方式。

我们熟悉的有穷自动机模型和算法3.39中的有穷自动机最小化方法由Huffman［6］和Moore［14］给出。而Rabin和Scott［15］最先提出了不确定有穷自动机的概念，他们还给出了子集构造法，即算法3.29。这个算法证明了确定自动机和不确定自动机在语言识别能力上是等价的。

McNaughton和Yamada［13］最先给出了一个利用正则表达式直接构造DFA的算法。3.9节中描述的算法3.36最早被Aho用于构建UNIX正则表达式匹配工具egrep，这个算法还被应用于awk［3］中的正则表达式模式匹配例程。将不确定自动机用作中间表示的匹配方法首先由Thompson［17］提出。该文还提出了直接模拟NFA的算法（算法3.22）。这个算法被Thompson用于文本编辑器QED中。

Lesk开发了Lex的第一个版本，随后Lesk和Schmidt用算法3.36编写了Lex的第二个版本［10］。此后出现了Lex的很多变体。GNU版本的Flex及其文档可以在［4］下载。流行的Lex的Java版本包括JFlex［7］和JLex［8］。

在3.4节的练习3.4.3之前讨论的KMP算法来自［11］。可处理多个关键字的此算法的扩展版本可以在［2］中找到。Aho在UNIX工具fgrep的第一个实现中使用了这个算法。

在［5］中完整地介绍了有关有穷自动机和正则表达式的理论，而［1］给出了字符串匹配技术的概述。

![135-1](../Images/image04138.jpeg)

---

[^1]: 然而，当讨论ASCII字符集中的特定字符时，我们通常将使用电传字体同时表示字符和它的正则表达式。

[^2]: 顺便说一下，在`yylval`和`lex.yy.c`中出现的yy指的是我们将在4.9节中讨论的语法分析器生成工具yacc，它一般和Lex一起使用。

[^3]: 如果Lex同Yacc一起使用，那么明示常量通常会在Yacc程序中定义，并在Lex程序中不加定义就使用它们。因为`lex.yy.c`是和Yacc的输出一起编译的，因而这些常量在Lex程序的动作中也是可用的。

[^4]: 这里有个小问题：按照我们的定义，正则表达不能描述空的语言，因为我们在实践中从不会想到使用这样的模式。但是，有穷自动机可以定义空语言。在理论研究中，Ø被视为一个额外的正则表达式，这个表达式的用途就是定义空语言。

[^5]: 在实践中可能还有另一个以状态为下标的数组，如果某个状态相关的动作，那么这个数组的相应元素会指明这个动作。
### 10.3.1　数据依赖图

我们把每个由机器指令组成的基本块表示成为一个数据依赖图（data-dependence graph），G=（N,E），其中结点集合N表示基本块中机器指令的运算，而有向边集合E表示运算之间的数据依赖约束。G的结点集合和边集按照如下方式构造：

1）在N中的每个运算n有一个资源预约表RTn，其值就是n的运算类型所对应的资源预约表。

2）E中的每条边e有一个表示延时的标号de。该标号表明目标结点必须在源结点发出后至少de个时钟周期之后发出。假设运算n1之后跟有运算n2，并且两条指令访问同一个内存位置，访问的延时分别为l1和l2。也就是说，该位置上的值在第一条指令开始之后的第l1个时钟周期生成，且第二条指令在其开始后的第l2个时钟周期需要这个值。请注意，在通常情况下l1=1而l2=0。那么，E中有一个延时标号为l1-l2的边n1→n2。

例10.6　考虑一个可以在每个时钟周期内执行两个运算的机器。其中第一个运算必须是分支运算或者以下形式的ALU运算：

![474-1](../Images/image04807.jpeg)

第二个运算必须是如下形式的加载运算或者保存运算：

![474-2](../Images/image04808.jpeg)

其中的加载运算（LD）是完全流水线化的并占用两个时钟周期。但是，一个加载运算后面可以立刻跟一个向被读内存地址进行写运算的保存运算`ST`。所有其他的运算都在一个时钟周期内完成。

资源预约表的图示方法

把一个运算的资源预约表用实心和空心方块组成的网格可视化地表示出来是非常有用的。在网格中，每一列对应于目标机器上的一种资源，而每一行表示该运算执行中的一个时钟周期。假设对于每种类型的资源，这个运算最多只需要一个单元，我们就可以使用实心方块表示1，用空心方块表示0。另外，如果该指令是完全流水线化的，那么只需要指明在第一行中使用的资源，相应的资源预约表变成了单独的一行。

例如，这个表示方式在例10.6中使用。在图10-7中，我们可以看到各个资源预约表都是单行的。其中的两个加法运算需要“alu”资源，而加载和保存运算需要“mem”资源。

图10-7中显示的是一个基本块例子的依赖图和它的资源需求。我们可以想像`R1`是一个栈指针，用来通过诸如0或者12这样的偏移量访问栈中的数据。第一条指令向寄存器`R2`中加载数据，直到两个时钟周期之后这个数据才变得在`R2`中可用。这就是从第一条指令到第二及第五条指令的边的标号为2的原因，这两条指令都需要`R2`中的值。类似地，从第三条指令到第四条指令的边也有标号表明延时为2；第四条指令需要被加载到`R3`中的值，而这个值要在第三条指令开始之后两个时钟周期才变得可用。

![475-1](../Images/image04809.jpeg)

图10-7　例10.6的数据依赖图

因为我们不知道`R1`和`R7`的值之间有什么样的关系，所以不得不考虑地址8（`R1`）和地址0（`R1`）相同的可能性。也就是说，最后一条指令可能正在把值保存到第三条指令读取数据的位置。我们正使用的机器模型允许我们在从某个位置开始读取数据的一个时钟周期之后把数据存放到这个位置上，即使被读出的数据需要再等一个时钟周期才出现在寄存器中。这就是从第三条指令到最后一条指令的边的标号为1的原因。这也同样是从第一条指令到最后一条指令有一条标号为1的边的原因。其他标号为1的边产生的原因是指令间的数据依赖关系，或者当`R7`取某些值时可能产生的依赖关系。
### 10.4.1　基本的代码移动

让我们首先通过一个简单的例子来研究一下指令移动可能涉及的问题。

例10.9　假设我们有一个可以在单个时钟周期内同时执行任意两条指令的机器。除了加载运算有两个时钟周期的延时外，其余每个运算的执行延时为一个时钟周期。为简单起见，我们假设例子中所有的内存访问都是正确的，且访问的数据都在高速缓存中。图10-12a显示了一个包括三个基本块的简单流图。其中的代码被扩展为图10-12b所示的机器指令。因为数据依赖关系，每个基本块中的所有指令必须顺序执行。实际上，每个基本块中都必须插入一个no-op指令。

![478-1](../Images/image04814.jpeg)

图10-12　例10.9中全局调度之前和之后的流图

假设变量a、b、c、d和e的地址互不相同，并且这些地址被分别存放在寄存器`R1～R5`中。因此不同基本块中的计算之间没有数据依赖关系。我们发现，不管是否选择图中的分支跳转，基本块B3中的所有运算都会被执行，因此它可以和基本块B1中的运算并行执行。我们不能把B1中的运算移动到B3，因为需要它们来决定分支跳转的出口。

B2中的运算和基本块B1中的测试指令之间具有控制依赖关系。我们可以在基本块B1中投机性执行B2中的加载运算而不会产生任何附加开销，并且只要该分支执行，就可以节约两个时钟周期。

保存运算不应该投机性地执行，因为它们覆写了某个内存位置上的原值。但是可以延迟执行一个保存运算。我们不能直接把B2中的保存运算放到基本块B3中，因为只有当控制流经过基本块B2时才能执行这个保存运算。但是，我们可以把保存运算放在B3的一个拷贝中。图10-12c中显示了经过这样优化后的调度方案。优化后的代码在4个时钟周期内执行完毕，这和单独执行基本块B3所需的时间一样。

例10.9表明我们可以沿着一个执行路径上下移动指令。在这个例子中，每一对基本块都有一个不同的“支配关系”，因此关于何时以及如何在每一对基本块之间移动指令的考虑是不同的。如9.6.1节中所讨论的，如果每一个从控制流图入口处到达基本块B′的路径都经过一个基本块B，那么就认为B支配B′。类似地，如果从B′到达流图出口处的路径都经过B，我们说B反向支配（postdominate）B′。当B支配B′并且B′反向支配B的时候，我们就说B和B′是控制等价的（control equivalent），其含义是一个基本块会被执行当且仅当另一个基本块也会被执行。对于图10-12中的例子，假设B1是流图入口，且B3是出口，则

1）B1和B3是控制等价的：B1支配B3而B3反向支配B1。

2）B1支配B2，但是B2不反向支配B1。

3）B2不支配B3但是B3反向支配B2。

在一条路径上的一对基本块之间也可能既不具有支配关系，也不具有反向支配关系。
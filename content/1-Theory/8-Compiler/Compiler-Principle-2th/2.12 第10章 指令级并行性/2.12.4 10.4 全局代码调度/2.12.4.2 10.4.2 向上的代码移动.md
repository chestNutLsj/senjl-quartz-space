### 10.4.2　向上的代码移动

我们现在仔细考查把一个运算沿着一条路径向上移动意味着什么。假设我们希望把一个运算从基本块src沿着一条控制流路径向上移动到基本块dst。同时假设这样的移动没有违反任何数据依赖关系，并且使得从dst到src的路径运行得更快。如果dst支配src并且src反向支配dst，那么被移动的运算会在它应该运行的时候被恰好运行一次。

如果src不反向支配dst

这种情况下，存在一条经过dst但是没有到达src的路径。此时会执行一个多余的运算。除非被移动的运算没有任何有害的副作用，否则这个代码移动就是非法的。如果被移动的运算是“免费”执行的（即它只使用那些本来会被闲置的资源），那么这次代码移动没有产生开销。只有当控制流到达src的时候这次代码移动才是有益的。

如果dst不支配src

这种情况下存在一条没有首先经过dst就到达src的路径。我们需要在这样的路径中插入被移动运算的拷贝。根据9.5节中对部分冗余消除的讨论我们可以知道如何准确做到这一点。我们把这个运算的拷贝放置在一组基本块中，这组基本块形成了一个将入口基本块和src分割开的割集。在每个插入这个拷贝的地方，下列约束必须满足：

1）该运算的运算分量必须和原运算的运算分量具有相同的值。

2）运算的结果没有覆盖掉可能在后面使用的值。

3）此运算本身的结果没有在到达src之前被覆盖掉。

这些拷贝使得src中的原指令完全冗余，因此可以被消除。

我们把这个运算指令的额外拷贝称为补偿代码（compen sation code）。9.5节讨论过，可以在关键边上插入基本块来放置这些拷贝。补偿代码可能使得某些路径的执行变慢。因此，只有当被优化路径的执行频率高于其他未被优化的路径时，这个代码移动才会提高程序执行的性能。
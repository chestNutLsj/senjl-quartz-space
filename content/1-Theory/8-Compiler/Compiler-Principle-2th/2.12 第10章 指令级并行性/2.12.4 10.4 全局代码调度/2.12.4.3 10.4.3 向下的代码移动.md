### 10.4.3　向下的代码移动

假设我们感兴趣的是把一个运算从基本块src沿着一条控制流路径向下移动到基本块dst。我们可以像上面介绍的那样考虑这样的代码移动。

如果src不支配dst

在这种情况下，存在一条没有先访问src就到达dst的路径。同样，在这种情况下会执行一个额外的运算。遗憾的是，向下代码移动经常用于写运算。这种运算具有副作用，会覆盖原来的值。我们可以设法绕过这个问题，方法是复制从src到dst的路径上的基本块，并且只在dst的新拷贝中放置这个运算。另一个方法是，如果可以在使用带断言的指令时使用这种指令。我们用基本块src的卫式断言作为被移动运算的卫式断言。请注意，这些带断言的指令只能被安排在由计算该断言的基本块所支配的基本块中，否则该断言的值会不可用。

如果dst不反向支配src

和上面的讨论一样，我们必须插入补偿代码以使得被移动的运算在所有没有到达dst的路径上都被执行了。这个转换仍然和部分冗余消除类似，不同之处在于运算的拷贝被放置在基本块src之后、把src和流图出口处分开的割集中。

关于向上和向下代码移动的总结

从上面的讨论中可知，我们看到存在一组可能的全局代码移动的方法。这些方法的收益、代价以及实现复杂度各不相同。图10-13中给出了这些代码移动方法的总结。图中的各行对应于下面四种情况：

1）在控制等价的基本块之间移动指令最简单且性价比最高。不需要执行额外的运算，也不需要补偿代码。

2）在向上（向下）代码移动中，如果源基本块不反向支配（支配）目标基本块，那么就可能需要执行额外的运算。当该额外运算能够免费执行并且通过源基本块的路径被执行时，这个代码移动就是有益的。

3）在向上（向下）代码移动中，如果目标基本块不支配（反向支配）源基本块，就需要补偿代码。带有补偿代码的路径的运行可能会变慢，因此保证被优化的路径具有较高的执行频率是很重要的。

4）最后一种情况把第二和第三种情况的不利之处合并了起来：可能既需要执行额外运算，又需要补偿代码。

![480-1](../Images/image04815.jpeg)

图10-13　代码移动的总结
### 10.4.5　全局调度算法

在上一节中，我们看到代码移动对某些路径有益，但是会损害另外一些路径的性能。好消息是指令并不是生而平等的。实际上，我们知道，一个程序的90%以上的执行时间被花在不到10%的代码上。因此，我们可以把目标确定为使得频繁执行的路径更快运行，虽然有可能降低不频繁路径的运行速度。

编译器有多种技术来估算执行频率。我们有理由假设在最内层的循环中的指令比外层循环中的指令执行得更频繁，也有理由假设选择向回跳转分支的使用频率高过不选择这个分支的使用频率。另外，转向程序出口或者异常处理例程的分支不大可能被选择执行。但是，最好的频率估算来自于动态获取的程序运行剖面。在这个技术中，程序经过插装以记录程序运行时刻各个条件分支的出口选择情况。然后，程序就在有代表性的输入上运行，确定程序总体的运行行为。人们发现应用这个技术得到的结果相当精确。这样的信息可以反馈给编译器，由编译器在其优化过程中使用。

基于区域的调度

现在我们描述一个简单的全局调度器，它支持两种最容易的代码移动：

1）把运算向上移动到控制等价的基本块。

2）把运算向上移动一个分支，移动到一个支配前驱中。

9.7.1节介绍过，一个区域是一个控制流图的子集，它只能通过一个入口基本块到达。我们可以把任何过程表示为一个区域的层次结构。顶层区域包括整个过程，而嵌套在其中的子区域代表该过程中的自然循环。我们假设控制流图是可归约的。

算法10.11　基于区域的调度。

输入：一个控制流图和一个机器-资源描述。

输出：一个调度方案S。它把每条指令映射到一个基本块和一个时间位置。

方法：执行图10-15中的程序。其中的一些术语缩写的含义是很明显的：ControlEquiv（B）表示和基本块B控制等价的基本块的集合，而作用于一个基本块集合的DominatedSucc表示下面的基本块集合：它们是该基本块集合中一个或多个基本块的后继，且被该集合中的所有基本块支配。

![481-1](../Images/image04817.jpeg)

图10-15　一个基于区域的全局调度算法

算法10.11中的代码调度从最内层的区域开始逐渐扩展到最外层。在对一个区域进行调度时，每一个内嵌的子区域都被当作一个黑盒子，指令不能移入或移出某个子区域。但是，只要指令的数据依赖关系和控制依赖关系都得到满足，我们可以绕着子区域移动这些指令。

算法忽略了所有流回区域头基本块的控制和依赖边，因此最后得到的控制流和数据依赖图都是无环的。对每个区域中的各基本块的访问遵守拓扑排序。这个顺序保证了只有在该基本块所依赖的所有指令都被调度好之后才对这个基本块进行调度。将被安排在一个基本块B中的指令来自于所有和基本块B控制等价的基本块（包含B），以及这些等价基本块的、被B支配的直接后继。

为各个基本块创建调度方案时使用的是列表调度算法。该算法有一个候选指令列表CandInsts，这个列表中包含了候选基本块中的所有其前驱已调度好的指令。该算法逐个时钟周期地构造调度方案。对于每个时钟周期，它按照优先级顺序检查CandInsts中的各条指令，在资源允许的情况下把指令安排在该时钟周期上。然后，算法10.11更新CandInsts并重复这个过程，直到B中所有指令都被安排完毕。

CandInsts中的指令的优先级顺序所使用的优先级函数和10.3节中讨论过的函数类似。然而，我们作了一个重要的修改。我们把较高的优先级赋予那些来自和基本块B控制等价的基本块的指令，而对来自于后继基本块的指令赋予较低的优先级。这么做的原因是后一种类型的指令只是在基本块B中被投机性执行。

循环展开

在基于区域的调度中，一个循环中迭代之间的界限是代码移动的障碍。来自一个迭代的运算不能和来自其他迭代的运算重叠。可缓解这一问题的简单且高效的技术是在代码调度之前少量地展开该循环。如下的for循环

![482-1](../Images/image04818.jpeg)

可以被写成图10-16a所示的代码。类似地，如下的repeat循环

![482-2](../Images/image04819.jpeg)

可以被写成图10-16b所示的代码。循环展开在循环体中产生了更多的指令，使全局调度算法找到更多的并行性。

![482-3](../Images/image04820.jpeg)

图10-16　循环的展开

相邻压缩

算法10.11只支持10.4.1节中描述的前两种形式的代码移动。需要引入补偿代码的代码移动有时也是有用的。支持这种代码移动的方法之一是在基于区域的调度之后再跟一个简单的处理过程。在这个过程中，我们可以检查各对连续执行的基本块，检查是否有运算可以在它们之间上移或下移，以改进这些基本块的执行时间。如果找到了一对这样的基本块，我们检查是否需要在别的路径中复制将被移动的指令。如果移动之后的预期收益是正的，就可以进行这样的代码移动。

这个简单的扩展能够有效提高循环的性能。比如，它可以把一个迭代开始处的运算移动到上一个迭代的结尾，同样也可以把运算从第一个迭代移动到循环之外。对于较紧密的循环，即每个迭代过程只执行少量指令的循环，这种优化特别具有吸引力。但是，由于每个代码移动的决定是局部地独立做出的，因此这个技术的效果受到一定的限制。
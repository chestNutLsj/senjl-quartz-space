### 10.5.3　寄存器分配和代码生成

我们首先讨论例10.14中经过软件流水线化的循环的寄存器分配。

例10.15　在例10.14中，第一个迭代中的乘法运算结果在第3个时钟周期生成，在第6个时钟周期使用。在这两个时钟周期之间，第二次迭代中的这个乘法运算又在第5个时钟周期生成一个新的结果，这个值在第8个时钟周期使用。这两次迭代的结果必须保存到不同的寄存器中，以防止它们之间互相干扰。因为干扰只会在两个相邻的迭代之间发生，使用两个寄存器就可以避免这种干扰：一个寄存器用于奇数次迭代，另一个寄存器用于偶数次迭代。因为奇数次迭代的代码和偶数次迭代的代码不同，稳定状态循环的代码大小是原来的两倍。这个代码可以用于执行任何具有大于等于5的奇数次迭代的循环。

为了处理迭代次数小于5的循环和具有偶数次迭代的循环，我们生成的代码在源语言层次上和图10-21中的代码等价。第一个循环被流水线化了，它的机器语言层次的等价表示见图10-22。图10-21的第二个循环不需要优化，因为它最多迭代4次。

![486-1](../Images/image04829.jpeg)

图10-21　例10.12中循环在源语言层次上的展开

![486-2](../Images/image04830.jpeg)

图10-22　在例10.15中经过软件流水线化和寄存器分配之后得到的代码
### 10.5.2　循环的软件流水线化

软件流水线化提供了一个方便的优化方法，能够在优化资源使用的同时保持代码的简洁。让我们用一个连续的例子来说明这个想法。

例10.14　图10-19中显示的是把例10.12展开5次之后得到的代码（我们再次忽略了对寄存器使用方面的考虑）。第i行中显示的是在第i个时钟周期发出的所有运算指令；第j列中显示的是第j次迭代的全部运算。请注意，相对于各个迭代的开始时间，每个迭代都有同样的调度方案，同时要注意每个迭代都在前一个迭代开始两个时钟周期之后开始。可见，这个调度方案满足所有的资源和数据依赖约束。

![485-1](../Images/image04827.jpeg)

图10-19　例10.12经过5次迭代展开后得到的代码

我们看到，在第7和第8个时钟周期运行的运算和在第9和第10个周期运行的运算是一样的。第7和第8个时钟周期执行的运算来自原程序中的前四个迭代。第9和第10个时钟周期执行的运算也是来自四个迭代，不过这次是来自第2到第5个迭代。实际上，我们可以不停地执行同样的多运算指令对，不断有一个最老的迭代退出，又有一个新的迭代加入，直到运行完所有的迭代。

如果假设这个循环至少有4个迭代，那么这样的动态行为可以用图10-20中显示的代码简洁地编码。图中的每一行对应于一条机器指令。第7行和第8行形成了一个两个时钟周期的循环。这个循环将执行n-3次，其中n是原循环中的迭代次数。

![485-2](../Images/image04828.jpeg)

图10-20　例10.12的经软件流水线化的代码

上面描述的技术被称为软件流水线化技术，因为这是原本用于硬件流水线调度的技术在软件中的对应。我们可以把这个例子中各个迭代执行的调度方案当作一个8阶段的流水线。每两个时钟周期就可以在这条流水线上启动一个新迭代。在开始的时候，这条流水线中只有一个迭代在运行。在第一个迭代进行到第三阶段的时候，第二个迭代开始进入它的第一个执行阶段。

到第7个时钟周期时，流水线被前面四个迭代充满。在稳定状态下有四个连续的迭代同时运行。每当流水线中最老的迭代退出时就有一个新的迭代被启动。当我们运行完所有的迭代时，流水线开始排空，其中的所有迭代运行结束。用来填充流水线的指令序列（在这个例子中是第1到第6行）被称为序言（prolog）；第7和第8行被称为稳定状态（steady state）；用来排空流水线的指令序列（即第9行到第14行）被称为尾声（epilog）。

对于这个例子，我们知道这个循环不可能运行得比每两个时钟周期一个迭代更快。原因是目标机器每个时钟周期只能发出一个读指令，而每个迭代有两个读指令。上面的经软件流水线化的循环在2n+6个时钟周期内执行完毕，其中n是原循环的迭代次数。当n→∞时，这个循环的通量接近每两个时钟周期一次迭代。因此，和循环展开技术不同，软件调度可以用一个非常简洁的代码序列给出最优调度方案的编码。

请注意，对于单个迭代而言，这个调度方案的运行时间并不是最短的。和图10-17中显示的局部优化的调度方案相比，这个方案在`ADD`运算之前引入了一个延时。引入这个延时是调度策略之一，其目的是使这个调度方案可以在保证没有资源冲突的情况下每两个时钟周期启动一个迭代。如果我们坚持使用局部紧凑的调度方案，为了避免资源冲突，各次启动之间的间隔不得不延长到4个时钟周期，而吞吐率将被减半。这个例子说明了流水线调度的一个重要原则：必须小心选择调度方案以便优化吞吐量。虽然一个局部紧凑的调度方案可以使完成一个迭代的时间降到最低，但是在流水线化之后得到的吞吐量却可能是次优的。
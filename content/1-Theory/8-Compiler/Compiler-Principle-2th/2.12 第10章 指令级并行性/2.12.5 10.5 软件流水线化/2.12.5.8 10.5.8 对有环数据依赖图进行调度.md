### 10.5.8　对有环数据依赖图进行调度

依赖环明显地增加了软件流水线化的复杂性。当按照拓扑顺序对一个无环图中的运算进行调度时，被调度的运算之间的数据依赖关系只能给出每个运算位置的下界。结果，算法总是能够通过推迟运算来满足数据依赖关系。有环的图没有“拓扑排序”的概念。实际上，给定一个环中的一对运算，放置一个运算会限定第二个运算的位置的下界和上界。

令n1和n2是一个依赖环中的两个运算，S是一个软件流水线调度方案，而T是这个调度方案的启动间隔。一个带有标号<δ1,d1>的依赖边n1→n2对S（n1）和S（n2）加上了如下约束：

（δ1×T）+S（n2）-S（n1）≥d1

类似地，一个带有标号<δ2,d2>的依赖边n2→n1增加了如下约束：

（δ2×T）+S（n1）-S（n2）≥d2

因此

S（n1）+d1-（δ1×T）≤S（n2）≤S（n1）-d2+（δ2×T）

一个图的强连通分量（Strongly Connected Component，SCC）是满足如下条件的一个结点集合，其中的每个结点都可以从集合中的所有其他结点到达。对SCC中的一个结点进行调度将会从上下两个方向限制其他各个结点的可行时间。如果存在一个从n1到n2的路径p，那么有

![491-1](../Images/image04840.jpeg)

请注意下面的情况：

1）沿着任何一个环，各个边上的δ值的总和必须为正。如果和是0或者负数，就表明环中的一个运算要么必须在它自己之前执行，要么所有迭代中的该运算都在同一时钟周期执行。

2）一个迭代中的各运算的调度方案和所有迭代中的调度方案相同，这个要求实质上就是“软件流水线”的含义。结果，一个环上的延时（即数据依赖图中边的标号的第二个元素）的总和除以环上的迭代距离的总和所得的商就是启动间隔T的一个下界。

当我们把这两点联系起来，就可以看到，如果p是一个环，那么对于任何可行的启动间隔T，式（10.1）的右边部分的值必然是负数或零。由此可见，对于结点位置的最强约束来自于简单路径——那些不包含环的路径。

因此，对于每个可行的启动间隔T，计算每对结点之间的数据依赖关系的传递效果就等同于寻找从第一个结点到达第二个结点的最长的简单路径。不仅如此，因为环不会增加一条路径的长度，所以可以用一个简单的动态规划算法在没有“简单路径”需求的情况下来寻找最长路径。这样得到的长度也一定是最长简单路径的长度（见练习10.5.7）。

例10.20　图10-27显示了有四个结点a、b、c、d的数据依赖图。每个结点上附加了该结点的资源预约表，每条边上附加了它的迭代距离和延时。假设这个例子中的目标机器的每一种资源都有一个单元。因为对第一种资源有三处使用，而第二种资源有两处使用，所以启动间隔必须不小于3个时钟。在这个图中有两个连通分量：第一个是只包含了结点a的分量，第二个包含了结点b、c和d。最长的环b、c、d、b的总延时是3个时钟周期。这个环把相隔一个迭代的结点连接起来。因此，根据数据依赖环约束得到的启动间隔的下界也是3个时钟周期。

![491-2](../Images/image04841.jpeg)

图10-27　例10.20中的依赖图和资源需求

对b、c或d中的任何一个进行调度都会对分量中的其他结点产生约束。令T为启动间隔。图10-28显示了传递依赖关系。图10-28a显示了每条边的延时和迭代距离δ。其中的延时是直接表示的，而δ则是通过在延时上“加”上-δT来表示的。

![492-1](../Images/image04842.jpeg)

图10-28　例10.20中的传递约束

如果两个结点之间存在简单路径，那么图10-28b中就显示了这两个结点之间的最长简单路径的长度。表中的项是图10-28a中给出的路径上各条边的表达式的和。然后，在图10-28c和图10-28d中，我们看到的表达式是将图10-28b的表达式中的T替换为两个相关值（即3和4）之后得到的表达式。根据不同的T值，两个结点n1和n2的调度时间位置之差S（n2）-S（n1）必须不小于在图10-28c或图10-28d中的项（n1,n2）的值。

比如，考虑图10-28中给出的表示从c到b的最长（简单）路径的项2-T。从c到b的最长简单路径是c→d→b。这条路径上的总延时是2，而δ的和是1，它表明迭代编号必须加1。因为T表示每个迭代和前一个迭代的时间差异，为b安排的时钟周期必须至少是安排给c的时钟周期之后的第2-T个时钟周期。因为T至少是3，我们实际上是说b必须被安排在c之前的T-2个时钟周期或再晚一些，但是不能更早了。

请注意，考虑从c到b的非简单路径并不会产生更强的约束。我们可以在路径c→d→b上加上由d和b组成的环的任意多次迭代。如果我们加上k个这样的环，因为路径的总延时为3，而环上的δ的总和是1，我们得到的路径长度为2-T+k（3-T）。因为T≥3，所以这个长度绝不会超过2-T，即b的时钟和c的时钟的差的下界是2-T，也就是我们考虑最长简单路径时得到的界限。

比如，从项（b,c）和（c,d）我们可以知道

S（c）- S（b）≥ 1

S（b）- S（c）≥ 2-T。

也就是说，

S（b）+1≤S（c）≤S（b）-2+T

如果T=3，则

S（b）+1≤S（c）≤S（b）+1

等价地说，c必须被安排在b后一个时钟周期上。但是，如果T=4，则

S（b）+1≤S（c）≤S（b）+2

也就是说，c可以被安排在b后的一个或两个时钟周期上。

给定所有点对之间的最长路径的信息，我们可以很容易地计算出由于数据依赖的原因，一个结点可以放置在什么位置。我们看到，当T=3时放置结点b的位置是没有松弛度的，而当T增加的时候这个松弛度会增加。

算法10.21　软件流水线化。

输入：一个机器资源向量R=［r1,r2,…］，其中ri表示第i种资源的可用单元的数量；一个数据依赖图G=（N,E）。N中的每个运算n的标号为它的资源预约表RTn；E中的每条边e=n1→n2上有标号<δe,de>，这个标号表示n2的执行时刻不能早于向前第δe个迭代中的结点n1之后的de个时钟周期。

输出：一个软件流水线化的调度方案S和一个启动间隔T。

方法：执行图10-29中的程序。

![493-1](../Images/image04843.jpeg)

图10-29　一个针对有环依赖图的软件流水线化算法

算法10.21在高层结构上和只能处理无环图的算法10.19类似。在本算法处理的情况中，最小的启动间隔不仅受到资源需求的限制，也受到图中数据依赖环的限制。整个图是按照每次处理一个强连通分量的方式进行调度的。通过把每个强连通分量当作一个单元，在强连通分量之间的边必然形成一个无环图。算法10.19的顶层循环按照拓扑顺序来调度图中的结点，而算法10.21的顶层循环按照拓扑顺序调度各个强连通分量。和前面一样，如果算法不能调度所有的分量，那么它就会尝试较大的启动间隔。请注意，如果给定一个无环的数据依赖图，算法10.21和算法10.19的做法是完全一样的。

算法10.21要计算得到额外两个边集：E′是所有的迭代距离为0的边，而E*是所有点对之间的最长路径边集。也就是说，对每个结点对（p,n），只要有一条从p到n的路径，在E*中就有一条边e，该边所关联的长度de是从p到n的最长简单路径的长度。对于启动间隔目标T的每一个取值都需要计算相应的E*。也可以像我们在练习10.20中所做的那样，先使用T的符号化值一次性完成这个计算过程，然后在每一次迭代的时候把T替换为实际的启动间隔的值。

算法10.21使用了回溯。如果它不能完成一个SCC的调度，它就会延后一个时钟周期再次对整个SCC进行调度。这些调度尝试会持续T个时钟周期。回溯是很重要的，因为如例10.20所示，对于一个SCC中的第一个结点的调度安排可能会完全地决定所有其他结点的调度安排。如果这个调度方案不能和至今已经产生的调度方案配合，那么这次尝试就失败了。

在对一个SCC进行调度时，对该分量中的每个结点，此算法确定了满足E*中的传递数据依赖关系的最早可调度的时间。然后，算法选择具有最早开始时间的结点作为第一个被调度的结点。然后，此算法调用SccScheduled，试图根据这个最早开始时间实际调度这个分量。如果尝试失败，此算法将逐次增大开始时间，不断尝试。该算法最多做T次尝试。如果T次尝试失败了，该算法就会尝试另一个启动间隔。

算法SccScheduled和算法10.19类似，但是有三大不同之处：

1）SccScheduled的目标是对输入的强连通分量在给定时间位置s上进行调度。如果该强连通分量的第一个结点不能被安排在s上，SccScheduled就返回false。在需要时，主函数main可以使用一个较晚的时间位置再次调用SccScheduled。

2）在强连通分量中的结点按照E’中的边集所确定的拓扑顺序进行调度。因为E’中的所有边的迭代距离都是0，这些边不会穿越任何迭代边界，也就不会形成环（穿越迭代边界的边被称为穿越循环的）。只有穿越循环的依赖会设置指令可调度位置的上界。因此，这个调度顺序以及尽早调度安排各条指令的策略把后继结点的可调度范围最大化了。

3）对于强连通分量，依赖关系既给出了一个结点的可调度范围的下界，又给出了其上界。SccScheduled计算了这些范围，并使用它们进一步限制调度尝试。

例10.22　让我们把算法10.21应用到例10.20中的有环的数据依赖图上。算法首先计算出这个例子的启动间隔的下界是3个时钟周期。注意，这个下界不可能达到。当启动间隔T是3时，图10-28中的传递依赖关系决定了S（d）-S（b）=2。把结点b和d安排在间隔两个时钟的位置会在长度为3的模数资源预约表中产生一个冲突。

图10-30说明了算法10.21是如何处理这个例子的。它首先试图找到一个启动间隔为3个时钟周期的调度方案。这次尝试开始时，算法尽可能早地调度结点a和b。但是，一旦结点b被安排在第二个时钟周期，结点c就只能安排在第3个时钟周期。这和结点a的资源使用相冲突。也就是说，a和c在能够被3整除的时钟周期上都需要第一种资源。

![494-1](../Images/image04844.jpeg)

图10-30　算法10.21在处理例10.20时的行为

这个算法执行回溯，试图延后一个时钟周期再对强连通分量{b,c,d}进行调度。这一次结点b被安排在第三个时钟周期上，而结点c可以被成功地安排在第4个时钟周期上。但是，结点d不能被安排在第5个时钟周期上。也就是说，在能够被3整除的时钟周期上，b和d都需要第二种资源。请注意，虽然至今为止找到的两个冲突都发生在除以3的余数都是0的时钟位置上，但是这只是一个巧合；在其他的例子中，冲突可能在余数为1或2的时钟周期上发生。

算法再次延后一个时钟周期尝试对强连通分量{b,c,d}进行调度。但是，前面讨论过，当启动间隔是3个时钟周期时，这个强连通分量实际上永远不可能被成功地调度，因此这次尝试一定会失败。此时，这个算法放弃尝试，并试图找到一个启动间隔为4个时钟的调度方案。这个算法最终在第6次尝试时找到了最优调度方案。
### 10.5.1　引言

在本节中，我们将使用例10.12中的do-all循环来解释软件流水线化。我们首先说明跨越迭代的调度极其重要，原因是在单一迭代过程中的运算之间的并行性相对较小。然后，我们说明循环展开技术通过让被展开迭代相互重叠执行来提高程序的性能。但是，被展开循环之间的界限仍然为代码移动设置了障碍，还有很多可改进性能机会没有被循环展开技术充分利用。另一方面，软件流水线化技术将多个连续的迭代持续地交叠执行，直到所有迭代执行完毕为止。这个技术使得软件流水线化技术可以生成高效紧凑的代码。

例10.12　下面是一个典型的do-all循环：

![484-1](../Images/image04823.jpeg)

上面循环中各个迭代对不同的内存位置执行写运算，而这些被写的位置不同于任何被读的位置。因此各个迭代之间没有内存依赖关系，所有的迭代都可以并行地进行。

在本节中，我们选择下面的模型作为目标机器。在这个模型中，

- 机器可以在同一个时钟周期内发出：一个加载运算、一个保存运算、一个算术运算和一个分支运算。
- 机器有一个如下形式的循环回归运算指令

![484-2](../Images/image04824.jpeg)

这个运算把寄存器R的值减一，并且在结果不为0的情况下跳转到位置L。

- 内存运算有一个自动加一的寻址模式，通过寄存器之后的++符号表示。在每次访问之后，寄存器自动地加一，指向接下来的一个地址。
- 算术运算是完全流水线化的。每个时钟周期可以启动一个算术运算，但是结果要到2个时钟周期后才可用。所有其他指令的执行延时为一个时钟周期。

如果每次只对一个迭代进行调度，那么在这个机器模型上得到的最好调度方案如图10-17所示。该图中也指明了一些有关数据布局的假设：寄存器`R1、R2和R3`存放数组A、B和D的开始地址，寄存器`R4`存放常量c，而寄存器`R10`存放值n-1，这个值在循环之外计算。这个计算过程大部分是串行的，共需要7个时钟周期。只有循环回归运算指令的执行和迭代的最后一个运算的执行重叠。

![484-3](../Images/image04825.jpeg)

图10-17　例10.12的局部调度代码

一般来说，我们可以展开一个循环的多个迭代来获得较好的硬件利用率。但是这么做会增加代码的大小，会对程序的整体性能产生负面影响。因此，我们必须选择一个折衷方案，选择适当的迭代展开次数以选择最大的性能提升，但是又不能过度扩展代码。下面的例子解释了这种折衷方案。

例10.13　虽然在例10.12中循环的各个迭代内部几乎找不到并行性，但各个迭代之间依然具有很多并行性。循环展开技术把该循环的多个迭代放到一个大基本块中，然后使用一个简单的列表调度算法来对这些运算进行调度，使之并行运行。如果把我们的例子中的循环展开四次并把算法10.7应用于展开得到的代码，那么就可以得到图10-18显示的调度方案（为简单起见，我们忽略寄存器分配的细节）。这个循环执行了13个时钟周期，或者说每个迭代执行3.25个周期。

![484-4](../Images/image04826.jpeg)

图10-18　例10.12的未展开的代码

一个被k次展开的循环至少需要2k+5个时钟周期，得到的吞吐量是每2+5/k个时钟周期一个迭代。因此，我们展开的迭代越多，循环就运行得越快。当k→∞时，一个完全展开的循环可以平均每两个时钟周期执行一次迭代。但是，我们展开的迭代越多，得到的代码也越大。我们当然承担不起把一个循环的全部迭代都展开的代价。把这个循环展开4次生成了有13条指令的代码，执行时间是最优情况的163%；把这个循环展开8次生成了带有21条指令的代码，执行时间是最优情况的131%。反过来，如果我们希望执行时间只是最优情况的110%，我们需要把这个循环展开25次，这将产生带有55条指令的代码。
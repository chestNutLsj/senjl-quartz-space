### 10.5.7　对无环数据依赖图进行调度

为简单起见，我们现在假设即将进行软件流水线化处理的循环只包含一个基本块。在10.5.11节中将放宽这个假设条件。

算法10.19　对一个无环依赖图进行软件流水线化处理。

输入：一个机器资源向量R=［r1,r2,…］，其中ri表示第i种资源的可用单元数量；一个数据依赖图G=（N,E）。N中的每个运算n用它的资源预约表RTn作为标号；E中的每条边e=n1→n2上有标号<δe,de>。这个标号表示n2只能在往前第δe个迭代中的结点n1执行de个时钟周期之后才可以执行。

输出：一个经过软件流水线化的调度方案S和一个启动间隔T。

方法：执行图10-26中的程序。

![490-1](../Images/image04839.jpeg)

图10-26　无环依赖图的软件流水线化算法

算法10.19将无环的数据依赖图进行软件流水线化处理。这个算法首先基于图中运算的资源需求找到启动间隔的界限T0。然后它尝试以T0为启动间隔的目标，寻找一个软件流水线化的调度方案。如果算法不能为当前目标找到一个调度方案，它就不断增加启动间隔并重复尝试。

这个算法在每次尝试中使用了一个列表调度方法。它使用一个模数资源预约表RT来跟踪流水线的稳定状态所要求的资源。运算按照拓扑顺序进行调度，以便总是能够通过推迟运算来满足数据依赖关系。为了调度一个运算，它首先根据数据依赖约束找到一个下界s0。然后，它调用NodeScheduled来检测在稳定状态上可能发生的资源冲突。如果发现了资源冲突，该算法试图把这个运算安排在下一个时钟周期。因为资源冲突检测的取模特性，如果发现该运算在连续T个时钟周期上都有冲突，那么继续尝试也不会有用。此时，这个算法认为对当前启动间隔目标的尝试已经失败，继续尝试另一个启动间隔。

把各个运算尽早安排的启发式规则往往会使单个迭代的调度方案的长度最小化。但是，尽早安排一条指令可能会加长某些变量的生命期。比如，加载数据的运算往往会被较早安排，有时候会在数据被使用前很早就执行。处理这个问题的一个简单的启发规则是逆向地调度一个依赖图，理由是加载运算通常要多于保存运算。
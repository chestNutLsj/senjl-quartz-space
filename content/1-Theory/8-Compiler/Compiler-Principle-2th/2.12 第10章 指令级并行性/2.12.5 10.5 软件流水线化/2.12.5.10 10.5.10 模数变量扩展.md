### 10.5.10　模数变量扩展

如果一个标量变量的活跃范围处于循环的一个迭代之内，那么该标量变量被称为可私有化的（privatizable）。换句话说，一个可私有化变量不能在任何迭代的入口或者出口处活跃。这些变量会这样命名的原因是执行一个循环中的不同迭代的各个处理器可以拥有这些变量的私有拷贝，使得它们不会互相干扰。

变量扩展（variable expansion）指的是这样一种变换技术：它把一个可私有化的标量变量转换成为一个数组，并让循环的第i个迭代读写第i个元素。这个转换消除了一个迭代中的读运算和后一个迭代中的写运算之间的反依赖关系，以及不同迭代的写运算之间的输出依赖关系。如果所有的穿越循环的依赖关系都可以被消除，那么循环的各个迭代就可以并行执行。

消除穿越循环的依赖关系也就消除了数据依赖图中的环，这样可以大大提高软件流水线化的效率。如例10.15所示，我们不需要根据循环的迭代次数来完全扩展可私有化变量。同一时间内只能执行少量的迭代，而在同一时刻私有变量在其中活跃的迭代数量更少。因此，同一个内存位置可用于存放其生命周期不交叠的多个变量的值。更明确地讲，如果一个寄存器的生命周期是l个时钟，且启动间隔是T，那么在一个时间点上只有![495-1](../Images/image04845.jpeg)个值是活跃的。我们可以为该变量分配q个寄存器，而第i个迭代中的变量使用第（i mod q）个寄存器。我们把这种转换称为模数变量扩展（modular variable expansion）。

存在不同于启发式的方法吗？

我们可以把同时寻找最优软件流水线调度方案和寄存器分配方案的问题写成一个整数线性规划问题。虽然很多整数线性规划问题可以很快地得出解，但有些问题需要特别长的时间。在编译器中使用一个求解整数线性规划问题的程序时，我们必须能够在它无法在某个预设时间内完成解答时退出求解过程。

这个方法曾经在一个目标机器上（SGI R8000）实验性地尝试过，结果发现规划求解器可以在一个合理的时间内为大部分试验程序找到最优解决方案。我们发现，用启发式方法得到的调度方案和最优解相当接近。这个结果说明，至少对于那个目标机器，使用整数线性规划方法是没有什么意义的。从一个软件工程师的角度来看尤其如此。因为整数线性规划求解程序可能不会按时结束，在编译器中实现某种启发式调度程序仍然是必要的。一旦有了一个这样的启发式调度器，也就不需要再去实现一个基于整数规划技术的调度器了。

算法10.23　使用模数变量扩展技术的软件流水线化。

输入：一个数据依赖图和一个机器资源描述。

输出：两个循环，一个经过软件流水线化处理，另一个没有。

方法：

1）从输入的数据依赖图中删除和可私有化变量相关的穿越循环的反依赖关系和输出依赖关系。

2）使用算法10.21对第一步得到的数据依赖图进行软件流水线化。令T是已经找到相应调度方案的启动间隔，L是一个迭代的调度方案的长度。

3）对于每个可私有化变量v，依据得到的调度方案计算qv，即v所需要的最小寄存器数目。令Q=maxvqv。

4）生成两个循环：一个经过软件流水线化的循环和一个没有被流水线化的循环。被软件流水线化的循环有

![496-1](../Images/image04846.jpeg)

个迭代的拷贝，各个拷贝之间相距T个时钟。它有一个带有

![496-2](../Images/image04847.jpeg)

条指令的序言部分，一个带有QT条指令的稳定状态和一个具有L-T条指令的尾声部分。插入一个从稳定状态的尾部到稳定状态顶端的循环回归指令。

分配给可私有化变量v的寄存器数目是

![496-3](../Images/image04848.jpeg)

在第i个迭代中的变量v使用的是被分配给v的第（i mod ![496-5](../Images/image04849.jpeg)）个寄存器。

令n为源代码循环中表示迭代数目的变量。这个软件流水线化的循环被执行的前提是

![496-4](../Images/image04850.jpeg)

循环回归分支的执行次数是

![497-1](../Images/image04851.jpeg)

因此，软件流水线化的循环所执行的源代码中的迭代的次数是

![497-2](../Images/image04852.jpeg)

未被流水线化的循环执行的迭代数目是n3=n-n2。

例10.24　在图10-22中经过软件流水线化的循环中，L=8，T=2且Q=2。这个软件流水线化的循环有7个迭代的拷贝，其中的序言、稳定状态和尾声部分分别有6、4、6条指令。令n为源代码循环中的迭代次数。这个软件流水线化的循环在n≥5的时候被执行，在这种情况下循环回归分支被执行

![497-3](../Images/image04853.jpeg)

次，且软件流水线化的循环负责执行

![497-4](../Images/image04854.jpeg)

个源代码循环中的迭代。

模数扩展会把稳定阶段代码的大小增加到Q倍。虽然如此，由算法10.23生成的代码仍然是相当精简的。在最坏情况下，经过软件流水线化的循环的指令数目是单个迭代的调度方案中指令数目的三倍。粗略地讲，把用来处理零星迭代的额外循环加在一起，整个代码的大小大约是原代码大小的四倍。这个技术通常应用于紧凑的内层循环，因此这样的代码增加量是可接受的。

算法10.23可以使用更多的寄存器来使代码的扩展量降到最低。我们可以通过生成更多的代码来降低对寄存器的使用。如果我们使用一个具有

T×LCMvqv

条指令的稳定状态，我们最少可以为每个变量v使用qv个寄存器。这里，LCMv是求解所有qv的最小公倍数（即能够被所有qv整除的最小整数）的函数，v的取值范围是所有的可私有化变量。遗憾的是，即使对少量很小的qv值，最小公倍数也可能变得相当大。
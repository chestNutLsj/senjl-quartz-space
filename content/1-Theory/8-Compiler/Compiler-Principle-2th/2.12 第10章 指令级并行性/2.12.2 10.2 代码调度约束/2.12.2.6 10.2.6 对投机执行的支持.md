### 10.2.6　对投机执行的支持

内存加载指令是能够从投机执行中获得很大好处的指令类型。当然，内存加载是很常见的。它们有比较长的执行延时，加载指令中使用的地址通常可以预先知道，且结果可以存放到一个新的临时变量中而不会破坏任何其他变量的值。遗憾的是，如果它们的地址是非法的，内存加载可能会引发异常，因此投机性地访问非法地址可能会使一个正确的程序意外地停止执行。另外，预测错误的内存加载可能引起额外的高速缓存脱靶和页面错误，这些问题的代价都非常大。

例10.5　在代码片段

![471-4](../Images/image04802.jpeg)

中，如果p的值是`null`，投机性地对p解引用可能会使得正确的程序停止执行。

很多高性能处理器都提供了特殊的功能来支持投机性内存访问。下面我们给出其中一些最重要的特殊功能。

预取指令

人们发明了预取（prefetch）指令，以便在数据被使用之前将其从内存移动到高速缓存。一个预取指令向处理器表明该程序可能很快就要使用特定内存字。如果指定的内存位置不可用，或者访问该位置会引起页面错误，那么处理器可以直接忽略这个指令。否则，如果该数据不在高速缓存中，处理器将把该数据从内存移动到高速缓存。

毒药位

另一个体系结构特征被称为毒药位（poison bit）。人们发明毒药位以便投机性地把数据从内存加载到寄存器文件。该机器上的每个寄存器都增加了一个毒药位。如果访问了非法内存，或者被访问的页面不在内存中，处理器并不立刻引发异常，而是仅仅设置目标寄存器的毒药位。只有当其毒药位被置位的寄存器中的内容被使用时才会引发一个异常。

带断言的执行

因为分支运算的开销很大，而预测错误的分支的开销更大（见10.1节），人们发明了带断言的指令（predicated instruction）以减少一个程序中的分支数量。一条带断言的指令和一条普通指令类似，但是它有一个额外的断言运算分量，作为它的执行条件。只有在该断言被满足时指令才会执行。

例如，一个带条件的移动指令`CMOVZ R2, R3, R1`的语义是只有当寄存器`R1`的值为零时寄存器`R3`的内容才会被移动到寄存器`R2`。假设a、b、c和d分别分配到寄存器`R1、R2、R4、R5`中，下面的代码

![472-1](../Images/image04803.jpeg)

可以使用如下两条机器指令实现：

![472-2](../Images/image04804.jpeg)

这个转换把一系列具有控制依赖关系的指令替换为只有数据依赖关系的指令。替换后的这些指令可以和相邻的基本块合并，形成更大的基本块。更重要的是，使用这些代码，处理器就不会产生预测错误，因此保证了指令流水线的平滑运行。

带断言的执行也是有代价的。即使最后不需要执行带断言的指令，处理器也必须获取该指令并解码。静态调度器必须保留执行它们所需要的资源，并保证所有可能的数据依赖都得到满足。除非机器拥有的资源大大多于不使用带断言指令时所需要的资源，否则不应该过度使用带断言指令。

动态调度机器

使用静态调度的机器的指令集明确地定义了哪些指令可以并行执行。但是，回顾一下10.1.2节，有些机器的体系结构允许到运行时刻再确定哪些指令可以并行运行。使用动态调度，同样的机器代码可以在同一系列的不同机器上运行。这些机器实现了同样的指令集，但是拥有不同数量的并行执行支持设施。实际上，机器代码级的兼容是动态调度机器的一个主要优点。

用软件方式在编译器中实现的静态调度器可以帮助（用机器硬件实现的）动态调度器更好地利用机器资源。在为一个动态调度机器构造一个静态调度器时，我们几乎可以照搬为静态调度机器设计的调度算法，只是新算法不需要明确地生成原算法放置在调度方案中的`no-op`指令。这个问题将在10.4.7中进一步讨论。
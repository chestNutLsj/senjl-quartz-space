### 10.2.3　寄存器使用和并行性之间的折衷

在这一章中，我们将假设源程序的机器无关中间表示形式使用了无限多个伪寄存器（pseudoregister）。这些伪寄存器代表了可以分配到寄存器的变量。这些变量包括源程序中不能通过任何其他名字访问的标量，也包括由编译器生成的用于存放表达式的部分结果的临时变量。和内存位置不同，寄存器的命名是唯一的。因此可以很容易地为寄存器访问生成精确的数据依赖约束。

在中间表示形式中使用的无限多个伪寄存器最终必须被映射到在目标机器上可用的少量物理寄存器。把几个伪寄存器映射为同一个物理寄存器有一个副作用。这种映射会生成人为的存储依赖，这限制了指令级的并行性。反过来，并行执行指令产生了更多的存储需求，以便存放同时计算出来的值。因此，尽量降低寄存器使用数量的目标和最大化指令级并行性的目标直接冲突。下面的例10.2和例10.3说明了存储和并行性之间的典型折衷处理。

硬件寄存器重命名

指令级并行性首先是作为一种加快普通的顺序机器代码执行速度的手段在计算机体系结构中使用的。当时的编译器还不知道机器上的指令级并行性，其目标是优化寄存器的使用。它们仔细地重新排列指令以使所用的寄存器数目最少，但同时也使可用的并行性的数量减到最少。例10.3说明的是在表达式树的计算过程中最小化寄存器使用的同时也限制了它的并行性。

在顺序代码中的并行性太少了，计算机体系结构设计师不得不发明了硬件寄存器重命名（hardware register renaming）的概念，试图通过寄存器重命名来撤销寄存器优化所带来的影响。硬件寄存器重命名在程序运行时动态地改变寄存器的指派。它对机器代码进行解释，把本来存放在同一个寄存器中的值存放在不同的内部寄存器中，并把对这些值的使用修正到相应的内部寄存器。

因为人为的寄存器依赖约束首先是由编译器引入的，如果使用了一个认识到指令级并行性的寄存器分配算法，这些约束就可以被消除。当一个机器的指令集只能引用少量寄存器时，硬件寄存器重命名机制仍然是有用的。这种能力使得我们可以给出这个指令集体系结构的更好的实现，把代码中的由指令集体系结构规定的少量寄存器动态地映射到多得多的内部寄存器上。

例10.2　下面的代码使用伪寄存器`t1`和`t2`把位于位置`a`和`c`上的变量的值分别复制到在位置`b`和`d`上的变量中。

![469-1](../Images/image04794.jpeg)

如果已知所有被访问的内存位置都互不相同，那么上面的复制过程可以并行进行。但是，如果为了尽量降低所用寄存器的数量而把`t1`和`t2`赋给同一个寄存器，那么复制过程就只能顺序进行了。

例10.3　传统的寄存器分配技术的目标是尽可能减少一个计算过程所需要的寄存器数目。考虑表达式

![469-2](../Images/image04795.jpeg)

图10-2显示了它的语法树。如图10-3的机器代码所示，可以使用3个寄存器来完成这个表达式的计算。

![470-1](../Images/image04796.jpeg)

图10-2　例10.3中的表达式树

![470-2](../Images/image04797.jpeg)

图10-3　图10-2中表达式的机器代码

但是，对寄存器的复用使得计算串行化。唯一可以并行执行的运算是把位置`a`和`b`的值加载到寄存器，以及把位置`d`和`e`的值加载到寄存器。因此并行地完成这个计算共需要7步。

假如我们使用不同的寄存器来存放各个部分和，这个表达式可以在4步内完成求值。这个步数正好是图10-2中的表达式树的高度。图10-4给出了这样的并行计算过程。

![470-3](../Images/image04798.jpeg)

图10-4　图10-2中表达式的并行求值过程
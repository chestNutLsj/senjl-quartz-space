### 10.2.4　寄存器分配阶段和代码调度阶段之间的顺序

如果在代码调度之前进行寄存器分配，那么得到的代码往往会有很多存储依赖，而这会限制代码调度。另一方面，如果在寄存器分配之前先进行代码调度，那么得到的代码调度方案可能需要太多的寄存器，以至于寄存器溢出（spilling）会抵消指令级并行性所带来的好处。所谓寄存器溢出是指把一个寄存器中的内容保存到一个内存位置上，使得该寄存器可以用于其他目的。一个编译器应该首先分配寄存器然后再进行代码调度吗？还是应该按照相反顺序处理？或者我们同时解决这两个问题？

为了回答上面的问题，我们必须考虑被编译程序的特性。很多非数值应用没有那么多可用的并行性。把少量的寄存器专门用于保存表达式的临时结果就足够了。我们可以首先应用8.8.4节中所述的着色算法，为所有非临时变量分配寄存器，然后进行代码调度，最后为临时变量分配寄存器。

这个方法对于数值应用的效果就不太好（数值应用中有很多大型表达式）。我们可以使用层次化的方法来处理。代码优化首先从最内层循环开始，按照从内向外的顺序进行。首先进行指令调度，此时假设可以给每个伪寄存器分配一个独占的物理寄存器。然后进行寄存器分配，并在需要的地方加入处理寄存器溢出的代码，然后再次对代码进行调度。然后我们对较外层的循环重复这个过程。当把同一个外层循环中的多个内层循环一起考虑时，同一个变量可能在不同内层循环中被分配到不同的寄存器中。我们可以改变寄存器的分配方案，以避免把值从一个寄存器复制到另一个寄存器。在10.5节中，我们将在特定调度算法的上下文环境下进一步讨论寄存器分配和指令调度之间的关系。
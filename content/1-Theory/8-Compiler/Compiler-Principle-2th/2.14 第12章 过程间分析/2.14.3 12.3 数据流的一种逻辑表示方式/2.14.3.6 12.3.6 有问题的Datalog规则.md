### 12.3.6　有问题的Datalog规则

有些Datalog规则，或者说程序，在技术上没有任何意义，因此不应该使用。两种最严重的风险是：

1）不安全规则：这些规则的头中有一个变量没有以适当的方法出现在规则体中。正确的方法必须限定这个变量只能取那些出现在EDB中的值。

2）不可分层的程序：一组规则之间存在涉及否定形式的循环定义。

我们将详细讨论这两个风险。

安全规则

出现在某个规则头的任何变量都必须出现在规则体中。不仅如此，这个变量所在的子目标必须是一个普通IDB或EDB原子。我们不能接受一个变量只出现在一个否定原子中或比较运算符中的情况。制定这个策略是为了避免那些可能使我们推导出无穷多个事实的规则。

例12.19　规则

p（X, Y）：- q（Z）& NOT r（X）& X≠Y

是不安全的。原因有两个：变量X只出现在否定的子目标r（X）和比较表达式X≠Y中；Y只出现在比较式中。结果是只要r（X）为假且Y不同于X，p对于无穷多个二元组（X, Y）为真。

可分层的Datalog程序

为了让一个程序有意义，递归定义和否定形式必须分开。正式要求如下。我们必须能够把IDB断言分割成为多个层次（strata），使得如果存在一个规则，其头断言为p且有一个形如`NOT` q（…）的子目标，那么q要么是一个EDB，要么是一个层次低于p的IDB断言。只要满足这个规则，我们就可以用算法12.15或算法12.18从低到高地对各个层次求值。首先处理处理较低层次的IDB，在处理较高层次时把低层次上的IDB当作EDB。但是，如果我们违反了这个规则，那么如下面的例子所示，迭代算法可能无法收敛。

例12.20　考虑下面的由单个规则构成的Datalog程序：

p（X）：- e（X）& NOT p（X）

假设e是一个EDB断言，并且只有e（1）为真。那么p（1）为真吗？

这个程序是不可分层的。不管我们把p放在哪一层，它的规则中有一个子目标是某个IDB（即p本身）的否定形式，且这个IDB（即p）所在的层次当然不会比p的层次更低。

如果我们应用上面的迭代算法，我们从![604-1](../Images/image05077.jpeg)开始，因此开始时的答案是“不；p（1）不为真。”但是，因为e（1）和`NOT` p（1）都为真，所以第一次迭代时推导出p（1）。但是，之后的第二次迭代告诉我们p（1）为假。也就是说，在这个规则中，把X替换为1不会令我们推导出p（1），因为子目标`NOT` p（1）为假。类似地，第三次迭代说p（1）为真，第四次迭代说它是假，如此往复。我们断定这个不可分层的程序是无意义的，也不能把它看作一个正确的程序。
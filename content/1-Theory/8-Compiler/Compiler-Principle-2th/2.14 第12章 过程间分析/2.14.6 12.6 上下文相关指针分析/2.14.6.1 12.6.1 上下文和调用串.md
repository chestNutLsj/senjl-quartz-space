### 12.6.1　上下文和调用串

下面描述的上下文相关的指针指向分析假设我们已经计算得到了一个调用图。这个假设有助于我们使用紧凑的方式来表示多个调用上下文。为了得到调用图，我们首先运行一次上下文无关的指针指向分析过程。12.5节讨论过，这个分析过程同时生成了调用图。现在我们描述如何创建克隆的调用图。

调用串形成了活跃的函数调用的历史，而一个上下文就是一个调用串的表示形式。另一个看待上下文的方法是把它看作一个调用序列的摘要。这些调用的活动记录当前位于运行时刻栈中。如果栈中没有递归函数，那么这个调用串（即调用了栈中函数的位置的序列）是一个完全表示。同时它也是一个可接受的表示方式，因为只有有限多个不同的上下文。虽然上下文的个数可能是程序中函数数量的指数级。

但如果程序中存在递归函数，那么可能的调用串的数目是无穷的，我们不能用所有可能的调用串来表示不同的上下文。可以使用多个方法来限制不同的上下文的数目。比如，我们可以编写一个描述了所有可能调用串的正则表达式，然后使用3.7节中的方法把这个表达式转化成为一个确定的有穷状态自动机。之后，各个上下文就可以使用这个自动机的状态来标识。

这里，我们将采用一个更简单的方案，它包含非递归调用的全部历史，但是把递归调用当作“难以分拆”的内容。我们首先找出程序中相互递归调用的函数的集合。这个过程很简单，因此这里不再详细讨论。考虑一个以程序中各个函数为结点的图。如果函数p调用了函数q，那么图中就存在一条从结点p到q的边。这个图的强连通分量（SCC）就是相互递归调用函数的集合。下面的这个特例很常见。一个函数p调用了它自身，但是它不在包含了其他函数的SCC中，那么函数p本身是一个SCC，而所有的非递归函数本身也是SCC。如果一个SCC具有多个成员（即相互递归调用的情况），或者它包含唯一一个递归成员，我们就说这个SCC是非平凡的（nontrivial）。单个非递归函数组成的SCC是平凡SCC。

前面有一个规则说任何调用串都是一个上下文，我们对这个规则做如下修改。给定一个调用串，如果下面情况成立就删除一个调用点s的出现：

1）s在一个函数p中。

2）函数q在调用点s处被调用（有可能q=p）。

3）p和q位于同一个强连通分量中（即p和q相互递归调用，或者p=q且p是递归函数）。

这么做的结果是，当一个非平凡SCC的成员S被调用时，这个调用的调用点变成了上下文的一部分，但是在S中对同一SCC中其他函数的调用都不在这个上下文中。最后，当一个S之外的调用发生时，我们把该调用点记录为这个上下文的一部分。

例12.26　图12-28中给出了五个函数的略图，图中给出了一些调用点和这些函数中的调用。检查一下这些调用就会发现，q和r是相互递归的。但是p、s和t根本不会递归调用。因此，我们的上下文将是除了`s3`和`s5`之外的所有调用点的列表。函数q和r之间的递归调用就发生在`s3`和`s5`处。

![614-1](../Images/image05092.jpeg)

图12-28　与一个运行实例对应的函数和调用点

让我们考虑从p到t的所有路径，也就是所有调用了t的上下文：

1）p可以在`s2`处调用s，然后s可以在`s7`或者`s8`处调用t。因此，两个可能的调用串是`（s2, s7）`和`（s2, s8）`。

2）p可以在`s1`处调用q。然后，q和r可以多次递归地调用对方。我们把这个环打开：

① 在`s4`处，t直接被q调用。这个选择可以得到唯一的上下文`（s1, s4）`。

② 在s6处，r调用s。这里，我们可以通过在`s7`处或`s8`处的调用到达t。这么做给出了两个新的上下文`（s1, s6, s7）`和`（s1, s6, s8）`。

因此，总共有五个不同的上下文调用了t。请注意，所有这些上下文都省略了递归调用点`s3`和`s5`。比如，上下文`（s1, s4）`实际上表示了对应于调用串`（s1, s3,（s5, s3）n, s4）`的无穷集合，其中n≥0。

现在我们描述一下如何得到克隆调用图。每一个被克隆的方法都使用程序中的方法M和一个上下文C来标识。在原调用图的边上加上相应的上下文就可以得到克隆后的调用图的边。请注意，在原调用图中有一条连接调用点S和方法M的边的条件是断言invokes（S, M）为真。为了增加上下文以标识克隆调用图中的例程，我们可以定义一个相应的断言CSinvokes，CSinvokes（S, C, M, D）为真的条件是上下文C中的调用点S调用了方法M的上下文D。
### 12.7.4　用BDD操作实现关系运算

现在，我们看到了如何把关系表示成BDD。但是，要实现像算法12.18（Datalog程序的增量式求值）那样的算法，我们还需要能够操作BDD以反映相应关系上的运算。下面给出了我们要完成的主要的关系运算：

1）初始化：我们需要创建一个BDD来表示一个关系的单个元组。我们将通过合并运算把这些表示单个元组的BDD集成到表示大型关系的BDD中去。

2）合并：为了表示关系的合并，我们使用布尔函数的逻辑OR运算来表示得到的关系。这个运算不仅用来构造初始关系，也用于把具有相同头断言的多个规则的结果合并起来，还会用于把新的断言事实合并到老事实的集合中去。算法12.18要求实现这些运算。

3）投影：当我们对一个规则体求值的时候，我们需要构造出由那些使得规则体取真值的元组所蕴含的头断言的关系。从表示这个关系的BDD的角度来说，我们需要消除其中的一些结点，这些结点的布尔变量标号没有用来表示头关系中的分量。我们可能还需要对BDD中的某些变量重新命名，以使得它们和头关系分量的布尔变量相对应。

4）连接：为了找出令一个规则体为真的变量的赋值组合，我们需要把对应于各个子目标的关系“连接”起来。比如，假设我们有两个子目标r（A, B）&s（B, C）。这些子目标的关系的连接是满足下列条件的三元组（a, b, c）的集合：（a, b）是r的关系中的一个元组，且（b, c）是s的关系的一个元组。我们将看到，在对BDD中的布尔变量重新命名，使得对应于两个B分量的变量同名之后，这个BDD操作和逻辑AND运算类似，而逻辑AND运算和在BDD上实现关系合并的逻辑OR运算类似。

单一元组的BDD

为了初始化一个关系，我们需要使用一种方法来为那些只对单个真假赋值取真值的函数构造BDD。假设布尔变量为x1，x2，…，xn，并且这个唯一的真假赋值为a1a2…an，其中每个ai是0或1。相应的BDD对于每个xi有一个结点Ni。如果ai=0，那么Ni的高边直接到达叶子结点0，而低边到达结点Ni+1，或在i=n时到达叶子1。如果ai=1，我们进行同样的处理，只是高边和低边顺序相反。

这个策略给出了一个BDD，它能够检查每个xi（i=1, 2, …, n）是否具有正确的值。一旦找到不正确的值，我们就直接跳转到叶子结点0。只有当所有变量的取值都正确时，我们才会在最后到达叶子结点1处。

作为例子，可以回到前面的图12-33b。这个BDD表示了一个当且仅当x=y=0（即真假赋值为00时）才取真值的函数。

合并

我们将详细地给出一个算法来计算BDD的逻辑OR，也就是这两个BDD所表示的关系的合并。

算法12.29　BDD的合并。

输入：两个排序的BDD，它们的变量集合相同，且排序也相同。

输出：一个BDD，它表示的函数是两个输入BDD所表示的布尔函数的逻辑OR。

方法：我们将描述一个合并两个BDD的递归过程。这个过程按照BDD中出现的变量集合的大小进行归纳。

归纳基础：零个变量。这两个BDD必然都是叶子结点，其标号是1或0。如果两个输入中有一个是1，那么输出就是标号为1的叶子结点；如果两个输入都是0，那么输出叶子结点的标号是0。

归纳步骤：假设两个BDD中总共出现了k个变量y1，y2，…，yk。执行下列步骤：

1）如果必要，使用反向的短路转换加入一个新的根，使得两个BDD的根的标号都是y1。

2）设两个BDD的根为N和M，令它们的低边子结点分别为N0和M0，它们的高边子结点分别为N1和M1。对分别以N0和M0为根的两个BDD递归地应用这个算法。同时也对分别以N1和M1为根的两个BDD应用这个算法。在得到的两个BDD中，第一个BDD表示的函数取真值的条件是：相应的真假赋值中y1=0，并且它使得两个输入BDD中的一个或全部取真值。第二个BDD表示同样的函数，不过其中的y1=1。

3）创建一个新的标号为y1的根结点。它的低边子结点是通过递归构造得到的第一个BDD的根结点，而它的高边子结点是第二个BDD的根结点。

4）在刚刚通过合并得到的BDD中把两个标号为0的叶子结点合并，同时把两个标号为1的叶子结点合并。

5）在可能的时候应用合并和短路转换，简化得到的BDD。

例12.30　在图12-33a和图12-33b中有两个简单的BDD。第一个BDD表示函数x OR y，而第二个BDD表示函数

`NOT` x AND `NOT` y

![620-1](../Images/image05100.jpeg)

图12-33　为逻辑OR构造BDD

请注意，它们的逻辑OR的结果是常量函数1，即永真函数。对这两个BDD应用算法12.29时，我们考虑两个根的低边子结点和它们的高边子结点。我们先考虑后者。

在图12-33a中，根的高边子结点是1，而在图12-33b中的相应子结点是0。因为这两个子结点都在叶子层次上，所以不需要在每条边上插入标号为y的结点，尽管我们这么做会得到同样的结果。结点0和1的合并是算法中归纳基础的情况，合并后生成一个标号为1的叶子结点。这个叶子结点将成为新的根结点的高边结点。

图12-33a和图12-33b中的根的低边结点的标号都是y，因此我们递归地计算它们的合并BDD。这两个结点的低边子结点的标号分别为0和1，因此它们的低边子结点的合并是标号为1的叶子结点。当我们加入新的根结点x后，我们得到图12-33c中的BDD。

我们还没有完成，因为图12-33c还可以进一步简化。标号为y的结点的两个子结点都是结点1，因此我们可以把结点y删除，并把1当作根结点的低边子结点。现在，根结点的两个子结点都是叶子结点1，因此我们可以消除根结点。也就是说，表示这个合并操作结果的最简单的BDD就是叶子1本身。
### 12.1.1　调用图

一个程序的调用图（call graph）是一个结点和边的集合，并满足

1）对程序中的每个过程都有一个结点。

2）对于每个调用点（call site）都有一个结点。所谓调用点就是程序中调用某个过程的一个位置。

3）如果调用点c调用了过程p，就存在一条从c的结点到p的结点的边。

很多用诸如C或Fortran语言编写的程序直接进行过程调用，因此每个调用的调用目标可以静态地确定。在这种情况下，调用图中的每个调用点都恰好有一条边指向一个过程。但是，如果程序使用了过程参数或函数指针，一般来说，需要到程序运行时刻才能知道调用目标，而且实际上可能各次调用的目标都有所不同。那么，一个调用点可能连接到调用图中的多个甚至所有的过程。

对于面向对象程序设计语言来说，间接调用是标准的调用方式。特别地，当存在子类对方法进行重载的情况时，对方法m的使用可能指向多个不同方法中的任意一个，这要取决于该调用所作用的接收对象的子类。使用这样的虚（virtual）方法调用意味着我们需要知道接收者的类型之后才可以确定调用了哪个方法。

例12.1　图12-1显示了一个C程序。该程序声明`pf`是一个指向类型为“整数到整数”的函数的全局指针。有两个函数`fun1`和`fun2`是这个类型。此外，`main`函数不是`pf`所指向的类型。图中显示了三个调用点，标记为`c1、c2`和`c3`，这些标号不是程序的一部分。

![589-1](../Images/image05052.jpeg)

图12-1　一个具有函数指针的程序

最简单的对`pf`可能指向哪个函数的分析只查看函数的类型。函数`fun1`及`fun2`和`pf`所指向的对象具有相同的类型，而`main`则不同。因此，一个保守的调用图如图12-2a所示。对这个程序进行更深入的分析，就可以观察到`pf`在`main`中指向`fun2`，而在`fun2`中指向`fun1`。但是没有其他的对任何指针的赋值，因此`pf`不可能指向`main`函数。这个推理过程产生的调用图和图12-2a中的相同。

一个更加精确的分析将指出`pf`在c3上只可能指向`fun2`，因为紧靠这个调用之前的赋值语句将`fun2`赋给`pf`。类似地，`pf`在c2处只可能指向`fun1`。分析的结果是，对`fun1`的第一次调用必然是`fun2`做出的，且`fun1`不会改变`pf`的值，因此当我们在`fun1`中时，`pf`就指向`fun1`。特别地，我们可以确信`pf`在`c1`处指向`fun1`。因此，图12-2b是一个更加精确、正确的调用图。

![589-2](../Images/image05053.jpeg)

图12-2　从图12-1得到的调用图

一般来说，当出现了对函数或方法的引用或指针时，要求我们对所有过程参数、指针、接收对象类型等的可能取值进行静态估计。要得到一个精确的估计值就必须进行过程间分析。这个分析从可以静态观察到的目标开始，迭代地进行。当发现一个新的调用目标时，分析过程就会把一条新边加入到调用图中，并不断寻找更多的目标，直到收敛。
### 12.1.5　基于摘要的上下文相关分析

基于摘要的过程间分析是基于区域的分析技术的扩展。基本上，在一个基于摘要的分析中，每个过程使用一个简洁的描述（摘要）来刻划。这个描述包含这个过程的某些可观察行为。摘要的主要目的是避免在每个可能调用某过程的调用点上都重复分析该过程的过程体。

让我们首先考虑没有递归的情况。每个过程被建模为只有一个入口点的区域。每一对调用者-被调用者之间具有类似于外层区域-内层区域的关系。和过程内分析的唯一不同在于，在过程间分析时，一个过程区域可能嵌套在多个不同的外层区域中。

这个分析由两部分组成：

1）一个自底向上的阶段，它为每个过程计算出一个总结该过程的效果的传递函数。

2）一个自顶向下的阶段，它传播和调用者有关的信息，计算出被调用者的结果。

为了得到完全上下文相关的结果，来自不同调用上下文的信息必须被单独传递到被调用者。如果希望计算过程更高效，但是允许相对的不精确性，那么也可以使用一个交函数合并来自各个调用者的信息，然后再向下传播到被调用者。

例12.8　对于常量传播，每个过程都使用一个传递函数作为其摘要，该传递函数描述了过程是如何通过它的过程体传播常量的。在例子12.2中，我们可以把f总结为如下的函数：如果把一个常量c作为v的实在参数，那么该函数返回常量c+1。基于这个信息，这个分析过程将确定`t1、t2`和`t3`分别具有常量值1、244和244。请注意，这个分析过程并没有因为不可实现的调用串而产生不精确的结果。

回忆一下，例子12.4扩展了例子12.2，增加了一个函数g来调用f。因此我们可以得出结论，g的传递函数和f的传递函数是相同的。我们仍然可以确定`t1、t2`和`t3`分别具有常量值1、244和244。

现在让我们考虑例子12.2中函数f内的参数v的值是什么。最初考虑时，我们可以把所有调用上下文的结果组合在一起。因为v的值可以是0或者243，所以可以简单地确定v不是一个常量。这个结论是合理的，因为没有哪个常量可以替换代码中的v。

如果我们希望得到更加精确的结果，那么可以为感兴趣的上下文计算特定值。必须把信息从我们感兴趣的上下文向下传递，以确定和这个上下文相关的答案。这个步骤和基于区域的分析中的自顶向下过程类似。比如，v在调用点`c1`处的值为0，而它在调用点`c2`和`c3`处的值为243。为了利用f内部的常量传播性质，我们需要创建两个克隆来表示这两者的不同，第一个克隆是针对输入值0的特例，而后一个克隆是针对输入值243的特例，如图12-9所示。

![594-1](../Images/image05060.jpeg)

图12-9　将所有可能的常量参数传递给函数f后的分析结果

通过例子12.8，最后我们看到如果希望在不同的上下文中以不同的方式编译代码，仍然需要克隆代码。本方法和基于克隆的方法的不同之处在于后者在分析之前就需要根据调用串进行克隆。在基于摘要的方法中，克隆是在分析之后，以分析结果为基础进行克隆。即使没有进行克隆，在基于摘要的方法中关于一个被调用过程的运行效果的推理结果也是精确的，不会出现不可实现路径的问题。

除了克隆一个函数，我们也可以对代码进行内联处理。内联的另一个效果是消除了过程调用的开销。

我们可以用计算不动点解的方法来处理递归。当出现递归时，我们首先找出调用图中的强连通分量。在自底向上阶段，只有当一个强连通分量的所有后继都已经被访问之后，我们才访问这个分量。对于一个非平凡的强连通分量，我们迭代地为该分量中的每个过程计算传递函数，直到重复过程收敛为止。也就是说，我们迭代地更新这些传递函数，直到它们不再发生改变为止。
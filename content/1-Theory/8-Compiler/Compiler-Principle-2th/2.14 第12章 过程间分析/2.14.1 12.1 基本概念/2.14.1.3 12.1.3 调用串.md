### 12.1.3　调用串

在例12.2中，我们只需要知道调用过程f的调用点就可以区分不同的上下文。一般情况下，一个调用上下文是通过整个调用栈中的内容来定义的。我们把栈中各个调用点组成的串称为调用串（call string）。

例12.4　图12-5是对图12-3进行细微的修改后得到的。这里我们把对f的调用替换成对g的调用。函数g随后用同样的参数调用f。函数g调用f的地点是`c4`，这是一个新增的调用点。

![591-1](../Images/image05056.jpeg)

图12-5　演示调用串的程序片段

有三个对应于f的调用串：`（c1, c4）、（c2, c4）`和`（c3, c4）`。如我们在这个例子中见到的，函数f中v的值并不由调用串中的直接（或者说最后）调用点`c4`决定。这些常量值实际上是由每个调用串中的第一个元素决定的。

例12.4表明，与分析相关的信息可能在调用链的早期就被引入。事实上，如例12.5所示，为了得到最精确的答案，有时甚至需要考虑计算整个调用串。

例12.5　这个例子说明了对不限长度的调用串的分析能力是如何产生出更加精确的结果的。在图12-6中，我们看到如果用一个正数值c来调用g，g将会被递归地调用c次。每次g被调用的时候，它的参数v的值减一。因此，在调用串为`c2（c4）`n的上下文中，g的参数v的值是243-n。因此，g的功能就是把0或任何负参数加一，并对任何大于等于1的参数返回2。

![591-2](../Images/image05057.jpeg)

图12-6　需要分析整个调用串的递归程序

函数f有三个可能的调用串。如果我们从`c1`处的调用开始，那么g可以立刻调用f，因此`（c1, c5）`就是这样的一个串。如果我们从`c2`或`c3`开始，那么我们共调用g 243次，然后再调用f。这些调用串是`（c2, c4, c4, … , c5）`和`（c3, c4, c4, … , c5）`，在这两种情况下的序列中都有242个c4。在这些上下文中，在第一个上下文中f的参数v的值是0，而在另外两个中的参数值为1。

在设计一个上下文相关分析的时候，我们可以选择不同的精确度。比如，我们可以选择只使用调用串中最直接的k个调用点来区分上下文，而不是使用整个调用串来提高分析结果的质量。这个技术被称为k-界限上下文分析技术。上下文无关分析就是k-界限上下文分析技术在k=0时的特例。我们可以使用1-界限分析技术找出例12.2中的所有常量，用2-界限分析技术找出例12.4中的所有常量。但是，只要例12.5中的常量243被替换成为不同的任意大小的常量值，没有任何k-界限分析可以找出该例中的所有常量。

如果不选定一个固定的k值，另一种可行方法是对所有无环调用串进行完全的上下文相关分析。所谓无环调用串就是不包含递归环的调用串。对于所有带有递归的调用串，我们可以把所有的递归环都塌缩成一个点，以便限定需要分析的不同上下文的数目。在例12.5中，从调用点c2开始的调用可以用调用串`（c2, c4*, c5）`近似地表示。请注意，使用这种方案时，即使对于不带递归的程序，不同调用上下文的数目和程序中的过程数目呈指数关系。
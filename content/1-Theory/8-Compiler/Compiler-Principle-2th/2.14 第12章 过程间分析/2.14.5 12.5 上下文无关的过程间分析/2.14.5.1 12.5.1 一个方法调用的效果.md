### 12.5.1　一个方法调用的效果

在Java中，一个形如`x=y.n（z）`的方法调用对指针指向关系的影响可以计算如下：

1）确定接收对象的类型，也就是y所指向对象的类型。假设它的类型是t。令m是最低的具有名为n的例程的t的超类中的那个名为n的例程。请注意，一般情况下只能动态确定被调用的方法。

2）方法m的形式参数被赋予了实在参数所指向的对象。实在参数不仅仅包括直接传递的参数，也包括接收对象本身。每个方法调用把接收对象赋给`this`变量[^3]。我们把`this`变量当作各个方法的第0个形式参数。在`x=y.n（z）`中有两个形式参数：y所指向的对象被赋给变量`this`，而z所指向的对象被赋给m中声明的第一个形式参数。

3）方法m的返回对象被赋给这个赋值语句的左部变量。

在上下文无关分析中，参数和返回值都由复制语句建模。尚待解决的一个有意思的问题是如何确定接收对象的类型。我们可以根据这个变量的声明保守地确定它的类型。比如，被声明变量的类型为t，那么只有t的某个子类型中名字为n的方法会被调用。遣憾的是，如果被声明变量的类型为`Object`，那么所有名为n的方法都是可能的调用目标。在密集使用对象层次结构和包含了大型类库的实际程序中，这个方法可能会得到很多虚假的调用目标，使得分析过程既缓慢又不精确。

我们需要知道被分析的变量可能指向什么样的对象，以便计算出调用目标。但是，除非我们知道了调用目标，否则无法找出所有这些变量会指向什么样的对象。这个递归关系要求我们在计算指针指向集合的同时找出调用目标。这个分析需要不断进行，直到找不到新的调用目标和新的指针指向关系为止。

例12.24　在图12-26的代码中，r是s的一个子类，而s本身又是t的一个子类。如果只使用声明类型的信息进行分析，`a.n()`可以调用在上述代码中声明的三个名为n的方法中的任何一个，因为s和r都是a的声明类型t的子类型。不仅如此，看起来在第5行之后a可以指向对象g、h和i。

![611-1](../Images/image05089.jpeg)

图12-26　一个虚拟方法调用

通过分析程序中指针指向关系，我们首先确定a可以指向j，而j是一个类型为t的对象。因此，第1行中声明的方法是一个调用目标。分析第1行，我们确定a也可能指向g，而g是一个类型为r的对象。因此，第3行中声明的方法也可能是一个调用目标，且现在a可能也指向i，而i是另一个类型为r的对象。因为没有发现更多的新调用目标，这个分析过程终止了。它既没有分析第2行中声明的方法，也没有断定a可能指向h。
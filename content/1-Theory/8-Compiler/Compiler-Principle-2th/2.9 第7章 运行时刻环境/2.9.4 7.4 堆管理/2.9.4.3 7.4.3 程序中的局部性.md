### 7.4.3　程序中的局部性

大部分程序表现出高度的局部性（locality），也就是说，程序的大部分运行时间花费在相对较小的一部分代码中，此时它们只涉及少部分数据。如果一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问，我们就说这个程序具有时间局部性（temporal locality）。如果被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问，我们就说这个程序具有空间局部性（spatial locality）。

通常认为程序把90%的时间用来执行10%的代码。原因如下：

- 程序经常包含很多从来不会被执行的指令。使用组件和库构建得到的程序只使用了它们提供的一小部分功能。同时，随着需求的改变和程序的演化，遗留系统中常常包含很多不再被使用的指令。
- 在程序的一次典型运行中，可能被调用的代码中只有一小部分会被实际执行。例如，虽然处理非法输入和异常情况的指令对于程序的正确性是至关重要的，但是它们在某次运行中很少会被调用。
- 通常的程序往往将大部分时间花费在执行程序中的最内层循环和最紧凑的递归环上。

静态的和动态的RAM

大部分随机访问内存是动态的（dynamic），这意味着它们是由简单的电子电路构成的。这些电路会在短时间内丢失电位（因此也就会“忘记”它们原本存储的比特值）。这些电路需要定期刷新，即读出然后重新写入它们的比特。另一方面，在静态（static）RAM的设计中，每个比特都需要一个更复杂的电路，结果是存储在其中的比特值可以保持任意长时间，直到它被改写为止。显然，一个芯片使用动态RAM电路可以比使用静态RAM电路存储更多的比特。因此我们通常会看到动态RAM类型的大容量主存，而像高速缓存这样的较小存储则使用静态电路构造。

局部性使得我们可以充分利用如图7-16所示的现代计算机的存储层次结构。将最常用的指令和数据放在快而小的存储中，而将其余部分放入慢而大的存储中，我们就可以显著地降低一个程序的平均存储访问时间。

人们已经发现，很多程序在对指令和数据的访问方式上既表现出时间局部性，又表现出空间局部性。然而，数据访问模式通常比指令访问模式表现出更大的多样性。将最近使用的数据放在最快的存储层次中的策略可以在普通程序中发挥很好的作用，但是在某些数据密集型程序中的作用并不明显——循环遍历非常大的数组的程序就是这样的例子。

仅仅通过查看代码，我们一般无法看出哪部分代码会被频繁地用到，针对特定输入指出这一点则更加困难。即使我们知道哪些指令会被频繁执行，最快的高速缓存通常也不能够同时存储这些指令。因此，我们必须动态调整最快的存储中的内容，用它们来保存可能很快会被频繁使用的指令。

利用存储层次结构的优化

将最近使用过的指令放入高速缓存的策略通常很有效。换句话说，过去的情况能够很好地预测将来的存储使用情况。当一条新的指令被执行时，其下一条指令也很有可能将被执行。这种现象是空间局部性的一个例子。提高指令的空间局部性的一个有效技术是让编译器把很可能连续执行的多个基本块（即总是顺序执行的指令序列）连续存放，即放在同一个存储页面中，可能的话甚至放在同一高速缓存线中。属于同一个循环或同一个函数的指令很有可能被一起运行[^4]。

我们还可以改变数据布局或计算顺序，从而改进一个程序中的数据访问的时间局部性和空间局部性。例如，一些程序反复地访问大量数据，而每次访问只完成少量的计算，这样的程序的性能不会很好。我们可以每次将一部分数据从存储层次结构的较慢层次加载到较快层次（比如从磁盘移到主存），并且在这些数据驻留在较快层中时执行所有针对这些数据的运算，那么程序的性能就会变得更好。这个概念可以递归地应用于物理内存、高速缓存以及寄存器中的数据的复用。

高速缓存体系结构

我们如何知道一个高速缓存线在高速缓存中呢？逐个检查高速缓存中的每一条高速缓存线过于费时，因此在实践中常常会限制一条高速缓存线在高速缓存中的放置位置。这个约束称为成组相关性（set associativity）。如果在一个高速缓存中，一条缓存线只能被放在k个位置上，那么这个高速缓存就称为k路成组相关的（k-way set associative）。最简单的高速缓存是1路相关高速缓存，它也称为直接映射高速缓存（direct-mapped cache）。在一个直接映射高速缓存中，存储地址为n的数据只能够放在缓存地址n mod s上，其中s是这个高速缓存的大小。类似地，一个k路成组相关高速缓存被分为k个集合，而一个地址为n的数据只能映射到各个集合中的位置n mod（s/k）上。大部分指令和数据高速缓存的相关性在1～8之间。如果一条缓存线被调入高速缓存，并且所有可能存放这个高速缓存线的位置都已经被占用，那么通常情况下会将最近最少使用的缓存线清除出高速缓存。
### 7.4.4　碎片整理

在程序开始执行的时候，堆区就是一个连续的空闲空间单元。随着这个程序分配和回收存储工作的进行，空间被分割成若干空闲存储块和已用存储块，而空闲块不一定位于堆区的某个连续区域中。我们将空闲存储块称为“窗口”（hole）。对于每个分配请求，存储管理器必须将请求的存储块放入一个足够大的“窗口”中。除非找到一个大小恰好相等的“窗口”，否则我们必定会切分某个窗口，结果创建出更小的窗口。

对于每个回收请求，被释放的存储块被放回到空闲空间的缓冲池中。我们把连续的窗口接合（coalesce）成为更大的窗口，否则窗口只会越变越小。如果我们不小心，空闲存储最终会变成碎片，即大量的细小且不连续的窗口。此时，就有可能找不到一个足够大的“窗口”来满足某个将来的请求，尽管总的空闲空间可能仍然充足。

best-fit和next-fit对象放置

我们通过控制存储管理器在堆区中放置新对象的方法来减少碎片。经验表明，使现实中的程序中碎片最少的一个良好策略是将请求的存储分配在满足请求的最小可用窗口中。这个best-fit算法趋向于将大的窗口保留下来满足后续的更大请求。另一种策略被称为first-fit。在这个策略中，对象被放置到第一个（即地址最低的）能够容纳请求对象的窗口中。这种策略在放置对象时花费的时间较少，但是人们发现它在总体性能上要比best-fit策略差。

为了更有效地实现best-fit放置策略，我们可以根据空闲空间块的大小，将它们分在若干个容器中。一个实际可行的想法是为较小的尺寸设置较多的容器，因为小对象的个数通常比较多。例如，在GNU的C编译器gcc中使用的存储管理器Lea将所有的存储块对齐到8字节的边界。对于16字节到512字节之间的、每个大小为8字节整数倍的存储块，这个存储管理器都设置了一个容器。更大尺寸的容器按照对数值进行划分（即每个容器的最小尺寸是前一个容器的最小尺寸的两倍）。在每一个容器中，存储块按照它们的大小排列。总是存在这样一个空闲空间块，存储管理器可以向操作系统请求更多的页面来扩展这个块。这个块被称为“荒野块”（wilderness chunk）。因为它的可扩展性，Lea把这个块当作最大尺寸存储块的容器。

容器机制使得寻找best-fit块变得容易。

- 如果被请求的尺寸有一个专有容器，即该容器只包含该尺寸的存储块，我们可以从该容器中任意取出一个存储块。Lea存储管理器在处理小尺寸请求时就是这样做的。
- 如果被请求的尺寸没有专有的容器，我们可以找出一个能够包含该尺寸的存储块的容器。在这个容器中，我们可以使用first-fit或best-fit策略。也就是说，我们既可以找到并选择第一个足够大的存储块，也可以花更多的时间去寻找最小的满足需求的存储块。注意，如果选择的空闲存储块的大小不是正好合适，通常将该块的剩余部分放到一个对应于更小尺寸的容器中。
- 不过，这个目标容器可能为空，或者这个容器中的所有存储块都太小，不能满足空间请求。在这种情况下，我们只需要使用对应于下一个较大尺寸的容器重新进行搜索。最后，我们要么找到可以使用的存储块，要么到达“荒野块”。从这个荒野块中我们一定可以得到需要的空间，但有可能需要请求操作系统为堆区增加更多的内存页。

虽然best-fit放置策略可以提高空间利用率，但从空间局部性的角度考虑，它可能并不是最好的。程序在同一时间分配的块通常具有类似的访问模式，并具有类似的生命周期。因此将它们放置在一起可以改善程序的空间局部性。对best-fit算法的有用改进之一是在找不到恰巧等于请求尺寸的存储块时，使用另一种对象放置方法。在这种情况下，我们使用next-fit策略，只要刚刚分割过的存储块中还有足够的空间来容纳这个对象，我们就把这个对象放置在这个存储块中。next-fit策略还可以提高分配操作的速度。

管理和接合空闲空间

当一个对象通过手工方式回收时，存储管理器必须将该存储块设置为空闲的，以便它可以被再次分配。在某些情况下，还可以将这个块和堆中的相邻块合并（接合）起来，构成一个更大的块。这样做是有好处的。因为我们总能够用一个大的存储块来完成总量相等的多个小存储块所完成的工作，但是不能用很多个小存储块来保存一个大对象，而合并后的存储块就有可能做到。

如果我们为所有具有固定尺寸的存储块保留一个容器，如Lea中为小尺寸块所做的那样，那么我们可能倾向于不把相邻的该尺寸的块合并成为双倍大小的块。比较简单的做法是将所有同样大小的块全部按照需要放在多个页中，而不必接合。那么，一个简单的分配/回收方案是维护一个位映射，其中的每个比特对应于容器中的一个块。1代表该块已被占用，0表示它是空闲的。当一个块被回收时，我们将它对应的1改为0。当我们需要分配一个存储块时，便找出任意一个相应比特为0的块，将这个位改为1，然后就可以使用该内存块了。如果没有空闲块，我们就获取一个新的页，将其分割成适当大小的存储块，同时扩展用于存储管理的位向量。

在有些情况下问题会变得比较复杂。比如，我们不使用容器而把堆区作为一个整体进行管理；或者我们想要接合相邻的块，并在必要的时候将合并得到的块移动到另一个容器中。有两种数据结构可以用于支持相邻空闲块的接合：

- 边界标记。在每个（不管是空闲的还是已分配的）存储块的高低两端，我们都存放了重要的信息。在块的两端都设置了一个free/used位，用来标识当前该块是已用的（used）还是空闲的（free）。在与每一个free/used位相邻的位置上存放了该块中的字节总数。
- 一个双重链接的、嵌入式的空闲列表。各个空闲块（而不是已分配的块）还使用一个双重链表进行链接。这个链表的指针就存放在这些块中，比如说存放在紧挨着某一端边界标记的位置上。因此，不需要额外的空间来存放这个空闲块列表，尽管它的存在为块的大小设置了一个下界。即使数据对象只有一个字节，存储块也必须提供存放两个边界标记和两个指针的空间。空闲列表中的存储块的顺序没有确定。例如，这个列表可以按块的大小排序，因此可以支持best-fit放置策略。

例7.10　图7-17给出堆区的一个部分，其中包含三个相邻的存储块A、B和C。B块的大小为100，它刚刚被回收并回到了空闲列表中。因为我们知道B的开始位置（左端），也就知道了紧靠在B的左边的存储块的末端，在这个例子中就是A。A右端的free/used位当前为0，因此A也是空闲的。于是我们可以将A和B接合成一个300字节的存储块。

![312-1](../Images/image04490.jpeg)

图7-17　堆的片段和一个双重链接的空闲列表

有可能出现这样的情况，即紧靠在B的右端的存储块C也是空闲的。在这种情况下，我们可以把A、B和C全部合并起来。请注意，如果我们总是尽可能地把存储块接合起来，那么就不会有两个连续的空闲块。因此我们总是只需要查看与正被回收的块相邻的两个块。在当前例子中，我们按照下面的步骤找到C的开始位置。我们从已知的B的左端开始，在B的左边界标记中知道B块的总字节数为100字节。根据这个信息，我们可以找到B的右端和紧靠在B右边的存储块的起始位置。在该点上，我们检查C的free/used位，发现其值为1，表明C正在被使用，因此C不可以被接合。

因为我们必须接合A和B，所以需要从空闲列表中删除它们中的一个。空闲列表的双重链接结构使得我们可以找到A和B中的前驱和后继结点。请注意，不应该假定在物理上相邻的A和B在空闲列表中也相邻。知道了A和B在空闲列表中的前驱和后继的存储块，就可以操作列表中的指针并将A和B替换为一个接合后的存储块。

如果自动垃圾回收过程将所有已分配的存储块移动到一段连续的存储中，它同时还可以消除所有的碎片。在7.6.4节中将更详细地讨论垃圾回收机制和存储管理之间的相互影响。
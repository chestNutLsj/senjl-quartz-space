### 7.4.5　人工回收请求

我们在本节的最后讨论人工存储管理。此时，程序员必须像在C和C++语言中那样显式地安排数据的回收。在理想情况下，任何不会再被访问的存储都应该删除。反过来，任何可能还会被引用的空间都不能删除。遗憾的是，这两个性质都很难保证。除了考虑人工回收的困难之处以外，我们还将描述一些被程序员用于处理这些难点的技术。

人工回收带来的问题

人工存储管理很容易出错。常见的错误有两种形式：一直未能删除不能被引用的数据，这称为内存泄漏（memory-leak）错误；引用已经被删除的数据，这称为悬空指针引用（dangling-pointer-dereference）错误。

程序员不能保证一个程序是否永远不会在将来引用某块存储，因此第一个常见的错误是没有删除那些不会被再次引用的数据。请注意，尽管内存泄漏可能由于占用的存储增多而降低程序运行的速度，但是只要机器没有用完全部存储，它们就不会影响程序的正确性。很多程序可以容忍内存泄漏，当泄漏比较缓慢时尤其如此。然而，对于长期运行的程序，特别是像操作系统和服务器代码这样不间断运行的程序，保证它们没有内存泄漏是非常关键的。

自动垃圾回收通过回收所有的垃圾而消除了内存泄漏问题。即使使用自动垃圾回收机制，程序可能仍然耗费了过多的内存。有时尽管在某处还存在着对某个对象的引用，但程序员可能已经知道该对象不会再被引用。在那种情况下，程序员可以主动地删除指向那些不会再被引用的对象的引用，使得这些对象可以被自动回收。

一个工具实例：Purify

Rational的Purify是帮助程序员寻找程序中的内存访问错误和内存泄漏的最常用的商业工具之一。Purify对二进制代码进行插装，加入在程序运行时检查程序错误的附加指令。它维护了一个存储的映像图，指明所有空闲的和已用的空间的分布。每个已分配空间的对象都被一段额外空间包围；对未分配空间的访问，或对数据对象之间的间隙空间的访问都被标记为错误。通过这种方法可以找到一些悬空指针引用，但是当该内存已经被重新分配且该位置上已经存在一个有效对象时，这种方法就无能为力了。这种方法还可以找到一些越界的数组访问，前提是它们恰巧落在这些对象之后，由Purify插入的空间中。

Purify也可以在程序运行结束时发现内存泄漏。它搜索所有的已分配的对象中的内容，找出所有可能的指针值。任何没有指针指向的对象都是一块泄漏的存储块。Purify可以报告泄漏内存的大小和泄漏对象的位置。我们可以将Purify和一个“保守的垃圾回收器”相比较，后者将在7.8.3节中讨论。

过度热衷于删除对象可能引起比内存泄漏更严重的问题。第二个常见的错误是删除了某个存储空间，然后又试图去引用这个已回收空间中的数据。指向已回收空间的指针称为悬空指针（dangling pointer）。一旦这个已释放的空间被重新分配给另一个变量，通过该悬空指针进行的任何读、写或回收操作都可能产生看起来不可捉摸的结果。我们把诸如读、写、回收等沿着一个指针试图使用该指针所指对象的所有操作称为对这个指针的“解引用”（dereferencing）。

注意，通过一个悬空指针读取数据可能会返回不确定的值。通过一个悬空指针进行写操作则可能不确定地改变新变量的值。回收一个悬空指针的存储空间意味着这个新变量的存储空间可能被分配给另一个变量。新旧变量上的动作可能会相互冲突。

和内存泄漏不一样，在释放的空间被重新分配之后再对相应的悬空指针进行解引用总是会带来难以调试的程序错误。因而，当程序员不能确定一个变量是否还会被引用时，他们更倾向于不回收该变量。

另一个相关的编程错误形式是访问非法地址。这种错误的常见例子包括对空指针的解引用和访问一个数组界限之外的元素。探测出这种错误要好过任由程序产生错误结果。实际上，很多安全危害就是利用了这种类型的程序错误。其中，某个程序输入会导致意想不到的数据访问，使得一个黑客取得这个程序和机器的控制权。解决办法之一是让编译器在每次访问中插入检查代码，以保证该次访问在数组界限之内。一些编译器的优化器可以发现并删除那些不必要的检查代码，因为这些优化器能够推导出相应的访问必然在区间之内。

编程规范和工具

现在我们给出几个最流行的编程规范和工具，开发它们的目的是帮助程序员来应对的存储管理的复杂性：

- 当一个对象的生命周期能够被静态推导出来时，对象所有者（object ownership）的概念是很有用的。它的基本思想是在任何时候都给每个对象关联上一个所有者（owner）。这个所有者是指向该对象的一个指针，通常属于某个函数调用。所有者（也就是这个函数）负责删除这个对象或者把这个对象传递给另一个所有者。可能会有其他的指针也指向同一个对象，但是这些指针不代表拥有关系。这些指针可在任何时刻被覆盖，但是绝对不应该通过它们进行删除操作。这个规范可以消除内存泄漏，同时也可以避免将同一对象删除两次。然而，它对解决悬空指针引用问题没有帮助，因为有可能沿着一个不代表拥有关系的指针访问一个已经被删除的对象。
- 当一个对象的生命周期需要动态确定时，引用计数（reference counting）会有所帮助。它的基本思想是给每个动态分配的对象附上一个计数。在指向这个对象的引用被创建时，我们将此对象的引用计数加一；当一个引用被删除时，我们将此引用计数减一。当计数变成0时，这个对象就不会再被引用，因此可以被删除。然而，这个技术不能发现无用的循环数据结构，其中的一组对象不能再被访问，但是因为它们之间互相引用，导致它们的引用计数不为0。在例子7.11中可以看到这个问题的一个示例。引用计数技术确实可以根除所有的悬空指针引用，因为不存在指向已删除对象的引用。因为引用计数在存储一个指针的每次运算上增加了额外开销，因此引用计数的运行时刻代价很大。
- 对于其生命周期局限于计算过程中的某个特定阶段的一组对象，可以使用基于区域的分配（region-based allocation）方法。当被创建的对象只在一个计算过程的某个步骤中使用时，我们可以把这些对象分配在同一个区域中。一旦这个计算步骤完成，我们就删除整个区域。基于区域的分配方法有一定的局限性。然而当可以使用它时，它又非常高效。因为该技术以成批的方式一次性删除区域中的所有对象，而不是每次回收一个对象。
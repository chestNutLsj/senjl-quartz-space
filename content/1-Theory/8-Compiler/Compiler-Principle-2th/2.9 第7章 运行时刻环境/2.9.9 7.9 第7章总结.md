## 7.9　第7章总结

- 运行时刻组织。为了实现源语言中的抽象概念，编译器与操作系统及目标机器协同，创建并管理了一个运行时刻环境。该运行时刻环境有一个静态数据区，用于存放对象代码和在编译时刻创建的静态数据对象。同时它还有动态的栈区和堆区，用来管理在目标代码执行时创建和销毁的对象。
- 控制栈。过程调用和返回通常由称为控制栈的运行时刻栈管理。我们可以使用栈结构的原因是过程调用（或者说活动）在时间上是嵌套的。也就是说，如果p调用q，那么q的活动就嵌套在p的活动之内。
- 栈分配。对于那些允许或要求局部变量在它们的过程结束之后就不可访问的语言而言，局部变量的存储空间可以在运行时刻栈中分配。对于这样的语言，每一个活跃的活动都在控制栈中有一个活动记录（或者说帧）。活动树的根结点位于栈底，而栈中的全部活动记录对应于活动树中到达当前控制所在活动的路径。当前活动的记录位于栈顶。
- 访问栈中的非局部数据。像C这样的语言不支持嵌套的过程声明，因此一个变量的位置要么是全局的，要么可以在运行时刻栈顶的活动记录中找到。对于带有嵌套过程的语言而言，我们可以通过访问链来访问栈中的非局部数据。访问链是加在各个活动记录中的指针。可以顺着访问链组成的链路到达正确的活动记录，从而找到期待的非局部数据。显示表是一个和访问链联合使用的辅助数组，它提供了一个不需要使用访问链链路的高效捷径。
- 堆管理。堆是用来存放生命周期不确定的，或者可以生存到被明确删除时刻的数据的存储区域。存储管理器分配和回收堆区中的空间。垃圾回收在堆区中找出不再被使用的空间，这些空间可以回收并用于存放其他数据项。对于要求垃圾回收的语言，垃圾回收器是存储管理器的一个重要子系统。
- 利用局部性。通过更好地利用存储的层次结构，存储管理器可以影响程序的运行时间。访问存储的不同区域所花的时间可能从几纳秒到几毫秒不等。幸运的是，大部分程序将它们的大部分时间用于执行相对较小的一部分代码，并且此时只会访问一小部分数据。如果一个程序很可能在短期内再次访问刚刚访问过的存储位置，该程序就具有时间局部性。如果一个程序很可能访问刚刚访问的存储区域附近的位置，该程序就具有空间局部性。
- 减少碎片。随着程序分配和回收存储，堆区可能会变得破碎，或者说被分割成大量细小且不连续的空闲空间（或称为“窗口”）。best-fit策略（分配能够满足空间请求的最小可用“窗口”）经实践证明是有效的。尽管best-fit策略提高了空间利用率，但对于空间局部性而言它可能并不是最好的。可以通过合并或者说接合相邻的“窗口”来减少碎片。
- 人工回收。人工存储管理有两个常见的问题：没有删除那些不可能再被引用的数据，这称为内存泄漏错误；引用已经被删除的数据，这称为悬空指针引用错误。
- 可达性。垃圾就是不能被引用或者说到达的数据。有两种寻找不可达对象的基本方法：要么截获一个对象从可达变成不可达的转换，要么周期性地定位所有可达对象，并推导出其余对象都是不可达的。
- 引用计数回收器维护了指向一个对象的引用的计数。当这个计数变为0时，该对象就变成不可达的。这样的回收器带来了维护引用的开销，并且可能无法找出“循环”的垃圾，即由相互引用的不可达对象组成的垃圾。这些垃圾也可能通过由引用组成的链路相互引用。
- 基于跟踪的垃圾回收器从根集出发，迭代地检查或跟踪所有的引用，找出所有可达对象。根集包括了所有不需要对任何指针解引用就可直接访问的对象。
- 标记-清扫式回收器在一开始的跟踪阶段访问并标记所有可达对象，然后清扫堆区，回收不可达对象。
- 标记并压缩回收器改进了标记并清扫算法。它们把堆区中的可达对象重新定位，从而消除存储碎片。
- 拷贝回收器将跟踪过程和发现空闲空间过程之间的依赖关系打破。它将存储分为两个半空间A和B。首先使用某个半空间，比如说A，来满足分配请求，直到它被填满。此时垃圾回收器开始工作，将可达对象拷贝到另一个半空间，也就是B，然后对换两个半空间的角色。
- 增量式回收器。简单的基于跟踪的回收器在垃圾回收期间会停止用户程序的执行。增量式回收器让垃圾回收过程和用户程序（或者说增变者）交错运行。增变者可能干扰增量式可达性分析，因为它可能改变之前已扫描对象中的引用。因此，增量式回收器通过超量估计可达对象集合，达到安全工作的目标。所有的“漂浮垃圾”可以在下一轮回收中被删除。
- 部分回收器同样可以减少停顿时间。它们每次只回收一部分垃圾。最有名的部分回收算法是世代垃圾回收方法，它根据对象已分配时间的长短对对象分区，对新建对象进行更频繁的回收操作，因为它们的生命期通常较短。另一个算法列车算法使用固定长度的被称为车厢的区域。这些车厢被组织成列车。每一个回收步骤都处理尚存的第一辆列车中的当前的第一节车厢。当一节车厢被回收时，可达对象被移动到其他车厢中，这节车厢中最终只剩下垃圾，因此可以将其从该列车中删除。这两种算法可以一起使用，创建出一个部分回收器。该回收器对较年轻对象使用世代算法，对较成熟的对象使用列车算法。
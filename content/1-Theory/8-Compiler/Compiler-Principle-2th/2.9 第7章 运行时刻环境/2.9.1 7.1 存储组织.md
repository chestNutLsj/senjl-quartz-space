## 7.1　存储组织

从编译器编写者的角度来看，正在执行的目标程序在它自己的逻辑地址空间内运行，其中每个程序值都在这个空间中有一个地址。对这个逻辑地址空间的管理和组织是由编译器、操作系统和目标机共同完成的。操作系统将逻辑地址映射为物理地址，而物理地址对整个内存空间编址。

一个目标程序在逻辑地址空间的运行时刻映像包含数据区和代码区，如图7-1所示。某个语言（比如C++）在某个操作系统（比如Linux）上的编译器可能按照这种方式划分存储空间。

![290-1](../Images/image04468.jpeg)

图7-1　运行时刻内存被划分成代码区和数据区的典型方式

在本书中，我们假定运行时刻存储是以多个连续字节块的方式出现的，其中字节是内存的最小编址单元。一个字节包含8个二进制位，4个字节构成一个机器字。多字节数据对象总是存储在一段连续的字节中，并把第一个字节作为它的地址。

第6章中讨论过，一个名字所需要的存储空间大小是由它的类型决定的。基本数据类型，比如字符、整数或浮点数，可以存储在整数个字节中。聚合类型（比如数组或结构）的存储空间大小必须足以存放这个类型的所有分量。

数据对象的存储布局受目标机的寻址约束的影响很大。在很多机器中，执行整数加法的指令可能要求整数是对齐的，也就是说这些数必须被放在一个能够被4整除的地址上。尽管在C语言或者类似的语言中一个有10个字符的数组只需要能够存放10个字符的空间，但是编译器可能为了对齐而给它分配12个字节，其中的两个字节未使用。因为对齐的原因而产生的闲置空间称为补白（padding）。如果空间比较紧张，编译器可能会压缩数据以消除补白。但是，在运行时刻可能需要额外的指令来定位被压缩数据，使得机器在操作这些数据时就好像它们是对齐的。

生成的目标代码的大小在编译时刻就已经固定下来了，因此编译器可以将可执行目标代码放在一个静态确定的区域：代码区。这个区通常位于存储的低端。类似地，程序的某些数据对象的大小可以在编译时刻知道，它们可以被放置在另一个称为静态区的区域中，该区域可以被静态确定。放置在这个区域的数据对象包括全局常量和编译器产生的数据，比如用于支持垃圾回收的信息等。之所以要将尽可能多的数据对象进行静态分配，是因为这些对象的地址可以被编译到目标代码中。在Fortran的早期版本中，所有数据对象都可以进行静态分配。

为了将运行时刻的空间利用率最大化，另外两个区域——栈和堆被放在剩余地址空间的相对两端。这些区域是动态的，它们的大小会随着程序运行而改变。这两个区域根据需要向对方增长。栈区用来存放称为活动记录的数据结构，这些活动记录在函数调用过程中生成。

在实践中，栈向较低地址方向增长，而堆向较高地址方向增长。然而，在本章及下一章中，我们将假定栈向较高地址方向增长，以便我们能够在所有例子中方便地使用正的偏移量。

我们将在下一节看到，一个活动记录用于在一个过程调用发生时记录有关机器状态的信息，例如程序计数器和机器寄存器的值。当控制从该次调用返回时，相关寄存器的值被恢复，程序计数器被设置成指向紧跟在这次调用之后的点，然后调用过程的活动就可以重新开始。如果一个数据对象的生命周期包含在一次活动的生命期中，那么该对象可以和其他关于该活动的信息一起被分配到栈区上。

很多程序设计语言支持程序员通过程序控制人工分配和回收数据对象。例如，C语言中的`malloc`和`free`函数可以用来获取及释放任意存储块。堆区被用来管理这种具有长生命周期的数据。7.4节中将讨论多种可以用来维护堆区的存储管理算法。

#### 静态和动态存储分配

数据在运行时刻环境中的内存位置的布局及分配是存储管理的关键问题。这些问题需要谨慎对待，因为程序文本中的同一个名字可能在运行时刻指向不同的存储位置。两个形容词静态（static）和动态（dynamic）分别表示编译时刻和运行时刻。如果编译器只需要通过观察程序文本即可做出某个存储分配决定，而不需要观察该程序在运行时做了什么，我们就认为这个存储分配决定是静态的。反过来，如果只有在程序运行时才能做出决定，那么这个决定就是动态的。很多编译器使用下列两种策略的某种组合进行动态存储分配：

1）栈式存储。一个过程的局部名字在栈中分配空间。我们将从7.2节开始讨论“运行时刻栈”。这种栈支持通常的过程调用/返回策略。

2）堆存储。有些数据的生命周期要比创造它的某次过程调用更长，这些数据通常被分配在一个可复用存储的“堆”中。我们将从7.4节开始讨论堆管理。堆是虚拟内存的一个区域，它允许对象或其他数据元素在被创建时获得存储空间，并在数据变得无效时释放该存储空间。

为了支持堆区管理，通过“垃圾回收”使得运行时刻系统能够检测出无用的数据元素，即使程序员没有显式地释放它们的空间，运行时刻系统也能够复用这些存储。尽管自动垃圾回收机制是一个难以高效完成的操作，但它仍是很多现代程序设计语言的一个重要特征。对于某些语言来说，垃圾回收甚至是不可能完成的。
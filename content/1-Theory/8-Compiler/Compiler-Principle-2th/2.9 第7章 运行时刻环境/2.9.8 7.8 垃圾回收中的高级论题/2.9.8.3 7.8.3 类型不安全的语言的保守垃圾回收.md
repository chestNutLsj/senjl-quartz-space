### 7.8.3　类型不安全的语言的保守垃圾回收

如7.5.1节中讨论的，我们不可能构造出一个可以处理所有C和C++程序的垃圾回收器。因为我们总是可以通过算术运算来计算地址，所以在C和C++中，没有任何内存位置可被认为是不可达的。然而，很多C或C++程序从不按照这种方式随意地构造地址。已经证明，人们可以为这一类程序构造出一种保守的垃圾回收器（也就是不一定回收所有垃圾的回收器），在实践中它能够很好地完成任务。

保守的垃圾回收器假定我们不可以随意构造出一个地址，或者在没有指向某已分配存储块中某处的地址的情况下得到该存储块的地址。我们可以在程序中找出所有满足这一假设的垃圾。方法是，对于在任意可达存储区域中找到的一个二进制位模式，如果该模式可以被构造成一个内存位置，我们就认为它是一个有效地址。这种方案可能会把有些数据错当作地址。然而，这么做是正确的，因为这只会使得垃圾回收器保守地回收垃圾，留下的数据包含了所有必要的数据。

对象重定位需要更新所有指向旧地址的引用，使之指向新地址，因此它和保守的垃圾回收方法是不兼容的。因为保守的垃圾回收器并不能确认某个位模式是否真的指向某个实际地址，所以它不能修改这些模式并使之指向新的地址。

下面是一个保守的垃圾回收器的工作方式。首先修改内存管理器，使之为所有已分配内存块保存一个数据映射（data map）。这个映射使我们很容易地找到一个内存块的起止位置。这两个起止位置跨越了多个地址。跟踪过程开始时，首先扫描程序的根集，找出所有看起来像内存位置的位模式，此时我们不考虑它的类型。通过在数据映射中查找这些可能的地址，我们可以找出所有可能通过这些位模式到达的内存块的开始位置，并将它们置为待扫描状态。然后，我们扫描所有待扫描的内存块，找出更多（很可能）可达的内存块，并且将它们放入工作列表。重复扫描过程，直到工作列表为空。在完成跟踪工作之后，我们使用上述数据映射来清扫整个堆区，定位并释放所有不可达的内存块。
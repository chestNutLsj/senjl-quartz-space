### 7.8.1　并行和并发垃圾回收

当将垃圾回收应用到并发或多处理器机器上运行的应用程序时，这一工作变得更具有挑战性。对于服务器应用，在同一时刻运行成千上万个线程是常有的事情；其中的每个线程都是一个增变者。堆区通常会包含几千兆的存储。

可处理大规模系统的垃圾回收算法必须充分利用系统的多个处理器。如果一个垃圾回收器使用多个线程，我们就称其为并行的（parallel）。如果回收器和增变者同时运行，就说它是并发的（concurrent）。

我们将描述一个并行的且基本上并发的垃圾回收器。它使用一个并发且并行的阶段来完成大部分的跟踪工作，然后执行一个全面停顿式的步骤来保证找到所有的可达对象并回收存储空间。这个算法在本质上并没有引入新的有关垃圾回收的基本概念，它说明了我们如何将曾经描述的思想组合起来，创造出一个解决并发、并行的垃圾回收问题的完整解决方案。然而，并行执行的本质会带来一些新的实现问题。我们将讨论这个算法如何使用一个相当常见的工作队列模型，在并行计算过程中协调多个线程。

为了理解这个算法的设计思想，我们必须牢记这个问题的规模。即使一个并行应用的根集也要比普通的应用大很多，它由每个线程的栈、寄存器集和全局可访问变量组成。堆区存储的数量也非常大，可达数据的数量同样也很大。增变过程发生速率也比一般的应用高很多。

为了减少停顿时间，我们可以采用原本为增量式分析而设计的基本思想，使垃圾回收和状态增变过程重叠执行。请回顾一下，正如7.7节所讨论的，一个增量式分析完成下列三个步骤：

1）找到根集。这个步骤通常是以原语方式完成的，即增变者暂时停止运行。

2）增变者的执行和对可达对象的跟踪交替进行。在这个阶段，每次有一个增变者写入一个从已扫描对象指向未被访问对象的引用时，我们都会记录这个引用。如7.7.2节中讨论的，我们可以选择多种粒度来记录这些引用。在本节中，我们将假定使用基于卡片的方案。我们将堆区分成若干被称为“卡片”的区段，并维护一个位映射来指明哪个卡片是脏的（即其中有一个或多个引用被覆写）。

3）再次暂停增变者的运行，重新扫描所有可能保存了指向未被访问对象的引用的卡片。

对于一个大型多线程应用，从根集到达的对象的集合可能非常大。终止所有增变者的执行，然后花费很多时间和空间去访问所有这样的对象是不可行的。同时，因为堆的规模巨大，并且增变线程数量巨大，在将所有对象扫描一次之后，很多卡片都需要重新扫描。此时，值得推荐的做法是并行地扫描其中的某些卡片，同时允许增变者继续并发执行。

为了并行地实现上面第（2）步中的跟踪过程，我们将使用多个垃圾回收线程。这些线程和各个增变者线程并发地运行，以跟踪得到大部分可达对象。然后，为了实现第（3）步，我们暂停执行各个增变者，使用并行线程来保证找到所有的可达对象。

完成第（2）步中跟踪过程的方法是让每个增变者线程在完成其自身工作的同时执行部分垃圾回收工作。另外，我们也使用一些专门用于回收垃圾的线程。一旦垃圾回收过程启动，只要增变者线程执行了某个内存分配操作，它同时也会执行一些跟踪计算。只有当计算机中有空闲的时钟周期时，专用的垃圾回收线程才会投入使用。和增量式分析一样，只要增变者写入了一个从已扫描对象指向未被访问对象的引用，存放这个引用的卡片就被标记为脏的，需要重新扫描。

下面给出一个并行、并发垃圾回收算法的大概描述：

1）扫描每个增变者线程的根集，将所有可以从根集中直接到达的对象设为待扫描状态。完成这一步的最简单的增量式做法是等待一个增变者线程调用内存管理器，如果那时它的根集还没有被扫描，就让它扫描自己的根集。如果所有其他跟踪工作都已经完成，而某个增变者线程还没有调用内存分配函数，那么必须暂停这个线程，扫描它的根集。

2）扫描处于待扫描状态的对象。为了支持并行计算，我们使用一个由固定大小的工作包（work packet）组成的工作队列。每个工作包保存了一些待扫描对象。当发现待扫描对象时，它们就被放置到工作包中。等待工作的线程将从队列中取出这些工作包，并跟踪其中的待扫描对象。这种策略允许在跟踪过程中把工作量平均分配给各个工作线程。如果系统用完了存储空间，使得我们无法找到创建这些工作包所需的空间，就直接为保存这些对象的卡片加上标记，使它们将在以后被扫描。后一种处理方法总是可行的，因为存放卡片标记的位数组已经预先分配好了。

3）扫描脏卡片中的对象。当工作队列中不再有待扫描对象，并且所有线程的根集都已经被扫描过之后，我们重新扫描这些卡片以寻找可达对象。只要增变者继续执行，脏卡片就会不断产生。因此，我们需要依照某种标准来停止跟踪过程。比如只允许卡片被再次扫描一次或固定的次数，或者当未完成扫描的卡片数量减少到某个阈值时停止跟踪。这么做的结果是使得并行和并发步骤通常会在完成全部跟踪工作之前就停止。剩下的工作将在下面介绍的最后一步中完成。

4）最后一步保证所有的可达对象都被标记为已被访问的。随着所有增变者停止执行，使用系统中的所有处理器就可以快速找到所有线程的根集。因为大部分可达对象已经被跟踪确定，预计只有少量的对象会被放在待扫描状态中。所有的线程都参与了对其余可达对象的跟踪和对所有卡片的重新扫描。

我们必须控制启动跟踪过程的频率，这很重要。跟踪步骤就像是一场赛跑。增变者创建出必须被扫描的新对象和新引用，而跟踪过程则试图扫描所有可达对象，并重新扫描同时产生的脏卡片。在需要进行垃圾回收之前过分频繁地启动跟踪过程是没有必要的，因为这样做将会增加漂浮垃圾的数量。另一方面，我们又不能等到存储耗尽时才开始跟踪过程。因为这时增变者将不能继续运行，此时的情况就退化为使用全面停顿式回收器的情形。因此，算法必须适当地选择启动回收的时机和跟踪的频率。对前面的各轮垃圾回收中的对象增变速率的估算可以帮助我们在这方面做出决策。根据专用垃圾回收线程所做的工作量，可以动态调整跟踪频率。
## 7.10　第7章参考文献

在数理逻辑中，作用域规则和通过替换进行参数传递最早由Frege［8］提出。Church的lamda演算［3］使用词法作用域。这个方法曾被用作研究程序设计语言的模型。Algol 60及其后续语言，包括C和Java，使用词法作用域。动态作用域首先由Lisp语言引入，随后成为该语言的一个重要特征。McCarthy［14］介绍了这段历史。

很多与栈分配相关的概念来源于Algol60中的块和递归。在词法作用域语言中使用显示表来访问非局部数据的思想来源于Dijkstra［5］。在Randell和Russell［16］中更具体地描述了栈分配、显示表的使用、数组动态分配等概念。Johnson和Ritchie［10］讨论了一个调用代码序列的设计，该设计支持一个过程在不同的调用中使用不同数量的参数。

垃圾回收的研究一直是一个活跃的研究领域，例如Wilson［17］。引用计数技术可以追溯到Collin［4］。基于跟踪的回收技术则最早由McCarthy［13］提出。他描述了一个针对固定长度单元的标记-清扫式算法。管理空闲空间的边界标记由Knuth在1962年提出并在［11］中出版。

算法7.14基于Baker［1］的算法。算法7.16基于Cheney［2］提出的Fenichel和Yochelson［7］拷贝算法的非递归版本。

增量式可达性分析由Dijkstra等［6］进行了详细研究。Lieberman和Hewitt［12］给出了一个世代回收器，它是拷贝回收方法的一个扩展。列车算法由Hudson和Moss［9］首先提出。

![339-1](../Images/image04504.jpeg)

![340-1](../Images/image04505.jpeg)

---

[^1]: 请回忆一下，“过程”这个词是函数、过程、方法和子例程的统称。

[^2]: ML支持相互递归调用的函数，这种情况可以用同样的方式处理。

[^3]: 在后面的内容中，我们将把需要内存空间的事物称为“对象”，尽管它们并不是“面向对象程序设计”意义上的真正对象。

[^4]: 当机器从内存中获得一个存储字时，同时预取（prefetch）出其后的多个连续内存字的开销相对较小。因此，一个常见的存储层次结构的特性是在每次访问某层存储的时候会从该层存储中获取一个包含了多个机器字的块。

[^5]: 在一个典型的数据结构中（如散列表），如果o没有被赋予一个位置，那么在这个结构中就没有相关信息。

[^6]: 从技术上来说，区域不会被填满，因为如果需要，存储管理器可以使用附加的磁盘块对它们进行扩展。然而，除了最后一个区域，其他区域的尺寸通常都有一个界限。我们将把到达这一界限称为“填满”。
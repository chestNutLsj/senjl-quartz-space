### 7.7.2　增量式可达性分析

如果我们让增变者和一个像算法7.12那样的基本跟踪算法交替执行，那么一些可达对象可能会被错认为是不可达的。问题的根源在于增变者的动作可能会违反这个算法的一个关键不变式，即一个已扫描对象中的引用只能指向已扫描或待扫描的对象，这些引用不可以指向未被访问对象。考虑下面的场景：

1）垃圾回收器发现对象o1可达并扫描o1中的指针，因而将o1置于已扫描状态。

2）增变者将一个指向未被访问（但可达）的对象o的引用存放到已扫描对象o1中。它从当前处于未被访问或待扫描状态的对象o2中将一个指向o的引用拷贝到o1中。

3）增变者失去了对象o2中指向o的引用。它可能已经在扫描o2中指向o的引用之前就覆写了这个指针；也可能o2已经变得不可达，因此一直没有进入待扫描状态，因此它内部的指针没有被扫描过。

现在，o可以通过对象o1到达，但是垃圾回收器可能既没有看到o1中指向o的引用，也没有看到o2中指向o的引用。

要得到一个更加准确且正确的增量式跟踪方法，关键在于我们必须注意所有将一个指向当前未被访问对象的引用从一个尚未扫描的对象中拷贝到已扫描对象中的动作。为了截获可能有问题的引用传递，算法可以在跟踪过程中按照下列方式修改增变者的动作：

- 写关卡。截获把一个指向未被访问的对象o的引用写入一个已扫描对象o1的运算。在这种情况下，将o作为可达对象并将其放入待扫描集合。另一种方法是将被写对象o1放回到待扫描集合中，使得我们可以再次扫描它。
- 读关卡。截获对未被访问或待扫描对象中的引用的读运算。只要增变者从一个处于未被访问或待扫描状态中的对象读取一个指向对象o的引用时，就将o设为可达的，并将其放入待扫描对象的集合。
- 传递关卡。截获在未被访问或待扫描对象中原引用丢失的情况。只要增变者覆写一个未被访问或待扫描对象中的引用时，保存即将被覆写的引用并将其设为可达的，然后将这个引用本身放入待扫描集合。

上述几种做法都不能找到最小的可达对象集合。如果跟踪过程确定一个对象是可达的，那么这个对象就一直被认为是可达的。即使在跟踪过程结束之前所有指向它的引用都被覆写，它仍然被认为是可达的。也就是说，找到的可达对象集合介于（R∪New）-Lost与（R ∪New）之间。

上面给出的可选算法中写关卡方法是最有效的。读关卡方法的代价较高，因为一般来说读运算要比写运算多得多。转换关卡没有什么竞争力，因为很多对象“英年早逝”，这种方法会保留很多的不可达对象。

写关卡的实现

我们可以用两种方式来实现写关卡。第一种方式是在增变阶段记录下所有被写入到已扫描对象中的新引用。我们可以将这些引用放入一个列表。如果不考虑从列表中剔除重复引用，列表的大小和对已扫描对象的写运算的数量成正比。注意，列表中的引用本身可能在后来又被覆写掉，因此可能被忽略。

第二种，也是更有效的方式是记住写运算发生的位置。我们可以用被写位置的列表来记录它们，其中可能会消除重复的位置。请注意，只要所有被写的位置都被重新扫描，那么是否精确记录被写的位置并不重要。因此，有多种技术支持我们记录较少的有关被覆写的确切位置的细节。

- 我们可以只记录包含了被写字段的对象，而不需要记录被写的精确地址或者被写的对象及字段。
- 我们可以将地址空间分成固定大小的块，这些块被称为卡片（card），并使用一个位数组来记录曾经被写入的卡片。
- 我们可以选择记录下包含了被写位置的页。我们可以只将那些包含了已扫描对象的页置为被保护状态。那么，不需执行任何显式的指令就可以检测到任何对已扫描对象的写运算。因为这样的写运算会引发一个保护错误，操作系统将引发一个程序异常。

一般来说，通过增大被覆写位置的记录粒度就可以减少所需的存储空间，但代价是增加了需要再次执行的扫描工作量。在第一种方案中，无论实际上修改了被修改对象中的哪个引用，该对象中的所有引用都要进行重新扫描。在后两种方案中，在被修改的卡片或页中的所有可达对象都要在跟踪过程的最后进行重新扫描。

结合增量和拷贝技术

上述的方法对于标记-清扫式垃圾回收来说已经足够了。因为拷贝回收和增变者的相互影响，它的实现要稍微复杂一点。处于已扫描或待扫描状态中的对象有两个地址，一个位于From半空间，另一个位于To半空间。和算法7.16一样，我们必须保存一个从对象的旧地址到其重新定位之后的地址的映射。

我们可以选择两种更新引用的方法。第一种方法是，我们可以让增变者在From空间中完成所有的运算，只是在垃圾回收结束的时候才更新所有的指针，并将所有的内容都拷贝到To空间。第二种方法是，我们可以让程序直接改变To空间中的表示。当增变者对一个指向From空间的指针解引用时，如果在To空间中存在对应于该指针的新位置，那么这个指针就被翻译成这个新位置。所有这些指针在最后都需要被转换成指向To空间的新位置。
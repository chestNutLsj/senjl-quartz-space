### 7.7.5　列车算法

尽管世代方法在处理年轻对象时非常高效，但它在处理成熟对象时却相对低效，因为每当一个垃圾回收过程涉及某个成熟对象时，该对象都会被移动，而且它们不太可能变成垃圾。另一种被称为列车算法的增量式回收方法用于改进对成熟对象的处理。它可以用来回收所有的垃圾。但是更好的方法是使用世代方法来处理年轻的对象，只有当这些对象经历了几轮世代回收之后仍然存在，才将它们提升到另一个由列车算法管理的堆区。列车算法的另一个优点是我们永远不需要进行全面的垃圾回收过程，而在世代垃圾回收中却仍然必须偶尔那样做。

为了描述列车算法的动机，我们首先看一个简单的例子。该例子告诉我们为什么在世代方法中必须偶尔进行一轮全面的垃圾回收。图7-29给出了位于两个区域i和j中的两个相互连接的对象，其中j>i。因为这两个对象都有来自其区域之外的指针，只对区域i或只对区域j进行回收都不能回收这两个对象。然而，它们可能实际上是一个循环垃圾结构中的一部分，没有外部链接指向该垃圾结构。一般来说，这里显示的对象之间的“链接”可能涉及很多对象和一条很长的引用链。

![331-1](../Images/image04502.jpeg)

图7-29　一个跨越区域的可能是循环垃圾的环状结构

在世代垃圾回收中，我们最终会回收区域j，并且因为i<j，我们同时还会回收i区域。那么这个循环结构将被完全包含在正在被回收的堆区中，我们就可以确定它是否真的是垃圾。然而，如果我们从没有进行过一轮包括了i和j的回收，那么我们就会碰到循环垃圾的问题，也就是我们在使用引用计数进行垃圾回收时碰到的问题。

列车算法使用固定大小的被称为车厢（car）的区域。当没有对象比磁盘块更大时，一节车厢可以是一个磁盘块，否则可以将车厢的尺寸设得更大。但是车厢的大小一旦确定就不再变化。多节车厢被组织成列车（train）。一辆列车中的车厢数量没有限制，且列车的数量也没有限制。车厢之间按照词典顺序进行排序：首先以列车号排序，在同一列车中则以车厢号排序，如图7-30所示。

![331-2](../Images/image04503.jpeg)

图7-30　列车算法中的堆区组织

列车算法有两种回收垃圾的方式：

- 在一个增量式垃圾回收步骤中，按照词典顺序排列的第一节车厢（即尚存的第一辆列车中尚存的第一节车厢）首先被回收。因为我们保留了一个来自该车厢之外的所有指针的“被记忆”列表，所以这一步类似于世代算法中针对第一个区域的回收步骤。这里我们确定出没有任何引用的对象，以及完全包含在这节车厢里的垃圾循环。该车厢中的可达对象总是被移至其他的某个车厢中，因此每个被回收过的车厢都变成空车厢，可以从这辆列车中删除。
- 有时，第一辆列车没有外部引用。也就是说，没有从根集指向该列车中任何车厢的指针，并且各节车厢中的被记忆集中只有来自本列车的其他车厢的引用，没有来自其他列车的引用。在这种情况下，该列车就是一个巨大的循环垃圾集合，我们可以删除整辆列车。

被记忆集

现在我们给出列车算法的细节。每节车厢有一个被记忆集，它由指向该车厢中对象的引用组成，这些引用来自：

1）同一辆列车中序号较高的车厢中的对象，以及

2）序号较高的列车中的对象。

此外，每辆列车有一个被记忆集，它由来自较高序号列车中的引用组成。也就是说，一个列车的被记忆集是它内部的所有车厢的被记忆集的并集，但是不包含列车内部的引用。因此，可以将车厢的被记忆集划分成“内部”（同一列车）和“外部”（其他列车）两个部分，同时表示这两种不同类型的被记忆集。

注意，指向这些对象的引用可以来自各个地方，不只是来自按字典顺序排列的序号较高的车厢。然而，算法中的两种垃圾回收过程分别处理第一辆列车的第一节车厢和整个第一辆列车。因此，当在垃圾回收中需要使用被记忆集的时候，已经没有更早的地方可以有引用到达被处理的车厢或者列车。因此记录下指向较高序号车厢的引用没有什么意义。当然，我们必须认真、正确地管理被记忆集，只要增变者改变了任何对象中的引用，就需要相应地改变被记忆集。

管理列车

我们的目标是找出第一辆列车中所有非循环垃圾的对象。此时，第一辆列车要么只包含了循环垃圾，因此将在下一轮垃圾回收时被回收；要么其中的垃圾不是循环的，那么它的车厢就可以被逐个回收。

因为对一辆列车中的车厢数目没有限制，每当我们需要更多空间时，在原则上我们可以直接向一辆列车中加入新的车厢。但是，我们偶尔也需要创建出新的列车。例如，我们可以设定每创建k个对象之后就新建一辆列车。也就是说，当最后一辆列车的最后车厢中还有足够的空间时，新创建的对象一般会被放置在这节车厢中；如果该车厢中没有足够空间，该对象就会被放到一个即将被加到最后一个车厢之后的新车厢中。然而，我们会定期新建一列只有一节车厢的列车，并将新对象放入其中。

单节车厢的垃圾回收

列车算法的核心是我们如何在一轮垃圾回收中处理第一辆列车的第一节车厢。一开始，可达集包括了该车厢中被来自根集的引用指向的对象，以及被该车厢的被记忆集中的引用指向的对象。然后，我们像标记-清扫式回收器那样扫描这些对象，但是不会扫描任何可达的位于被回收车厢之外的对象。在这次跟踪之后，该车厢中的某些对象可能被确定为垃圾。因为无论如何整节车厢都将消失，因此不必回收它们的空间。

然而，该车厢中很可能还有一些可达对象，这些对象必须被移到其他地方。移动一个对象的规则如下：

- 如果被记忆集中有一个来自其他列车的引用（该列车的序号高于被回收车厢所在列车的序号），那么将这个对象移到这些列车中的某一辆中。如果在发出一个引用的某辆列车中能够找到足够的空间，就将该对象移动这辆列车的某节车厢中。如果找不到空间，它就进入一个新的、最末端的车厢。
- 如果没有来自其他列车的引用，但是存在来自根集或第一辆列车的引用，那么就将此对象移到同一列车中的其他车厢中。如果没有足够空间，就创建一个新的车厢放到列车的末端。如果有可能，挑选有一个指向该对象的引用的车厢，以尽快把循环结构放到同一个车厢中。

在从第一节车厢中移出了所有可达对象之后，我们就可以删除这节车厢。

恐慌模式

上面的规则还存在一个问题。为了保证所有的垃圾最终都会被回收，我们需要保证每辆列车迟早会变成第一辆列车，并且如果这辆列车不是循环垃圾，那么此列车中的所有车厢最后都会被删除，且该列车每次至少会减少一节车厢。然而，根据上面的第二个规则，回收第一辆列车的第一节车厢时可能会产生一个位于最后的新车厢。这个过程不会创建出两个或更多的新车厢，因为第一节车厢中的所有对象一定能够被一起放到最后的新车厢中。然而，是否会出现这种情况，一辆列车的每一个回收步骤都产生一节新车厢，以致于我们永远不能回收完这辆列车，结果永远不能继续处理另一辆列车？

遗憾的是，这种情况是可能出现的。如果我们有一个大型的、循环的非垃圾的结构，并且增变者改变引用的方式使得我们在回收一节车厢时一直没有在被记忆集中看到任何来自较高序号列车的引用，就会出现上述问题。只要在回收一节车厢时有一个对象从这个列车中移出，问题就解决了，因为没有新的对象会被加入到第一辆列车中，所以第一辆列车中的所有对象最终一定会被全部移出。然而，有可能在某个阶段我们根本回收不到任何垃圾，这样就会存在出现循环的风险：有可能一直只对当前的第一辆列车进行垃圾回收。

为了避免出现这个问题，只要我们遇到一个无效（futile）垃圾回收，我们就需要改变做法。所谓无效垃圾回收是指，在回收一节车厢时没有一个对象可以作为垃圾删除或者被移动到另一辆列车中。在这种“恐慌模式”下，我们做出两个变化：

1）当指向第一辆列车中的某个对象的某个引用被覆写时，我们将这个引用保留为根集的一个新成员。

2）在进行垃圾回收时，如果第一节车厢中的一个对象有来自根集的引用，其中包括在第1点中设置的哑引用，那么即使该对象没有来自其他列车的引用，我们还是将它移至另一辆列车。只要不是移到第一辆列车，移到哪辆列车并不重要。

按照这个方法，如果有一个指向第一辆列车的对象的引用来自该列车之外，在我们回收每节车厢时都会考虑这些引用，并且最终必然会有一些对象从那辆列车移除。然后，我们就可以脱离恐慌模式，继续正常处理，确保当前的第一辆列车一定要比以前小。
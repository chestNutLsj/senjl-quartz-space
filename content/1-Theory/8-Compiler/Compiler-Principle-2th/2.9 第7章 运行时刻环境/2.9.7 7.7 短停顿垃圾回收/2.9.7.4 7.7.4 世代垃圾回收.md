### 7.7.4　世代垃圾回收

世代垃圾回收（generational garbage collection）是一种充分利用了大多数对象“英年早逝”的特性的有效方法。在世代垃圾回收中，堆区被分成一系列小的区域。我们将用0，1，2，…，n对它们进行编号，序号越小的区域存放的对象越年轻。对象首先在0区域被创建。当这个区域被填满时，它的垃圾被回收，且其中的可达对象被移到1区。现在，0区又成为空的，我们继续把新对象分配到这个区域。当0区再次被填满[^6]，它的垃圾又被回收，且它的可达对象被拷贝到1区，与之前被拷贝的对象合在一起。这个模式一直被重复，直到1区也被填满为止。此时应对0区和1区应用垃圾回收。

一般来说，每一轮垃圾回收都是针对序号小于等于某个i的区域进行的，应该将i选择为当前被填满区域的最高编号。每当一个对象经历了一轮回收（即它被确定为可达的），它就从它当前所在区域被提升到下一个较高的区域，直到它到达最老的区域，即序号为n的区域。

使用7.7.3节中介绍的术语，当区域i及更低区域中的垃圾被回收时，从0到i的区域组成了目标集，所有序号大于i的区域组成了稳定集。为了为各种可能的部分回收找到根集，我们为每个区域i保持了一个被记忆集，该集合由指向区域i中对象且位于大于i的区域中的所有对象组成。在i上激活的一次部分回收的根集包括了区域i及更低区域的被记忆集。

在这个方案中，只要我们对i进行回收，所有序号小于i的区域也将进行垃圾回收。有两个原因促使我们采用这个策略：

1）因为较年轻的世代往往包含较多的垃圾，也就更频繁地被回收。所以，我们可以将它们和较老的世代一起回收。

2）根据这种策略，我们只需要记录从较老世代指向较新世代的引用。也就是说，对最年轻世代的对象进行写运算，以及将对象提升到下一世代时都不需要更新任何被记忆集。如果我们对某个区域进行回收，但是不回收某个较年轻的世代，那么后者将成为稳定集的一部分。我们将不得不同时记录从较年轻世代指向较年老世代的引用。

总而言之，这种方案更频繁地回收较年轻的世代，并且因为“对象英年早逝”，对于这些世代进行垃圾回收的效费比特别高。对较老世代的垃圾回收则要花更多的时间，因为它包括了对所有较年轻世代的回收，同时它们包含的垃圾也相应减少。虽然如此，较老世代还是需要每过一段时间进行一次回收，以删除不可达对象。最老的世代保存了最成熟的对象，对这些对象的回收是最昂贵的，因为它相当于一次完整的回收。也就是说，世代回收器偶尔也需要执行完整的跟踪步骤，因此也会在程序运行时引入较长时间的停顿。接下来将讨论另一种只处理成熟对象的方法。
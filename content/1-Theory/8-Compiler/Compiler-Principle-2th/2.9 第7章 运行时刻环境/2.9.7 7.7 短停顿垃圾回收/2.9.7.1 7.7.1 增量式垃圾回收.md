### 7.7.1　增量式垃圾回收

增量式回收器是保守的。虽然垃圾回收器一定不能回收不是垃圾的对象，但是它并不一定要在每一轮中回收所有的垃圾。我们将每次回收之后留下的垃圾称为漂浮垃圾（floating garbage）。我们当然期望漂浮垃圾越少越好。明确地说，增量式回收器不应该遗漏那些在回收周期开始时就已经不可达的垃圾。如果我们能够保证做到这一点，那么在某一轮中没有被回收的垃圾一定会在下一轮中被回收。因此不会因为这个垃圾回收方法而产生内存泄漏问题。

换句话说，增量式垃圾回收器会过多地估算可达对象集合，从而保证安全性。它们首先以不可中断的方式处理程序的根集，此时没有来自增变者的干扰。在找到了待扫描对象的初始集合之后，增变者的动作与跟踪步骤交错进行。在这个阶段，任何可能改变可达性的增变者动作都被简洁地记录在一个副表中，使得回收器可以在继续执行时做出必要的调整。如果在跟踪完成之前空间就被耗尽，那么回收器将不再允许增变者执行，并完成全部跟踪过程。在任何情况下，当跟踪完成后，空间回收以原语的方式完成。

增量回收的准确性

一旦对象成为不可达的，该对象就不可能再变成可达的。因此，在垃圾回收和增变者运行时，可达对象的集合只可能：

1）因为垃圾回收开始之后的某个新对象的分配而增长。

2）因为失去了指向已分配对象的引用而缩小。

令垃圾回收开始时的可达对象集合为R，令New表示在垃圾回收期间创建并分配的对象集合，并令Lost表示在跟踪开始之后因为引用丢失而变得不可达的对象的集合。那么当跟踪完成之后，可达对象的集合为：

（R ∪New）- Lost

如果在每次增变者丢失了一个指向某个对象的引用之后都重新确定该对象的可达性，那么开销会变得很大，因此增量式回收器并不试图在跟踪结束时回收所有的垃圾。任何遗留下的垃圾——漂浮垃圾——应该是Lost对象的一个子集。如果形式化地描述，那通过跟踪找到的对象集合S必须满足

（R∪New）- Lost ⊆S ⊆（R ∪New）

简单的增量式跟踪

我们首先描述一种用来找到集合R ∪New的上界的简单跟踪算法。在跟踪期间，增变者的行为更改如下：

- 在垃圾回收开始之前已经存在的所有引用都被保留。也就是说，在增变者覆写一个引用之前，它原来的值被记住，并被当作一个只包含这个引用的附加待扫描对象。
- 所有新创建的对象立即就被认为是可达的，并被放置在待扫描状态中。

这种方案是保守且正确的，因为它找出了R和New。R是在垃圾回收之前可达的所有对象的集合，New是所有新分配的对象的集合。然而，这种方案付出的代价也很高，因为算法需要拦截所有的写运算，并记住所有被覆写的引用。这些工作中的一部分是不必要的，因为它涉及的对象在垃圾回收结束时可能已经是不可达的。如果我们能够探测到哪些被覆写的引用所指的对象在本轮垃圾回收结束时不可达，我们就可以避免这部分工作，同时还可以提高算法的准确性。下一个算法在这两个方面都做了很好的改进。
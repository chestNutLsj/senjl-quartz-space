### 7.6.4　标记并压缩的垃圾回收器

进行重新定位（relocating）的垃圾回收器会在堆区内移动可达对象以消除存储碎片。通常，可达对象占用的空间要大大小于空闲空间。因此，在标记出所有的“窗口”之后并不一定要逐个释放这些空间，另一个有吸引力的做法是将所有可达对象重新定位到堆区的一端，使得堆区的所有空闲空间成为一个块。毕竟垃圾回收器已经分析了可达对象中的每个引用，因此更新这些引用使之指向新的存储位置并不需要增加很多工作量。我们需要改变的全部引用包括可达对象中的引用和根集中的引用。

将所有可达对象放在一段连续的位置上可以减少内存空间的碎片，使得它更容易存储较大的对象。同时，通过使数据占用更少的缓存线和内存页，重新定位可以提高程序的时间局部性和空间局部性，因为几乎同时创建的对象将被分配在相邻的存储块中。如果这些相邻的块中的对象一起使用，那么就可以从数据预取中得到好处。不仅如此，用以维护空闲空间的数据结构也可以得到简化。我们不再需要一个空闲空间列表，需要的只是一个指向唯一空闲块的起始位置的指针free。

存在多种进行重新定位的回收器，其不同之处在于它们是在本地进行重新定位，还是在重新定位之前预留了空间：

- 本节描述的标记并压缩回收器（mark-and-compact collector）在本地压缩对象。在本地重新定位可以降低存储需求。
- 7.6.5节中给出了更高效、更流行的拷贝回收器（copying collector），它把对象从内存的一个区域移到另一个区域。保留额外的空间用于重新定位可以使得一发现可达对象就立刻移动它。

算法7.15中的标记并压缩垃圾回收器有3个阶段：

1）首先是标记阶段，它和前面描述的标记-清扫式算法的标记阶段类似。

2）在第二阶段，算法扫描堆区中的已分配内存段，并为每个可达对象计算新的地址。新地址从堆的最低端开始分配，因此在可达对象之间没有空闲存储窗口。每个对象的新地址记录在一个名为NewLocation的结构中。

3）最后，算法将对象拷贝到它们的新地址，更新对象中的所有引用，使之指向相应的新地址。新的地址可以在NewLocation中找到。

算法7.15　一个标记并压缩的垃圾回收器。

输入：一个由对象组成的根集，一个堆，以及一个标记空闲空间的起始位置的指针free。

输出：指针free的新值。

方法：图7-26给出了这个算法，此算法使用下列的数据结构：

![323-1](../Images/image04499.jpeg)

图7-26　一个标记并压缩回收器

1）一个Unscanned列表，同算法7.12中的Unscanned列表。

2）所有对象的reached位也和算法7.12中相同。为了使我们的描述简单，当我们要说一个对象的reached位为1或0时，我们分别称它们为“已被访问的”或“未被访问的”。在初始时刻，所有的对象都是未被访问的。

3）指针free，标记了堆区中未分配空间的开始位置。

4）NewLocation表。这个结构可以是任意一个实现了如下两个操作的散列表、搜索树或其他数据结构：

① 将NewLocation（o）设为对象o的新地址。

② 给定对象o，得到NewLocation（o）的值。

我们不会关心到底使用了什么样的数据结构，虽然你可以假设NewLocation是一个散列表，因此“set”和“get”操作所需要的平均时间为某个常量，这个时间和堆区内的对象数量无关。

第（1）行到第（7）行的第一（或标记）阶段在本质上和算法7.12的第一阶段相同。第二阶段是从第（8）行到第（12）行。该阶段从左边（或者说从低地址端）开始访问堆中的已分配部分的每一个存储块。结果，被分配给存储块的新地址与它们的老地址按照同样的顺序增长。这个顺序很重要，它可以保证我们在重新定位对象时总是将对象向左移，那么在移动时，原来占据目标空间的对象已经被我们移走了。

第（8）行首先将free指针设定为指向堆区的低端。在这个阶段，我们使用free来指示第一个可用的新地址。我们只会为标记为已被访问的对象o创建新的地址。在第（10）行中，对象o被赋予下一个可用地址；在第（11）行，我们根据对象o需要的存储数量增加free指针，因此free仍然指向空闲空间的开始位置。

从第（13）行到第（17）行是最后阶段，此时我们再次按照第二阶段中的自左向右的顺序访问可达对象。第（15）、（16）行将一个已被访问到的对象o的所有内部指针替换为它们的新地址，NewLocation表用来确定这个新的地址。然后，第（17）行将内部引用已被更新的对象o移动到新的位置。最后，第（18）和（19）行重新确定根集元素中的指针指向的目标，这些元素本身不是堆区对象，它们可能是静态分配对象或栈分配对象。图7-27说明了如何将可达对象（图中无阴影的对象）移动到堆区的底部，同时内部指针被修改，指向已被访问对象的新位置。

![324-1](../Images/image04500.jpeg)

图7-27　将已被访问对象移动到堆的前部，同时保持内部指针的指向关系
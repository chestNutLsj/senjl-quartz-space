### 7.6.2　基本抽象

所有基于跟踪的算法都计算可达对象集合，然后取这个集合的补集。因此，内存是按照下列方式循环使用的：

1）程序（或者说增变者）运行并发出分配请求。

2）垃圾回收器通过跟踪揭示可达性。

3）垃圾回收器收回不可达对象的存储空间。

图7-23按照存储块的四种状态（空闲的、未被访问的、待扫描的和已扫描的）说明这个循环。一个存储块的状态可以存储在该块内部，也可以使用垃圾回收算法的某个数据结构隐含地表示。

![320-2](../Images/image04496.jpeg)

图7-23　在一个垃圾回收循环中的存储块的状态

虽然不同的基于跟踪的算法可能在实现方法上有所不同，但是它们都可以通过下列状态进行描述：

1）空闲的。存储块处于空闲状态表示它可以被分配。因此，一个空闲块内不会存放任何可达对象。

2）未被访问的。除非通过跟踪证明存储块可达，否则它被默认为是不可达的。在垃圾回收过程中的任何时刻，如果还没有确定一个块的可达性，该块就处于未被访问的状态。如图7-23a所示，当一个存储块被存储管理器分配出去时，它的状态就被设置为未被访问的。一轮垃圾回收之后，可达对象的状态仍然会被重置为未被访问状态，以准备下一轮处理，参见图中从已扫描状态到未被访问状态的转换。这个转换用虚线显示，以强调它是为下一轮处理做准备。

3）待扫描的。已知可达的存储块要么处于待扫描状态，要么处于已扫描状态。如果已知一个存储块是可达的，但是该块中的指针还没被扫描，那么该块就处于待扫描状态。当我们发现某个块可达时，就会发生一个从未被访问状态到待扫描状态的转换，如图7-23b所示。

4）已扫描的。每个待扫描对象最终都将被扫描并转换到已扫描状态。在扫描一个对象时，我们检查其内部的各个指针，并且沿着这些指针找到它们引用的对象。如果引用指向一个未被访问的对象，那么该对象将被设为待扫描状态。当对一个对象的扫描结束时，这个对象被放入已扫描状态，见7-23b中下面的转换。一个已扫描的对象只能包含指向其他已扫描或待扫描对象的引用，决不会包含指向未被访问对象的引用。

当不再有对象处于待扫描状态时，可达性的计算就完成了。到最后仍然处于未被访问状态的对象确实是不可达的。垃圾回收器收回它们占用的空间，并将这些存储块置于空闲的状态，如图7-23c中实线转换所示。为了准备下一轮垃圾回收，处于已扫描状态中的对象将回到未被访问状态，见图7-23c中的虚线转换。再次提醒大家，这些对象现在确实是可达的。将它们设定为未被访问状态是正确的，因为当下一轮垃圾回收开始时，我们将要求所有对象都从这个状态出发。在那个时候，当前可达的某些对象可能实际上已经被变成了不可达的。

例7.13　我们看一下算法7.12中的数据结构与上面介绍的四种状态有什么关系。使用reached位，以及是否在列表Free和Unscanned中，我们可以区分全部四种状态。图7-24中的表格归纳了用算法7.12中的数据结构来刻画四种状态的方式。

![321-1](../Images/image04497.jpeg)

图7-24　算法7.12中状态的表示方式
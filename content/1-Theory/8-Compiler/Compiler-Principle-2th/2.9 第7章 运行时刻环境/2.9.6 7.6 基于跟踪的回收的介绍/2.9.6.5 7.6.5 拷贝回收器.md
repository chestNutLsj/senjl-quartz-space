### 7.6.5　拷贝回收器

拷贝回收器预先保留了可以将对象移入的空间，因而解除了跟踪和发现空闲空间之间的依赖关系。整个存储空间被划分为两个半空间（semispace）A和B。增变者在半空间之一（比如A）内分配内存，直到它被填满。此时增变者停止，垃圾回收器将可达对象拷贝到另一个半空间，比如说B。当垃圾回收完成时，两个半空间的角色进行对换。增变者可以继续运行，并在半空间B中分配对象。下一轮垃圾回收将把可达对象移动到A。下面的算法是由C.J.Cheney提出的。

算法7.16　Cheney的拷贝回收器。

输入：一个由对象组成的根集，一个包含了From半空间和To半空间的堆区，其中From半空间包含了已分配对象，To半空间全部是空闲的。

输出：最后，To半空间保存已分配的对象。free指针指明了To半空间中剩余空闲空间的开始位置。From半空间此时全部空闲。

方法：图7-28显示了这个算法。Cheney算法在From半空间中找出可达对象，并且访问到它们时立刻把它们拷贝到To半空间。这种放置方法将相关对象放在一起，从而提高空间局部性。

在探讨算法本身（即图7-28中的函数CopyingCollector）之前，首先考虑第（11）行到第（16）行的辅助函数LookupNewLocation。该函数的输入是一个对象o，如果o在To空间中还没有对应的位置，则为其分配一个To空间中的新地址。所有新地址都被记录在一个结构NewLocation中，特殊值Null用来表示还没有为o分配空间[^5]。和算法7.15一样，NewLocation结构的具体形式可以变化，但是现在假设它是一个哈希表就行了。

![325-1](../Images/image04501.jpeg)

图7-28　一个拷贝垃圾回收器

如果我们在第（12）行发现o没有存储位置，那么在第（13）行上它将被赋予To半空间中空闲空间的开始位置。第（14）行使free指针增加o所占的空间数量。在第（15）行，我们将o从From空间拷贝到To空间。因此，对象从一个半空间到另一个半空间的移动实际上是一个函数的副作用。这个副作用发生在我们第一次为这个对象寻找新地址的时候。不管之前有没有设定对象o的位置，第（16）行返回o在To空间中的位置。

现在我们可以考虑这个算法本身了。第（2）行确保From空间中的所有对象都还没有新地址。在第（3）行中，我们初始化两个指针unscanned和free，使它们都指向To半空间的开始位置。指针free将总是指向To半空间中空闲空间的起始位置。当我们往To空间加入对象时，那些地址低于unscanned的对象将处于已扫描状态，而那些位于unscanned和free之间的对象则处于待扫描状态。因此，free总是在unscanned的前面。当后者追上前者时就表示不存在更多的待扫描对象了，我们就完成了垃圾回收工作。请注意，我们是在To空间中完成垃圾回收工作的，尽管在第（8）行中检查的对象中的所有引用都是指向From空间的。

第（4）行和第（5）行处理可以从根集访问到的对象。请注意，因为函数副作用，在第（5）行中对LookupNewLocation的某些调用会在To中为这些对象分配存储块，同时增加free指针的值。因此，除非没有被根集引用的对象（在这种情况下，整个堆区都是垃圾），当程序第一次运行到这里时将进入第（6）行到第（10）行的循环。然后，这个循环扫描所有已经被加入到To空间中并处于待扫描状态的对象。第（7）行处理下一个待扫描的对象o。在第（8）、（9）行，对于o中的每个引用，从它在From半空间中的原值被翻译为在To半空间中的值。请注意，因为函数副作用，如果o内的某个引用所指向的对象之前还没有被访问过，那么第（9）行中对LookupNewLocation的调用将在To空间中为这个对象分配空间并将它移到该空间中。最后，第（10）行增加指针unscanned的值，使之指向下一个对象，即To空间中o之后的对象。
### 7.6.1　基本的标记-清扫式回收器

标记-清扫式（mark-and-sweep）垃圾回收算法是一种直接的全面停顿的算法。它们找出所有不可达的对象，并将它们放入空闲空间列表。算法7.12在一开始的跟踪步骤中访问并“标记”所有的可达对象，然后“清扫”整个堆区并释放不可达对象。在介绍了基于跟踪的算法的一个一般性框架之后，我们将考虑算法7.14，它是算法7.12的一个优化。算法7.14使用一个附加的列表来保存所有已分配对象，使得它对每个可达对象只访问一次。

算法7.12　标记-清扫式垃圾回收。

输入：一个由对象组成的根集，一个堆和一个被称为Free的包含了堆中所有未分配存储块的空闲空间列表（free list）。和7.4.4节中一样，所有空间块都用边界标记进行标识，指明它们的空闲/已用状态和大小。

输出：在删除了所有垃圾之后的经过修改的Free列表。

方法：在图7-21中显示的算法使用了几个简单的数据结构。列表Free保存了已知的空闲对象。一个名为Unscanned的列表保存了我们已经确定可达的对象，但是我们还没有考虑这些对象的后继对象的可达性。也就是说，我们还没有扫描这些对象来确定通过它们能够到达哪些对象。列表Unscanned最初为空。另外，每个对象包括一个比特，用来指明该对象是否可达（即reached位）。在算法开始之前，所有已分配对象的reached位都被设定为0。

![319-1](../Images/image04494.jpeg)

图7-21　一个标记-清扫式垃圾回收器

在图7-21的第（1）行，我们初始化Unscanned列表，在其中放入所有被根集引用的对象。同时这些对象的reached位被设置为1。第（2）行到第（7）行是一个循环，在此循环中我们逐个检查每个已经被放入Unscanned列表中的对象o。

从第（4）行到第（7）行的for循环实现了对对象o的扫描。我们检查每个在o中被引用的对象o′。如果o′已经被访问过（其reached位为1），那么就不需要对o′做任何处理；它要么已经在之前被扫描过，要么已经在Unscanned列表中等待扫描。然而，如果o′还没有被访问到，那么我们需要在第（6）行将它的reached位设置为1，并在第（7）行中将o′加入到Unscanned列表中。图7-22说明了这个过程。它显示了一个带有四个对象的Unscanned列表。列表中的第一个对象对应于上述讨论中的对象o。它正在被扫描。虚线对应于可能从o到达的三种类型的对象：

1）之前扫描过的对象，它不需要被再次扫描。

2）当前在Unscanned列表中的对象。

3）一个可达的数据项，但是之前它被认为是未被访问的。

![320-1](../Images/image04495.jpeg)

图7-22　一个标记-清扫式垃圾回收器的标记阶段中对象之间的关系

第（8）行到第（11）行是清扫阶段，它收回所有那些在标记阶段结束之后仍然未被访问到的对象的空间。请注意，这些对象将包括所有原本就在Free列表中的对象。因为无法直接枚举不可达对象的集合，这个算法将清扫整个堆区。第（10）行将空闲且不可达的对象逐个放入Free列表。第（11）行处理可达对象。我们将它们的reached位设为0，以便在这个垃圾回收算法下一次运行时，其前置条件得到满足。
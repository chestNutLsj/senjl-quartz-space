### 7.2.4　栈中的变长数据

运行时刻存储管理系统必须频繁地处理某些数据对象的空间分配。这些数据对象的大小在编译时刻未知，但是它们是这个过程的局部对象，因而可以被分配在运行时刻栈中。在现代程序设计语言中，在编译时刻不能决定大小的对象将被分配在堆区。堆区的存储结构将在7.4节中讨论。不过，也可以将未知大小的对象、数组以及其他结构分配在栈中。我们在这里将讨论如何进行这种分配。尽可能将对象放置在栈区的原因是我们可以避免对它们的空间进行垃圾回收，也就减少了相应的开销。注意，只有一个数据对象局限于某个过程，且当此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间。

为变长数组（即其大小依赖于被调用过程的一个或多个参数值的数组）分配空间的一个常用策略如图7-8所示。同样的方案可以用于任何类型的对象的分配，只要它们对被调用的过程而言是局部的，并且其大小依赖于该次调用的参数即可。

在图7-8中，过程p有三个局部数组，我们假设它们的大小无法在编译时刻确定。尽管这些数组的存储出现在栈中，它们并不是p的活动记录的一部分。只有指向各个数组的开始位置的指针存放在活动记录中。因此当p执行时，这些指针的位置相对于栈顶指针的偏移量是已知的，因而目标代码可以通过这些指针访问数组元素。

![297-1](../Images/image04475.jpeg)

图7-8　访问动态分配的数组

图7-8中还给出了一个被p调用的过程q的活动记录。q的这个活动记录从p的数组之后开始，q的所有变长数组被分配在q的活动记录之外。

对栈中数据的访问通过指针top和top_sp完成。这里，top标记了实际的栈顶位置，它指向下一个活动记录将开始的位置，第二个指针top_sp用来找到顶层活动记录的局部的定长字段。为了和图7-7保持一致，我们将假定top_sp指向机器状态字段的末端。在图7-8中，top_sp指向q的活动记录的机器状态字段的末端。从那里，我们可以找到q的控制链字段，根据这个字段我们可以知道当p位于栈顶时，top_sp所指的p的活动记录中的位置。

重新设置top和top_sp所指位置的代码可以在编译时刻生成。这些代码根据将根据在运行时刻获知的记录大小来计算top和top_sp的新值。当q返回时，可以根据q的活动记录中的被保存的控制链来恢复top_sp的值。top的新值等于（未经恢复的原来的）top_sp值减去q的活动记录中机器状态、控制链、访问链、返回值、参数字段（如图7-5所示）的总长度。调用者可以在编译时刻知道这个长度，尽管当调用参数的个数可变时，它仍取决于调用者（如果调用q的参数个数可变）。
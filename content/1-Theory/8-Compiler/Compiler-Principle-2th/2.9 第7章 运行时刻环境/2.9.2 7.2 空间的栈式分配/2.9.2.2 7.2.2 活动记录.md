### 7.2.2　活动记录

过程调用和返回通常由一个称为控制栈（control stack）的运行时刻栈进行管理。每个活跃的活动都有一个位于这个控制栈中的活动记录（activation record，有时也称为帧（frame））。活动树的根位于栈底，栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径。程序控制所在的活动的记录位于栈顶。

例7.3　如果当前的控制位于图7-4的树中的活动q（2，3）上，那么q（2，3）对应的活动记录在控制栈的顶端。紧跟在下面的是q（1，3）的活动记录，即树中q（2，3）的父结点。再下面是q（1，9）的活动记录。栈的底端是主函数m的活动记录，也就是活动树的根。

按照惯例，我们在画控制栈的时候将把栈底画在栈顶之上。因此在一个活动记录中出现在页面最下方的元素实际上最靠近栈顶。

根据所实现语言的不同，其活动记录的内容也有所不同。这里列举出可能出现在一个活动记录中的各种类型的数据（图7-5列出了这些元素以及它们之间的可能顺序）：

![294-1](../Images/image04472.jpeg)

图7-5　一个概括性的活动记录

1）临时值。比如当表达式求值过程中产生的中间结果无法存放在寄存器中时，就会生成这些临时值。

2）对应于这个活动记录的过程的局部数据。

3）保存的机器状态，其中包括对此过程的此次调用之前的机器状态信息。这些信息通常包括返回地址（程序计数器的值，被调用过程必须返回到该值所指位置）和一些寄存器中的内容（调用过程会使用这些内容，被调用过程必须在返回时恢复这些内容）。

4）一个“访问链”。当被调用过程需要其他地方（比如另一个活动记录）的某个数据时需要使用访问链进行定位。访问链将在7.3.5节中讨论。

5）一个控制链（control link），指向调用者的活动记录。

6）当被调用函数有返回值时，要有一个用于存放这个返回值的空间。不是所有的被调用过程都有返回值，即使有，我们也可能倾向于将该值放到一个寄存器中以提高效率。

7）调用过程使用的实在参数（actual parameter）。这些值通常将尽可能地放在寄存器中，而不是放在活动记录中，因为放在寄存器中会得到更好的效率。然而，我们仍然为它们预留了相应的空间，使得我们的活动记录具有完全的通用性。

例7.4　图7-6给出了当控制流在图7-4所示的活动树中运行时运行时刻栈的多个快照。这些不完整的树中的虚线指向已经结束的活动。程序的执行随着过程main的一次活动而开始。因为数组a是全局的，在此之前已经为a分配了存储空间，如图7-6a所示。

![295-1](../Images/image04473.jpeg)

图7-6　向下增长的活动记录栈

当控制到达main的函数体中的第一个函数调用时，过程r被激活，它的活动记录被压入栈中（参见图7-6b）。r的活动记录包含了局部变量i的空间。请记住栈顶是在图的下方。当控制从这次活动中返回时，它的记录被弹出栈，栈中只留下main的记录。

然后控制到达实在参数为1和9的对q（即快速排序）的调用，这次调用的活动记录被放置在栈顶，如图7-6c所示。q的活动记录中包括了参数m和n以及局部变量i的空间。它们按照图7-5所示的通用布局放置。请注意，曾经被r的调用使用的空间被复用了。函数调用q（1，9）没有任何方法找到r的局部数据。当q（1，9）返回时，栈中再次只剩下了main的活动记录。

在图7-6的最后两个快照之间发生了多个活动。q（1，9）递归地调用了q（1，3）。在q（1，3）的生命期内，活动p（1，3）和q（1，0）开始执行并结束，栈顶只留下了活动记录q（1，3）（见图7-6d）。注意，当一个过程是递归的时，常常会有该过程的多个活动记录同时出现在栈中。
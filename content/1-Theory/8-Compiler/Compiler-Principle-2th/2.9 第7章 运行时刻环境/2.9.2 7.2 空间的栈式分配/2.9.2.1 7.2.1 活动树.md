### 7.2.1　活动树

假如过程调用（或者说过程的活动）在时间上不是嵌套的，那么栈式分配就不可行了。下面的例子说明了过程调用的嵌套情形。

例7.1　图7-2给出了一个程序的概要。该程序将9个整数读入到一个数组a，并使用递归的快速排序算法对这些整数排序。

![292-1](../Images/image04469.jpeg)

图7-2　一个快速排序程序的概要

程序的主函数有三个任务。它调用readArray，设定上下限值，然后在整个数组之上调用quicksort。图7-3给出了可能在程序的某次执行中得到的调用序列。在这次执行中，对partition（1，9）的调用返回4，因此a［1］到a［3］存放了小于被选定的分割值v的元素，而较大的元素被存放在a［5］到a［9］。

在这个例子中，过程活动在时间上是嵌套的，在一般情况下也是这样。如果过程p的一个活动调用了过程q，那么q的该次活动必定在p的活动结束之前结束。有三种常见的情况：

1）q的该次活动正常结束，那么基本上在任何语言中，控制流从p中调用q的点之后继续。

2）q的该次活动（或q调用的某个过程）直接或间接地中止了，也就是说不能再继续执行了。在这种情况下，q和p同时结束。

3）q的该次活动因为q不能处理的某个异常而结束。过程p可能会处理这个异常。此时q的活动已经结束而p的活动继续执行，尽管p的活动不一定从调用q的点开始。如果p不能处理这个异常，那么p的活动和q的活动一起结束。一般来说某个过程的尚未结束的活动将处理这个异常。

因此，我们可以用一棵树来表示在整个程序运行期间的所有过程的活动，这棵树称为活动树（activation tree）。树中的每个结点对应于一个活动，根结点是启动程序执行的main过程的活动。在表示过程p的某个活动的结点上，其子结点对应于被p的这次活动调用的各个过程的活动。我们按照这些活动被调用的顺序，自左向右地显示它们。值得注意的是，一个子结点必须在其右兄弟结点的活动开始之前结束。

一种快速排序

图7-2中的快速排序程序概要使用了两个辅助函数readArray和partition。函数readArray仅用于将数据加载到数组a中。数组a的第一个和最后一个元素没有用于存放输入数据，而是用于存放主函数中设定的“限值”。我们假定a［0］被设为小于所有可能输入数据值的值，而a［10］被设为大于所有数据值的值。

函数partition对数组中第m个元素到第n个元素的部分进行分割，使得a［m］到a［n］之间的小元素存放在前面，而大的元素存放在尾部，但是这两组内部不一定是排好序的。我们将不会探究partition的工作方式，只需要知道这个过程要求前面提到的上下限值必须存在。图9-1中的更加详细的代码给出了实现partition的一种可能的算法。

递归过程quicksort首先确定它是否需要对多个数组元素进行排序。请注意，单个元素总是“有序的”，因此在这种情况下quicksort不需要做任何事。如果有多个元素需要排序，quicksort首先调用partition。这次调用会返回一个数组下标i，它是小元素和大元素之间的分界线。然后通过递归调用quicksort对这两组元素排序。

例7.2　图7-3给出了一个调用和返回序列，而图7-4中显示了一棵完成这个调用/返回序列的可能的活动树。各个函数用它的函数名的第一个字母表示。请记住，这个树只代表了一种可能性，因为后续调用的参数会有不同，并且各个分支上的调用次数会受到partition的返回值的影响。

![293-1](../Images/image04470.jpeg)

图7-3　图7-2中程序的可能的活动序列

在活动树和程序行为之间存在下列多种有用的对应关系，正是因为这些关系使我们可以使用运行时刻栈：

1）过程调用的序列和活动树的前序遍历相对应。

2）过程返回的序列和活动树的后序遍历相对应。

3）假定控制流位于某个过程的特定活动中，且该过程活动对应于活动树上的某个结点N。那么当前尚未结束的（即活跃的）活动就是结点N及其祖先结点对应的活动。这些活动被调用的顺序就是它们在从根结点到N的路径上的出现顺序。这些活动将按照这个顺序的反序返回。

![293-2](../Images/image04471.jpeg)

图7-4　表示quicksort的某次运行中的调用的活动树
### 7.2.3　调用代码序列

实现过程调用的代码段称为调用代码序列（calling sequence）。这个代码序列为一个活动记录在栈中分配空间，并在此记录的字段中填写信息。返回代码序列（return sequence）是一段类似的代码，它恢复机器状态，使得调用过程能够在调用结束之后继续执行。

即使对于同一种语言，不同实现中的调用代码序列和活动记录的布局也可能千差万别。一个调用代码序列中的代码通常被分割到调用过程（调用者）和被调用过程（被调用者）中。在分割运行时刻任务时，调用者和被调用者之间不存在明确界限。源语言、目标机器、操作系统会提出某些要求，使得能够选择出一种较好的分割方案。总的来说，如果一个过程在n个不同点上被调用，分配给调用者的那部分调用代码序列会被生成n次。然而，分配给被调用者的部分只被生成一次。因此，我们期望把调用代码序列中尽可能多的部分放在被调用者中——能够根据被调用者的信息确定的部分都应该放到被调用者中。不过，我们将看到，被调用者不可能知道所有的事情。

在设计调用代码序列和活动记录的布局时，可以使用下列的设计原则：

1）在调用者和被调用者之间传递的值一般被放在被调用者的活动记录的开始位置，因此它们尽可能地靠近调用者的活动记录。这样做的动机是，调用者能够计算该次调用的实在参数的值并将它放在自身活动记录的顶部，而不用创建整个被调用者的活动记录，甚至不用知道该记录的布局。不仅如此，它还使得语言可以使用参数个数或类型可变的过程，比如C语言中的`printf`函数。被调用者知道应该把返回值放置在相对于它自己的活动记录的哪个位置。同时，不管有多少个参数，它们都将在栈中顺序地出现在该位置之下。

2）固定长度的项被放置在中间位置。根据图7-5，这样的项通常包括控制链、访问链和机器状态字段。如果每次调用中保存的机器状态的成分相同，那么可以使用同一段代码来保存和恢复每次调用的数据。不仅如此，如果我们将机器状态信息标准化，那么当错误发生时，诸如调试器这样的程序将可以更容易地将栈中的内容解码。

3）那些在早期不知道大小的项将被放置在活动记录的尾部。大部分局部变量具有固定的长度，编译器通过检查该变量的类型就可以确定其长度。然而，有些局部变量的大小只有在程序运行时才能确定。最常见的例子是动态数组，数组大小根据被调用者的某个参数决定。另外，临时量所需空间的大小通常依赖于代码生成阶段能够将多少临时变量放在寄存器中。因此，虽然编译器最终可以知道临时变量所需要的空间，但在刚开始生成中间代码时可能并不知道该空间的大小。

4）我们必须小心地确定栈顶指针所指的位置。一个常用的方法是让这个指针指向活动记录中固定长度字段的末端。这样，固定长度的数据就可以通过固定的相对于栈顶指针的偏移量来访问，而中间代码生成器知道这些偏移量。使用这种方法的后果是活动记录中的变长域实际上位于栈顶“之上”。它们的偏移量需要在运行时刻进行计算，但是它们仍然可以基于栈顶指针进行访问，但是偏移量为正。

图7-7给出了调用者和被调用者如何合作管理调用栈的一个例子。寄存器top_sp指向当前的顶层活动记录中机器状态字段的末端。调用者知道这个位于被调用者的活动记录中的位置。因此，调用者可以负责在控制转向被调用者之前设定top_sp的值。这个调用代码序列以及它在调用者和被调用者之间的划分描述如下：

![296-1](../Images/image04474.jpeg)

图7-7　调用者和被调用者之间的任务划分

1）调用者计算实在参数的值。

2）调用者将返回地址和原来的top_sp值存放到被调用者的活动记录中。然后，调用者增加top_sp的值，使之指向图7-7所示的位置。也就是说，top_sp越过了调用者的局部数据和临时变量以及被调用者的参数和机器状态字段。

3）被调用者保存寄存器值和其他状态信息。

4）被调用者初始化其局部数据并开始执行。

一个与此匹配的返回代码序列如下：

1）如图7-5所示，被调用者将返回值放到与参数相邻的位置。

2）使用机器状态字段中的信息，被调用者恢复top_sp和其他寄存器，然后跳转到由调用者放在机器状态字段中的返回地址。

3）尽管top_sp已经被减小，但调用者仍然知道返回值相对于当前top_sp值的位置。因此，调用者可以使用那个返回值。

上面的调用和返回代码序列支持使用不同数量的参数来调用同一个被调用程序（就像C语言中的`printf`函数那样）。请注意，在编译时刻，调用者的目标代码知道它向被调用者提供的参数的数量和类型。因此，调用者知道参数区域的大小。然而，被调用者的目标代码必须还能处理其他调用，因此，它要等到被调用时再检查相应的参数字段。使用图7-7中的组织方法，描述参数的信息必定放置在状态字段的相邻位置，因此被调用者可以找到这个信息。例如，在C语言的`printf`函数中，第一个参数描述了其余的参数，因此一旦找到了第一个参数，调用者就可以找到所有的其他参数。
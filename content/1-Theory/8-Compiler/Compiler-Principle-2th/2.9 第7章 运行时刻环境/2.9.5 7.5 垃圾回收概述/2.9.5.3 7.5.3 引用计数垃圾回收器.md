### 7.5.3　引用计数垃圾回收器

现在，我们考虑一个简单但有缺陷的基于引用计数的垃圾回收器。当一个对象从可达转变为不可达的时候，该回收器就可以将该对象确认为垃圾；当一个对象的引用计数为0时，该对象就会被删除。使用引用计数的垃圾回收器时，每个对象必须有一个用于存放引用计数的字段。引用计数可以按照下面的方法进行维护：

1）对象分配。新对象的引用计数被设置为1。

2）参数传递。被传递给一个过程的每个对象的引用计数加一。

3）引用赋值。如果u和v都是引用，对于语句u=v，v指向的对象的引用计数加1，u本来指向的原对象的引用计数减1。

4）过程返回。当一个过程退出时，该过程活动记录的局部变量中所指向的对象的引用数必须减一。如果多个局部变量存放了指向同一对象的引用，那么对每个这样的引用，该对象的引用计数都要减1。

5）可达性的传递丢失。当一个对象的引用计数变成0时，我们必须将该对象中的各个引用所指向的每个对象的引用计数减1。

引用计数有两个主要的缺点：它不能回收不可达的循环数据结构，并且它的开销较大。循环数据结构的出现都是有理由的：数据结构常常会指回到它们的父结点，也可能相互指向对方，从而形成交叉引用。

例7.11　图7-18给出了三个对象以及它们之间的引用，但是没有来自其他部分的引用。如果这些对象都不是根集的成员，那么它们都是垃圾，但是它们的引用计数都大于0。如果我们在垃圾回收中使用引用计数技术，这个情况就等同于一次内存泄漏，因为这种垃圾以及任何类似的结构永远不会被回收。

![318-1](../Images/image04491.jpeg)

图7-18　一个不可达的循环数据结构

引用计数的开销比较大，因为每一次引用赋值，以及在每个过程的入口和出口处，都会增加一个额外运算。这个开销和程序中的计算量成正比关系，而不仅仅和系统中的对象数目相关。需要特别考虑的是对一个程序的根集中的引用的更新。局部栈访问会引起引用计数的更新，为了消除因这种更新而引起的时间开销，人们提出了延期引用计数的概念。也就是说，引用计数不包括来自程序根集的引用。除非扫描整个根集仍没有找到指向某一对象的引用，否则这个对象不会被当作垃圾。

另一方面，引用计数的优势在于垃圾回收是以增量方式完成的。尽管总的开销可能很大，但这些运算分布在增变者的整个计算过程中。尽管删除一个引用可能致使大量对象变得不可达，我们可以很容易地延期执行递归地修改引用计数的运算，并在不同的时间点上逐步完成修改。因此，当应用必须满足某个时间期限时，或者对于不能接受长时间突然停顿的交互式系统而言，引用计数是一种特别有吸引力的算法。这个方法的另一种优势是垃圾被及时回收，从而保持了较低的空间使用量。
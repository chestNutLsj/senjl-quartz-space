### 7.5.2　可达性

我们把所有不需要对任何指针解引用就可以被程序直接访问的数据称为根集（root set）。例如，在Java中，一个程序的根集由所有的静态字段成员和栈中的所有变量组成。显然，程序可以在任何时候访问根集中的任何成员。递归地，对于任意一个对象，如果指向它的一个引用被保存在任何可达对象的字段成员或数组元素中，那么这个对象本身也是可达的。

当程序被编译器优化之后，可达性问题会变得更加复杂。首先，编译器可能会把引用变量放在寄存器中。这些引用也必须被看做是根集的一部分。其次，尽管在一个类型安全语言中，程序员不能直接操作内存地址，但是编译器常常会为了提高代码速度而这么做。因此，编译得到的代码中的寄存器可能会指向一个对象或数组的中间位置，或者程序可能把一个偏移量加到这些寄存器中的值上，计算得到一个合法地址。为了使得垃圾回收器能够找到正确的根集，优化编译器可以做如下的处理：

- 编译器可以限制垃圾回收机制只能在程序中的某些代码点上被激活。在这些点上没有“隐藏”的引用。
- 编译器可以写出一些信息供垃圾回收器恢复所有的引用。比如，指出哪些寄存器中包含了引用，或者如何根据给定的某个对象的内部地址来计算该对象的基地址。
- 编译器可以确保当垃圾回收器被激活时每个可达对象都有一个引用指向它的基地址。

可达对象的集合随着程序的执行而变化。当新对象被创建时该集合会增长，当某些对象变得不可达时该集合就缩小。重要的是记住一旦某个对象变得不可达，它就不可能再次变得可达。下面是一个增变者程序改变可达对象集合的四种基本操作：

- 对象分配。这些操作由存储管理器完成。它返回一个指向新创建的存储区域的引用。这个操作向可达对象集中添加成员。
- 参数传递和返回值。对象引用从实在输入参数传递到相应的形式参数，也可以从返回结果传回给调用者。这些引用指向的对象仍然是可达的。
- 引用赋值。对于引用u和v，形如u=v的赋值语句有两个效果。首先，u现在是v所指对象的一个引用。只要u是可达的，那么它指向的对象当然也是可达的。其次，u中原来的引用丢失了。如果这个引用是指向某一可达对象的最后一个引用，那么那个对象就变成不可达的。当某个对象变得不可达时，所有只能通过这个对象中的引用到达的对象都会变成不可达的。
- 过程返回。当一个过程退出时，保存其局部变量的活动记录将被弹出栈。如果这个活动记录中保存了某个对象的唯一引用，那个对象就变得不可达。同样，如果这个刚刚变得不可达的对象保存了指向其他对象的唯一引用，那么那些对象也将变得不可达，以此类推。

总而言之，新的对象通过对象分配被引入。参数传递和赋值可以传递可达性；赋值和过程结束可能结束对象的可达性。当一个对象变得不可达时，可能会导致更多的对象变得不可达。

栈对象的残存问题

当一个过程被调用时，一个局部变量v的对象被分配在栈中。可能会有一些指向v的指针被放置在非局部变量中。这些指针将在这个过程返回之后继续存在，但是存放v的空间消失了，从而产生了一个悬空指针的情况。我们是否应该象C所作的那样将象v这样的局部变量分配在栈中呢？答案是很多语言的语义要求局部变量在它们的过程返回后不再存在。保留一个指向这样的变量的引用是一个编程错误，不会要求编译器去改正程序中的这个错误。

有两种寻找不可达对象的基本方法。我们可以捕获可达对象变得不可达的转变时刻，也可以周期性地定位出所有可达对象，然后推出所有其他对象都是不可达的。7.4.5节中介绍的引用计数技术是一种著名的近似实现第一种方法的技术。我们在增变者执行可能改变可达对象集合的动作时，维护了指向各个对象的引用的计数。当计数器变成0时，相应的对象变得不可达。我们将在7.5.3节中更详细地讨论这个方法。

第二种方法传递地跟踪所有的引用，从而计算可达性。一个基于跟踪的垃圾回收器首先为根集中的所有对象加上“可达的”标号，然后重复地检查可达对象中的所有引用，找到更多的可达对象，并为它们加上同样的标号。这个方法必须首先跟踪所有的引用，然后才能决定哪些对象是不可达的。但是一旦计算得到可达集合，它就可以立刻找到很多不可达对象，并同时确定大量的空闲存储空间。因为所有的引用都必须在同一时刻进行分析，所以我们还可以选择将可达对象重新定位，从而减少碎片。有很多种不同的基于跟踪的算法，我们将在7.6节和7.7.1节中讨论这些可选算法。
### 7.5.1　垃圾回收器的设计目标

垃圾回收是重新收回那些存放了不能再被程序访问的对象的存储块。我们假定这些对象的类型可以由垃圾回收器在运行时刻确定。基于这个类型信息，我们可以知道该对象有多大，以及该对象的哪些分量包含指向其他对象的引用（指针）。我们还假定对对象的引用总是指向该对象的起始位置，而不会指向该对象中间的位置。因此，对同一个对象的所有引用具有相同的值，可以被很容易地识别。

我们把一个用户程序称为增变者（mutator），它会修改堆区中的对象集合。增变者从存储管理器处获取空间，创建对象，它还可以引入和消除对已有对象的引用。当增变者程序不能“到达”某些对象时，这些对象就变成了垃圾。在7.5.2节中将给出“到达”的准确定义。垃圾回收器找到这些不可达对象，并将这些对象交给跟踪空闲空间的存储管理器，收回它们所占的空间。

一个基本要求：类型安全

不是所有的语言都适合进行自动垃圾回收。为了使垃圾回收器能够工作，它必须知道任何给定的数据元素或一个数据元素的分量是否为（或可否被用作）一个指向某块已分配存储空间的指针。在一种语言中，如果任何数据分量的类型都是可确定的，那么这种语言就称为类型安全（typesafe）的。对于某些类型安全的语言，比如ML，我们可以在编译时刻确定数据的类型。另外一些类型安全语言，比如Java，其类型不能在编译时刻确定，但是可以在运行时刻确定。后者称为动态类型（dynamically typed）语言。如果一个语言既不是静态类型安全的，也不是动态类型安全的，它就被称为不安全的（unsafe）。

类型不安全的语言不适合使用自动垃圾回收机制。遗憾的是，有些最重要语言却是类型不安全的，比如C和C++。在不安全语言中，存储地址可以进行任意操作：可以将任意的算术运算应用于指针，创建出一个新的指针，并且任何整数都可以被强制转化为指针。因此，从理论上来说，一个程序可以在任何时候引用内存中的任何位置。这样，没有哪个内存位置可以被认为是不可访问的，也就无法安全地收回任何存储空间。

在实践中，大部分C和C++程序并没有随意地生成指针。因此人们开发了一个在理论上不正确，但是实践经验表明很有效的垃圾回收器。我们将在7.8.3节中讨论用于C和C++语言的保守的垃圾回收技术。

性能度量

尽管在几十年前就发明了垃圾回收机制，并且它能够完全防止内存泄漏，但是垃圾回收的代价是如此高昂，所以至今没有被很多主流的程序设计语言使用。在多年的研究中，很多不同的回收方法被提出来，但是还没有一种无可争议的最好的垃圾回收算法。在讨论这些方法之前，我们首先列举一些在设计垃圾回收器时必须考虑的性能度量标准。

- 总体运行时间。垃圾回收的速度可能会很慢。使它不会显著增加一个应用程序的总运行时间是很重要的。因为垃圾回收器必须要访问很多数据，它的性能很大程度上决定于它能否充分利用存储子系统。
- 空间使用。重要之处在于垃圾回收机制避免了内存碎片，并最大限度地利用了可用内存。
- 停顿时间。简单的垃圾回收器有一个众所周知的问题，即垃圾回收过程会在没有任何预警的情况下突然启动，导致程序（即增变者）突然长时间停顿。因此，除了最小化总体运行时间之外，人们还希望将最长停顿时间最小化。作为一个重要的特例，实时应用要求某些计算在一个时间界限内完成。我们要么在执行实时任务时压制住垃圾回收过程，要么限定最长停顿时间。因此，垃圾回收机制很少在实时应用中使用。
- 程序局部性。我们不能只通过一个垃圾回收器的运行时间来评价它的速度。垃圾回收器控制了数据的放置，因此影响了增变者程序的数据局部性。它可以通过释放空间并复用该空间来改善增变者程序的时间局部性；它也可以将那些一起使用的数据重新放置在同一个高速缓存线或内存页上，从而改善程序的空间局部性。

这些设计目标中的某些目标可能互相冲突，设计者必须在认真考虑程序的典型行为之后作出权衡。不同特性的对象可能适会使用不同的处理方式，这就要求垃圾回收器使用不同的技术来处理不同类型的对象。

例如，已分配的对象数量中小对象的数量很大比例，那么对小对象的分配不能产生大的开销。另一方面，考虑一下对可达对象进行重定位的垃圾回收器。在处理大对象时重新定位是非常昂贵的，但在处理小对象时代价就比较小。

考虑另一个例子。一般来说，在基于跟踪的回收器中，我们等待垃圾回收的时间越长，可回收对象的比例就越大。原因在于很多对象常常“英年早逝”，因此如果我们等一段时间，很多新分配的对象就会变成不可达的。这样的回收器平均花在每个被回收对象上的开销就会变小。另一方面，降低回收频率会增加程序的内存使用要求，降低数据局部性，并增加停顿时间。

相比之下，一个使用引用计数的回收器给增变者的每次运算引入一个常量开销，从而明显地减慢程序的整体运行速度。但是另一方面，引用计数技术不会产生长时间的停顿，并且能够有效地利用内存，因为它可以在垃圾产生时立刻发现它们（除了7.5.3节中将讨论的特定的循环结构）。

语言的设计同样会影响内存使用的特性。有些语言提倡的程序设计风格会产生很多垃圾。比如，函数式（或者几乎函数式）的程序设计语言为了避免改变已存在的对象，会创建出更多的对象。在Java中，除了整型和引用这样的基本类型，所有的对象都被分配在堆区而不是栈区。即使这些对象的生命周期被限制在一次函数调用的生命周期内，它们仍然被分到堆区中。这种设计使得程序员不需要关注变量的生命周期，但是其代价是产生更多的垃圾。已经有一些编译器优化技术可以分析变量的生命周期，并尽可能地将它们分配到栈区。
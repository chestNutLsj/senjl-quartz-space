### 7.3.6　处理访问链

如何确定访问链呢？当一个过程调用另一个特定的过程，而被调用过程的名字在此次调用中明确给出，那么处理方法就很简单。更复杂的情况是当调用的对象是一个过程型参数的时候。在那种情况下，要在运行时刻才能知道被调用的是哪个过程，因此在这个调用的不同执行中，被调用过程的嵌套深度可能有所不同。因此，让我们首先考虑当一个过程q显式地调用过程p时会发生什么事情。有三种情况：

1）过程p的嵌套深度大于q的嵌套深度，那么p一定是直接在q中定义的，否则q调用p的位置就不可能位于过程名p的作用域内。因此，p的嵌套深度恰好比q的嵌套深度大1，而p的访问链一定指向q。这个问题很简单，只需要在调用代码序列中增加一个步骤，即在p的访问链中放置一个指向q的活动记录的指针。这样的例子包括sort对quicksort的调用，该调用生成了图7-11a；以及quicksort对partition的调用，该调用产生了图7-11c。

2）这个调用是递归的，也就是说p=q[^2]。那么，新的活动记录的访问链和它下面的活动记录的访问链是相同的。例如quicksort（1，9）对quicksort（1，3）的调用，该调用形成了图7-11b。

3）p的嵌套深度np小于q的嵌套深度nq。为了使q中的调用位于名字p的作用域中，过程q必定嵌套在某个过程r中，而p是一个直接在r中定义的过程。因此，从q的活动记录开始，沿着访问链经过nq-np+1步就可以找到栈中最高的r的活动记录。那么，p的访问链必须指向r的这个活动记录。

例7.7　作为情况3的一个例子，请注意我们是如何从图7-11c转变为图7-11d的。被调用函数exchange的嵌套深度为2，比调用函数partition的嵌套深度3少1。因此，我们从partition的活动记录开始，前进3-2+1=2个访问链，这使我们从partition的活动记录到达quicksort（1，3）的活动记录，再到sort的活动记录。因此，exchange的访问链指向sort的这个活动记录，这就是我们在图7-11d中看到的。

另一种等价的找到这个访问链的方法是沿着访问链前进nq-np步，并拷贝在那个活动记录中找到的访问链。在我们的例子中，我们将经过一步到达quicksort（1，3）的活动记录，并拷贝出它的指向sort的访问链。请注意，这个访问链对于exchange来说是正确的，尽管exchange不在quicksort的作用域中，这两个函数是嵌套在sort中的兄弟函数。
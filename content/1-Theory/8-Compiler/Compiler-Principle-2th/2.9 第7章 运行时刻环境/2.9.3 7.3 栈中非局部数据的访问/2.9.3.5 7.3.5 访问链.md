### 7.3.5　访问链

针对嵌套函数的通常的静态作用域规则的一个直接实现方法是在每个活动记录中增加一个被称为访问链（access link）的指针。如果过程p在源代码中直接嵌套在过程q中，那么p的任何活动中的访问链都指向最近的q的活动。请注意，q的嵌套深度一定比p的嵌套深度恰巧少1。访问链形成了一条链路，它从栈顶活动记录开始，经过嵌套深度逐步递减的活动的序列。沿着这条链路找到的活动就是其数据和对应过程可以被当前正在运行的过程访问的所有活动。

假定栈顶的过程p的嵌套深度是np且p需要访问x，而x是在某个包围p的嵌套深度为nq的过程q中定义的一个元素。注意，nq≤np，且仅当p和q是同一个过程时两者相等。为了找到x，我们从位于栈顶的p的活动记录开始，沿着访问链进行np-nq次从一个活动记录到另一个活动记录的查找，最终我们找到了q的活动记录。这一定是当前出现在在栈中的最近（即最高）的q的活动记录。这个活动记录中包含了我们要找的元素x。因为编译器知道活动记录的布局，所以我们可以根据最后一个访问链找到q的活动记录中的某个位置，而x就位于和这个位置具有某个固定偏移量的位置上。

例7.6　图7-11给出了图7-10中的函数sort在执行时可能得到的栈的序列。同以前一样，我们用函数名的第一个字母来表示函数。我们展示了某些可能在不同活动记录中出现的数据，同时显示了每个活动的访问链。在图7-11a中，我们看到的是sort调用readArray将输入加载到数组a上后再调用quicksort（1，9）对数组进行排序的情形。quicksort（1，9）中的访问链指向sort的活动记录，这不是因为sort调用了quicksort，而是因为在图7-10的程序中，sort是qucksort外围的最靠近它的嵌套函数。

![302-1](../Images/image04484.jpeg)

图7-11　用来查找非局部数据的访问链

在图7-11所示的连续步骤中，我们看到对quicksort（1，3）的一次递归调用，然后是对partition的调用，而partition又调用exchange。请注意，quicksort（1，3）的访问链指向sort，其理由和quicksort（1，9）的访问链指向sort的理由相同。

在图7-11d中，exchange的访问链绕过了quicksort和partition的活动记录，因为exchange直接嵌套在sort中。这种安排是合理的，因为exchange只需要访问数组a，而它要对换的两个元素由其参数i和j指定。
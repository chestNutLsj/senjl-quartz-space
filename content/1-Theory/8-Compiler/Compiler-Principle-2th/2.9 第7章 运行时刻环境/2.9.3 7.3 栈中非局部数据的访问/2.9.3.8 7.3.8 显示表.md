### 7.3.8　显示表

使用访问链的方法来访问非局部数据的问题之一是，如果嵌套深度变大，我们就必须沿着一段很长的访问链路才能找到需要的数据。一个更高效的实现方法是使用一个称为显示表（display）的辅助数组d，它为每个嵌套深度保存了一个指针。我们设法使得在任何时刻，指针d［i］指向栈中最高的对应于某个嵌套深度为i的过程的活动记录。图7-14给出了一个显示表的例子。例如，在图7-14d中，我们看到显示表d的元素d［1］保存了一个指向sort的活动记录的指针，该活动记录是最高的（也是唯一的）对应于某个嵌套深度为1的函数的活动记录。同时，d［2］保存了指向exchange的活动记录的指针，该记录是嵌套深度为2的最高活动记录。d［3］指向partition，即嵌套深度为3的最高活动记录。

使用显示表的优势在于如果过程p正在运行，且它需要访问属于某个过程q的元素x，那么我们只需要查看d［i］即可。其中，i是q的嵌套深度。我们沿着指针d［i］找到q的活动记录，根据已知的偏移量就可以在这个活动记录中找到x。编译器知道i的值，因此它可以产生代码，该代码根据d［i］和x相对于q的活动记录顶部的偏移量来访问x。因此，该代码不需要经过一段很长的访问链路。

为了正确地维护显示表，我们需要在新的活动记录中保存显示表条目的原来的值。如果嵌套深度为np的过程p被调用，并且它的活动记录不是栈中的对应于某个深度为np的过程的第一个活动记录，那么p的活动记录就需要保存d［np］原来的值，同时d［np］本身则被设定指向p的这个活动记录。当p返回且它的这个活动记录从栈中清除时，我们将d［np］恢复到对p的这次调用之前的值。

例7.9　图7-14给出了操作显示表的若干步骤。在图7-14a中，深度为1的sort调用了深度为2的quicksort（1，9）。quicksort的活动记录中有一个用于存放d［2］的原值的位置，图中显示为“保存的d［2］”，尽管在这个例子中因为之前没有深度为2的活动记录，这个指针为空。

![305-1](../Images/image04487.jpeg)

图7-14　维护显示表

在图7-14b中，quicksort（1，9）调用quicksort（1，3）。因为这两次调用的活动记录的深度都为2，所以我们必须首先将d［2］中指向quicksort（1，9）的指针保存到quicksort（1，3）的活动记录中去。然后d［2］被设置为指向quicksort（1，3）。

下一步调用partition。这个函数的嵌套深度为3，因此我们将首次使用显示表中的d［3］位置，并使它指向partition的活动记录。partition的记录中有一个存放原来的d［3］值的位置。但是在这个例子中，d［3］原先没有值，因此这个位置上的指针为空。此时的显示表和栈如图7-14c所示。

然后，partition调用exchange。函数exchange的嵌套深度为2，因此它的活动记录保存了旧的d［2］指针，即指向quicksort（1，3）的活动记录的指针。请注意，这里出现了多个显示表指针之间相互交叉的情况。也就是说，d［3］指向的位置比d［2］所指位置更低。这是一个正常的情况，因为exchange只访问它自己的数据和通过d［1］访问的sort的数据。
### 7.3.7　过程型参数的访问链

当一个过程p作为参数传递给另一个过程q，并且q随后调用了这个参数（因此也就在q的这个活动中调用了p），有可能q并不知道p在程序中出现时的上下文。如果是这样，q就不可能知道如何为p设定访问链。这个问题的解决办法如下：当过程被用作参数的时候，调用者除了传递过程参数的名字，同时还需要传递这个参数对应的正确的访问链。

调用者总是知道这个访问链，因为如果p被过程r当作一个实在参数传递，那么p必然是一个可以被r访问的名字。因此，r可以像直接调用p那样为p确定访问链。也就是说，我们使用7.3.6节中给出的有关构造访问链的规则。

例7.8　在图7-12中，我们看到一个ML函数a的大体描述。函数a中嵌套了函数b和c。函数b有一个值为函数的参数f，b调用了这个参数。函数c在它自身中定义了一个函数d，然后c用实在参数d调用了b。

![303-1](../Images/image04485.jpeg)

图7-12　使用函数参数的ML程序的概要

让我们分析一下在执行a的时候发生了什么事情。首先，a调用c，因此我们在栈中将c的活动记录放在a的活动记录之上。因为c是直接在a中定义的，所以c的访问链指向a的记录。然后c调用b（d）。调用代码序列设置了b的活动记录，如图7-13a所示。

![304-1](../Images/image04486.jpeg)

图7-13　带有它们自己的访问链的实在参数

在这个活动记录中有实在参数d和它的访问链，两者结合组成了b的活动记录中的形式参数f的值。请注意，c了解d的信息，因为d是在c中定义的，因而c传递了一个指向它自己的活动记录的指针作为d的访问链。不管d在哪里定义，如果c在该定义的作用域内，那么必然适用7.3.6节中的三条规则之一，因此c可以给出这个访问链。

现在让我们看一下函数b所做的工作。我们知道它将在某个点上使用它的参数f，其效果就是调用了d。如图7-13b所示，d的一个活动记录出现在栈中。应该放在这个活动记录中的正确的访问链可以在参数f的值中找到。该访问链指向c的活动记录，因为c就在d的定义的外围。请注意，b能够正确地设置这个访问链，尽管b不在c的定义的作用域内。
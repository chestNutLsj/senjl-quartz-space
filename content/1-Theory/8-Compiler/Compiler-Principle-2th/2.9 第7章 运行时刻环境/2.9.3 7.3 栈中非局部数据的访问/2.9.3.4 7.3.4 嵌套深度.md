### 7.3.4　嵌套深度

对于不内嵌在任何其他过程中的过程，我们设定其嵌套深度（nesting depth）为1。例如，所有C函数的嵌套深度为1。然而，如果一个过程p在一个嵌套深度为i的过程中定义，那么我们设定p的嵌套深度为i+1。

例7.5　图7-10给出了我们连续使用的快速排序例子的一个ML程序的概要。唯一的嵌套深度为1的函数是最外层的函数sort。它读入一个有9个整数的数组a，并使用快速排序算法对它们进行排序。在sort内部的第二行上定义了数组a本身。请注意ML声明的形式。`array`的第一个参数说明我们要求该数组具有11个元素。所有的ML数组的下标都是从0开始的整数，因此这个数组与图7-2中的C语言数组a很相似。`array`的第二个参数说明数组a中的所有元素的初始值都是0。因为0是整数，选择这样的初始值使得ML编译器推断出a是一个整型数组，因此我们就不需要为a声明一个类型。

![301-1](../Images/image04483.jpeg)

图7-10　一个使用嵌套函数声明的ML风格的quicksort版本

ML的更多特性

ML几乎是纯函数式的语言。除此之外，ML还具有多个令那些熟悉C及C系列语言的程序员感到惊奇的特性：

- ML支持高阶函数（higher-order function）。也就是说，一个函数可以将函数作为参数，并且能够构造并返回其他函数。而这些函数又可以将函数作为参数。从而构造出任何层次的函数。
- ML本质上没有像C中的for和while语句那样的迭代语句，而是通过递归来达到循环的效果。这种方法在一个函数式语言中是很重要的，因为我们不能改变迭代变量，比如C语言中的“`for（i=0；i<10；i++）`”的i的值。ML将会把i作为一个函数的参数，该函数将用不断增加的i值作为参数递归地调用自身，直到到达循环界限为止。
- ML将列表和带标号的树结构作为其基本数据类型。
- ML不需要声明变量的类型。准确地说，它在编译时刻推导出类型，并且当它不能推导出结果时就将其作为错误处理。例如，`val x=1`显然使得x具有整数类型，并且如果我们还看到`val y=2*x`，那么我们就知道y也是一个整数。

在sort中声明的函数还有：readArray、exchange和quicksort。在第（4）行和第（6）行中，我们说明readArray和exchange都访问了数组a。请注意，ML中的数组访问可能违反这个语言的函数式特性。就像C版本的quicksort中那样，这两个函数实际上都改变了a中元素的值。因为这三个函数都是直接在嵌套深度为1的函数中定义的，所以它们的嵌套深度都是2。

第（7）行到第（11）行给出了quicksort的一些细节。局部值v（即分划算法的分割值）在第8行声明。第（9）行则给出了函数partition的定义。在第（10）行中我们指出partition访问了数组a和分割值v，并且还调用了函数exchange。因为partition直接在嵌套深度为2的函数中定义，所以其嵌套深度为3。第（11）行表明quicksort访问变量a和v以及函数partition，并递归调用其自身。

第（12）行表明最外层函数sort访问a，并调用两个过程readArray和quicksort。
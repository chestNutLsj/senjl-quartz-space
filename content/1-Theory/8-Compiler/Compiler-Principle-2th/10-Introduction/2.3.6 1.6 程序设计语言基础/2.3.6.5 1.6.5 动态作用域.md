### 1.6.5　动态作用域

从技术上讲，如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的因素，它就是动态的。然而，术语动态作用域通常指的是下面的策略：对一个名字x的使用指向的是最近被调用但还没有终止且声明了x的过程中的这个声明。这种类型的动态作用域仅仅在一些特殊情况下才会出现。我们将考虑两个动态作用域的例子：C预处理器中的宏扩展，以及面向对象编程中的方法解析。

例1.7　在图1-12给出的C程序中，标识符a是一个代表了表达式（x+1）的宏。但x到底是什么呢？我们不能够静态地（也就是说通过程序文本）解析x。

![034-1](../Images/image03963.jpeg)

图1-12　一个其名字的作用域必须动态确定的宏

实际上，为了解析x，我们必须使用前面提到的普通的动态作用域规则。我们检查所有当前活跃的函数调用，然后选择最近调用的且具有一个对x的声明的函数[^3]。对x的使用就是指向这个声明。

在图1-12的例子中，函数main首先调用函数b。当b执行时打印宏a的值。因为首先必须用（x+1）替换掉a，所以我们把本次对x的使用解析为对函数b中的声明`int x=1`。原因是b有一个x的声明，因此b中的`printf`中的（x+1）指向这个x。因此，打印出的值是2。

在b运行结束之后，函数c被调用，我们依旧需要打印宏a的值。然而，唯一可以被c访问的x是全局变量x。函数c中的`printf`语句指向x的这个声明，且被打印的值是3。

动态作用域解析对多态过程是必不可少的。所谓多态过程是指对于同一个名字根据参数类型具有两个或多个定义的过程。在有些语言中，比如ML（见7.3.3节），人们可以静态地确定名字所有使用的类型。在这种情况下，编译器可以把每个名字为p的过程替换为对相应的过程代码的引用。但是，在其他语言中，比如在Java和C++中，编译器有时不能够做出这样的决定。

静态作用域和动态作用域的类比

虽然可以有各种各样的静态或者动态作用域策略，在通常的（块结构的）静态作用域规则和通常的动态策略之间有一个有趣的关系。从某种意义上说，动态规则处理时间的方式类似于静态作用域处理空间的方式。静态规则让我们寻找的声明位于最内层的、包含变量使用位置的单元（块）中；而动态规则让我们寻找的声明位于最内层的、包含了变量使用时间的单元（过程调用）中。

例1.8　面向对象语言的一个突出特征就是每个对象能够对一个消息做出适当反应，调用相应的方法。换句话说，执行x.m()时调用哪个过程要由当时x所指向的对象的类来决定。一个典型的例子如下：

1）有一个类C，它有一个名字为m()的方法。

2）D是C的一个子类，而D有一个它自己的名字为m()的方法。

3）有一个形如x.m()的对x的使用，其中x是类C的一个对象。

正常情况下，在编译时刻不可能指出x指向的是类C的对象还是其子类D的对象。如果这个方法被多次应用，那么很可能某些调用作用在由x指向的类C的对象，而不是类D的对象，而其他调用作用于类D的对象之上。只有到了运行时刻才可能决定应当调用m的哪个定义。因此，编译器生成的代码必须决定对象x的类，并调用其中的某一个名字为m的方法。
### 1.6.3　静态作用域和块结构

包括C语言和它的同类语言在内的大多数语言使用静态作用域。C语言的作用域规则是基于程序结构的，一个声明的作用域由该声明在程序中出现的位置隐含地决定。稍后出现的语言，比如C++、Java和C#，也通过诸如public、private和protected等关键字的使用，提供了对作用域的明确控制。

在本节中，我们将考虑块结构语言的静态作用域规则，其中块（block）是声明和语句的一个组合。C使用括号{和}来界定一个块。另一种为同一目的使用begin和end的方法可以追溯到Algol。

名字、标识符和变量

虽然术语“名字”和“变量”通常指的是同一个事物，我们还是要很小心地使用它们，以便区别编译时刻的名字和名字在运行时刻所指的内存位置。

标识符（identifier）是一个字符串，通常由字母和数字组成。它用来指向（标记）一个实体，比如一个数据对象、过程、类，或者类型。所有的标识符都是名字，但并不是所有的名字都是标识符。名字也可以是一个表达式。比如名字x.y可以表示x所指的一个结构中的字段y。这里，x和y是标识符，而x.y是一个名字。像x.y这样的复合名字称为受限名字（qualified name）。

变量指向存储中的某个特定的位置。同一个标识符被多次声明是很常见的事情，每一个这样的声明引入一个新的变量。即使每个标识符只被声明一次，一个递归过程中的局部标识符将在不同的时刻指向不同的存储位置。

例1.5　C语言的静态作用域策略可以概述如下：

1）一个C程序由一个顶层的变量和函数声明的序列组成。

2）函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内。

3）名字x的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也有一个x的声明，那么函数中的那些语句就不在这个顶层声明的作用域内。

还有一些关于C语言的静态作用域策略的细节用来处理语句中的变量声明。我们将在接下来的内容中，以及在例1.6中查看这样的声明。

过程、函数和方法

为了避免总是说“过程、函数或方法”，每次我们要讨论一个可以被调用的子程序时，我们通常把它们统称为“过程”。但是当明确地讨论某个语言（比如C）的程序时有一个例外。因为C语言只有函数，所以我们把它们称为“函数”。或者，如果我们讨论像Java这样的只有“方法”的语言时，我们就使用这个术语。

一个函数通常返回某个类型（即“返回类型”）的值，而一个过程不返回任何值。C和类似的语言只有函数，因此它们把过程当作是具有特殊返回类型“void”的函数来处理。“void”表示没有返回值。像Java和C++这样的面向对象语言使用术语“方法”。这些方法可以像函数或者过程一样运行，但是总是和某个特定的类相关联。

在C语言中，有关块的语法如下：

1）块是一种语句。块可以出现在其他类型的语句（比如赋值语句）所能够出现的任何地方。

2）一个块包含了一个声明的序列，然后再跟着一个语句序列。这些声明和语句用一对括号包围起来。

注意，这个语法允许一个块嵌套在另一个块内。这个嵌套特性称为块结构（block structure）。C族语言都具有块结构，但是不能在一个函数内部定义另一个函数。

如果块B是包含声明D的最内层的块，那么我们说D属于B。也就是说，D在B中，且不在嵌套于B中的任何其他块中。

在一个块结构语言中，关于变量声明的静态作用域规则如下。如果名字x的声明D属于块B，那么D的作用域包括整个B，但是以任意深度嵌套在B中、重新声明了x的所有块B′不在此作用域中。这里，x在B′中重新声明是指存在另一个属于B′的对相同名字x的声明D′。

另一个等价的表达这个规则的方法着眼于名字x的一次使用。设B1，B2，…，Bk是所有的包含了x的该次使用的块。其中，Bk嵌套在Bk-1中，Bk-1嵌套在Bk-2中，…，依此类推。寻找最大的满足下面条件的i：存在一个属于Bi的x的声明。本次对x的使用就是指向Bi中对x的声明。换句话说，x的本次使用在Bi中的这个声明的作用域内。

例1.6　在图1-10中的C++程序有四个块，其中包含了变量a和b的几个定义。为了帮助记忆，每个声明把其变量初始化为它所属于的那个块的编号。

![033-1](../Images/image03961.jpeg)

图1-10　一个C++程序中的块结构

比如，考虑块B1中的声明`int a=1`。它的作用域包括整个B1，当然那些（可能很深地）嵌套在B1中并且有它自己的对a的声明的块除外。直接嵌套在B1中的B2没有a的声明，而B3就有。B4没有a的声明。因此块B3是整个程序中唯一位于名字a在B1中的声明的作用域之外的地方。也就是说，这个作用域包括B4和B2中除了B3之外的所有部分。关于程序中的全部五个声明的作用域的总结见图1-11。

![033-2](../Images/image03962.jpeg)

图1-11　例1.6中的声明的作用域

从另一个角度看，让我们考虑块B4中的输出语句，并把那里使用的变量a和b和适当的声明绑定。包含该语句的块的列表从小到大是B4、B2、B1。请注意，B3没有包含问题中所提到的点。B4有一个b的声明，因此该语句中对b的使用被绑定到这个声明，因此打印出来的b的值是4。然而，B4没有a的声明，因此我们接着看B2。这个块也没有a的声明，因此我们继续看B1。幸运的是，这个块有一个声明`int a = 1`。因此，打印出来的a的值是1。如果没有这个声明，程序就是错误的。
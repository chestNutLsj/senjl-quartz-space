### 1.6.2　环境与状态

我们在讨论程序设计语言时必须了解的另一个重要区别是在程序运行时发生的改变是否会影响数据元素的值，还是影响了对那个数据的名字的解释。比如，执行像`x=y+1`这样的赋值语句会改变名字x所指的值。更加明确地说，这个赋值改变了x所指向的内存位置上的值。

可能下面这一点就不是那么明显了。即x所指的位置也可能在运行时刻改变。比如，我们在例1.3中讨论过，如果x不是一个静态（或者说“类”）变量，那么这个类的每一个对象都有它自己的分配给变量x的实例的位置。这种情况下，对x的赋值可能会改变那些“实例”变量中的某一个变量的值，这取决于包含这个赋值的方法作用于哪个对象。

名字和内存（存储）位置的关联，及之后和值的关联可以用两个映射来描述。这两个映射随着程序的运行而改变（见图1-8）。

![031-1](../Images/image03958.jpeg)

图1-8　从名字到值的两步映射

1）环境（environment）是一个从名字到存储位置的映射。因为变量就是指内存位置（即C语言中的术语“左值”），我们还可以换一种方法，把环境定义为从名字到变量的映射。

2）状态（state）是一个从内存位置到它们的值的映射。以C语言的术语来说，即状态把左值映射为它们的相应右值。

环境的改变需要遵守语言的作用域规则。

例1.4　考虑图1-9中的C程序片断。整数i被声明为一个全局变量，同时也被声明为局部于函数f的变量。执行f时，环境相应地调整，使得名字i指向那个为局部于f的那个i所保留的存储位置，且i的所有使用（如图中明确显示的赋值语句`i=3`）都指向这个位置。局部的i通常被赋予一个运行时刻栈中的位置。

![031-2](../Images/image03959.jpeg)

图1-9　名字i的两个声明

只要当一个不同于f的函数g运行时，i的使用就不能指向那个局部于f的i。在函数g中对名字i的使用必须位于其他某个对i的声明的作用域内。一个例子是图中明确显示的赋值语句`x=i+1`，它位于某个其定义没有在图中显示的过程中。可以假定i+1中的i指向全局的i。和大多数语言一样，C语言中的声明必须先于其使用，因此在全局i的声明之前的函数不能指向它。

图1-8中的环境和状态映射是动态的，但是也有一些例外。

1）名字到位置的静态绑定与动态绑定。大部分从名字到位置的绑定是动态的。我们在这一节中讨论了这种绑定的几种方法。某些声明（比如图1-9中的全局变量i）可以在编译器生成目标代码时一劳永逸地分配一个存储位置。[^2]

2）从位置到值的静态绑定与动态绑定。一般来说，位置到值的绑定（图1-8的第二阶段）也是动态的，因为我们无法在运行一个程序之前指出一个位置上的值。被声明的常量是一个例外。比如，C语言的定义把名字

![031-3](../Images/image03960.jpeg)

`ARRAYSIZE`静态地绑定为值1000。我们看到这个语句就可以知道这个绑定关系，并且知道在程序运行时刻这个绑定不可能改变。
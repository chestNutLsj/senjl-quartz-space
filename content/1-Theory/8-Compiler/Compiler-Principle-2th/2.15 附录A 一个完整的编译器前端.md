   

# 附录A　一个完整的编译器前端

这个附录给出了一个完整的编译器前端，它是基于2.5节至2.8节中非正式描述的简单编译器编写的。和第2章的主要不同之处在于，这个前端像6.6节中描述的那样为布尔表达式生成跳转代码。我们首先给出源语言的语法。描述这个语法所用的文法需要进行调整，以适应自顶向下的语法分析技术。

这个翻译器的Java代码由五个包组成：`main、lexer、symbol、parser`和`inter`。包`inter`中包含的类处理用抽象语法表示的语言结构。因为语法分析器的代码和其他各个包交互，所以它将在最后描述。每个包存放在一个独立的目录中，每个类都有一个单独的文件。

作为语法分析器的输入时，源程序就是一个由词法单元组成的流，因此面向对象特性和语法分析器的代码之间没有什么关系。当由语法分析器输出时，源程序就是一棵抽象语法树，树中的结构或结点被实现为对象。这些对象负责处理下列工作：构造一个抽象语法树结点、类型检查、生成三地址中间代码（见包`inter`）。

## A.1　源语言

这个语言的一个程序由一个块组成，该块中包含可选的声明和语句。语法符号`basic`表示基本类型。

![626-1](../Images/image05104.jpeg)

把赋值当作一个语句（而不是表达式中的运算符）可以简化翻译工作。

面向对象与面向步骤

在一个面向对象方法中，一个构造的所有代码都集中在这个与构造对应的类中。但是在面向步骤的方法中，这个方法中的代码是按照步骤进行组织的，因此一个类型检查过程中对每个构造都有一个case分支，且一个代码生成过程对每个构造也都有一个case分支，等等。

对这两者进行衡量，可知使用面向对象方法会使得改变或增加一个构造（比如for语句）变得较容易；而使用面向步骤的方法会使得改变或增加一个步骤（比如类型检查）变得比较容易。使用对象来实现时，增加一个新的构造可以通过写一个自包含的类来实现；但是如果要改变一个步骤，比如插入自动类型转换的代码，就需要改变所有受影响的类。使用面向步骤的方式时，增加一个新构造可能会引起各个步骤中的多个过程的改变。

![626-2](../Images/image05105.jpeg)

表达式的产生式处理了运算符的结合性和优先级。它们对每个优先级级别都使用了一个非终结符号，而非终结符号factor用来表示括号中的表达式、标识符、数组引用和常量。

![627-1](../Images/image05106.jpeg)

## A.2　Main

程序的执行从类`Main`的方法`main`开始。方法`main`创建了一个词法分析器和一个语法分析器，然后调用语法分析器中的方法`program`。

![627-2](../Images/image05107.jpeg)

## A.3　词法分析器

包`lexer`是2.6.5节中的词法分析器的代码的扩展。类`Tag`定义了各个词法单元对应的常量：

![627-3](../Images/image05108.jpeg)

其中的三个常量`INDEX、MINUS`和`TEMP`不是词法单元，它们将在抽象语法树中使用。

类`Token`和`Num`和2.6.5节的相同，但是增加了方法`toString`：

![627-4](../Images/image05109.jpeg)

类Word用于管理保留字、标识符和像&&这样的复合词法单元的词素。它也可以用来管理在中间代码中运算符的书写形式；比如单目减号。例如，源文本中的`-2`的中间形式是`minus 2`。

![628-1](../Images/image05110.jpeg)

类Real用于处理浮点数：

![628-2](../Images/image05111.jpeg)

如我们在2.6.5节中讨论的，类`Lexer`的主方法，即函数`scan`，识别数字、标识符和保留字。

类`Lexer`中的第9～13行保留了选定的关键字。第14～16行保留了在其他地方定义的对象的词素。对象`Word.True`和`Word.False`在类`Word`中定义。对应于基本类型`int、char、bool`和`float`的对象在类`Type中`定义。类`Type`是`Word`的一个子类。类`Type`来自包`symbols`。

![628-3](../Images/image05112.jpeg)

函数`readch()`（第18行）用于把下一个输入字符读到变量`peek`中。名字`readch`被复用或重载，（第19～24行），以便帮助识别复合的词法单元。比如，一看到输入字符<，调用`readch（"="）`就会把下一个字符读入`peek`，并检查它是否为=。

![628-4](../Images/image05113.jpeg)

函数`scan`一开始首先略过所有的空白字符（第26～30行）。它首先试图识别像<=这样的复合词法单元（第31～34行）和像365及3.14这样的数字（第45～58行）。如果不成功，它就试图读入一个字符串（第59～70行）。

![629-1](../Images/image05114.jpeg)

最后，`peek`中的任意字符都被作为词法单元返回（第71～72行）。

![629-2](../Images/image05115.jpeg)

## A.4　符号表和类型

包`symbols`实现了符号表和类型。

类`Env`实质上和图2-37中的代码一样。类`Lexer`把字符串映射为字，类`Env`把字符串词法单元映射为类`Id`的对象。类`Id`和其他的对应于表达式和语句的类一起都在包`inter`中定义。

![630-1](../Images/image05116.jpeg)

我们把类`Type`定义为类`Word`的子类，因为像`int`这样的基本类型名字就是保留字，将被词法分析器从词素映射为适当的对象。对应于基本类型的对象是`Type.Int、Type.Float、Type.Char`和`Type.Bool`（第7～10行）。这些对象从超类中继承了字段`tag`，相应的值被设置为`Tag.BASIC`，因此语法分析器以同样的方式处理它们。

![630-2](../Images/image05117.jpeg)

函数`numeric`（第11～14行）和`max`（第15～20行）可用于类型转换。

![630-3](../Images/image05118.jpeg)

在两个“数字”类型之间允许进行类型转换，“数字”类型包括`Type.Char、Type.Int`和`Type.Float`。当一个算术运算符应用于两个数字类型时，结果类型是这两个类型的“max”值。

数组是这个源语言中唯一的构造类型。在第7行中调用`super`设置字段`width`的值。这个值在计算地址时是必不可少的。它同时也把`lexeme`和`tok`设置为默认值，这些值没有被使用。

![630-4](../Images/image05119.jpeg)

## A.5　表达式的中间代码

包`inter`包含了`Node`的类层次结构。`Node`有两个子类：对应于表达式结点的`Expr`和对应于语句结点的`Stmt`。本节介绍`Expr`和它的子类。`Expr`的某些方法处理布尔表达式和跳转代码，这些方法和`Expr`的其他子类将在A.6节中讨论。

抽象语法树中的结点被实现为类`Node`的对象。为了报告错误，字段`lexline`（文件`Node.java`的第4行）保存了本结点对应的构造在源程序中的行号。第7～10行用来生成三地址代码。

![631-1](../Images/image05120.jpeg)

表达式构造被实现为`Expr`的子类。类`Expr`包含字段`op`和`type`（文件`Expr.java`的第4～5行），分别表示了一个结点上的运算符和类型。

![631-2](../Images/image05121.jpeg)

方法`gen`（第7行）返回了一个“项”，该项可以成为一个三地址指令的右部。给定一个表达式E=E1+E2，方法`gen`返回一个项x1+x2，其中x1和x2分别是存放E1和E2值的地址。如果这个对象是一个地址，就可以返回`this`值。`Expr`的子类通常会重新实现`gen`。

方法`reduce`（第8行）把一个表达式计算（或者说“归约”）成为一个单一的地址。也就是说，它返回一个常量、一个标识符，或者一个临时名字。给定一个表达式E，方法`reduce`返回一个存放E的值的临时变量t。如果这个对象是一个地址，那么`this`仍然是正确的返回值。

我们把对方法`jumping`和`emitjumps`（第9～18行）的讨论推迟到A.6节中进行，它们为布尔表达式生成跳转代码。

![631-3](../Images/image05122.jpeg)

因为一个标识符就是一个地址，类`Id`从类`Expr`中继承了`gen`和`reduce`的默认实现。

![632-1](../Images/image05123.jpeg)

对应于一个标识符的类`Id`的结点是一个叶子结点。函数调用`super（id,p）`（文件Id.java的第5行）把`id`和`p`分别保存在继承得到的字段`op`和`type`中。字段`offset`（第4行）保存了这个标识符的相对地址。

类`Op`提供了`reduce`的一个实现（文件`Op.java`的第5～10行）。这个类的子类包括：表示算术运算符的子类`Arith`，表示单目运算符的子类`Unary`和表示数组访问的子类`Access`。这些子类都继承了这个实现。在每种情况下，`reduce`调用`gen`来生成一个项，生成一个指令把这个项赋值给一个新的临时名字，并返回这个临时名字。

![632-2](../Images/image05124.jpeg)

类`Arith`实现了双目运算符，比如+和*。构造函数`Arith`首先调用`super（tok,null）`（第6行），其中`tok`是一个表示该运算符的词法单元，`null`是类型的占位符。相应的类型在第7行使用函数`Type.max`来确定，这个函数检查两个运算分量是否可以被类型强制为一个常见的数字类型；`Type.max`的代码在A.4节中给出。如果它们能够进行自动类型转换，`type`就被设置为结果类型；否则就报告一个类型错误（第8行）。这个简单编译器检查类型，但是它并不插入类型转换代码。

![632-3](../Images/image05125.jpeg)

方法`gen`把表达式的子表达式归约为地址，并将表达式的运算符作用于这些地址（文件Arith.java的第11行），从而构造出了一个三地址指令的右部。比如，假设`gen`在`a+b*c`的根部被调用。其中对`reduce`的调用返回`a`作为子表达式`a`的地址，并返回`t`作为`b*c`的地址。同时，`reduce`还生成指令`t=b*c`。方法`gen`返回了一个新的`Arith`结点，其中的运算符是*，而运算分量是地址`a`和`t`。[^1]

值得注意的是，和所有其他表达式一样，临时名字也有类型。因此，构造函数`Temp`被调用时有一个类型参数（文件Temp.java的第6行）。[^2]

![633-1](../Images/image05126.jpeg)

类`Unary`和类`Arith`对应，但是处理的是单目运算符：

![633-2](../Images/image05127.jpeg)

## A.6　布尔表达式的跳转代码

布尔表达式B的跳转代码由方法`jumping`生成。这个方法的参数是两个标号`t`和`f`，它们分别称为表达式B的true出口和false出口。如果B的值为真，代码中就包含一个目标为`t`的跳转指令；如果B的值为假，就有一个目标为`f`的指令。按照惯例，特殊标号0表示控制流从B穿越，到达B的代码之后的下一个指令。

我们从类`Constant`开始。第4行上的构造函数`Constant`的参数是一个词法单元`tok`和一个类型`p`。它在抽象语法树中构造出一个标号为`tok`、类型为`p`的叶子结点。为方便起见，构造函数`Constant`被重载（第5行），重载后的构造函数可以根据一个整数创建一个常量对象。

![633-3](../Images/image05128.jpeg)

方法jumping（文件Constant.java的第9～12行）有两个参数：标号为`t`和`f`。如果这个常量是静态对象`True`（在第7行中定义），`t`不是特殊标号0，那么就会生成一个目标为`t`的跳转指令。否则，如果这是对象`False`（在第8行中定义）且`f`非零，那么就会生成一个目标为`f`的跳转指令。

类`Logical`为类`Or、And`和`Not`提供了一些常见功能。字段`expr1`和`expr2`（第4行）对应于一个逻辑运算符的运算分量（虽然类`Not`实现了一个单目运算符，为方便起见，我们还是把它当作`Logical`的子类）。构造函数`Logical（tok,a,b）`（第5～10行）构造出了一个语法树的结点，其运算符为`tok`，而运算分量为`a`和`b`。在完成这些工作时，它调用函数`check`来保证`a`和`b`都是布尔类型。方法`gen`将会在本节的最后讨论。

![634-1](../Images/image05129.jpeg)

在类`Or`中，方法`jumping`（第5～10行）生成了一个布尔表达式B=B1‖B2的跳转代码。当前假设B的true出口`t`和false出口`f`都不是特殊标号0。因为如果B1为真，B必然为真，所以B1的true出口必然是`t`，而它的false出口对应于B2的第一条指令。B2的true和false出口和B的相应出口相同。

![634-2](../Images/image05130.jpeg)

在一般情况下，B的true出口`t`可能是特殊标号0。变量`label`（文件`Or.java`的第6行）保证了B1的true出口被正确地设置为B的代码的结尾处。如果`t`为0，那么`label`被设置为一个新的标号，并在B1和B2的代码被生成后再生成这个新标号。

类`And`的代码和`Or`的代码类似。

![635-1](../Images/image05131.jpeg)

虽然类`Not`实现的是一个单目运算符，这个类和其他布尔运算符之间仍然具有相当多的共同之处，因此我们把它作为`Logical`的一个子类。它的超类具有两个运算分量，因此在第4行对`super`的调用中`x2`出现了两次。在第5～6行的方法中，只有`expr2`（文件`Logical.java`的第4行上声明）被用到。在第5行，方法`jumping`仅仅把true出口和false出口对调，调用`expr2.jumping`。

![635-2](../Images/image05132.jpeg)

类`Rel`实现了运算符<、<=、==、！=、>=和>。函数`check`（第5～9行）检查两个运算分量是否具有相同的类型，但它们不是数组类型。为简单起见，这里不允许类型强制转换。

![635-3](../Images/image05133.jpeg)

方法jumping（文件Rel.java的第10～15行）首先为子表达式`expr1`和`expr2`生成代码（第11～12行）。然后它调用方法`emitjumps`，这个方法在A.5节的文件Expr.java中的第10～18行中定义。如果`t`和`f`都不是特殊标号0，那么`emitjumps`执行下列代码：

![635-4](../Images/image05134.jpeg)

如果`t`或`f`是特殊标号0，那么最多只会生成一个指令（同样是来自文件Expr.java）：

![635-5](../Images/image05135.jpeg)

在生成类`Access`的代码时演示了方法`emitjumps`的另一种用法。源语言允许把布尔值赋给标识符和数组元素，因此一个布尔表达式可能是一个数组访问。类`Access`有一个方法`gen`，用来生成“正常”代码，另一个方法`jumping`用来生成跳转代码。方法`jumping`（第11行）在把这个数组访问归约为一个临时变量后调用`emitjumps`。这个类的构造函数（第6～9行）被调用时的参数为一个平坦化的数组`a`、一个下标`i`和该数组的元素类型`p`。在生成数组地址计算代码的过程中完成了类型检查。

![636-1](../Images/image05136.jpeg)

跳转代码还可以被用来返回一个布尔值。本节中较早描述的类`Logical`有一个方法`gen`（第15～24行）。这个方法返回一个临时变量`temp`。这个变量的值由这个表达式的跳转代码中的控制流决定。在这个布尔表达式的true出口，`temp`被赋予`true`值；在false出口，`temp`被赋予`false`值。这个临时变量在第17行声明。这个表达式的跳转代码在第18行生成，其中的true出口是下一条指令，而false出口是一个新标号`f`。下一条指令把`true`值赋给`temp`（第19行），后面紧跟目标为新标号`a`的跳转指令（第20行）。第21行上的代码生成标号`f`和一个把`false`赋给`temp`的指令。这个代码片段的结尾是标号`a`，该标号在第22行生成。最后，gen返回`temp`（第23行）。

## A.7　语句的中间代码

每个语句构造被实现为`Stmt`的一个子类。一个构造的组成部分对应的字段是相应子类的对象。例如，如我们将看到的，类`While`有一个对应于测试表达式的字段和一个子语句字段。

下面的类`Stmt`的代码中的第3～4行处理抽象语法树的构造。构造函数`Stmt()`不做任何事情，因为相关处理工作是在子类中完成的。静态对象`Stmt.Null`（第4行）表示一个空的语句序列。

![636-2](../Images/image05137.jpeg)

第5～7行处理三地址代码的生成。方法`gen`被调用时两个参数分别是标号`a`和`b`，其中`b`标记这个语句的代码的开始处，而`a`标记这个语句的代码之后的第一条指令。方法`gen`（第5行）是子类中的`gen`方法的占位符。子类`While`和`Do`把它们的标号`a`存放在字段`after`（第6行）中。当任何内层的`break`语句要跳出这个外层构造时就可以使用这些标号。对象`Stmt.Enclosing`在语法分析时被用于跟踪外层构造。（对于包含`continue`语句的源语言，我们可以使用同样的方法来跟踪一个`continue`语句的外层构造。）

类`If`的构造函数为语句if（E）S构造一个结点。字段`expr`和`stmt`分别保存了E和S对应的结点。请注意，小写字母组成的`expr`是一个类`Expr`的字段的名字。类似地，`stmt`是类为`Stmt`的字段的名字。

![637-1](../Images/image05138.jpeg)

一个`If`对象的代码包含了`expr`的跳转代码，然后是`stmt`的代码。如A.6节中所讨论的，第11行的调用`expr.jumping（0,a）`指明如果`expr`的值为真，控制流必须穿越`expr`的代码；否则控制流必须转向标号`a`。

类`Else`处理条件语句的`else`部分。它的实现和类`If`的实现类似：

![637-2](../Images/image05139.jpeg)

一个`While`对象的构造过程分为两个部分：构造函数`While()`创建了一个子结点为空的结点（第5行）；初始化函数`int（x,s）`把子结点`expr`设置成为x，把子结点`stmt`设置成为`s`（第6～9行）。函数`gen（b,a）`用于生成三地址代码（第10～16行）。它和类`If`中的相应函数`gen()`在本质上有着相通之处。不同之处在于标号`a`被保存在字段`after`中（第11行），且`stmt`的代码之后紧跟着一个目标为`b`的跳转指令（第15行）。这个指令使得`while`循环进入下一次迭代。

![637-3](../Images/image05140.jpeg)

类`Do`和类`While`非常相似。

![638-1](../Images/image05141.jpeg)

类`Set`实现了左部为标识符且右部为一个表达式的赋值语句。在类`Set`中的大部分代码的目的是构造一个结点并进行类型检查（第5～13行）。函数`gen`生成一个三地址指令（第14～16行）。

![638-2](../Images/image05142.jpeg)

类`SetElem`实现了对数组元素的赋值。

![638-3](../Images/image05143.jpeg)

类`Seq`实现了一个语句序列。在第6～7行上对空语句的测试是为了避免使用标号。请注意，空语句`Stmt.Null`不会产生任何代码，因为类`Stmt`中的方法`gen`不做任何处理。

![639-1](../Images/image05144.jpeg)

一个break语句把控制流转出它的外围循环或外围switch语句。类`Break`使用字段`stmt`来保存它的外围语句构造（语法分析器保证`Stmt.Enclosing`表示了其外围构造对应的语法树结点）。一个`Break`对象的代码是一个目标为标号`stmt.after`的跳转指令。这个标号标记了紧跟在`stmt的`代码之后的指令。

![639-2](../Images/image05145.jpeg)

## A.8　语法分析器

语法分析器读入一个由词法单元组成的流，并调用适当的在A.5～A.7节中讨论的构造函数，构建出一棵抽象语法树。当前符号表按照2.7节中图2-38的翻译方案进行处理。

包`parser`包含一个类`Parser`：

![639-3](../Images/image05146.jpeg)

和2.5节中的简单表达式的翻译器类似，类`Parser`对每个非终结符号有一个过程。消除A.1节中源语言文法中的左递归后可以得到一个新的文法。这些过程就是基于这个新文法创建的。

语法分析过程首先调用了过程`program`，这个过程又调用了`block()`（第16行）来对输入流进行语法分析，并构建出抽象语法树。第17～18行生成了中间代码。

![640-1](../Images/image05147.jpeg)

对符号表的处理明确显示在过程`block`中[^3]。变量`top`（在第5行中声明）存放了最顶层的符号表，变量`savedEnv`（第21行）是一个指向前面的符号表的连接。

![640-2](../Images/image05148.jpeg)

程序中的声明会被处理为符号表中有关标识符的条目（见第30行）。虽然这里没有显示，声明还可能生成在运行时刻为标识符保留存储空间的指令。

![640-3](../Images/image05149.jpeg)

过程`stmt`有一个switch语句。这个语句的各个case分支对应于非终结符号`Stmt`的各个产生式。每个case分支都使用A.7节中讨论的构造函数来建立某个构造对应的结点。当语法分析器碰到while语句和do语句的开始关键字的时候，就会创建这些语句的结点。这些结点在相应语句进行完语法分析之前就构造出来，这可以使得任何内层的break语句回指到它的外层循环语句。当出现嵌套的循环时，我们通过使用类`Stmt`中的变量`Stmt.Enclosing和savedStmt`（在第52行声明）来保存当前的外层循环的。

![640-4](../Images/image05150.jpeg)

![641-1](../Images/image05151.jpeg)

为方便起见，赋值语句的代码出现在一个辅助过程`assign`中。

![641-2](../Images/image05152.jpeg)

对算术运算和布尔表达式的语法分析很相似。在每种情况下都会创建一个正确的抽象语法树结点。如A.5节和A.6节所讨论的，这两者的代码生成方法有所不同。

![641-3](../Images/image05153.jpeg)

![642-1](../Images/image05154.jpeg)

在语法分析器中的其余代码处理表达式“因子”。辅助过程`offset`按照6.4.3节中讨论的方法为数组地址计算生成代码。

![642-2](../Images/image05155.jpeg)

![643-1](../Images/image05156.jpeg)

## A.9　创建前端

这个编译器的各个包的代码存放在五个目录中：`main、lexer、symbols、parser`和`inter`。创建编译器的命令行根据系统的不同而不同。下面是编译器的UNIX实现：

![643-2](../Images/image05157.jpeg)

上面的`javac`命令为每个类创建了`.class`文件。要练习使用我们的翻译器，只需要输入`java main.Main`，后面跟上将要被翻译的源程序，比如文件`test`中的内容：

![643-3](../Images/image05158.jpeg)

对于这个输入，这个前端输出：

![644-1](../Images/image05159.jpeg)

尝试一下。

---

[^1]: 为了报告错误，在构造一个结点时，类`Node`中的字段`lexline`记录了当前的文本行号。我们把在中间代码生成过程中构造新的结点时跟踪行号的任务留给读者。

[^2]: 另一种可行的方法是让这个构造函数以一个表达式结点作为参数，这样它就可以复制这个表达式结点的类型和文本位置。

[^3]: 另一种很具有吸引力的方法是向类`Env`中添加方法`push`和`pop`，而当前的符号表可以通过一个静态变量`Env.top`来访问。
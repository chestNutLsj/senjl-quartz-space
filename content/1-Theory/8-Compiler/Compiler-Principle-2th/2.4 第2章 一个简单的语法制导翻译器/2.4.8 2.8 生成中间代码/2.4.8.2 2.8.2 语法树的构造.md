### 2.8.2　语法树的构造

我们将首先给出一个可以创建抽象语法树的翻译方案，然后在2.8.4节中说明如何修改这个翻译方案，使得它可以在构造语法树的同时生成三地址代码，或者让它只生成三地址代码。

回顾一下2.5.1节，下面的语法树

![073-1](../Images/image04025.jpeg)

表示将运算符op应用于E1和E2所代表的子表达式而得到的表达式。我们可以为任意的构造创建抽象语法树，而不仅仅为表达式创建语法树。每个构造用一个结点表示，其子结点代表此构造中具有语义含义的组成部分。比如，在C语言的一个while语句

while（expr）stmt

中，具有语义含义的组成部分是表达式expr和语句stmt[^12]。这样的while语句的抽象语法树结点有一个运算符，我们称为while，并有两个子结点——分别是expr和stmt的抽象语法树。

图2-39中的翻译方案为一个有代表性但却很简单的由表达式和语句组成的语言构造出一棵语法树。这个翻译方案中的所有非终结符都有一个属性n，即语法树的一个结点。这些结点被实现为类Node的对象。

类Node有两个直接子类：一个是Expr，代表各种表达式；另一个是Stmt，代表各种语句。每一种语句都有一个对应的Stmt的子类。比如，运算符while对应于子类While。一个对应于运算符while，子结点为x和y的语法树结点可以由如下伪代码创建：

new While（x，y）

它通过调用构造函数While创建了类While的一个对象，其名称和类名相同。就和构造函数对应于运算符一样，构造函数的参数对应于抽象语法中的运算分量。

当我们研究附录A中的详细代码时，我们就会发现各个方法在这个类层次结构中的位置。在本节中，我们将简单讨论一下这些方法中的一小部分。

我们将依次考虑图2-39中的每一条产生式和规则。首先，我们将解释定义各种类型语句的产生式，然后再解释用于定义有限几种表达式的产生式。

![074-1](../Images/image04026.jpeg)

图2-39　为表达式和语句构造抽象语法树

语句的抽象语法树

我们在抽象语法中为每一种语句构造定义了相应的运算符。对于以关键字开头的构造，我们将使用这个关键字作为对应的运算符。因此，我们把while作为while语句的运算符，而把do作为do-while语句的运算符。对于条件语句，我们定义了两个运算符ifelse和if，分别对应于带有和不带有else部分的if语句。在我们简单的示例性语言中，我们没有使用else，所以仅有一种if语句。增加else会在语法分析过程中产生一些问题。我们将在4.8.2节中讨论这些问题。

每个语句运算符都有一个对应的同名的类，但是类名的首字符要大写。比如，类If对应于if。此外，我们还定义了子类Seq，它表示一个语句序列。这个子类对应于文法中的非终结符号stmts。这些类都是Stmt的子类，而Stmt又是Node的子类。

图2-39中的翻译方案说明了抽象语法树结点的构建方法。一个典型的用于if语句的规则如下：

stmt → if（expr）stmt1 { stmt.n = new If（expr.n，stmt1.n）；}

if语句中具有语义含义的成分是expr和stmt1。语义动作将结点stmt.n定义为子类If的一个新对象。我们没有给出If的构造函数的代码。它创建一个标号为if，子结点为expr.n和stmt1.n的新结点。

表达式语句不以某个关键字开头，所以我们定义了一个新运算符eval及类Eval（其中Eval是Stmt的一个子类）表示表达式语句。相关的规则如下：

stmt → expr；{ stmt.n = new Eval（expr.n）；}

在抽象语法树中表示语句块

在图2-39中，另一个语句构造是由一系列语句组成的语句块。考虑下面的规则：

![075-3](../Images/image04027.jpeg)

第一个规则说明当一个语句是一个语句块时，它的抽象语法树和这个语句块的相同；第二个规则说明非终结符号block对应的抽象语法树就是该块中的语句序列对应的语法树。

为简单起见，图2-39中的语言不包含声明。虽然在附录A中包含声明，但我们将看到一个语句块的抽象语法树仍然就是块中的语句序列的抽象语法树。因为声明中的信息已经加入到符号表中，所以它们不需要出现在抽象语法树中。因此，不管它是否包含声明，语句块在中间代码中看起来就是一个普通的语句构造。

一个语句序列的表示方法如下：用一个叶子结点null表示一个空语句序列，用运算符seq表示一个语句序列。规则如下：

stmts → stmts1 stmt { stmts.n = new Seq（stmts1.n，stmt.n）；}

例2.18　在图2-40中，我们可以看到表示一个语句块或语句列表的语法树的一部分。列表中有两个语句。第一个语句是一个if语句，第二个语句是while语句。我们没有显示在这个语句列表之上的那部分抽象语法树，并且将各棵子树用三角形表示，包括这个语句列表中对应于if语句和while语句的条件的抽象语法树，以及对应于这两个语句的子语句的语法树。

![075-1](../Images/image04028.jpeg)

图2-40　由一个if语句和一个while语句组成的语句列表的语法树的一部分

表达式的语法树

在以前的章节中，我们用三个非终结符号expr、term和factor使得乘法*相对加法+具有较高的优先级。我们在2.2.6节中指出，非终结符号的数目正好比表达式中优先级的层数多一。在图2-39中，我们增添了两个同优先级的比较运算符<和<=，同时也保留了+和*运算符，故我们增加了一个新的非终结符号add。

抽象语法允许我们将“相似的”运算符分为一组，以减少在实现表达式时需要处理的不同情况和需要设计的子类。在本章中，“相似的”意指运算符的类型检查规则和代码生成规则相近。比如，运算符+和*通常分为一组，因为它们可以用同一种方式进行处理——它们对运算分量类型的要求是一样的，且它们都会生成一个将一个运算符应用到两个数值之上的三地址指令。一般来说，在抽象语法中对运算符分组是根据编译器后期处理的需要来决定的。图2-41中的表描述了几种常见Java运算符的具体语法和抽象语法之间的对应关系。

![075-2](../Images/image04029.jpeg)

图2-41　几种常见Java运算符的具体语法和抽象语法

在具体语法中，几乎所有的运算符都是左结合的，只有赋值运算符=是右结合的。同一行中的运算符具有同样的优先级，也就是说==和！=具有同样的优先级。各行是按照优先级递增的方式排列的，比如==比&&或=的优先级更高。-unary中的下标unary用于区分单目减号（比如`-2`中的符号）和双目减号（比如`2-a`中的符号）。运算符［］表示数组访问，例如`a［i］`。

图中“抽象语法”列描述了运算符的分组方法。赋值运算符=所在的组仅包含它自己。组cond包含了条件布尔运算符&&和||。组rel包含==和<所在行中的各个关系比较运算符。组op包含诸如+和*这样的算术运算符。单目减、逻辑非和数组访问运算符各自为一组。

图2-41中具体语法和抽象语法之间的映射关系可以通过编写翻译方案来实现。图2-39中的非终结符号expr、rel、add、term和factor的产生式描述了一些运算符的具体语法。这些运算符是图2-41中的运算符的一个代表性子集。这些产生式中的语义动作创建出相应的语法树结点。比如，规则

term → term1 * factor { term.n = new Op（′*′，term1.n，factor.n）；}

创建了类Op的结点，这个类实现了图2-41中被分在op组中的运算符。构造函数Op的参数中包含了一个`′*′`，它指明了实际的运算符。它的参数还包括对应于子表达式的结点term1.n和factor.n。
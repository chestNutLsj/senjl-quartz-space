### 2.8.4　三地址码

一旦抽象语法树构造完成，我们就可以计算树中各结点的属性值并执行各结点中的代码片段，进行进一步的分析和综合。我们将说明如何通过遍历语法树来生成三地址代码。具体地说，我们将显示如何编写一个抽象语法树的函数，并且同时生成必要的三地址代码。

三地址指令

三地址代码是由如下形式的指令组成的序列

x = y op z

其中x、y和z可以是名字、常量或由编译器生成的临时量；而op表示一个运算符。

数组将由下面的两种变体指令来处理：

x［y］= z

x = y［z］

前者将z的值保存到x［y］所指示的位置上，而后者则将y［z］的值放到位置x上。

三地址指令将被顺序执行，但是当遇到一个条件或无条件跳转指令时，执行过程就会跳转。我们选择下面的指令来控制程序流：

![077-1](../Images/image04031.jpeg)

在一个指令前加上前缀`L：`就表示将标号`L`附加到该指令。同一指令可以同时拥有多个标号。

最后，我们还需要一个拷贝值的指令。如下的三地址指令将y的值拷贝至x中：

x = y

语句的翻译

通过利用跳转指令实现语句内部的控制流，我们就可以将语句转换成为三地址代码。图2-42的代码布局说明了对语句if expr then stmt1的翻译。该代码布局中的跳转指令

![078-3](../Images/image04032.jpeg)

![078-1](../Images/image04033.jpeg)

图2-42　if语句的代码布局

将在expr的值为false时跳过语句stmt1对应的翻译结果。其他语句的翻译方法是类似的：我们将使用一些跳转指令在其各个组成部分对应的代码之间进行跳转。

为了具体说明，我们在图2-43中给出了类If的伪代码。类If是类Stmt的一个子类，对应于其他语句的类也是Stmt的子类。Stmt的每一个子类（这里是If）都有一个构造函数及一个为此类语句生成三地址代码的函数gen。

![078-2](../Images/image04034.jpeg)

图2-43　类If中的函数gen生成三地址代码

图2-43中的构造函数If构建了if语句的语法树结点。它有两个参数，一个表达式结点x和一个语句结点y。它们被分别存放在属性E和S中。同时，这个构造函数调用了函数newlable()，给属性after赋予一个唯一的新标号。这个标号将按照图2-42所示的布局被使用。

一旦源程序的整个抽象语法树被创建完毕，函数gen在此抽象语法树的根结点处被调用。在我们的简单语言中，一个程序就是一个语句块，所以这棵抽象语法树的根结点就代表这个语句块中的语句序列。所有的语句类都有一个gen函数。

图2-43中类If的gen函数的伪代码具有代表性。它调用E.rvalue()函数来翻译表达式E（即作为if语句的组成部分的布尔值表达式），并保存E.rvalue()返回的结果结点。我们稍后会讨论表达式的翻译。然后，gen函数发生一个条件跳转指令，并且调用S.gen()来翻译子语句S。

表达式的翻译

我们将考虑包含二目运算符op、数组访问和赋值运算，并包含常量及标识符的表达式，以此来说明对表达式的翻译。为了简单起见，我们要求在数组访问y［z］中，y必须为标识符[^13]。关于表达式的中间代码生成的详细讨论请见6.4节。

我们将采用一种简单的方法，为一个表达式的语法树中的每个运算符结点都生成一个三地址指令。不需要为标识符和常量生成任何代码，因为它们可以作为地址出现在指令中。如果一个结点x的类为Expr，其运算符为op，我们就发出一个指令来计算结点x上的值，并将此值存放到一个由编译器生成的“临时”名字（比如t）中。因此，`i-j+k`会被翻译成为两条指令

![079-1](../Images/image04035.jpeg)

在处理数组访问及赋值运算时要区分左值和右值。例如，对于`2*a［i］`，可以通过计算`a［i］`的右值并存放在一个临时量中而得到翻译结果，如下所示：

![079-2](../Images/image04036.jpeg)

但是，当`a［i］`出现在一个赋值表达式的左边时，我们不能简单地以一个临时量来替换`a［i］`。

我们的简单方法使用了两个函数lvalue及rvalue，它们分别显示在图2-44和图2-45中。当函数rvalue被应用于一个非叶子结点x时，它生成一些指令，这些指令对x求值并存放到一个临时量中，然后该函数返回一个表示此临时量的新结点。当函数lvalue被应用于一个非叶子结点x时，它也会生成一些指令，这些指令计算x之下的各个子树。然后这个函数返回代表x的“地址”的新结点。

因为函数lvalue要处理的情况相对较少，我们首先对它进行描述。当将它应用于一个结点x时，如果此结点对应于一个标识符（即x的类是Id），那么它直接返回x。在我们的简单语言中，除此之外只存在一种情况会使一个表达式拥有左值，即结点x代表一个数组访问，比如`a［i］`。在这种情况下，结点x形如Access（y，z），其中类Access是类Expr的子类，y表示被访问数组的名字，而z表示被访问元素在该数组中的偏移量（下标）。在图2-44所示的伪代码中，函数lvalue会在必要时调用rvalue（z）来生成计算z的右值的指令。然后它创建并返回一个新的Access结点，此结点包含两个子结点，分别对应于数组名y及z的右值。

![079-3](../Images/image04037.jpeg)

图2-44　函数lvalue的伪代码

例2.19　当结点x表示数组访问`a［2*k］`时，lvalue（x）的调用将生成指令

![079-4](../Images/image04038.jpeg)

并返回一个表示`a［t］`的左值的新结点x′，其中t是一个新的临时名字。

具体来说，lvalue函数将运行到代码

return new Access（y，rvalue（z））；

处，此时y是对应于a的结点，z是对应于表达式`2*k`的结点。对rvalue（x）的调用生成了表达式`2*k`的代码（即三地址语句`t = 2 * k`），并返回表示临时名字`t`的新结点z′。这个结点就成为新的Access结点x′的第二个字段的值。

图2-45中的函数rvalue生成指令并返回一个（可能是新生成的）结点。当x代表一个标识符或常量时，rvalue返回x本身。在其他情况下，它都返回一个对应于新的临时名字t的Id结点。各种情况的处理如下：

![080-1](../Images/image04039.jpeg)

图2-45　函数rvalue的伪代码

- 如果结点x表示y op z，则代码首先计算y′ = rvalue（y）及z′ = rvalue（z）。它创建一个新的临时名字t并产生一个指令t = y′ op z′（更精确地说，生成了一个由代表t、y′、op和z′的字符串组合而成的指令字符串）。它返回一个对应于标识符t的结点。
- 如果结点x表示一个数组访问y［z］，我们可以复用函数lvalue。函数调用lvalue（x）返回一个数组访问y［z′］，其中z′代表一个标识符，它保存了该数组访问的偏移量。函数rvalue会创建一个临时变量t，并按照t = y［z′］生成一个指令，最后返回一个对应于t的结点。
- 如果x表示y = z，那么代码将首先计算z′ = rvalue（z）。它生成一条计算lvalue（y）= z′的指令，并返回结点z′。

例2.20　当将函数rvalue应用于

![080-2](../Images/image04040.jpeg)

的语法树时，它将生成

![080-3](../Images/image04041.jpeg)

这棵语法树的根是Assign结点，它的第一个参数是`a［i］`，第二个参数是`2*a［j-k］`。因此，适用rvalue函数的第三种情况，函数被递归地应用于`2*a［j-k］`。这棵子树的根结点是表示*的Op结点，因此rvalue首先创建一个临时变量t1，然后处理左运算分量2，再后是右运算分量。常量2没有生成三地址代码，rvalue返回它的右值，即一个值为2的Constant结点。

右运算分量`a［j-k］`是一个Access结点，因此rvalue创建一个新的临时变量`t2`，然后在这个结点上调用lvalue函数。函数rvalue被递归地调用来处理表达式`j-k`。这个调用的副作用是创建临时变量`t3`，然后生成三地址语句`t3=j-k`。接着，函数的执行返回到正在处理`a［j-k］`的函数lvalue的活动中，临时名字`t2`被赋予整个数组访问表达式的右值，即`t2=a［t3］`。

现在，我们返回到处理Op结点`2*a［j-k］`的rvalue的活动中。这次调用已经创建了临时变量`t1`。作为一个副作用，rvalue生成了一条执行这个乘法表达式的三地址指令。最后，应用于整个表达式的rvalue的调用活动在最后调用lvalue来处理左部`a［i］`，然后生成了一条三地址指令`a［i］=t1`。这个指令把这个赋值表达式的右部赋给左部。

改进表达式的代码

使用如下几种方法，我们可以改进图2-45中的函数rvalue，使它生成更少的三地址指令：

- 在之后的优化阶段减少拷贝指令的数目。例如，对于指令`t = i + 1；i = t`，如果`t`没有再被使用，我们就可以将它们合并为`i = i + 1`。
- 充分考虑上下文的情况，在最初生成指令时就减少生成的指令。例如，如果一个三地址赋值指令的左部是一个数组访问`a［t］`，那么其右部必然是一个名字、常量或临时变量，它们都只使用了一个地址。但如果左部是一个名字x，那么其右部可以是一个使用两个地址的运算y op z。

我们可以按照如下的方式来避免一些拷贝指令。首先修改翻译函数，使之生成一个部分完成的指令，该指令只进行计算，比如计算`j+k`，但并不确定将结果保存在哪里，而是用null来替代结果地址：

![081-1](../Images/image04042.jpeg)

随后，这个空的结果地址会被替换为适当的标识符或临时量。如果`j+k`位于一个赋值表达式的右部，如`i=j+k`，那么null就会被替换为标识符。此时（2.8）就变成

![081-2](../Images/image04043.jpeg)

但如果`j+k`是一个子表达式，比如它在`j+k+l`中，那么这个空的结果地址会被替换成一个新的临时变量`t`，并且生成一个新的部分指令：

![081-3](../Images/image04044.jpeg)

很多编译器想方设法使得它生成的代码和汇编代码专家手写的一样好，甚至更好。如果使用第9章中讨论的代码优化技术，那么一个有效的策略是首先使用一个简单的中间代码生成方法，然后依靠代码优化器来消除不必要的指令。
### 2.2.6　运算符的优先级

考虑表达式`9+5*2`。该表达式有两种可能的解释，即`（9+5）*2`或`9+（5*2）`。+和*的结合性规则只能作用于同一运算符的多次出现，因此它们无法解决这个二义性。为此，当多种运算符出现时，我们需要给出一些规则来定义运算符之间的相对优先关系。

如果*先于+获得运算分量，我们就说*比+具有更高的优先级。在通常的算术中，乘法和除法比加法和减法具有更高的优先级。因此在表达式`9+5*2`和`9*5+2`中，都是运算分量5首先参与*运算，即这两个表达式分别等价于`9+（5*2）`和`（9*5）+2`。

例2.6　算术表达式的文法可以根据表示运算符结合性和优先级的表格来构建。我们首先考虑四个常用的算术运算符和一个优先级表。在此优先级表中，运算符按照优先级递增的顺序排列，同一行上的运算符具有相同的结合性和优先级：

左结合：`+-`

左结合：`*/`

我们创建两个非终结符号expr和term，分别对应于这两个优先级层次，并使用另一个非终结符号factor来生成表达式中的基本单元。当前，表达式的基本单元是数位和带括号的表达式。

factor → digit |（expr）

现在我们考虑具有最高优先级的二目运算符`*`和`/`。由于这些运算符是左结合的，因此其产生式和左结合列表的产生式类似：

![045-3](../Images/image03978.jpeg)

类似地，expr生成由加减运算符分隔的term列表：

![045-4](../Images/image03979.jpeg)

因此最终得到的文法是：

expr → expr + term | expr -term | term

term → term * factor | term / factor | factor

factor → digit |（expr）

例2.6中表达式文法的推广

我们可以将因子（factor）理解成不能被任何运算符分开的表达式。“不能分开”的意思是说当我们在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的运算分量。当然，因子本身作为一个整体可以成为该运算符的一个运算分量。如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用。如果因子就是一个运算分量，那么它当然不能被分开。

一个（不是因子的）项（term）是一个可能被高优先级的运算符*和/分开，但不能被低优先级运算符分开的表达式。一个（不是因子也不是项的）表达式可能被任何一个运算符分开。

我们可以把这种思想推广到具有任意n层优先级的情况。我们需要n+1个非终结符号。首先，例2.6中描述的factor不可被分开。通常，这个非终结符号的产生式体只能是单个运算分量或括号括起来的表达式。然后，对于每个优先级都有一个非终结符，表示能被该优先级或更高优先级的运算符分开的表达式。通常，这个非终结符的产生式有一些产生式体表示了该优先级的运算符的应用；另有一个产生式体只包含了代表更高一层优先级的非终结符号。

使用这个文法时，一个表达式就是一个由`+或-`分隔开的项（term）的列表，而项是由`*或/`分隔的因子（factor）的列表。请注意，任何由括号括起来的表达式都是一个因子。因此，我们可以使用括号来构造出具有任意嵌套深度的表达式（以及具有任意深度的语法分析树）。

例2.7　由于大多数语句是由一个关键字或一个特殊字符开始的，因此关键字能够帮助我们识别语句。这一规则的例外情况包括赋值语句和过程调用语句。由图2-8中的（二义性）文法定义的语句都符合Java的语法。

![046-1](../Images/image03980.jpeg)

图2-8　Java语句的子集的文法

在stmt的第一个产生式中，终结符号id表示任意标识符。非终结符号expression的产生式还没有给出。第一个产生式描述的赋值语句符合Java的语法，虽然Java将`=`号看作是可出现在表达式内部的赋值运算符。比如，在Java中允许出现a=b=c，而这个文法不允许出现这样的形式。

非终结符号stmts产生一个可能为空的语句列表。stmts的第二个产生式生成一个空列表∈。第一个产生式生成的是一个可能为空的列表再跟上一个语句。

分号的放置方式很微妙。它们出现在所有不以stmt结尾的产生式的末尾。这种方法可以避免在if或while这样的语句后面出现多余的分号，因为if和while语句的最后是一个嵌套的子语句。当嵌套子语句是一个赋值语句或do-while语句时，分号将作为这个子语句的一部分被生成。
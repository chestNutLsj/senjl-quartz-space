### 2.7.2　符号表的使用

从效果看，一个符号表的作用是将信息从声明的地方传递到实际使用的地方。当分析标识符x的声明时，一个语义动作将有关x的信息“放入”符号表中。然后，一个像factor →id这样的产生式的相关语义动作从符号表中“取出”这个标识符的信息。因为对一个表达式E1 op E1（其中op代表一般的运算符）的翻译只依赖于对E1和E2的翻译，不直接依赖于符号表，所以我们可以加入任意数量的运算符，而不会影响从声明通过符号表到达使用地点的基本信息流。

例2.17　图2-38中的翻译方案说明了如何使用类Env。这个翻译方案主要考虑作用域、声明和使用。它实现了例2.14中描述的翻译。如前面描述的，在处理输入

![071-1](../Images/image04022.jpeg)

时，这个翻译方案过滤掉了各个声明，并生成

![071-2](../Images/image04023.jpeg)

请注意图2-38中各个产生式的体都已经对齐，因此所有的文法符号出现在同一列上，并且所有的语义动作都出现在第二列上。结果，一个产生式体的各个组成部分常常分开出现在多行上。

![071-3](../Images/image04024.jpeg)

图2-38　使用符号表翻译带有语句块的语言

现在考虑语义动作。这个翻译方案在进入和离开块的时候将分别创建和释放符号表。变量top表示一个符号表链的顶部的顶层符号表。这个翻译方案的基础文法的第一个产生式是program→block。在block之前的语义动作将top初始化为null，即不包含任何条目。

第二个产生式block→ ′*′{decls stmts′}′中包含了进入和离开块时的语义动作。在进入块时，在decls之前，一个语义动作使用局部变量saved保存了对当前符号表的引用。这个产生式的每次使用都有一个单独的局部变量saved，这个变量和这个产生式的其他使用中的局部变量都不同。在一个递归下降语法分析器中，saved可以是block对应的过程的局部变量。对于递归函数中的局部变量的处理方法将在7.2节中讨论。代码

top = new Env（top）；

将变量top设置为刚刚创建的新符号表。这个新符号表被链接到进入这个块之前一刻top的原值。变量top是类Env的一个对象，构造函数Env的代码显示在图2-37中。

在离开块时，′}′之后的一个语义动作将top的值恢复为进入块时保存起来的值。从实际效果看，这个表形成了一个栈，将top恢复为之前保存的值实际上是将该块中各个声明的结果弹出栈[^10]。这样就使得该块中的声明在块外不可见。

声明decl→type id的结果是创建一个对应于已声明标识符的新条目。我们假设词法单元type和id都有一个相关的属性，分别是被声明标识符的类型和词素。我们不会讨论符号对象s的所有字段，但是我们假设对象中有一个字段type给出该符号的类型。我们创建一个新的符号对象s，并通过代码s.type = type.lexeme为它赋予正确的类型。整个条目使用top.put（id.lexeme，s）加入到顶层的符号表中。

产生式factor→id中的语义动作通过符号表获取这个标识符的条目。操作get从top开始搜索符号表链中的第一个关于此标识符的条目。搜索得到的条目包含有关该标识符的所有信息，比如标识符的类型。
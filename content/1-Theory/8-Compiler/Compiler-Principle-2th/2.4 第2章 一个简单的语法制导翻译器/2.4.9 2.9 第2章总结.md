## 2.9　第2章总结

本章介绍的语法制导翻译技术可以用于构造如图2-46所示的编译器的前端。

![082-1](../Images/image04045.jpeg)

图2-46　一个语句的两种可能的翻译结果

- 构造一个语法制导翻译器要从源语言的文法开始。一个文法描述了程序的层次结构。文法的定义使用了称为终结符号的基本符号和称为非终结符号的变量符号。这些符号代表了语言的构造。一个文法的规则，即产生式，由一个作为产生式头或产生式左部的非终结符，以及称为产生式体或产生式右部的终结符号/非终结符号序列组成。文法中有一个非终结符被指派为开始符号。
- 在描述一个翻译器时，在程序构造中附加属性是非常有用的。属性是指与一个程序构造关联的任何量值。因为程序构造是使用文法符号来表示的，因此属性的概念也被扩展到文法符号上。属性的例子包括与一个表示数字的终结符号num相关联的整数值，或与一个表示标识符的终结符号id相关联的字符串。
- 词法分析器从输入中逐个读取字符，并输出一个词法单元的流，其中词法单元由一个终结符号以及以属性值形式出现的附加信息组成。在图2-46中，词法单元被写成用〈〉括起的元组。词法单元〈id，`"peek"`〉由终结符号id和一个指向包含字符串"`peek`"的符号表条目的指针构成。翻译器使用符号表来存放保留字和已经遇到的标识符。
- 语法分析要解决的问题是指出如何从一个文法的开始符号推导出一个给定的终结符号串。推导的方法是反复将某个非终结符替换为它的某个产生式的体。从概念上讲，语法分析器会创建一棵语法分析树。该树的根结点的标号为文法的开始符号，每个非叶子结点对应于一个产生式，每个叶子结点的标号为一个终结符号或空串∈。语法分析树推导出由它的叶子结点从左到右组成的终结符号串。
- 使用被称为预测语法分析法的自顶向下（从语法分析树的根结点到叶子结点）方法可以手工建立高效的语法分析器。预测分析器有对应于每个非终结符的子过程。该过程的过程体模拟了这个非终结符号的各个产生式。只要在输入流中向前看一个符号，就可以无二义地确定该过程体中的控制流。其他语法分析方法见第4章。
- 语法制导翻译通过在文法中添加规则或程序片段来完成。在本章中，我们只考虑了综合属性。任意结点x上的一个综合属性的值只取决于x的子结点（如果有的话）上的属性值。语法制导定义将规则和产生式相关联，这些规则用于计算属性值。语法制导的翻译方案在产生式体中嵌入了称为语义动作的程序片段。这些语义动作按照语法分析中产生式的使用顺序执行。
- 语法分析的结果是源代码的一种中间表示形式，称为中间代码。图2-46列出了中间代码的两种主要形式。抽象语法树中的各个结点代表了程序构造，一个结点的子结点给出了该构造有意义的子构造。另一种表示方法是三地址代码，它是一个由三地址指令组成的序列，其中每个指令只执行一个运算。
- 符号表是存放有关标识符的信息的数据结构。当分析一个标识符的声明的时候，该标识符的信息被放入符号表中。当在后来使用这个标识符时，比如它作为一个表达式的因子使用时，语义动作将从符号表中获取这些信息。

---

[^1]: 单个斜体字母在第4章中详细讨论文法时另有它用。例如，我们将使用X、Y和Z来表示终结符号或非终结符号。但是，包含两个或两个以上字符的任何斜体名字仍然表示一个非终结符号。

[^2]: 从技术上讲，∈可以是任意字母表（符号的集合）上的零个符号组成的串。

[^3]: 在这个规则以及很多其他的规则中，同一个非终结符号（这里是expr）会在一个产生式中出现多次。expr1中的下标1用于区分产生式中expr的两次出现，但“1”并不是该非终结符号的一部分。在下面的“区分一个非终结符号的不同使用的约定”中有更加详细的描述。

[^4]: 在一般的左递归文法中，非终结符号A可能通过一些中间产生式推导出Aα，而不一定存在产生式A → Aα。

[^5]: 作为一个小小的优化，我们可以在调用match之前打印这个数位，避免将这个数位保存起来。一般来说，改变语义动作和文法符号之间的顺序是有风险的，因为这么做可能改变这个翻译的结果。

[^6]: `的调用放在一个`try`语句中。该`try`语句可以捕获`SyntaxError`异常，输出一个消息并结束。如果这么做，我们将需要在图2-27的程序中加入一个类`SyntaxError`。要完成这个扩展，我们还必须修改`match`和`term`的声明，使得它们不仅可以抛出`IOException`，还可以抛出`SyntaxError`。同时也必须重新声明调用它们的函数`expr`，使得它可以抛出`SyntaxError`异常。

[^7]: ASCII字符通常被转化为0～255之间的整数。因此我们用大于255的整数来表示终结符号。

[^8]: 比如，在C语言中，程序块要么是一个函数，要么是函数中由花括号分隔的一个部分，这个部分中有一个或多个声明。

[^9]: “环境”是另一个用于表示与程序中某个点相关的符号表集合的术语。

[^10]: 我们也可以使用另一种方法来处理，可以在类`Env`中加入静态操作push和pop，而不用显式地保存和恢复符号表。

[^11]: 和它的对应“动态”指的是“当程序运行时”。很多语言也会进行某些动态检查。比如，像Java这样的面向对象语言有时必须在程序执行时检查类型，因为可能需要根据一个对象的特定子类来决定应该将哪个方法应用于该对象。

[^12]: 其中的右括号的唯一作用是将表达式和语句分开。左括号实际上没有任何含义，把它放在那里只是为了让while语句看起来顺眼一些，因为如果没有左括号，C语言中就会出现不匹配的括号对。

[^13]: 这个简单语言支持`a［a［n］］`，但是不支持`a［m］［n］`。请注意，`a［a［n］］`是形如`a`［E］的访问，其中的E是`a［n］`。
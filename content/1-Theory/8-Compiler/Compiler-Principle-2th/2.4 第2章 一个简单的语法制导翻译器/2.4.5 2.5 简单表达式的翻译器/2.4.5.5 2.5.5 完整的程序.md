### 2.5.5　完整的程序

我们的翻译器的完整Java程序显示在图2-27中。第一行以`import`开头，使得程序可以访问`java.io`包以进行系统输入和输出。其余的代码包括两个类：`Parser`和`Postfix`。类`Parser`包含变量`lookahead`和函数`Parser`、`expr`、`term`和`match`。

![061-1](../Images/image04001.jpeg)

图2-27　将中缀表达式翻译为后缀表达形式的Java程序

程序的执行从类`Postfix`中定义的函数`main`开始。函数`main`创建了一个`Parser类的实例parse`，然后调用它的函数`expr`对一个表达式进行语法分析。

和类`Parser同名的函数Parser`是该类的构造函数（constructor），它在创建该类的一个对象时自动调用。请注意，根据类`Parser`开始处的定义，构造函数`Parser`读入一个词法单元，并将变量`lookahead`初始化为这个词法单元。由单个字符组成的词法单元是由系统输入例程`read`提供的，该子程序从输入文件中读取下一个字符。注意，`lookahead`被声明为整型变量，而不是字符型变量。这是为了便于在后面引入非单个字符的其他词法单元。

函数`expr`是2.5.4节中讨论的简化处理的结果。它实现了图2-23中的非终结符号`expr`和`rest`。图2-27中`expr`的代码首先调用`term`，然后用一个while循环不断测试`lookahead`是否和`+`或`-`匹配。当运行到代码中的`return`语句时，控制流离开这个while循环。在循环内部，`System`类的输入/输出功能用来写一个字符。

函数`term`使用Java类`Character`中的例程`isDigit`来判断向前看符号是否为一个数位。例程`isDigit`的参数是一个字符。然而，为了方便将来的扩展，`lookahead`被声明为整型变量。`（char）lookahead`将`lookahead`的类型强制转化（cast）为字符。和图2-25相比，这里有一个小的改动，即输出向前看字符的语义动作在调用`match`之前就执行了。

函数match检查终结符号。如果向前看符号是匹配的，它就读取下一个输入终结符号，否则它执行下面的代码，发出出错消息。

![062-1](../Images/image04002.jpeg)

上述代码创建了类`Error`的一个新异常，并将“`syntax error`”作为其错误消息。Java并不强制要求在`throw`子句中声明`Error`异常，因为这些异常的本意是表示不应该发生的不正常事件。[^6]

Java的一些主要特征

对于不熟悉Java的读者来说，下面的一些注解有助于他们阅读图2-27中的代码：

- 一个Java的类由变量和函数定义的序列组成。
- 函数（例程）的参数列表用括号括起来，即使没有参数也需要写出括号，因此我们写成`expr()`和`term()`。这些函数实际上是过程，因为它们的函数名字前面的关键字`void`表示它们没有返回值。
- 函数之间通信时可以通过“值传递方式”传递参数，也可以通过访问共享数据进行通信。比如，函数`expr()`和`term()`使用类变量`lookahead`来检查向前看符号。这两个函数都可以访问这个类变量，因为它们同属于类`Parser`。
- 和C语言一样，Java语言使用=表示赋值，==表示等于，！=表示不等于。
- `term()`定义中的子句“`throw IOException`”声明该函数在执行时可能会出现一个名为`IOException`的异常。当函数`match`调用例程`read`时，如果无法读到输入就会出现这样的异常。任何调用了`match`的函数也必须声明在该函数运行时可能出现一个`IOException`异常。
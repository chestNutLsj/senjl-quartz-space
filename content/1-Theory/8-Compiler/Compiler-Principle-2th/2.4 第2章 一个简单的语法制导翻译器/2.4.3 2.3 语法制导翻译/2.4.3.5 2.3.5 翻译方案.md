### 2.3.5　翻译方案

图2-10中的语法制导定义将字符串作为属性值附加在语法分析树的结点上，从而得到翻译结果。我们现在来考虑另外一种不需要操作字符串的方法。它通过运行程序片段，逐步生成相同的翻译结果。

前序遍历和后序遍历

前序遍历和后序遍历是深度优先遍历的两种重要的特例。在这两种遍历中，我们都是从左到右递归地访问每个结点的子结点。

我们经常遍历一棵树，并在各个结点上执行某些特定的动作。如果动作在我们第一次访问一个结点时被执行，那么我们将这种遍历称为前序遍历（preorder traversal）。类似地，如果动作在我们最后离开一个结点前被执行，则称这种遍历为后序遍历（postorder traversal）。图2-11中的过程visit（N）就是一个后序遍历的例子。

前序遍历和后序遍历根据一个结点的动作执行时间来定义这些结点的相应次序。一棵以结点N为根的（子）树的前序排序由N，跟上它的从左到右的每棵子树（如果存在）的前序排序组成。而一棵以结点N为根的（子）树的后序排序则由N的从左到右的每棵子树的后序排序，再跟上N自身组成。

语法制导翻译方案是一种在文法产生式中附加一些程序片段来描述翻译结果的表示方法。语法制导翻译方案和语法制导定义相似，只是显式指定了语义规则的计算顺序。

被嵌入到产生式体中的程序片段称为语义动作（semantic action）。一个语义动作用花括号括起来，并写入产生式的体中，它的执行位置也由此指定，如下面的规则所示：

rest → + term {print（′+′）} rest1

当我们考虑表达式的另一种形式的文法时，我们就会看到这样的规则，其中非终结符号rest代表“一个表达式中除第一个项之外的一切”。这种形式的文法将在2.4.5节中讨论。此外，rest1中的下标将非终结符号rest在产生式体中的实例与产生式头部的rest实例区分开来。

当我们画出一个翻译方案的语法分析树时，我们为每个语义动作构造一个额外的子结点，并使用虚线将它和该产生式头部对应的结点相连。例如，表示上述产生式和语义动作的部分语法分析树如图2-13所示。对应于语义动作的结点没有子结点，因此在第一次访问该结点时就会执行这个动作。

![051-1](../Images/image03986.jpeg)

图2-13　为一个语义动作创建一个额外的叶子结点

例2.12　图2-14的语法分析树在额外的叶子结点中含有打印语句。这些叶子结点通过虚线与语法分析树的内部结点相连接。它的翻译方案如图2-15所示。该翻译方案的基础文法生成了由符号+和-分隔的数位序列组成的表达式。假设我们对整棵树进行从左到右的深度优先遍历，并在我们访问它的叶子结点时执行每个打印语句，那么产生式体中内嵌的语义动作将把这样的表达式翻译为相应的后缀表示形式。

![051-2](../Images/image03987.jpeg)

图2-14　把`9-5+2`翻译成`95-2+`的语义动作

图2-14的根结点代表图2-15中的第一个产生式。这个根结点的最左边的子树代表左边的运算分量，它的标号和根结点一样都是expr。在一次后序遍历中，我们首先执行该子树中的所有语义动作。然后我们访问没有语义动作的叶子结点+。接下来，我们执行代表右运算分量term的子树中的所有语义动作。最后执行额外结点上的语义动作{print（′+′）}。

![052-1](../Images/image03988.jpeg)

图2-15　把表达式翻译成后缀形式的语义动作

由于term的产生式的右部只有一个数位，该产生式的语义动作把这个数位打印出来。产生式expr→term不需要产生输出，只有前面两个产生式的语义动作中的运算符才会打印出来。图2-14中的语义动作在对语法分析树的后序遍历中执行时会打印出`95-2+`。

注意，尽管图2-10和图2-15中的翻译方案产生相同的翻译结果，但它们构造结果的过程是不同的。图2-10是把字符串作为属性附加到语法分析树中的结点上，而图2-15通过语义动作把翻译结果以增量方式打印出来。

如图2-14所示的语法分析树中的语义动作将中缀表达式`9-5+2`翻译成`95-2+`，它恰好将`9-5+2`中的每个字符各打印一次。它不需要任何附加空间来存放子表达式的翻译结果。当按照这种方式递增地创建输出时，字符的打印顺序非常重要。

实现一个翻译方案时，必须保证各个语义动作按照它们在语法分析树的后序遍历中的顺序执行。这个实现不一定要真的构造出一棵语法分析树（通常也不会这么做），只要能够确保语义动作的执行过程等同于我们真的构建了语法分析树并在后序遍历中执行这些动作时的情形。
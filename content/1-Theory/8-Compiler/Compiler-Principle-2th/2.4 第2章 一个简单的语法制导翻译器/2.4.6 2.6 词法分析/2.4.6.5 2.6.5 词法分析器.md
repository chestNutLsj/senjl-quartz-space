### 2.6.5　词法分析器

将本节到目前为止给出的伪代码片段组合起来，就可以得到一个返回词法单元对象的函数scan。如下所示：

---

Token scan(){
      跳过空白符，见2.6.1节；
      处理数字，见2.6.3节；
      处理保留字和标识符，见2.6.4节；
      /*如果我们运行到这里，就将预读字符peek作为一个词法单元*/
      Token t= new Token（peek）；
      peek = 空白符 /*按照2.6.2讨论的方法初始化*/；
      return t；
}

---

本节的其余部分将函数scan实现为一个用于词法分析的Java程序包的一部分。这个叫做lexer的包中包含对应于各种词法单元的类和一个包含函数`scan`的类`Lexer`。

图2-32中显示了对应于各个词法单元的类及它们的字段，但图中没有给出它们的方法。类`Token`有一个`tag`字段，它用于做出语法分析决定。子类`Num`增加了一个用于存放整数值的字段`value`；子类`Word`增加了一个字段`lexeme`，用于保存关键字和标识符的词素。

![065-3](../Images/image04009.jpeg)

图2-32　类Token以及子类Num和Work

每个类都在以它的名字命名的文件中。`Token`类的文件内容如下：

![065-4](../Images/image04010.jpeg)

第一行指明了lexer包。第3行声明了字段`tag`为`final`的，即它一旦被赋值就不能再修改。第4行上的构造函数`Token`用于创建词法单元对象，比如

![066-1](../Images/image04011.jpeg)

创建了`Token`类的一个新对象，并且把它的`tag`字段初始化为“+”的整数表示。（为简洁起见，我们省略了常用的方法`toString`。该方法将返回一个适于打印的字符串。）

在伪代码中使用诸如num、id这样的终结符号的地方，Java代码中使用整型常量表示。类`Tag`实现了这些常量：

![066-2](../Images/image04012.jpeg)

除了值为整数的字段`NUM`和`ID`外，这个类还定义了两个字段`TRUE`和`FALSE`以备后用，它们将用于演示如何处理保留的关键字。[^7]

`Tag`类中的字段是`public`的，因此它们可以在包的外面使用。它们同时也是`static`的，因此这些字段只能有一个实例，或者说拷贝。这些字段是`final`的，因此它们只能被赋值一次。事实上，这些常量就代表常量。在C语言中，可以使用`define`语句来获得类似的效果。这些`define`语句使得`NUM`这样的名字可以被当作符号常量使用，例如：

![066-4](../Images/image04013.jpeg)

在伪代码引用终结符号num和id的地方，Java代码引用的是`Tag.NUM`和`Tag.ID`。唯一的要求是`Tag.NUM`和`Tag.ID`必须被初始化为互不相同的值，且这些初始化值还必须不同于那些代表单字符词法单元（比如“+”或“*”）的常量。

类`Num`和`Word`显示在图2-33中。类`Num`通过在第3行声明一个整数字段`value`而扩展了`Token`。第4行的构造函数`Num`调用了`super（Tag.NUM）`，该函数把其父类`Token`的`tag`字段设定为`Tag.NUM`。

![066-3](../Images/image04014.jpeg)

图2-33　`Token`的子类`Num`和`Word`

类`Word`既可用于保留字，也可用于标识符，因此第4行上的构造函数`Word`需要两个参数：一个词素和一个与`tag`对应的整数值。一个用于保留字`true`的对象可以通过以下语句创建：

![066-5](../Images/image04015.jpeg)

这个语句创建了一个新对象，该对象的`tag`字段被设为`Tag.TRUE，lexeme`字段被设为字符串“`true`”。

用于词法分析的类`Lexer`显示在图2-34和图2-35中。第4行上的整型变量`line`用于对输入行计数，第5行上的字符变量`peek`用于存放下一个输入字符。

保留字在第6行到第11行处理。第6行声明了表`words`。第7行上的辅助函数`reserve`将一个字符串-字对放入这个表中。构造函数`Lexer`中的第9行和第10行初始化这个表。它们使用构造函数`Word`来创建字对象，这些对象被传递到辅助函数`reserve`。因此，在第一次调用`scan`之前，这个表被初始化，并且预先加入了保留字“true”和“false”。

在图2-34和图2-35中，scan的代码实现了本节中的各个伪代码片段。从第13行到第17行的for语句跳过了空格、制表符和换行符。当`peek`的值不是空白符时，控制流离开for循环。

![067-1](../Images/image04016.jpeg)

图2-34　词法分析器的代码（第1部分）

![067-2](../Images/image04017.jpeg)

图2-35　词法分析器的代码（第2部分）

第18行到第25行的代码读取一个数位序列。函数`isDigit`来自于Java的内置类`Character`。它在第18行上用于检查`peek`是否为一个数位。如是，第19行到第24行的代码就会累积计算输入中的数位序列对应的整数值，然后返回一个新的`Num`对象。

第26行到第38行分析了保留字和标识符。关键字true和false已经在第9行和第10行被保留了。因此，如果字符串`s`不是保留字，则程序就会执行第35行，此时`s`一定是某个标识符的词素。因此第35行返回一个新的`word`对象，该对象的`lexeme`字段被设为`s`，`tag`字段被设为`Tag.ID`。最后，第39行到第41行将当前字符作为一个词法单元返回，并把`peek`设为一个空格。当下一次调用`scan`时，这个空格会被删除。
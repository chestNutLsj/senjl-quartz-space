### 5.5.1　在递归下降语法分析过程中进行翻译

4.4.1节讨论过，一个递归下降的语法分析器对每个非终结符号A都有一个函数A。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：

1）函数A的参数是非终结符号A的继承属性。

2）函数A的返回值是非终结符号A的综合属性的集合。

在函数A的函数体中，我们要进行语法分析并处理属性：

1）决定用哪一个产生式来展开A。

2）当需要读入一个终结符号时，在输入中检查这些符号是否出现。我们假设分析过程不需要进行回溯，但是只要在出现语法错误时恢复输入位置，就可以把这个方法扩展到带回溯的递归下降语法分析技术，见4.4.1节中的讨论。

3）在局部变量中保存所有必要的属性值，这些值将用于计算产生式体中非终结符号的继承属性，或产生式头部的非终结符号的综合属性。

4）调用对应于被选定产生式体中的非终结符号的函数，向它们提供正确的参数。因为基础的SDD是L属性的，所以我们必然已经计算出了这些属性并且把它们存放到了局部变量中。

例5.20　让我们考虑例5.19中while语句的SDD和SDT。图5-29显示了函数S的相关部分的伪代码说明。

我们显示的这个函数S需要存储并返回很长的字符串。在实践中，更有效率的做法是让像S和C这样的函数返回一个指针，指向表示这些字符串的记录。那么，函数S中的返回语句将不会真的把各个组成部分连接起来，而是构造出一个记录或记录树。这个记录或记录树表示了将Scode、Ccode、标号L1和L2以及文字串“`label`”的两次出现全部连接起来而得到的串。

![232-1](../Images/image04357.jpeg)

图5-29　用一个递归下降语法分析器实现while语句的翻译

例5.21　现在我们将处理图5-26中用于方框排版的SDT。我们首先处理语法分析问题，因为图5-26中的基础文法是二义性的。下面经过转换的文法使得并列运算和下标运算都是右结合的，而sub的优先级高于并列：

![233-1](../Images/image04358.jpeg)

引入两个非终结符号T和F的灵感来自于表达式中的项和因子。这里，由F生成的一个“因子”要么是一个括号中的方框，要么是一个文本串。由T生成的一个“项”是一个带有一系列下标的“因子”，而由B生成的一个方框是一个并列的“项”的序列。

T和F的属性和B的属性一样，因为新的非终结符号也表示方框。引入它们的目的仅仅是为了帮助进行语法分析。因此，T和F都有一个继承属性ps和综合属性ht及dp。它们的语义动作可以从图5-26的SDT中修改得到。

这个文法还不可以直接进行自顶向下的语法分析，因为B、T的产生式都有相同的前缀。比如，考虑T。一个自顶向下的语法分析器不能仅在输入中向前看一个符号就在T的两个产生式间做出决定。幸运的是，我们可以使用4.3.4节中讨论的提取左公因子的方法，使得这个文法可以进行自顶向下语法分析。处理SDT时，公共前缀的概念也被应用到语义动作中。T的两个产生式都以非终结符号F开头，这个符号从T中继承了属性ps。

图5-30中T（ps）的伪代码中加入了F（ps）的代码。对产生式T→F sub T1 | F应用提取左公因子的操作之后，只需要对F调用一次。这个伪代码显示了将该次调用替换为F的代码之后的结果。

![233-2](../Images/image04359.jpeg)

图5-30　递归下降的方框排板

B的函数以T（10.0）的方式调用函数T，我们没有在这里显示这个调用。该次调用返回一个二元组，包括由非终结符号T生成的方框的高度和深度。在实践中，它将返回一个包含高度和深度的记录。

函数T首先检查输入是否为左括号。如果是，它就必须处理产生式F→（B）。它保存了括号中B返回的任何值，但是如果B后面没有跟着一个右括号，那么就存在语法错误。处理这个语法错误的方式没有在这里显示。

否则，如果当前的输入是text，那么函数T使用getHt和getDp来确定这个文本的高度和深度。

然后，函数T确定下一个方框是否为一个下标，如果是就调整point size。我们使用和图5-26的产生式B→B sub B关联的语义动作来处理较大方框的高度和深度。否则，我们直接返回F所返回的值：（h1，d1）。
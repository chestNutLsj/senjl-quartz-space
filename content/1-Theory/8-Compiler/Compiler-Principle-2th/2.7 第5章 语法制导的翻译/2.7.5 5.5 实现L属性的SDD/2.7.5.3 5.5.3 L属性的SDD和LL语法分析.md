### 5.5.3　L属性的SDD和LL语法分析

假设一个L属性SDD的基础文法是一个LL文法，并且我们已经按照5.4.5节中描述的方法把它转换成一个SDT，其语义动作被嵌入到各个产生式中。然后，我们就可以在LL语法分析过程中完成翻译过程，其中的语法分析栈需要进行扩展，以存放语义动作和属性求值所需的某些数据项。一般来说，这些数据项是属性值的拷贝。

除了那些代表终结符号和非终结符号的记录之外，语法分析栈中还将保存动作记录（action-record）和综合记录（synthesize-record），其中动作记录表示即将被执行的语义动作，而综合记录保存非终结符号的综合属性值。我们使用下列两个原则来管理栈中的属性：

- 非终结符号A的继承属性放在表示这个非终结符号的栈记录中。对这些属性求值的代码通常使用紧靠在A的栈记录之上的动作记录来表示。实际上，从L属性的SDD到SDT的转换方法保证了动作记录将紧靠在A的上面。
- 非终结符号A的综合属性放在一个单独的综合记录中，它在栈中紧靠在A的记录之下。

这个策略在语法分析栈中放置了多种类型的记录，这些不同的记录类型将被当作“栈记录”的子类进行正确管理。在实践中，我们可能把几个记录组合成一个记录，但是如果要解释这个方法的基本思想，最好还是把用于不同目的的数据分别存放在不同的记录中。

动作记录包含指向将被执行的动作代码的指针。动作也可能出现在综合记录中，这些动作通常把其他记录中的综合属性拷贝到栈中更低的位置上。在这个综合属性所在的记录被弹出栈之后，语法分析程序需要在这个较低的位置上找到该属性的值。

我们简单地看一下LL语法分析技术，以了解为什么需要建立属性的临时拷贝。根据4.4.4节的介绍可知，一个通过分析表驱动的LL语法分析器模拟了一个最左推导过程。如果w是至今为止已经匹配完成的输入，那么栈中就包含了一个文法符号序列α，使得![236-1](../Images/image04362.jpeg)，其中S是开始符号。当语法分析器按照一个产生式A→B C展开的时候，它把栈顶的A替换为B C。

假设非终结符号C有一个继承属性C.i。对于产生式A→B C，继承属性C.i可能不仅仅依赖于A的继承属性，还可能依赖于B的所有属性。因此，我们可能需要在计算C.i之前完成对B的处理。因此，我们需要计算C.i所需的所有属性值的临时拷贝存放到计算C.i的动作记录中。否则，当语法分析器把栈顶的A替换为BC的时候，A的继承属性就和它的栈记录一起消失了。

因为基础SDD是L属性的，我们可以肯定当A位于栈顶时，A的继承属性的值是可用的。因此当需要把这些值拷贝到对C的继承属性求值的动作记录中时，这些值也是可用的。不仅如此，用于存放A的综合属性的空间也不成问题，因为这个空间位于A的综合记录中，而这个记录在语法分析器使用A→B C进行展开时还保持在分析栈中（位于B和C之下）。

当处理B时，如果需要，我们可以（通过栈中紧靠在B之上的一个记录）执行一个动作，将它的继承属性拷贝给C使用。在处理完B之后，如果需要，B的综合记录也可以拷贝它的综合属性供C使用。类似地，也可能需要一些临时变量来计算A的综合属性的值。这些值可以在先后处理B和C的时候被拷贝到A的综合记录中。所有这些属性的拷贝工作能够正确进行的原理是：

- 所有拷贝都发生在对某个非终结符号的一次展开时创建的不同记录之间。因此，这些记录中的每一个都知道其他各个记录在栈中离它有多远，因此可以安全地把值写到它下面的记录中。

下一个例子说明了通过不断地拷贝属性值，在LL语法分析过程中实现继承属性的方法。有可能存在一些捷径或者优化方法，对于那些只把一个属性值拷贝到另一个属性值的拷贝规则而言更是如此。我们要到例5.24中再说明这个问题，该例子还演示了对综合记录的处理方法。

例5.23　这个例子实现了图5-32中的SDT，该SDT边扫描边为while语句生成代码。这个SDT中除了表示标号的哑属性之外，没有综合属性。

图5-33a显示了我们即将使用while产生式来展开S的情况。这里假设我们已经知道输入的向前看符号就是while。栈顶的记录对应于S，它只包含继承属性S.next。我们假设这个属性的值为x。因为我们现在以自顶向下方式进行语法分析，所以按照惯例把栈顶显示在左边。

![236-2](../Images/image04363.jpeg)

图5-33　根据while语句的产生式扩展S

图5-33b显示了我们展开S之后的情况。在非终结符号C和S1之前存在动作记录，它们对应于图5-32中的基础SDT的语义动作。C的记录包含了存放继承属性true和false的字段，而S1的记录包含了存放属性next的字段。所有的S记录都必须包含这个字段。我们将这些字段的值显示为？，因为我们现在还不知道它们的值。

接下来，语法分析器识别了输入中的while和（，并将它们的记录弹出栈。现在，第一个动作位于栈顶，因此必须执行这个动作。这个动作记录有一个字段snext，该字段存放了继承属性S.next的一个拷贝。当S被弹出栈的时候，S.next的值被拷贝到字段snext中。在求C的继承属性值的时候将用到这个字段。第一个动作的代码生成了L1和L2的新值，我们分别将这两个值假设为y和z。下一步是令C.true的值等于z。我们把这个赋值语句写作stack［top-1］.true = L2是因为只有当这个动作记录位于栈顶时这个语句才会被执行，因此top-1指向它下面的记录，即C的记录。

第一个动作记录将L1拷贝到第二个动作记录的al1字段中，在该处它将用于S1.next的求值。它也会将L2拷贝到第二个动作记录中的al2字段中，第二个动作需要这个值来正确打印输出。最后，第一个动作记录将`label y`打印到输出设备。

完成了第一个动作并将它的记录弹出栈之后的情形显示在图5-34中。在C的记录中的继承属性值都已经正确填写好，同时第二个动作记录中的临时变量al1和al2也已经填写好。此时C被展开，我们假设实现条件表达式C的包含了正确跳转到x和z的指令的代码已经生成。当C的记录被弹出栈时，）的记录变成了栈顶，使得语法分析器检查输入中的）。

![237-1](../Images/image04364.jpeg)

图5-34　C之上的动作被执行之后

当S1之上的动作位于栈顶时，它的代码设置S1.next，并打印出`label` z。上述工作完成之后，S1的记录成为栈顶。随着S1被展开，假设它正确地生成了S1的代码。不管S1是什么类型的语句，生成的代码正确地实现了这个语句，随后跳转到y。

例5.24　现在让我们考虑同样的while语句，但是翻译方法把输出S.code作为一个综合属性，而不是通过边扫描边处理的方式生成。记住下面的不变式，或者说归纳假设，有助于理解接下来的解释。我们假设这些假设适用于每个非终结符号：

- 每个具有代码的非终结符号都把它的（字符串形式的）代码存放在栈中该符号的记录下方的综合记录中。

假设这个结论为真，我们处理while产生式时，将使它在处理完成后仍然成立，成为一个不变式。

图5-35a显示了使用while语句的产生式展开S之前的情形。我们在栈顶看到的是S的记录。和例5.23中一样，它有一个存放继承属性S.next的字段。紧靠在这个记录之下是S的本次出现的综合记录，它有一个存放S.code的字段。每个S的综合记录都包含这个字段。我们还显示了其他一些用于局部存储和动作的字段，因为图5-28中while产生式的SDT实际上是一个更大的SDT的一部分。

我们对S的展开是基于图5-28中的SDT的，展开的情形显示在图5-35b中。作为一种捷径，我们假设在展开过程中继承属性S.next被直接赋给C.false，而不是先放到第一个动作中，然后再拷贝到C的记录中。

![238-1](../Images/image04365.jpeg)

图5-35　栈中构造的具有综合属性的S的扩展

我们看一下各个记录在变成栈顶的时候会做哪些事情。首先，while记录使得词法单元while和输入匹配。这是一定会匹配的，否则我们就不会用这个产生式来展开S。在while和（被弹出栈之后，执行动作记录中的代码。它生成了L1和L2的值，我们通过捷径直接把它们拷贝到需要它们的继承属性中，即S1.next和C.true中。这个动作的最后两个步骤把L1和L2拷贝到被称为“Synthesize S1.code”的记录中。

S1的综合记录有两个任务：它不仅仅要保存综合属性S1.code，它还要作为一个动作记录对整个产生式S→while（C）S1的属性求值。特别是，当它到达栈顶时，它将计算综合属性S.code，并将这个值放到产生式头S的综合记录中。

当C成为栈顶的时候，它的两个继承属性都已经计算完成。根据上面给出的归纳假设，我们假设它正确地生成了代码，该代码执行了它的条件判断并跳转到正确的标号。我们同时假设在展开C时执行的动作正确地把这个代码放在了栈中下面的记录中，作为综合属性C.code的值。

在C被弹出栈后，C.code的综合记录成为栈顶。它的代码要在S1.code的综合记录中使用，因为我们要在那里把所有的代码元素连接起来得到S.code。因此，C.code的综合记录中有一个语义动作把C.code拷贝到S1.code的综合记录中。完成上述工作之后，词法单元）的记录到达栈顶，使得语法分析器检查输入中的）。假设这个测试成功，S1的记录变成栈顶。根据我们的归纳假设，这个非终结符号被展开。这次展开的最终效果是它的代码被正确构造出来，并被放到S1的综合记录中存放code的字段中。

现在，S1的综合记录的所有数据字段都已经填充完毕，因此当它变成栈顶时，该记录中的动作就可以被执行。这个动作使得标号和来自C.code和S1.code的代码按照正确的顺序被连接到一起。得到的串放在栈中下面的记录中，也就是S的综合记录中。我们现在已经正确地计算出了S.code，并且当S的综合记录变成栈顶时，该代码可以被放置到栈中更低层的另一个记录中，在那里它最终会被组装到一个更大的代码串中，用于实现了包含这个S的更大的程序元素。

我们可以处理LR文法上的L属性SDD吗？

在5.4.1节中，我们看到在LR文法上的每个S属性SDD都可以在自底向上语法分析过程中实现。根据5.3.5节，LL文法上的每个L属性都可以在自顶向下语法分析中实现。因为LL文法类是LR文法类的一个真子集，并且S属性SDD类是L属性SDD类的一个真子集，那么我们能否以自底向上的方式处理每个LR文法和每个L属性SDD呢？

如下面的直观论述指出的，我们不能这么做。假设我们有一个LR文法的产生式A→BC，并且有一个继承属性B.i，它依赖于A的继承属性。当我们规约到B的时候，我们还没有看到由C生成的输入，因此不能确定会扫描到产生式A→BC的体。因此，我们在此时还不能计算B.i，因为我们不能确定是否使用和这个产生式相关联的规则。

也许我们可以等到已经归约得到C，并且知道必须把BC归约到A时才进行计算。然而，即使到那个时候，我们仍然不知道A的继承属性，因为即使在归约之后，我们仍然不能确定包含这个A的是哪个产生式的体。我们可以说这个决定也应该推迟，因此也需要将B.i的计算进一步推迟。如果我们继续这样推迟，我们很快会发现必须把所有的决定推迟到对整个输入的语法分析完成之后再进行。实质上，这就是“先构造语法分析树，再执行翻译”的策略。
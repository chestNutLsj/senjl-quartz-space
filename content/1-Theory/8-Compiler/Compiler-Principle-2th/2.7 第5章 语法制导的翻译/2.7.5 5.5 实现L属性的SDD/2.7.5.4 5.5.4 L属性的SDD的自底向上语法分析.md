### 5.5.4　L属性的SDD的自底向上语法分析

我们可以使用自底向上的方法来完成任何可以用自顶向下方式完成的翻译过程。更准确地说，给定一个以LL文法为基础的L属性SDD，我们可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD。这个“技巧”包括三个部分：

1）以按照5.4.5节中的方法构造得到的SDT为起点。这样的SDT在各个非终结符号之前放置语义动作来计算它的继承属性，并且在产生式后端放置一个动作来计算综合属性。

2）对每个内嵌的语义动作，向这个文法中引入一个标记非终结符号来替换它。每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式M→∈。

3）如果标记非终结符号M在某个产生式A→α{a}β中替换了语义动作a，对a进行修改得到a’，并且将a’关联到M→∈上。这个动作a’

① 将动作a需要的A或α中符号的任何属性作为M的继承属性进行拷贝。

② 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性。

这个变换看起来是非法的，因为通常和产生式M→∈相关的动作将不得不访问某些没有出现在这个产生式中的文法符号的属性。然而，我们将在LR语法分析栈上实现各个语义动作。因此必要的属性总是可用的，它们位于栈顶之下的已知位置上。

例5.25　假设一个LL文法中存在一个产生式A→B C，而继承属性B.i是根据继承属性A.i按照某个公式B.i=f（A.i）计算得到的。也就是说，我们关心的SDT片段是

![239-1](../Images/image04366.jpeg)

我们引入标记M，M有继承属性M.i和综合属性M.s。前者是A.i的一个拷贝，而后者将成为B.i。这个SDT将被写作

![239-2](../Images/image04367.jpeg)

请注意，M的规则中不可以使用A.i，但是实际上我们将设法安排分析栈，使得如果即将进行一个到A的归约，那么A的每个继承属性都将出现在栈中执行这个归约的位置下方，从该处就可以读到这些继承属性。因此，当我们将∈归约为M时，我们直接在它的下方找到A.i，在那里读取到它的值。另外，M.s的值和M一起存放在栈中，它实际上是B.i，以后在进行到B的归约时可以在下方找到这个值。

为什么标记能够正确工作？

标记是只能推导出∈的非终结符号，每个标记在所有产生式体中只出现一次。我们将正式证明如果一个文法是LL的，那么标记非终结符号可以被插入到产生式体中的任何位置，并且结果文法是LR的。如果文法是LL的，那么我们只需要看输入符号串w的第一个符号（如果w为空则是下一个符号），就可以确定w是否可以从A开始，经过一个以产生式A→α开头的推导序列得到。因此，如果我们用自底向上的方式对w进行语法分析，那么只要w的开头出现在输入中，我们就可以确定w的一个前缀首先必须被归约成为α，然后再归约到S。特别是，如果我们在α的任何位置插入标记，相应的LR状态将隐含地表明这个标记必定存在，并将在输入的正确位置上把∈归约为标记。

例5.26　本例中我们把图5-28的SDT修改成基于经过修改的LR文法的SDT，新的SDT可以和LR语法分析器一起完成翻译。我们在C之前引入标记M，在S1之前引入标记N，因此基础文法变成

![240-1](../Images/image04368.jpeg)

在我们讨论标记M及N的关联动作之前，先给出有关属性存放位置的“归纳假设”。

1）在while产生式的整个产生式体之下（就是说在栈中的while之下）将是继承属性S.next。我们可能不知道这个栈记录与哪个非终结符号或语法分析器状态相关，但是我们肯定该记录有一个字段存放了S.next。这个字段位于该记录中的固定位置上，并且在我们知道S推导出什么短语之前就已经计算得到了S.next。

2）继承属性C.true和C.false将紧靠在C的栈记录的下方。因为假设这个文法是LL的，输入中出现的while告诉我们while产生式是唯一可能被识别的产生式，因此我们可以肯定M将出现在栈中紧靠C的下方，而M的记录将保存C的这些继承属性。

3）类似地，继承属性S1.next必定出现在栈中紧靠S1的下方，因此我们把该属性放在N的记录中。

4）综合属性C.code将出现在C的记录中。我们期望在实践中这个记录中出现的是一个指向这个字符串（对象）的指针，而该字符串本身位于栈外。当有一个属性的值是很长的字符串时，我们总是这样处理。

5）类似地，综合属性S1.code将出现在S1的记录中。

现在我们跟踪一个while语句的语法分析过程。假设一个保存S.next的记录出现在栈顶，并且下一个输入是终结符号while。我们把这个终结符号移入栈中。此时识别出的产生式肯定是while产生式，因此LR语法分析器可以移入“（”并确定下一步把∈归约为M。此时的栈显示在图5-36中。我们同时还在该图中显示了和M的归约相关联的动作。我们创建出L1和L2的值，它们被存放在M的记录的域中。同处这个记录还有C.true和C.false的域。这些属性必定在这个记录的第二和第三个域中。这是为了和可能在不同上下文中出现于C之下，且需要为C提供这些属性的其他栈记录保持一致。这个动作最后把两个值赋给C.true和C.false。其中的第一个值来自于刚刚生成的L2，另一个则从栈下方存放S.next的地方获取。

![241-1](../Images/image04369.jpeg)

图5-36　在将∈归约为M之后的LR语法分析栈

我们假设后面的输入被正确地归约为C。因此，综合属性C.code存放在C的记录中。这一次对栈的改变显示在图5-37中。该图还显示了接下来将被放到栈中的多个记录，它们将被放到C的记录之上。

![241-2](../Images/image04370.jpeg)

图5-37　即将把while产生式的体归约为S之前的栈

继续识别while语句，语法分析器下一步将在输入中发现“）”，把它放在该符号自己的记录中，并压入栈中。因为文法是LL的，因此语法分析器在该点上已经知道它在处理一个while语句。语法分析器将把∈归约为N。和N相关联的唯一数据是继承属性S1.next。请注意，需要将这个属性存放在此记录中的原因是这个记录将恰好位于S1的记录之下。计算S1.next的值的代码是

![241-3](../Images/image04371.jpeg)

这个动作从N之下三个记录的地方获取了L1的值。当这个代码执行的时候，N的记录位于栈顶。

接下来，语法分析器将其余输入的某个前缀归约成为S。我们一直把它称为S1，以便和产生式头的S区分开。S1.code的值计算完成并放在S1的栈记录中。这个步骤对应于图5-37所示的情形。

此时，语法分析器将把从while到S1的全部内容归约为S。在这一次归约中，执行的代码是：

![241-4](../Images/image04372.jpeg)

也就是说，我们在变量tempCode中构造出S.code的值。该代码也是由两个标号L1和L2、C的代码和S1的代码组成。这个栈执行了一些弹出操作，因此S出现在while原来出现的地方。S的代码值存放在该记录的code字段中。它在那里被解释为综合属性S.code。请注意，我们在这次讨论中没有显示对LR状态的操作，实际上这些状态必须出现在栈中，其所在的字段就是存放文法符号的字段。
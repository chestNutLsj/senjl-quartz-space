### 5.2.5　具有受控副作用的语义规则

在实践中，翻译过程会出现一些副作用：一个桌上计算器可能打印出一个结果；一个代码生成器可能把一个标识符的类型加入到符号表中。对于SDD，我们在属性文法和翻译方案之间找到了一个平衡点。属性文法没有副作用，并支持任何与依赖图一致的求值顺序。翻译方案要求按从左到右的顺序求值，并允许语义动作包含任何程序片段。翻译方案将在5.4节中讨论。

我们将按照下面的方法之一来控制SDD中的副作用：

- 支持那些不会对属性求值产生约束的附带副作用。换句话说，如果按照依赖图的任何拓扑顺序进行属性求值时都可以产生“正确的”翻译结果，我们就允许副作用存在。这里的“正确”要视具体应用而定。
- 对允许的求值顺序添加约束，使得以任何允许的顺序求值都会产生相同的翻译结果。这些约束可以被看作隐含加入到依赖图中的边。

作为附带副作用的一个例子，让我们修改例5.1的桌上计算器，使它打印出计算结果。我们不使用规则L.val = E.val，这个规则将结果保存到综合属性L.val中。我们考虑：

![216-4](../Images/image04320.jpeg)

像print（E.val）这样的语义规则的目的就是执行它们的副作用。它们将会被看作与相应产生式头相关的哑综合属性的定义。这个经过修改的SDD在任何拓扑顺序下都能产生相同的值，因为这个打印语句在结果被计算到E.val中之后才会被执行。

例5.10　图5-8中的SDD处理了简单的声明D。该声明中包含一个基本类型T，后跟一个标识符列表L。T的类型可以是int或float。对于列表中的每个标识符，这个类型被录入到标识符的符号表条目中。我们假设录入一个标识符的类型不会影响其他标识符对应的符号表条目。这样，这些条目可以按照任何顺序进行更新。这个SDD不会检查一个标识符是否被声明了多次，我们也可以修改这个SDD，使它能够对标识符声明次数进行检查。

![217-1](../Images/image04321.jpeg)

图5-8　简单类型声明的语法制导定义

非终结符号D表示了一个声明。根据产生式1可知，这个声明包含一个类型T，后跟一个标识符的列表。T有一个属性T.type，它是声明D中的类型。非终结符号L也有一个属性，我们称它为inh，以强调它是一个继承属性。L.inh的作用是将声明的类型沿着标识符列表向下传递，使得它可以被加入到相应的符号表条目中。

产生式2和产生式3都计算综合属性T.type，为它赋予正确的值：integer或float。这个类型值在产生式1的规则中被传递给属性L.inh。产生式4将L.inh沿着语法分析树向下传递。也就是说，在一个分析树结点上，值L1.inh是通过拷贝该结点的父结点的L.inh值而得到的，这个父结点对应于此产生式的头。

产生式4和产生式5还包含另一个规则。该规则用如下两个参数调用函数addType：

- id.entry：在词法分析过程中得到的一个指向某个符号表对象的值。
- L.inh：被赋给列表中各个标识符的类型值。

我们假设函数addType正确地将id所代表的标识符的类型设置为类型值L.inh。

输入串float id1，id2，id3的依赖图如图5-9所示。数字1～10表示了这个依赖图中的结点。结点1、2和3表示了和各个标号为id的叶子结点相关的属性entry。结点6、8和10是表示函数addType的应用于一个类型和这些entry值之一的哑属性。

![217-2](../Images/image04322.jpeg)

图5-9　声明float id1，id2，id3的依赖图

结点4表示属性T.type，它实际上是属性求值过程开始的地方。然后，这个类型被传递到结点5、7和9。这些结点表示和非终结符号L的各次出现相关的L.inh。
### 5.4.3　产生式内部带有语义动作的SDT

动作可以放置在产生式体中的任何位置上。当一个动作左边的所有符号都被处理过后，该动作立刻执行。因此，如果我们有一个产生式B→X{a}Y，那么当我们识别到X（如果X是终结符号）或者所有从X推导出的终结符号（如果X是非终结符号）之后，动作a就会执行。更准确地讲，

- 如果语法分析过程是自底向上的，那么我们在X的此次出现位于语法分析栈的栈顶时，我们立刻执行动作a。
- 如果语法分析过程是自顶向下的，那么我们在试图展开Y的本次出现（如果Y是非终结符号）或者在输入中检测Y（如果Y是终结符号）之前执行语义动作a。

可以在语法分析过程中实现的SDT包括后缀SDT和即将在5.5节中讨论的一类SDT，这类SDT实现了L属性定义。不是所有的SDT都可以在语法分析过程中实现，下面我们就给出一个例子。

例5.16　作为一个有问题的SDT的极端例子，假设我们将桌上计算器的例子改成一个可以打印输入表达式的前缀表示方式的SDT，而不再对表达式进行求值。新SDT的产生式和动作显示在图5-21中。

![224-2](../Images/image04337.jpeg)

图5-21　在语法分析过程中完成中缀到前缀翻译的有问题的SDT

遗憾的是，不可能在自顶向下或自底向上的语法分析过程中实现这个SDT，因为语法分析程序必须在它还不知道出现在输入中的运算符号是*还是+的时候，就执行打印这些符号的操作。

在产生式2和4中分别使用标记非终结符号M2和M4来替代相应的动作，一个移入-归约语法分析器（见4.5.3节）在处理输入digit（比如3）的时候会因为不能确定是使用M2→∈归约，使用M4→∈归约，还是移入输入数字而产生一个冲突。

任何SDT都可以按照下列方法实现：

1）忽略语义动作，对输入进行语法分析，并产生一棵语法分析树。

2）然后检查每个内部结点N，假设它的产生式是A→α。将α中的各个动作当作N的附加子结点加入，使得N的子结点从左到右和α中的符号及动作完全一致。

3）对这棵语法树进行前序遍历（见2.3.4节），并且当访问到一个以某个动作为标号的结点时立刻执行这个动作。

比如，图5-22显示了带有插入动作的表达式3*5+4的语法分析树。如果我们按照前序次序来访问结点，我们就得到了这个表达式的前缀形式：+*354。

![225-1](../Images/image04338.jpeg)

图5-22　嵌入了动作的语法分析树
### 5.4.5　L属性定义的SDT

在5.4.1节，我们将S属性的SDD转换成为后缀SDT，它的动作位于产生式的右端。只要基础文法是LR的，后缀SDT就可以按照自底向上的方式进行语法分析和翻译。

现在，我们考虑更加一般化的情况，即L属性的SDD。我们假设基础文法将以自顶向下的方式进行语法分析，因为如果不是这样，那么翻译过程常常无法和一个LL或LR语法分析器一起完成。对于任何文法，我们只需要将动作附加到一棵语法分析树中，并在对这棵树进行前序遍历时执行这些动作，便可以实现下面的技术。

将一个L属性的SDD转换为一个SDT的规则如下：

1）把计算某个非终结符号A的继承属性的动作插入到产生式体中紧靠在A的本次出现之前的位置上。如果A的多个继承属性以无环的方式相互依赖，就需要对这些属性的求值动作进行排序，以便先计算需要的属性。

2）将计算一个产生式头的综合属性的动作放置在这个产生式体的最右端。

我们将使用两个例子来说明这些原则。第一个例子是关于排版的。它说明了如何将编译技术应用于其他的语言处理应用，编译技术的应用范围并不限于我们通常认为的程序设计语言。第二个例子是关于一个典型程序设计语言构造的中间代码生成的，这个构造是某种形式的while语句。

例5.18　这个例子来自于数学公式排版语言。Eqn是这种语言的早期例子，来自Eqn的思想仍然可以在Tex排版系统中找到，本书就是用Tex排版系统排版的。

我们将关注定义下标、下标的下标等排版能力，而忽略了上标、叠加的分数以及其他数学功能。在Eqn语言中，人们可以使用`a sub i sub j`来设定表达式![227-2](../Images/image04348.jpeg)。一个简单的boxes（即由一个方框括起来的文本元素）的文法是：

B→B1B2｜B1subB2｜（B1）｜text

对应于这四个产生式，一个方框可以是下列之一：

1）两个并列的方框，其中第一个方框B1在另一个方框B2的左边。

2）一个方框和一个下标方框。第二个方框的尺寸较小且位置较低，位于第一个方框的右边。

3）一个用括号括起来的方框，用于方框和下标的分组。Eqn和Tex都使用花括号进行分组，但是我们将使用通常的圆括号来分组，以避免和SDT动作两边的括号混淆。

4）一个文本串，也就是任何字符串。

这个文法是二义性的，但是如果我们令下标和并列关系都是右结合的，并且令sub的优先级高于并列，那么我们仍然可以使用它来完成自底向上的语法分析。

表达式的排版过程就是由较小的方框构造出较大的方框的过程。在图5-24中，E1的方框和.height将被并列放置形成方框E1.height。而E1的左边方框本身又是从E的方框和下标1的方框构造得到的。下标1的处理方法是将它的方框缩小大约30%，并放在较低的位置上，然后把它放在E的方框之后。虽然我们将把.height作为一个文本串进行处理，但它的方框中的长方形会说明它是如何从各个字母对应的方框构造得到的。

![228-1](../Images/image04349.jpeg)

图5-24　从较小的方框构造较大的方框

在这个例子中，我们只考虑这些方框的垂直方向的几何性质。水平方向的几何性质，即方框的宽度，也很有意思，当不同字符具有不同宽度时更是如此。可能看起来不是那么明显，但是图5-24中的各个字符确实具有不同的宽度。

和这些方框的垂直方向几何性质相关的值如下：

1）字体大小（point size）。它被用于在一个方框中设置文本。我们将假设不在下标中的字符被设置为10点，也就是一般书籍的字体大小。进一步，我们假设如果一个方框的字体大小是p，那么它的下标方框的字体大小就是0.7p。继承属性B.ps表示块B的字体大小点数。这个属性必须是继承属性，因为一个给定的块的上下文决定了这个块在哪个下标层次，从而决定需要缩小多少。

2）每个方框有一个基线（baseline），它是对应于文本行的底部的垂直位置，它不考虑像g这样的伸展到正常基线之下的字符。在图5-24中，点虚线就表示了方框E、.height以及整个表达式的基线。包含了下标1的方框的基线经过了调整，以便把这个下标放在较低位置。

3）每个方框有一个高度（height），它是从方框顶部到方框基线的距离。综合属性B.ht给出了方框B的高度。

4）每个方框有一个深度（depth），它是从基线到达方框底部的距离。综合属性B.dp给出了方框B的深度。

图5-25中的SDD给出了计算字体大小、高度和深度的规则。产生式1的功能是把初始值10赋给B.ps。

![228-2](../Images/image04350.jpeg)

图5-25　方框排版的SDD

产生式2处理并列的情况。字体大小被沿着语法分析树向下拷贝，也就是说，一个方框的两个子方框从这个较大的方框中继承了同样的字体大小点数。高度和深度是沿着语法分析树向上计算的，总是取两者的最大值。也就是说，大方框的高度是它的两个组成部分的高度的最大值，深度也按照类似的方法计算。

产生式3处理下标，它是最复杂的。在这个简化了的例子中，我们假设一个下标方框的字体大小是它的父方框的大小的70%。实际情况会更加复杂，因为下标不可能无限缩小。在实践中，在几层下标之后，下标的大小就几乎不再缩小。另外我们还假设一个下标方框的基线向下移动了父方框的字体点数大小的25%，同样，实际情况要更加复杂。

产生式4在使用括号的时候正确地拷贝各个属性。最后，产生式5处理表示文本方框的叶子结点。在这里，实际情况也是很复杂的，因此我们只显示了两个未定义的函数getHt和getDp。它们检查各个字体的表格，以确定文本串中的全部字符的最大高度和最大深度。我们假设这个文本串中的字符是由终结符号text的属性lexval提供的。

最后一个任务是按照图5-25中处理L属性SDD的规则，将这个SDD转换为SDT。正确的SDT显示在图5-26中。因为产生式的体比较长，为了增加可读性，我们把它们分割到多行中，并把动作对齐排列。因此，产生式体包含了到下一个产生式的头为止的多行内容。

![229-1](../Images/image04351.jpeg)

图5-26　方框排版的SDT

我们的下一个例子是考虑一个简单的while语句，考虑如何为这种类型的语句生成中间代码。中间代码将被当作一个值为字符串的属性。稍后我们将探究一些高效的技术。这些技术在我们进行语法分析的时候顺序输出一个取值为字符串的属性的各个部分，从而避免了通过长字符串的拷贝来构造出更长的字符串。这个技术在例5.17中已经介绍过。在那个例子中，我们以“边扫描边生成”的方式生成了一个中缀表达式的后缀形式，而不是把表达式的后缀形式当作一个属性来计算。然而，在我们第一次表示中间代码生成时，我们通过字符串的连接来创建一个值为字符串的属性。

例5.19　在这个例子中，我们只需要一个产生式：

S→`while`（C）S1

这里，S是生成各种语句的非终结符号，我们假设这些语句包括if语句、赋值语句和其他类型的语句。在这个例子中，C表示一个条件表达式——一个值为真或假的布尔表达式。

在这个关于语句控制流的例子中，我们只需要生成多个标号。我们假设其他的中间代码指令都由这个SDT的未显示部分生成。更明确地讲，我们生成显式的形如label L的指令，其中L是一个标识符。这个指令表明后一条指令的标号是L。我们假设中间代码和2.8.4节中介绍的代码类似。

这个while语句的含义是首先对条件表达式C求值。如果它为真，控制就转向S1的代码的开始处。如果C的值为假，那么控制就转向跟在这个while语句的代码之后的代码。我们必须设计S1的代码，使得它在结束的时候能够跳转到这个while语句的代码的开始处。图5-27没有显示出跳转到对C求值的代码的开始处的指令。

我们使用下面的属性来生成正确的中间代码：

1）继承属性S.next是必须在S执行结束之后执行的代码的开始处的标号。

2）综合属性S.code是中间代码的序列，它实现了语句S，并在最后有一条跳转到S.next的指令。

3）继承属性C.true是必须在C为真时执行的代码的开始处的标号。

4）继承属性C.false是必须在C为假时执行的代码的开始处的标号。

5）综合属性C.code是一个中间代码的序列，它实现了条件表达式C，并根据C的值为真或假跳转到C.true或者C.false。

计算while语句的这些属性的SDD显示在图5-27中。有几个要点需要解释一下：

![230-1](../Images/image04352.jpeg)

图5-27　while语句的SDD

- 函数new生成了新的标号。
- 变量L1和L2存放了在代码中需要的标号。L1表示这个while语句的代码的开始处，我们必须安排S1在执行完毕之后跳转到这里。这就是我们把S1.next设置为L1的原因。L2是S1的代码的开始处，它变成了C.true的值，因为在C为真时会跳转到那里。
- 请注意C.false被设置为S.next，因为当条件为假时，就会执行S的代码之后的代码。
- 我们使用‖作为连接各个中间代码片段的符号。因此，S.code的值的以标号L1开始，然后是条件表达式C的代码，然后是另一个标号L2，然后是S1的代码。

这个SDD是L属性的。当我们把它转换为SDT时，还需要考虑如何处理标号L1和L2，它们是变量而不是属性。如果我们把语义动作当作哑非终结符号来处理，那么这样的变量可以当作哑非终结符号的综合属性来处理。因为L1和L2不依赖于其他属性，它们可以被分配到产生式的第一个语义动作中。实现这个L属性定义的带有内嵌语义动作的SDT显示在图5-28中。

![230-2](../Images/image04353.jpeg)

图5-28　while语句的SDT
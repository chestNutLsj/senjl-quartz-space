### 5.4.4　从SDT中消除左递归

因为带有左递归的文法不能按照自顶向下的方式确定地进行语法分析，所以在4.3.3节中介绍了左递归的消除。当文法是SDT的一部分时，我们还需要考虑如何处理其中的动作。

首先考虑简单的情况，即我们只需要关心一个SDT中的动作的执行顺序的情况。比如，如果每个动作只打印一个字符串，我们就只关心这些字符串的打印顺序。在这种情况下，可以应用下面的原则完成这个转化：

- 当转换文法的时候，将动作当成终结符号处理。

这个原则基于下面的思想：文法转换保持了由文法生成的符号串中终结符号的顺序。因此，这些动作在任何从左到右的语法分析过程中都按照相同的顺序执行，不管这个分析是自顶向下的还是自底向上的。

消除左递归的“技巧”是对两个产生式

![225-2](../Images/image04339.jpeg)

进行替换。这两个产生式生成的串包含一个β和任意数量的α。它们将被替换为下面的产生式。新的产生式使用了一个新非终结符号R（代表“其余部分”）来生成同样的串。

![225-3](../Images/image04340.jpeg)

如果β不以A开头，那么A就不再有左递归的产生式。按照正则定义的表示法，在两组产生式中A都被定义为β（α）*。在4.3.3节中可以看到如何处理A有多个递归或非递归产生式的情况。

例5.17　考虑下面的E产生式。它们来自一个将中缀表达式翻译成后缀表达式的SDT：

![225-4](../Images/image04341.jpeg)

如果我们对E应用标准的左递归消除转换，左递归产生式的余部为

![226-1](../Images/image04342.jpeg)

而β（即另一个产生式的体）是T。如果我们引入R来表示E的余部，我们就得到如下的产生式集合：

![226-2](../Images/image04343.jpeg)

当一个SDD的动作是计算属性的值，而不是仅仅是打印输出时，我们必须更加小心地考虑如何消除文法中的左递归。然而，如果这个SDD是S属性的，那么我们总是可以通过将计算属性值的动作放在新产生式中的适当位置上来构造出一个SDT。

我们将给出一个通用的解决方案，以解决只有单个递归产生式、单个非递归产生式并且该左递归非终结符号只有单个属性的情况。将这个方案推广到多个递归/非递归产生式的情况并不困难，但是写起来非常麻烦。假设这两个产生式是：

![226-3](../Images/image04344.jpeg)

这里A.a是左递归非终结符号A的综合属性，而X和Y是单个文法符号，分别有综合属性X.x和Y.y。因为这个方案在递归的产生式中用任意的函数g来计算A.a，而在第二个产生式中用任意函数f来计算A.a的值，所以这两个符号可以代表由多个文法符号组成的串，每个符号都有自己的属性。在每种情况下，f和g可以把它们能够访问的属性当作它们的参数，只要这个SDD是S属性的。

我们要把基础文法改成

![226-4](../Images/image04345.jpeg)

图5-23指出了在新文法上的SDT必须做的事情。在图5-23a中，我们看到的是原文法之上的后缀SDT的运行效果。我们将f应用一次，该次应用对应于产生式A→X的使用。然后我们应用函数g，应用的次数和我们使用产生式A→AY的次数一样。因为R生成了Y的一个余部，它的翻译依赖于它左边的串，即一个形如XYY…Y的串。对产生式R→YR的每次使用都导致对g的一次应用。对于R，我们使用一个继承属性R.i来累计从A.a的值开始不断应用g所得到的结果。

![226-5](../Images/image04346.jpeg)

图5-23　消除一个后缀SDT中的左递归

除此之外，R还有一个没有在图5-23中显示的综合属性R.s。当R不再生成文法符号Y时才开始计算这个属性的值，这个时间点是以产生式R→∈的使用为标志的。然后R.s沿着树向上拷贝，最后它就可以变成对应于整个表达式XYY…Y的A.a的值。从A生成XYY的情况显示在图5-23中，我们看到在图5-23a中的根结点上的A.a的值使用了两次g，而在图5-23b的底部的R.i也使用了两次g，而正是这个结点上的R.s的值被沿着树向上拷贝。

为了完成这个翻译，我们使用下列SDT：

![227-1](../Images/image04347.jpeg)

请注意，继承属性R.i在产生式体中R的一次使用之前完成求值，而综合属性A.a和R.s在产生式的结尾完成求值。因此，计算这些属性时需要的任何值都已经在左边计算完成，变成了可用的值。
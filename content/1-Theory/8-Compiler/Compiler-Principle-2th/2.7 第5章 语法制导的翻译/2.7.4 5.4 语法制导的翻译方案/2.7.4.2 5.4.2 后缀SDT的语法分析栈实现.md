### 5.4.2　后缀SDT的语法分析栈实现

后缀SDT可以在LR语法分析的过程中实现，当归约发生时执行相应的语义动作。各个文法符号的属性值可以放到栈中的某个位置，使得执行归约的时候可以找到它们。最好的方法是将属性和文法符号（或者表示文法符号的LR状态）一起放在栈中的记录里。

在图5-19中，语法分析栈包含的记录中有一个字段，该字段用于存放文法符号（或语法分析器的状态），并且在这个字段之下有一个字段用于存放属性。三个文法符号X Y Z位于栈的顶部，可能它们即将按照一个产生式，比如A→X Y Z，进行归约。这里，我们用X.x表示X的一个属性，等等。一般来说，我们可以支持多个属性，方法是使记录变得足够大，或者在栈中的记录里放上指针。对于小型的属性，将记录变得足够大可能是比较简单的方法，即使有些时候有些字段不会被用到也没有太大关系。然而，如果一个或多个属性的大小没有限制，比如它们是字符串，那么最好把一个指针放到栈记录的属性值中，并把实际的值存放在栈之外的某个比较大的共享存储区域中。

![223-2](../Images/image04335.jpeg)

图5-19　带有用于存放综合属性的字段的语法分析栈

如果所有属性都是综合属性，并且所有动作都位于产生式的末端，那么我们可以在把产生式体归约成产生式头的时候计算各个属性的值。如果我们使用A→XYZ这样的产生式进行归约，那么此时X、Y和Z的所有属性值都是可用的，并且都位于已知的位置上，如图5-19所示。在这个动作之后，A和它的属性都位于栈的顶端，即现在存放X的记录的位置上。

例5.15　让我们重写例5.14中桌上计算器SDT中的动作，使它们显式地操作语法分析栈。这样的栈操作通常是由语法分析器自动完成的。

假设语法分析栈存放在一个被称为stack的记录数组中，而top是指向栈顶的游标。这样，stack［top］指向这个栈的栈顶记录，stack［top-1］指向栈顶记录的下一个记录，依此类推。我们还假设每个记录有一个被称为val的字段，该字段存放了这个记录所代表的文法符号的属性值。这样，我们可以使用stack［top-2］.val来指向出现在栈中第三个位置上的属性E.val。完整的SDT显示在图5-20中。

![224-1](../Images/image04336.jpeg)

图5-20　在一个自底向上语法分析栈中实现桌上计算器

比如，在第二个产生式E→E1+T中，我们在栈顶之下两个位置上找到E1的值，在栈顶找到T的值。求和的结果放在归约之后产生式头E将出现的位置上，也就是当前栈顶之下两个位置处。这是因为在归约之后，最上面的三个符号将被替换为一个符号。在计算完E.val之后，我们将两个符号弹出栈，现在我们放置E.val的记录将变成栈顶。

在第三个产生式E→T中不需要任何语义动作，因为栈的长度没有改变，栈顶的T.val值直接变成了E.val的值。产生式T→F和F→digit的情况与此类似。产生式F→（E）稍有不同。虽然值没有改变，但是在归约过程中消除了栈中的两个位置，因此这个值必须移动到归约之后的位置上。

请注意，我们省略了针对栈中记录的第一个字段的操作步骤。这个字段保存了LR状态或文法符号。如果我们执行LR语法分析过程，语法分析表将给出每次归约之后的新状态，见算法4.44。因此，我们可以直接把这个新状态放到新的栈顶记录中。
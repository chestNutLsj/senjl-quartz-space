### 8.9.1　树翻译方案

在这一节中，代码生成过程的输入是一个由目标机器的语义层次上的树组成的序列。像8.3节讨论的那样在中间代码中插入运行时刻地址之后就可以得到这些树。另外，这些树的叶子包含有关它们的标号的存储类型的信息。

例8.18　图8-19包含了一个对应于赋值语句`a［i］=b+1`的树，其中数组`a`存放在运行时刻栈中，而`b`是一个存放在内存位置Mb的全局变量。局部变量`a`和`i`的运行时刻地址是以相对于`SP`的常数偏移量Ca和Ci的方式给出的，其中`SP`是存放当前活动记录的起始位置的寄存器。

![374-1](../Images/image04595.jpeg)

图8-19　`a［i］=b+i`的中间代码树

对`a［i］`的赋值是一个间接赋值，其中`a［i］`的位置上的右值被设置成表达式`b+1`的右值。数组`a`和变量`i`的地址是通过分别把常量Ca和Ci的值加上寄存器`SP`的内容而得到的。为了简化数组地址的计算，我们假设每个元素值都是一个字节的字符（某些指令集中提供了特殊指令用于在地址计算中进行乘数为某些常数（比如2、4、8等）的乘法运算）。

在这棵树中，运算符ind把它的参数作为内存地址处理。作为一个赋值运算符的左子结点，ind结点指出了一个内存位置，该位置用来存放赋值运算符右部的右值。如果一个+或者ind运算符的某个参数是内存位置或寄存器，那么该内存位置或寄存器中的内容就是参数的值。这棵树的叶子结点的标号为属性，而下标表示属性的值。

目标代码是通过应用一个树重写规则序列来生成的，这些规则最终会把输入的树归约为单个结点。各个树重写规则形如

replacement←template ｛action｝

其中，replacement（被替换结点）是一个结点，template（模板）是一棵树，action（动作）是一个像语法制导翻译方案中那样的代码片断。

一组树重写规则被称为一个树翻译方案（tree-translation scheme）。

每个树重写规则表示了如何翻译由模板给出的输入树的一个片段。翻译中包含了一组可能为空的机器指令序列，该序列由与模板关联的动作发出。和输入树一样，模板的叶子是带有下标的属性。有时，会存在一些对于模板中的下标值的约束，这些约束通过语义断言来表示。只有满足这些约束才可以匹配模板。比如，一个断言可能规定某个常数的值必须位于某个区间内。

树翻译方案可以很方便地表示代码生成器的指令选择阶段。作为树重写规则的例子，考虑关于寄存器到寄存器加法指令的规则：

![375-1](../Images/image04596.jpeg)

这个规则按照如下方法使用。如果输入树包含一个和上面的模板匹配的子树，也就是说，有一个子树的根结点的标号是运算符+，且其左右子结点是寄存器i和j中的量，那么我们可以把这个子树替换为标号为Ri的单一结点，同时输出指令`ADD` Ri，Ri，Rj。我们把这次替换称为对该子树的一次覆盖（tiling）。在一个给定时刻可能有多个模板与某个子树匹配，我们将简要描述在冲突情况下决定应用哪个规则的一些机制。

例8.19　图8-20包含了我们的目标机上的一部分指令的树重写规则。这些规则将被用于一个贯穿本节的例子中。前面的两个规则对应于加载指令，接下来的两个规则对应于保存指令，其余的规则对应于带有下标的加载与加法运算。请注意，规则（8）要求常量的值必须是1。这个条件将用一个语义断言来描述。

![375-2](../Images/image04597.jpeg)
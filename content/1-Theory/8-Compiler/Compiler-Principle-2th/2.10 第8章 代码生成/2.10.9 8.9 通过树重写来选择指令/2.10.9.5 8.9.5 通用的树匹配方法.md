### 8.9.5　通用的树匹配方法

基于前缀表示的用于模式匹配的LR语法分析方法优先处理双目运算符的左运算分量。在一个前缀表示op E1 E2中，有限向前看的LR语法分析方法中有关扫描动作的决定必须依据E1的某个前缀做出。这是因为E1可能具有任意长度。右运算分量可能会带来一些能够在目标指令集中选择较好指令的机会。但是模式匹配方法可能会错失这些机会。

我们也可以弃用前缀表示方式而使用后缀表示。但是，一个用于模式匹配的LR语法分析方法会优先处理右运算分量。

对于一个手写的代码生成器，我们可以使用图8-20中所示的树模板作为指南，编写一个专门的匹配程序。比如，如果输入树的根的标号是ind，那么唯一能够匹配的是规则5的模式；否则如果根的标号是+，那么可能匹配的是规则6～8的模式。

对于一个可以生成代码生成器的生成器，我们需要一个通用的树匹配算法。通过扩展第3章中介绍的串模式匹配技术，我们可以开发出一个高效的自顶向下算法。其基本思想是把每个模板表示成一个串的集合，其中每个串对应于模板中的一条从根到某个叶结点的路径。通过在串中（从左到右地）为每个子结点加入位置编号，我们平等地处理每个运算分量。

例8.22　在为一个指令集构建串集合的时候，我们将去掉下标。因为进行模式匹配时只考虑属性，而不考虑它们的值。

图8-22中的模板有如下的从根到叶子结点的串集合：

![379-1](../Images/image04611.jpeg)

![379-2](../Images/image04612.jpeg)

图8-22　一个用于树匹配的指令集

串C表示以C为根的模板。串+ 1 R表示以+为根的两个模板中的+号和它的左运算分量R。

使用例8.22中的串集合可以构造出一个树模式匹配程序。该程序使用了可以高效地并行匹配多个串的技术。

在实践中，树重写过程可以按照如下方法实现：对输入树进行深度优先遍历的同时运行树模式匹配程序，并且在最后一次访问这个结点的时候进行归约。

如果要考虑指令代价的问题，可以给每个树重写规则关联一个代价值。这个值等于应用这个规则时所产生的代码序列的总代价。在8.11节中，我们将讨论一个可以和树模式匹配算法联合使用的动态规划算法。

通过并发地运行该动态规划算法，我们可以使用各个规则相关的代价信息来选择一个最优的匹配序列。我们要在各个候选序列的代价值都确定之后再决定使用哪个匹配序列。使用这个方法，可以根据一个树重写方案快速地构造出一个小而高效的代码生成器。不仅如此，动态规划算法使得代码生成器的设计者不需要再去解决匹配冲突的问题，或者决定求值的顺序。
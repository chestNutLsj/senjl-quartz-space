### 8.9.3　通过扫描进行模式匹配

在考虑通用的树匹配方法之前，我们先考虑一个特殊的匹配方法。这个方法使用LR语法分析器来完成模式匹配。输入树可以用前缀方式表示为一个串。比如，图8-19中的树的前缀表示为：

![377-4](../Images/image04607.jpeg)

一个树翻译方案可以转换为一个语法制导的翻译方案，方法是把每个树重写规则替换为相应的上下文无关文法的产生式。对于一个树重写规则，相应的产生式的右部就是其指令模板的前缀表示方式。

例8.21　图8-21中的语法制导翻译方案是基于图8-20中的树翻译方案构造的。

![377-5](../Images/image04608.jpeg)

图8-21　由图8-20构造得到的语法制导翻译方案

相应文法的非终结符号是R和M。终结符号m表示特定的内存位置，比如例8.18中全局变量`b`的位置。可以这么理解规则（10）中的产生式M→m：在使用涉及M的某个模板之前首先要把M和m匹配。类似地，我们为寄存器`SP`引入终结符sp，并增加产生式R→sp。最后，终结符c表示常量。

使用这些终结符，图8-19中的输入树对应的串是：

![378-1](../Images/image04609.jpeg)

根据这个翻译方案的产生式，我们可以使用第4章中的某个LR语法分析器构造技术来构建一个LR语法分析器。目标代码通过每一步归约中发出的机器指令来生成。

一个用于代码生成的语法具有很大的二义性。在构造语法分析器的时候，对于如何处理语法分析动作冲突的问题要多加小心。在没有指令代价信息的时候，总体处理规则是偏向于执行较大的归约，而不是较小的规约。这意味着在一个归约-归约冲突中，优先选择较长的归约；在一个移入-归约冲突中，优先选择移入动作。这种“贪吃”的做法使得多个运算由一条机器指令完成。

在代码生成中使用LR语法分析方法有多个好处。第一，语法分析方法是高效的，并且容易被人们理解。因此，使用第4章中描述的算法可以构造出可靠和高效的代码生成器。第二，比较容易为所得代码生成器重新确定目标。只要写出描述新机器的指令集合的语法，就可以构造得到一个针对新机器的代码选择器。第三，可以通过增加特殊产生式来利用机器特有的指令，从而生成高效的代码。

但使用这个方法也存在着一些挑战。语法分析方法确定了求值过程必须是从左到右的。另外，对于某些具有很多种寻址模式的机器来说，描述机器的文法和由此得到的语法分析器可能变得异常庞大。其结果是人们不得不使用特殊技术对描述机器的文法进行编码和处理。我们还必须注意不要让得到的语法分析器在对表达式树进行语法分析的时候被阻塞（即无法进行下一步动作）。造成阻塞的原因可能是该文法不能处理某些运算符的模式，也可能是语法分析器在解决某些语法分析动作冲突的时候做出了错误的选择。我们必须保证语法分析器不会进入无限循环，不停地使用右部只有单个符号的产生式进行归约。无限循环问题可以在生成语法分析器表的时候通过状态分裂技术来解决。
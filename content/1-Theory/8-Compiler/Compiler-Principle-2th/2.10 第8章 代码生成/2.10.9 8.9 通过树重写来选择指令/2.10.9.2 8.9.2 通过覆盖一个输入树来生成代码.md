### 8.9.2　通过覆盖一个输入树来生成代码

一个树翻译方案按照下面的方式工作。给定一个输入树，在这些树重写规则中的模板被用来覆盖输入树的子树。如果找到一个匹配的模板，那么输入树中匹配的子树将被替换为相应规则中的替换结点，并且执行规则的相关动作。如果这个动作包含了一个机器指令序列，那么就会生成这些指令。这个过程将一直重复，直到这个树被归约成单个结点，或找不到匹配的模板为止。在将一个输入树归约成单个结点的过程中生成的机器指令代码序列就是树翻译方案作用于给定输入树而得到的输出。

这样，描述一个代码生成器的过程就变得和使用语法制导翻译方案来描述翻译器的过程类似。我们写出一个树翻译方案来描述目标机的指令集合。在实践中，我们将试图找到一个能够对每个输入树生成代价最小的指令序列的树翻译方案。现在有很多工具可以帮助我们根据一个树翻译方案自动生成代码生成器。

例8.20　让我们用图8-20的树翻译方案来为图8-19中的输入树生成代码。假设第一个规则用于把常量Ca加载到寄存器`R0`中：

![376-1](../Images/image04598.jpeg)

最左边叶子结点的标号就由Ca变成R0，同时生成了指令`LD　R0，#a`。现在，第七个规则和最左边的根标号为+的子树匹配：

![376-2](../Images/image04599.jpeg)

使用这个规则，我们把这棵子树重写为一个标号为`R0`的单一结点，同时生成指令`ADD R0，R0，SP`。现在这棵树如下所示：

![376-3](../Images/image04600.jpeg)

此时，我们可以应用规则（5）来把子树

![376-4](../Images/image04601.jpeg)

归约为单个结点，设其标号为R1。我们也可以使用规则（6）把较大的子树

![376-5](../Images/image04602.jpeg)

归约为单个结点R0，并生成指令`ADD R0，R0，i（SP）`。假设用一个指令来计算较大的子树要比计算较小的子树更加高效，我们选择规则（6）得到下面的树：

![376-6](../Images/image04603.jpeg)

在右边的子树中，可将规则（2）可应用于叶子结点Mb，并产生一个把`b`加载到某个寄存器（比方说`R1`）的指令。现在，使用规则（8）我们可以匹配子树

![377-1](../Images/image04604.jpeg)

并生成增量指令`INC R1`。至此，输入树已经被归约成为：

![377-2](../Images/image04605.jpeg)

剩下的这棵树和规则（4）匹配，从而把这棵树归约为单个结点，并生成指令`ST *R0，R1`。在把树归约成为单一结点的过程中，我们生成了下列代码序列：

![377-3](../Images/image04606.jpeg)

为了实现对例8.18中的树的归约过程，我们必须解决一些和树模式匹配相关的问题：

- 如何完成树模式匹配？代码生成过程（在编译时刻）的效率依赖于树匹配算法的效率。
- 如果在某个给定时刻有多个模板可以匹配，我们该做什么？生成的代码（在运行时刻）的效率依赖于模板被匹配的顺序，因为不同的匹配序列通常将产生不同的目标机代码，这些代码之间的效率是不同的。

如果没有匹配的模板，那么代码生成过程就无法继续了。在另一种极端情况下，我们要防止出现某个单个结点被重写无穷多次的可能性。这种情况会产生无穷多个寄存器之间的移动指令，或者无穷多个加载、保存指令。

为了避免阻塞，我们假设中间代码中的每个运算符都能够使用一个或多个目标机器的指令来实现。我们进一步假设存在足够多的寄存器用于计算树的每个结点。那么，不管树匹配过程如何进行，剩下的树总能够被翻译成为目标机器指令序列。
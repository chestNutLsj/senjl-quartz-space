### 8.3.1　静态分配

为了说明简化的过程调用和返回的代码生成，我们关注下面的三地址语句：

- `call` callee
- `return`
- `halt`
- `action`，这是代表其他三地址语句的占位符。

活动记录的大小和布局是由代码生成器通过存放于符号表中的名字的信息来确定的。我们将首先说明如何在过程调用时在一个活动记录中存放返回地址，以及如何在过程调用结束后把控制返回到这个地址。为方便起见，我们假设活动记录的第一个位置存放返回地址。

我们首先考虑实现最简单情况（即静态分配）时的代码。这里，中间代码中的`call` callee语句可以用包含两个目标机指令的序列来实现：

![349-1](../Images/image04530.jpeg)

`ST`指令把返回地址保存到callee的活动记录的开始处，而`BR`把控制传递到被调用过程callee的目标代码上。属性callee.staticArea是一个常量，给出了callee的活动记录的开始处的地址，而属性callee.codeArea也是一个常量，指向运行时刻内存中Code区中被调用过程callee的第一个指令的地址。

`ST`指令中的运算分量#here+20是返回地址的文字表示，它是紧跟在`BR`指令之后的指令的地址。我们假设#here是当前指令的地址，而调用序列中的三个常量加上两个指令的长度为5个字，即20个字节。

过程代码的结尾处是一个返回到调用者过程的指令。但是没有调用者的第一个过程例外，它的最后一个指令是`HALT`。这个指令把控制返回给操作系统。一个`return`语句可以使用一个简单的跳转语句实现：

![349-2](../Images/image04531.jpeg)

它把控制流转到保存在callee的活动记录开始位置的地址上。

例8.3　假设我们有下面的三地址代码：

![349-3](../Images/image04532.jpeg)

图8-4给出了这个三地址代码的目标程序。我们使用伪指令`ACTION`来代表执行语句`action`的机器指令序列。这些`action`语句代表了和本次讨论无关的三地址代码。我们假定过程`c`的代码从地址100开始，而过程`p`从地址200开始。我们假定每个`ACTION`伪指令占用20个字节。我们还假定这些过程的活动记录以静态方式分配，其位置分别是300和364。

![350-2](../Images/image04533.jpeg)

图8-4　静态分配的目标代码

从地址100开始的指令实现了过程`c`的语句：

![350-3](../Images/image04534.jpeg)

因此程序的运行从地址100上的指令`ACTION1`开始。在地址120上的`ST`指令把返回地址140存放在机器状态字段中，也就是`p`的活动记录的第一个字中。在地址132上的`BR`指令把控制转移到被调用过程`p`的目标代码的第一个指令。

执行了`ACTION3`之后，位于地址220的跳转指令被执行。因为上面的调用代码序列把位置140存放在地址364中，因此当位于地址220的`BR`语句执行时，`*364`代表140。所以当过程`p`结束时，控制流返回到地址140，过程`c`继续执行。
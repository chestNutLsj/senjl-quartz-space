### 8.3.2　栈分配

如果在保存活动记录时使用相对地址，静态分配就可以变成栈分配。但是在栈分配方式中，只有等到运行时刻才能知道一个过程的活动记录的位置。这个位置通常存放在一个寄存器里面，因此活动记录中的字可以通过相对于寄存器中值的偏移量来访问。我们的目标机的下标地址模式可以方便地完成这种访问。

正如我们在第7章中已经看到的，活动记录的相对地址可以用相对于活动记录中的任一已知位置的偏移量来表示。为方便起见，我们将在寄存器`SP`中维护一个指向栈顶的活动记录的开始处的指针，这样就可以使所有的偏移量都是正数。当发生过程调用时，调用过程增加`SP`的值，并把控制传递到被调用过程。在控制返回到调用者时，我们减少`SP`的值，从而释放被调用过程的活动记录。

第一个过程的代码把`SP`设置成内存中栈区的开始位置，完成对栈的初始化：

![351-1](../Images/image04535.jpeg)

一个过程调用指令序列增加`SP`的值，保存返回地址，并把控制传递到被调用过程：

![351-2](../Images/image04536.jpeg)

运算分量#caller.recordSize表示一个活动记录的大小，因此`ADD`指令使得`SP`指向下一个活动记录。在`ST`指令中的运算分量#here+16是跟随在`BR`之后的指令的地址，它被存放在`SP`所指向的地址中。

返回指令序列包含两个部分。被调用过程使用下面的指令把控制传递到返回地址：

![351-3](../Images/image04537.jpeg)

在`BR`中使用`*0（SP）`的原因是我们需要两层间接寻址：`0（SP）`是活动记录的第一个字所在的位置，而`*0（SP）`是存放在那里的返回地址。

返回指令序列的第二部分在调用者中，这个序列减少`SP`的值，因此把`SP`恢复为以前的值。也就是说，在减法运算之后，`SP`指向调用者的活动记录的开始处：

![351-5](../Images/image04538.jpeg)

第7章中包含了有关调用指令序列以及在调用过程和被调用过程之间进行任务分配的折衷方案的更广泛的讨论。

例8.4　图8-5中的程序是前一章中的快速排序程序的一个抽象。过程q是递归的，因此在同一时刻可能有多个活跃的q的活动记录。

![351-4](../Images/image04539.jpeg)

图8-5　例8.4的代码

假设过程`m、p`和`q`的活动记录的大小已经确定，分别是msize、psize和qsize。每个活动记录的第一个字存放返回地址。我们随意地假设这些过程的代码分别从地址100、200和300处开始，并假设栈区在地址600处开始。目标程序在图8-6中显示。

![351-6](../Images/image04540.jpeg)

图8-6　栈式分配时的目标代码

![352-1](../Images/image04541.jpeg)

图8-6　（续）

我们假设`ACTION4`包含了一个条件跳转指令，跳转到`q`的返回代码序列开始地址456；否则，递归过程`q`将不得不永远调用自己。

令msize、psize和qsize分别是20、40和60。在地址100处的第一个指令把`SP`初始化为600，即栈区的开始地址。在控制从`m`转向`q`的前一刻，`SP`中的值是620（因为msize为20）。随后当`q`调用`p`时，在地址320处的指令把`SP`增加到680，即`p`的活动记录的开始处；当控制返回到`q`的时候，`SP`回复到620。如果接下来的两个对`q`的递归调用立刻返回，那么执行过程中`SP`的最大值就是680。但是请注意，栈区中被使用的最后的位置是739，因为从位置680开始的`q`的活动记录总共有60个字节。
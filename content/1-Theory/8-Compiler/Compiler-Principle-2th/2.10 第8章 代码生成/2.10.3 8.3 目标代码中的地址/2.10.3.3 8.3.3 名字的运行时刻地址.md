### 8.3.3　名字的运行时刻地址

存储分配策略以及过程的活动记录中局部数据的布局决定了如何访问名字对应的内存位置。在第6章，我们假设一个三地址语句中的名字实际上是一个指向该名字的符号表条目的指针。这个方法有一个极大的好处，它使得编译器更加易于移植，因为即使当编译器被移植到使用不同运行时刻组织方式的其他机器时，其前端也不需要修改。但是从另一个方面来看，在生成中间代码时生成特定的访问步骤对于一个优化编译器也有极大的好处，因为这使得优化器能够利用原本在简单的三地址语句中不可见的细节。

在任何一种情况下，名字最终必须被替代为访问存储位置的代码。在这里，我们考虑简单的三地址拷贝语句`x=0`的一些细节。假设在处理完一个过程的声明部分后，x的符号表条目包含了`x`的相对地址12。如果`x`被分配在一个从地址static开始的静态分配区域中，那么`x`的实际运行时刻地址是static+12。虽然编译器最终可以在编译时刻确定static+12的值，但是在生成访问该名字的中间代码时可能还不知道静态区域的位置。在这种情况下，生成“计算”static+12的三地址代码是有意义的。当然我们要理解，这个计算在程序运行之前就会完成：它或者在代码生成阶段完成，或者由加载器完成。那么，赋值语句`x`=0被翻译成

![352-2](../Images/image04542.jpeg)

如果静态区从地址100开始，这个语句的目标代码是

![352-3](../Images/image04543.jpeg)
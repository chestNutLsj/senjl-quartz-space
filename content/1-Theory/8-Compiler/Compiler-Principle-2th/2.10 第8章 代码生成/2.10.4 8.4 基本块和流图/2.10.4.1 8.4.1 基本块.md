### 8.4.1　基本块

我们的第一项工作是把一个三地址指令序列分割成为基本块。我们以第一个指令作为一个新基本块的开始，然后不断把后续的指令加进去，直到我们碰到一个无条件跳转、条件跳转指令或者下一个指令前面的标号为止。当没有跳转和标号时，控制流直接从一个指令到达下一个指令。这个想法在下面的算法中形式化地表示出来。

算法8.5　把三地址指令序列划分成为基本块。

输入：一个三地址指令序列。

输出：输入序列对应的一个基本块列表，其中每个指令恰好被分配给一个基本块。

方法：首先，我们确定中间代码序列中哪些指令是首指令（leader），即某个基本块的第一个指令。跟在中间程序末端之后的指令的不包含在首指令集合中。选择首指令的规则如下：

1）中间代码的第一个三地址指令是一个首指令。

2）任意一个条件或无条件转移指令的目标指令是一个首指令。

3）紧跟在一个条件或无条件转移指令之后的指令是一个首指令。

然后，每个首指令对应的基本块包括了从它自己开始，直到下一个首指令（不含）或者中间程序的结尾指令之间的所有指令。

例8.6　图8-7中的中间代码把一个10×10的矩阵`a`设置成一个单位矩阵。这段代码来自哪里并不重要，它也许是从图8-8的伪代码中翻译得到的。在生成这个中间代码的时候，我们假设每一个实数值的数组元素占8个字节，且矩阵`a`按行存放。

![354-1](../Images/image04549.jpeg)

图8-7　把一个10×10的矩阵设置成单位矩阵的中间代码

![354-2](../Images/image04550.jpeg)

图8-8　图8-7的源代码

首先，根据算法8.5的规则（1）可知第一个指令是一个首指令。为了找到其他的首指令，我们要找到跳转指令。在这个例子中有三个跳转指令（全部是条件跳转指令），即指令9、11和17。根据规则（2），这些跳转指令的目标是首指令，它们分别是指令3、2和13。然后，根据规则（3），跟在一个跳转指令后面的每个指令都是首指令，即指令10和12。注意，在这段代码里没有跟在指令17后面的指令。假如有的话，那么第18个指令也是一个首指令。

我们可以得出结论：指令1、2、3、10、12和13是首指令。每个首指令对应的基本块包括了从它开始直到下一个首指令之前的所有指令。因此，指令1的基本块就是指令1，指令2的基本块是指令2。但首指令3的基本块包含了从指令3到指令9的所有指令。指令10的基本块是10和11；指令12的基本块仅仅包含指令12，而指令13的基本块是指令13到17。
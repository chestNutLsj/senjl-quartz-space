### 8.2.2　程序和指令的代价

我们经常会指出编译及运行一个程序所需的代价。根据我们在优化一个程序时感兴趣的方面，我们会使用不同的度量。常用的度量包括编译时间的长短，以及目标程序的大小、运行时间和能耗。

确定编译和运行一个程序的实际代价是一个复杂的问题。总的来说，为一个给定的源程序找到一个最优的目标程序是一个不可判定问题，而很多相关的子问题都是NP困难的。正如我们已经指出的，在代码生成时，我们通常必须满足于那些能够生成优良代码但不一定是最优目标程序的启发式技术。

在本章的其余部分，我们将假设每个目标语言指令都有相应的代价。为简单起见，我们把一个指令的代价设定为1加上与运算分量寻址模式相关的代价。这个代价对应于指令中字的长度。寄存器寻址模式具有的附加代价为0，而涉及内存位置或常数的寻址方式的附加代价为1。下面是一些例子：

- 指令`LD R0，R1`把寄存器R1中的内容拷贝到寄存器`R0`中。因为不要求附加的内存字，所以这个指令的代价是1。
- 指令`LD R0，M`把内存位置M中的内容加载到寄存器`R0`中。指令的代价是2，因为内存位置`M`的地址在紧跟着指令的字中。
- 指令`LD R1，*100（R2）`把值contents（contents（100 + contents`（R2）`））加载到寄存器`R1`中。这个指令的代价是2，因为常数100存放在紧跟着指令的内存字中。

在本章中，我们假设对于一个指定的输入，目标语言程序的代价是当此程序在该输入上运行时所执行的所有指令的代价总和。优秀的代码生成算法的目标是使得程序在典型输入上运行时所执行指令的代价总和最小。我们将会看到，在某些情况下，我们真的能够在某些类型的寄存器机器上为表达式生成最优的代码。
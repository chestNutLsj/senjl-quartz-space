### 8.2.1　一个简单的目标机模型

我们的目标计算机是一个三地址机器的模型。它具有加载和保存操作、计算操作、跳转操作和条件跳转。这个计算机的内存按照字节寻址，它具有n个通用寄存器`R0`，`R1`，…，`R`n-1。一个完整的汇编语言具有几十到上百个指令。为了避免因为过多的细节而妨碍对概念的解释，我们将只使用一个很有限的指令集合，并假设所有的运算分量都是整数。大部分指令包含一个运算符，然后是一个目标地址，最后是一个源运算分量的列表。指令之前可能有一个标号。我们假设有如下种类的指令可用：

- 加载运算：指令`LD` dst，addr把位置addr上的值加载到位置dst。这个指令表示赋值dst=addr。这个指令最常见的形式是`LD` r，x。它把位置x中的值加载到寄存器r中。形如`LD` r1，r2的指令是一个寄存器到寄存器的拷贝运算。它把寄存器r2的内容拷贝到寄存器r1中。
- 保存运算：指令`ST` x，r把寄存器r中的值保存到位置x。这个指令表示赋值x=r。
- 计算运算：形如OP dst，src1，src2，其中OP是一个诸如`ADD`或`SUB`的运算符，而dst、src1和src2是内存位置。这些位置不一定要相互不同。这个机器指令的作用是把OP所代表的运算作用在位置src1和src2中的值上，然后把这次运算的结果放到位置dst中。比如，SUB r1，r2，r3计算了r1=r2-r3。原先存放在r1中的值丢失了，但是如果r1等于r2或者r3，计算机会首先读出原来的值。只需要一个运算分量的单目运算符没有src2。
- 无条件跳转：指令`BR` L使得控制流转向标号为L的机器指令。（`BR`表示产生分支）。
- 条件跳转：该指令的形式为`B`cond r，L，其中r是一个寄存器，L是一个标号，而cond代表了对寄存器r中的值所做的某个常见测试。比如，当寄存器r中的值小于0时，`BLTZ` r，L使得控制流跳转到标号L；否则，控制流传递到下一个机器指令。

我们假设目标机具有多种寻址模式：

- 在指令中，一个位置可以是一个变量名x，它指向分配给x的内存位置（即x的左值）。
- 一个位置也可以是一个带有下标的形如a（r）的地址，其中a是一个变量，而r是一个寄存器。a（r）所表示的内存位置按照如下方式计算得到：a的左值加上存放在寄存器r中的值。比如，指令`LD R1，a（R2）`的效果是`R1`=contents（`a`+contents`（R2）`），其中contents（x）表示x所代表的寄存器或内存位置中存放的内容。这个寻址方式对于数组访问是很有用的，其中a是数组的基地址（即第一个元素的地址），而r中存放了从基地址到数组a的某个元素所要经过的字节数。
- 一个内存位置可以是一个以寄存器作为下标的整数。比如，`LD R1，100（R2）`的效果就是使得`R1`=contents（100 +contents`（R2））`。也就是说，首先计算寄存器`R2`中的值加上100得到的和，然后把这个和所指向的位置中的值加载到`R1`中。正如我们在下面的例子中将看到的那样，这个寻址方式可以用于沿指针取值。
- 我们还支持另外两种间接寻址模式：*r表示在寄存器r的内容所表示的位置上存放的内存位置。而`*100（r）`表示在r中内容加上100的和所代表的位置上的内容所代表的位置。比如，`LD R1，*100（R2）`的效果是把`R1`设置为contents（contents（100+contents`（R2）`））。也就是说，首先计算寄存器`R2`中的内容加上100的和，取出和值所指的位置中的内容，再把这个内容代表的位置中的值加载到`R1`中。
- 最后，我们支持一个直接常数寻址模式。在常数前面有一个前缀#。指令`LD R1，#100`把整数100加载到`R1`中，而`ADD R1，R1，#100`则把100加到寄存器`R1`中去。

在指令之后的注解由//开头。

例8.2　三地址语句`x=y-z`可以使用下面的机器指令序列实现：

![346-1](../Images/image04515.jpeg)

也许我们能做得更好。一个优秀的代码生成算法的目标之一是尽可能地避免使用上面的全部四个指令。比如，`y`和/或`z`可能已经被计算出来并存放在一个寄存器中。如果是这样，我们就可以避免相应的`LD`步骤。类似地，如果x的值被使用时都存放在寄存器中，并且之后不会再被用到，我们就不需要把这个值保存回`x`。

假设`a`是一个元素为8字节值（比如实数）的数组。再假设`a`的元素的下标从0开始。我们可以通过下面的指令序列来执行三地址指令`b=a［i］：`

![346-2](../Images/image04516.jpeg)

这里的第二步计算8i；而第三步把`a`的第i个元素的值放到`R2`中，这个元素位于离数组`a`的基地址8i个字节的地方。

类似地，三地址指令`a［j］=c`所代表的对数组`a`的赋值可以实现为：

![346-3](../Images/image04517.jpeg)

为了实现一个简单的指针间接存取，比如三地址语句`x=*p`，我们可以使用如下的机器指令序列：

![347-1](../Images/image04518.jpeg)

通过指针的赋值语句`*p=y`可以类似地用如下的机器代码实现：

![347-2](../Images/image04519.jpeg)

最后考虑一个带条件跳转的三地址指令：

![347-3](../Images/image04520.jpeg)

它的等价的机器代码如下：

![347-4](../Images/image04521.jpeg)

这里的`M`是从标号为`L`的三地址指令所产生的机器指令序列中的第一个指令的标号。对于任意一个三地址指令，我们希望可以省略这些指令中的某些指令。省略的原因可能是所需的运算分量已经在寄存器中了，也可能因为结果不需要存放回内存。
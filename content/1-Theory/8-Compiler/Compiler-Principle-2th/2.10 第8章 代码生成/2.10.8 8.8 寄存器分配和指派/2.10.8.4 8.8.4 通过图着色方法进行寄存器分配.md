### 8.8.4　通过图着色方法进行寄存器分配

当计算中需要一个寄存器，但所有可用寄存器都在使用时，某个正被使用的寄存器的内容必须被保存（溢出）到一个内存位置上，以便释放出一个寄存器。图着色方法是一个可用于分配寄存器和管理寄存器溢出的简单且系统化的技术。

这个方法需要进行两趟处理。在第一趟处理中选择目标机器指令，处理时假设有无穷多个符号化寄存器。经过这次处理，中间代码中使用的名字变成了寄存器的名字，而三地址指令变成了机器指令。如果对变量的访问要求一些指令使用栈指针、显示表指针、基址寄存器或其他的量来辅助访问，我们就假设这些量存放在那些为相应目的而保留的寄存器中。通常情况下，它们的使用可以直接翻译成为机器指令中的一个地址所使用的某种访问模式。如果访问方式更加复杂，这个访问就必须被分解成为多个机器指令，并且需要创建一个或多个临时的符号化寄存器。

在选择好了指令之后，第二趟处理把物理寄存器指派给符号化寄存器。这一次处理的目标是寻找到一个溢出代价最小的指派方法。

在第二趟处理中，对每个过程都构造了一个寄存器冲突图（register-interference graph）。图中的结点是符号化寄存器。对于任意两个结点，如果一个结点在另一个被定值的地方是活跃的，那么这两个结点之间就有一条边。比如，图8-17对应的寄存器冲突图中有两个结点`a`和`b`。在基本块B1中，`a`在对`b`定值的第二个语句上是活跃的，因此在图中结点`a`和`b`之间有一条边。

然后就可以尝试用k种颜色对寄存器冲突图进行着色，其中k是可指派的寄存器的个数。一个图被称为已着色（colored）当且仅当每个结点都被赋予了一个颜色，并且没有两个相邻的结点的颜色相同。一种颜色代表一个寄存器。着色方案保证不会把同一个物理寄存器指派给两个可能相互冲突的符号化寄存器。

一般来说，确定一个图是否k-可着色是一个NP完全问题，但在实践中我们常常可以使用下面的启发式技术进行快速着色。假设图G中有一个结点n，其邻居（即通过一条边连接到n的结点）个数少于k个。把n及和n相连的边从G中删除后得到一个图G′。对图G′的一个k-着色方案可以扩展成为一个对G的k-着色方案：只要给n指派一个尚未指派给它的邻居的颜色就可以了。

通过不断地从寄存器冲突图中删除边数少于k的结点，要么最终我们得到一个空图，要么得到的图中每个结点都至少有k个相邻的结点。在第一种情况下，我们可以依照结点被删除的相反顺序对结点进行着色，从而得到一个原图的k-着色方案。在第二种情况下已经不存在k-着色方案了[^6]。此时就需要通过引入保存和重新加载寄存器的代码，将某个结点溢出。Chaitin设计了多个用来选择溢出结点的启发式规则。总的原则是避免在内部循环中引入溢出代码。
### 8.8.2　使用计数

通过在循环L运行时把一个变量x保存在寄存器里面，我们可以节省从内存中加载x的开销。在本节我们假设，如果把x分配在寄存器中，对x的每一次引用可以节省一个单位的（用于加载的）成本。然而，如果x在一个基本块中被计算之后又在同一个基本块中被使用，那么当使用8.6节中的算法来生成基本块代码时，x有很大的机会被仍然保存在寄存器中。（因此对x的使用很可能本来就不需要从内存中加载。——译者注）因此，只有当x在循环L的某个基本块内被使用，且在同一基本块中x没有被先行赋值时，我们才认为这次使用节约了一个单位的开销。如果我们能够避免在某个基本块的结尾把x保存回内存，我们也可以省略2个单位的开销：保存指令和之后的加载指令。因此，如果x被分配在某个寄存器中，对于每个向x赋值且x在其出口处活跃的基本块，我们节省了两个单位的开销。

在支出方面，如果x在循环头部的入口处活跃，我们必须在进入循环L之前把x加载到它的寄存器中。这个加载的成本是两个成本单元。类似地，对于循环L的每个出口基本块B，如果x在B的某个L之外的后继的入口处活跃，我们必须以2个单位的代价把x保存起来。然而，假设循环将迭代多次，我们可以忽略这些支出。因为每次进入循环时，这些指令只会运行一次。因此，在循环L中把一个寄存器分配给x所得到的好处的一个估算公式是

![371-1](../Images/image04592.jpeg)

其中，use（x，B）是x在B中被定值之前被使用的次数。如果x在B的出口处活跃并在B中被赋予一个值，则live（x，B）的取值为1，否则live（x，B）为0。请注意，式8.1只是一个估算公式。这是因为一个循环中的各基本块的运行频率实际是不同的，也因为式（8.1）是基于循环被多次迭代的假设之上的。因此在特定的机器上，有可能需要设计一个与式（8.1）类似，但具有一定差异的公式。

例8.17　考虑图8-17中所示的内部循环中的基本块。图中的跳转指令和条件跳转指令都被省略了。假设寄存器`R0`、`R1`和`R2`用于存放整个循环范围内的值。为方便起见，在图8-17中，各个基本块的入口处/出口处的活跃变量分别显示在基本块的上方和下方。我们将在下一章中讨论关于活跃变量的复杂问题。比如，请注意`e`和`f`都在`B1`的结尾处活跃，但是只有`e`在`B2`的入口处活跃，只有`f`在`B3`的入口处活跃。一般来说，在一个基本块的结尾处活跃的变量集合是那些在该基本块的后继基本块的入口处活跃的变量的并集。

![372-1](../Images/image04593.jpeg)

图8-17　一个内层循环的流图

为了计算当x=a时式（8.1）的值，我们观察到`a`在B1的出口处活跃且在B1中被赋值，但是它不在B2、B3、B4的出口处活跃。因此，∑B在循环L中use（a，B）=2。当x=a时，式（8.1）的值是4。也就是说，如果选择某个全局寄存器来存放`a`的值，可以节约的4个成本单位。对`b、c、d、e`和`f`，式（8.1）的值分别是5、3、6、4和4。因此，我们可以为`R0、R1、R2`分别选择`a、b、d`。把`R0`用于存放`e`或`f`是另一种选择，显然这样做具有同样的收益。假设8.6节中介绍的策略用于生成各个基本块的代码，图8-18显示了根据图8-17生成的汇编代码。在图8-17中，我们没有为略去的各个基本块结尾处的条件或无条件跳转指令生成代码，因此我们没有像通常那样把代码显示成为一个序列。

![372-2](../Images/image04594.jpeg)

图8-18　使用全局寄存器指派的代码序列
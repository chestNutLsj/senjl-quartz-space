### 8.5.5　数组引用的表示

初看上去，数组下标指令似乎可以像其他的运算那样处理。比如，考虑下列的三地址指令序列：

![360-4](../Images/image04564.jpeg)

如果我们把`a［i］`当作是一个和a+i类似的关于`a`和`i`的普通运算，那么`a［i］`的两次使用看起来好像是一个公共子表达式。在这种情况下，我们可能会把第三个指令`z=a［i］`优化为`z=x`。然而，因为`j`可能等于`i`，中间的语句可能实际上改变了`a［i］`的值。因此，这种优化是不合法的。

在DAG中，表示数组访问的正确方法如下。

1）从一个数组取值并赋给其他变量的运算（比如`x=a［i］`）用一个新创建的运算符为`=［］`的结点表示。这个结点的左右子结点分别代表数组初始值（本例中是`a0`）和下标i。变量`x`是这个结点的标号之一。

2）对数组的赋值（比如`a［j］= y`）用一个新创建的运算符为`［］=`的结点来表示。这个结点的三个子结点分别表示`a0、j`和`y`。没有变量用这个结点标号。不同之处在于此结点的创建杀死了所有当前已经建立的，其值依赖于`a0`的结点。一个被杀死的结点不可能再获得任何标号。也就是说，它不可能成为一个公共子表达式。

例8.13　基本块

![361-1](../Images/image04565.jpeg)

的DAG见图8-14。对应于`x`的结点N首先被创建，但是当标号为`［］=`的结点被创建时，N就被杀死了。因此当z的结点被建立时，它不会被认为和N等同，而是必须创建一个具有同样的运算分量`a0`和`i0`的新结点。

![361-2](../Images/image04566.jpeg)

图8-14　一个数组赋值序列的DAG

例8.14　有时即使某个结点的所有子结点都没有像例8.13中的`a0`那样的附加数组变量，它也必须被杀死。类似地，如果一个结点具有数组后代，即使它的子结点都不是数组结点，它也可以杀死别的结点。例如考虑下面的三地址代码

![361-3](../Images/image04567.jpeg)

这里的情况是，为了效率方面的原因，`b`被定值为数组`a`中的一个位置。例如，如果`a`的元素长度是4个字节，那么`b`代表了`a`的第四个元素。如果`j`和`i`表示同一个值，那么`b［i］`和`b［j］`代表了同一个位置。因此，很重要的一件事情就是让第三个指令`b［j］=y`杀死带有附加变量x的结点。然而，正如我们在图8-15中看到的，被杀的结点和杀死被杀结点的结点都把`a0`作为孙结点，而不是子结点。

![361-4](../Images/image04568.jpeg)

图8-15　即使没有把一个数组作为子结点，一个结点也可能杀死对该数组的使用
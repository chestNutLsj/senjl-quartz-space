### 8.5.6　指针赋值和过程调用

当我们像下面的赋值语句

![361-5](../Images/image04569.jpeg)

那样，通过指针进行间接赋值时，我们并不知道`p`和`q`指向哪里。从效果看，`x=*p`是对任意变量的使用，而`*q=y`可能对任意一个变量赋值。其结果是，运算符=*必须把当前所有带有附加标识符的结点当作其参数。但是这么做会影响死代码的消除过程。更加重要的是，*=运算符会把至今为止构造出来的DAG中的其他结点全部杀死。

我们可以进行一些全局指针分析，以便把一个指针在代码中某个位置上可能指向的变量限制在一个较小的子集内。即使是局部分析也可以限制一个指针指向的范围。比如，对于下面的序列

![361-6](../Images/image04570.jpeg)

我们知道是`x`（而不是其他变量）被赋予`y`的值。因此，我们只需要杀死以`x`为附加变量的结点，不需要杀死其他结点。

过程调用和通过指针赋值很相似。在缺乏全局数据流信息的情况下，我们必须假设一个过程调用使用和改变了它访问的所有数据。因此，如果变量`x`在一个过程P的访问范围之内，对P的调用不仅使用了以`x`为附加变量的结点，还杀死了这个结点。
### 8.10.2　从带标号的表达式树生成代码

假设在我们的机器模型中，所有的运算分量都必须在寄存器中，且寄存器可以同时用于存放某个运算的运算分量和结果。可以证明，如果在计算表达式的过程中不允许把中间结果保存回内存，那么一个结点的标号就等于计算该结点对应的表达式时需要的最少的寄存器个数。因为在这个机器模型中，我们必须把每个运算分量加载到寄存器中，且必须计算每个内部结点所对应的中间结果，所以，造成生成代码不是最优代码的唯一可能是我们使用了不必要的将临时结果存回内存的指令。对这个断言的证明包含在下面的算法中。这个算法生成的代码不包含将临时结果存回内存的指令，而这个代码所使用的寄存器数目就是根结点的标号。

算法8.24　根据一个带标号的表达式树生成代码。

输入：一个带有标号的表达式树，其中的每个运算分量只出现一次（即没有公共子表达式）。

输出：计算根结点对应的值并将该值存放在一个寄存器中的最优的机器指令序列。

方法：下面是一个用来生成机器代码的递归算法。从树的根结点开始应用下面的步骤。如果算法被应用于一个标号为k的结点，那么得到的代码只使用k个寄存器。然而，这些代码从某个基线b（b≥1）开始使用寄存器，实际使用的寄存器是Rb，Rb+1，…，Rb+k-1。计算结果总是存放在Rb+k-1中。

1）为一个标号为k且两个子结点的标号相同（它们的标号必然是k-1）的内部结点生成代码时，做如下处理：

① 使用基线b+1递归地为它的右子树生成代码。其右子树的结果将存放在寄存器Rb+k-1中。

② 使用基线b，递归地为它的左子树生成代码。其左子树的结果将存放在寄存器Rb+k-2中。

③ 生成指令“`OP` Rb+k-1，Rb+k-2，Rb+k-1”，其中`OP`是标号为k的结点对应的运算。

2）假设我们有一个标号为k的内部结点，其子结点的标号不相等。那么，它必然有一个子结点的标号为k，我们称之为“大子结点”；而另一个子结点的标号为某个m<k，它被称为“小子结点”。使用基线b，通过下列步骤为这个内部结点生成代码：

① 使用基线b，递归地为大子结点生成代码，其结果存放在寄存器Rb+k-1中。

② 使用基线b，递归地为小子结点生成代码，其结果存放在寄存器Rb+m-1中。请注意，因为m<k，寄存器Rb+k-1和编号更高的寄存器都没有被使用。

③ 根据大子结点是该内部结点的右子结点还是左子结点，分别生成指令“`OP` Rb+k-1，Rb+m-1，Rb+k-1”或者“`OP` Rb+k-1，Rb+k-1，Rb+m-1”。

3）对于代表运算分量x的叶子结点，当基线为b时生成指令“`LD` Rb，x”。

例8.25　让我们把算法8.24应用于图8-23中的树。因为根结点的标号是3，其结果将存放在R3中，并且只有寄存器R1、R2、R3被使用。根结点的基线是b=1。因为根结点的两个子结点的标号相同，我们首先以2为基线生成右子结点的代码。

当我们为根结点的标号为t3的右子结点生成代码时，我们发现该子结点的大子结点是其右子结点，而小子结点是其左子结点。这样，我们首先以2为基线生成右子结点的代码。应用针对具有相同标号子结点和叶子结点的规则，我们为标号t2的结点生成下列代码：

![381-2](../Images/image04616.jpeg)

接下来，我们为根结点的右子结点的左子结点生成代码。这是一个标号为e的叶子结点。因为b=2，正确的指令是

![381-3](../Images/image04617.jpeg)

现在我们加上指令

![381-4](../Images/image04618.jpeg)

就完整地生成了根结点的右子结点的代码。算法继续以1为基线生成根结点的左子结点的代码，并把结果放在R2中。图8-24中显示了生成的全部指令序列。

![381-1](../Images/image04619.jpeg)

图8-24　图8-23中的树的最优的三地址代码
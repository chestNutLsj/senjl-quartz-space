### 8.10.3　寄存器数量不足时的表达式求值

当可用寄存器的数量少于树的根结点的标号时，我们不能直接应用算法8.24。此时需要引入一些保存指令，把某些子树的值溢出到内存中，然后在必要的时候生成加载指令把那些值再加载到寄存器中。下面是一个经过修改的代码生成算法，它考虑了寄存器数量的限制。

算法8.26　根据一个带标号的表达式树生成代码。

输入：一个带有标号的表达式树和寄存器的数量r≥2。表达式树的每个运算分量只出现一次（即没有公共子表达式）。

输出：计算根结点对应的值并将其存放到一个寄存器中的最优的机器指令序列。代码使用的寄存器的数量不大于r。我们假设这些寄存器为R1，R2，…，Rr。

方法：令基线b=1，从根结点开始应用下面的递归算法。对于标号为r或者更小的结点N，本算法和算法8.24完全一样，这里不再重复。但是，对于标号k>r的内部结点，我们要分别处理该内部节点的各个子结点，并把较大子树的结果保存到内存中。该结果在对结点N求值之前才从内存重新加载，而最后的求值步骤将在Rr-1和Rr内进行。对于基本算法的改动如下：

1）结点N至少有一个子结点的标号为r或者大于r。选择较大的子结点（如果子结点标号相同则选择任意一个）作为“大”子结点，并把另外一个子结点作为“小”子结点。

2）令基线b=1，递归地为大子结点生成代码。这个求值的结果将存放在寄存器Rr中。

3）生成机器指令“`ST` tk，Rr”，其中tk是一个用于存放中间结果的临时变量。这个变量用于对标号为k的结点求值。

4）按照如下方式为小子结点生成代码。如果小子结点的标号大于或等于r，选取基线b=1。如果小子结点的标号为j<r，选取基线b=r-j。然后递归地把本算法应用于小子结点，其结果存放在Rr中。

5）生成指令“`LD` Rr-1，tk”。

6）如果大子结点是N的右子结点，生成指令“`OP` Rr，Rr，Rr-1”。如果大子结点是N的左子结点，生成代码“`OP` Rr，Rr-1，Rr”。

例8.27　现在假设r=2，让我们重新回顾一下图8-23所代表的表达式。也就是说，只有寄存器`R1`和`R2`可以用来存放表达式求值过程中产生的临时结果。当我们把算法8.26应用到图8-23中时，我们看到根结点的标号（3）大于r=2。这样，我们需要选择其中的一个子结点作为大子结点。因为子结点的标号相同，我们可以任选其中的一个。假设我们选择了右子结点作为大子结点。

因为根结点的大子结点的标号为2，因此寄存器是够用的。我们把算法8.24应用到这个子树，其中基线b=1，而寄存器个数为2。最终的结果和我们在图8-24中生成的代码很相似，但原来的寄存器`R2`和`R3`被替换为`R1`和`R2`。代码如下：

![382-1](../Images/image04620.jpeg)

现在，因为我们要把这两个寄存器都用于根结点的左子树，我们需要生成指令

![382-2](../Images/image04621.jpeg)

接下来处理根结点的左子结点。同样，寄存器的数量足以处理这个子结点，代码如下：

![382-3](../Images/image04622.jpeg)

最后，我们用指令

![382-4](../Images/image04623.jpeg)

把存放了根结点的右子结点的值的临时变量重新加载到寄存器中，并使用指令

![382-5](../Images/image04624.jpeg)

执行树的根结点上的运算。完整的指令序列显示在图8-25中。

![382-6](../Images/image04625.jpeg)

图8-25　图8-23中的树的最优的三寄存器代码（只使用两个寄存器）
## 8.13　第8章参考文献

本章中讨论的很多技术在最早的编译器中就出现了。Ershov的加标号算法出现在1958年［7］。Sethi和Ullman［16］在一个算法中使用了这种标号方法。他们还证明了这种算法可以为算术表达式生成最优代码。Aho和Johnson［1］使用动态规划技术来为CISC机器上的表达式树生成最优代码。Hennessy和Patterson［12］对CISC和RISC机器体系结构的发展，以及在设计一个好的指令集时需要做出的权衡进行了很好的讨论。

虽然RISC的历史可以追溯到更早的计算机中，比如最先在1964年交付的CDC6600，但RISC体系结构在1990年之后才流行起来。在1990年之前设计的很多计算机都是CISC机器，然而大多数在1990年之后安装的通用计算机仍然是CISC机器，因为它们都基于Intel 80x86或其后代（比如Pentium芯片）的体系结构。在1963年交付的Burroughs B5000是一个早期的栈计算机。

本章中给出的很多关于代码生成的启发式规则已经被用到不同的编译器中。我们描述了在循环执行时用固定数量寄存器存放变量的策略。这个策略被Lowry和Medlock用在Fortran H的实现中［13］。

高效的寄存器分配技术在编译器出现的最早时代就开始研究了。把图着色算法作为一种寄存器分配技术是由Cocke、Ershov［8］和Schwartz［15］提出的。针对寄存器分配，人们提出了很多种图着色算法的变体。我们处理图着色的方法来自于Chaitin［3］［4］。Chow和Hennessy在［5］中描述了他们的可用于寄存器分配的基于优先级的着色算法。在［6］中可以见到针对最新的用于寄存器分配的图分划和重写技术的讨论。

词法分析器和语法分析器的自动生成工具刺激了模式制导的指令选择技术的发展。Glanville和Graham［11］使用LR语法分析器生成技术来处理指令的自动选择。表格驱动的代码生成器发展成为多个基于树模式匹配的代码生成工具［14］。在代码生成工具twig中，Aho、Ganapathi和Tjiang［2］把高效的树模式匹配技术和动态规划技术结合起来。Fraser、Hanson和Proebsting［10］在他们的简单有效的代码生成器的生成器中进一步精化了这些思想。

![387-1](../Images/image04630.jpeg)

![388-1](../Images/image04631.jpeg)

---

[^1]: 原文如此。如果s的某个运算分量在基本块内没有在s之前被定值，那么这个运算分量对应的子结点就是代表该运算分量的初始值的结点。——译者注

[^2]: 总的来说，在从DAG生成代码时我们必须非常小心地处理变量的名字。如果变量x被定值两次，或者虽然只赋值一次但初始值x0被使用过，那么必须保证不会在原先存放x值的结点被全部使用之前改变x的值。

[^3]: 在编译时刻对算术表达式求值时，必须使用和运行时刻相同的求值方法。K. Thompson给出了一个很完美的解决方法：对常量表达式进行编译，在目标机上执行目标代码，然后把表达式替换为执行结果。按照这样的做法，编译器就不需要另带一个解析器。

[^4]: 然而，减法运算可能引起上溢或下溢，而比较指令不会引起这个问题。

[^5]: 即不能跨越括号求值——译者注。

[^6]: 实际并非如此，例如由4个结点组成的圈中，每个结点都有两条边，但是却存在2-着色方案：奇数点为白色，而偶数点为黑色。作者的意思可能是指难以在适当的时间内找出k-着色方案——译者注。
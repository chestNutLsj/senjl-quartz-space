### 8.11.1　连续求值

动态规划算法把为一个表达式生成最优代码的问题分解成为多个为该表达式的子表达式生成最优代码的子问题。作为一个简单的例子，考虑一个形如E1+E2的表达式E。E的一个最优程序由E1和E2的最优程序以某种顺序组合而成，然后是对+求值的代码。为E1和E2生成最优程序的子问题也以类似的方式解决。

由动态规划算法产生的最优程序有一个重要的性质。该代码以“连续”的方式计算表达式E=E1 op E2。我们可以通过查看E的语法树T来理解这句话的含义。

![383-1](../Images/image04626.jpeg)

这里，T1和T2分别是E1和E2的语法树。

我们说一个程序P连续计算一棵树T，如果它首先计算那些需要计算值并将其存放到内存中的T的子树。然后，它再计算T的其余部分，计算的顺序可以是T1，T2，根结点，或者T2，T1，根结点。无论在哪种情况下，作为非连续计算的一个例子，程序P可能先计算T1的一部分并把结果存放在一个寄存器中（而不是内存中），然后计算T2，然后再回过来计算T1的其余部分。

对于本节中的寄存器机器，我们可以证明对于任何一个计算表达式树T的机器语言程序P，我们都可以找到一个等价的程序P′，使得

1）P′的代价不高于P的代价。

2）P′使用的寄存器不多于P使用的寄存器，而且

3）P′连续地对该树求值。

这个结果表明，每个表达式树可以用一个连续程序最优地求值。

相对而言，使用偶数-奇数寄存器对的计算机不一定总是具有最优的连续求值过程。x86体系结构在乘法和除法中使用寄存器对。对于这样的机器，我们可以给出一些表达式树的例子。这些树的最优机器语言程序必须首先对根的左子树的一部分进行求值并把结果存放到寄存器中，然后处理右子树的一部分，再处理左子树的另一部分，如此往复。使用本节中的机器对任意一个表达式树进行最优求值时，没有必要进行这种类型的摆动。

上面定义的连续求值的性质保证了对于任何表达式树T，总是存在一个最优程序。这个程序由根结点的子树的最优程序组成，最后是计算根结点值的指令。这个性质支持我们使用一个动态规划算法为T生成一个最优程序。
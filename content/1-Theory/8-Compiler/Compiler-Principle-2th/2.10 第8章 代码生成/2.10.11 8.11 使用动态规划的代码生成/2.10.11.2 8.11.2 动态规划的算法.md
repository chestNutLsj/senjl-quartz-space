### 8.11.2　动态规划的算法

动态规划算法有三个步骤（假设目标机器具有r个寄存器）：

1）对表达式树T的每个结点n自底向上地计算得到一个代价数组C，其中C的第i个元素C［i］是在假设有i（1≤i≤r）个可用寄存器的情况下对以n为根的子树S求值并将结果存放在一个寄存器中的最优代价。

2）遍历T，使用代价向量（数组）来决定T的哪棵子树应该被计算并保存到内存中。

3）使用每个结点的代价向量和相关指令来遍历各棵子树并生成最终的目标代码。在这个过程中，首先为那些需要把结果值保存到内存的子树生成代码。

上述每一个步骤都可以高效地实现，运行所需时间与表达式树的大小成线性关系。

计算一个结点n的代价包括在给定寄存器数量的情况下对S求值时所需要的全部加载和保存运算，也包括了计算S的根结点处的运算符所需要的代价。代价向量的第0个元素存放的是把子树S的值计算出来并保存到内存的最优代价。只需要考虑S的根结点的各子树的最优程序的不同组合，就可以生成S的最优程序。这是由连续求值的性质来确保的。这个限制减少了需要考虑的情况。

为了计算结点n的代价C［i］，我们像8.9节中那样把指令看作是树重写规则。考虑和结点n处的输入树相匹配的各个模板E。只要检查n的相应后代的代价向量，就可以确定对E的叶子结点所代表的运算分量进行求值时所需要的代价。对于E的寄存器运算分量，考虑对T的相应子树求值并放到寄存器中的各种可能的顺序。在每个顺序中，第一个对应于某个寄存器运算分量的子树可以使用i个寄存器，而第二个则使用i-1个寄存器，以此类推。考虑结点n时，需要加上和模板E相关的指令的代价。C［i］的值就是所有这些可能的顺序所对应的代价值中的最小者。

整棵树T的代价向量可以用自底向上的方式计算。计算所需时间和T中结点的个数呈线性正比关系。在每个结点上为各个i值保存用于获得最优代价C［i］所使用的指令可以带来方便。T的根结点的代价向量中的最小值给出了对T求值所需的最小代价。

例8.28　考虑有两个寄存器`R0、R1`及下列的指令的机器。每个指令的代价是一个成本单位：

![385-1](../Images/image04627.jpeg)

在这些指令中，`R`i可以是`R0`或者`R1`，而`M`j则是一个内存位置。运算符op对应于某个算术运算符。

让我们应用动态规划算法为图8-26中的语法树生成最优的代码。在第一步中，我们计算每个结点的代价向量。这些向量在图中各个结点的旁边显示。为了说明代价计算方法，考虑在叶子结点`a`处的代价向量。C［0］（即计算`a`并保存到内存的代价）是0，因为它已经在内存中了。C［1］（即计算a并保存到一个寄存器的代价）是1，因为我们可以使用指令`LD R0，a`把它加载到一个寄存器中。C［2］（即在有两个可用寄存器的情况下把`a`加载到一个寄存器中的代价）和只有一个可用寄存器的情况下的代价是一样的。因此，在叶子结点`a`上的代价向量是（0，1，1）。

![385-2](../Images/image04628.jpeg)

图8-26　表达式`（a-b）+c*（d/e）`的语法树，每个结点都标有代价向量

考虑一下根结点处的代价向量。我们首先确定在有一个及两个可用寄存器的情况下计算根结点所需的最小代价。因为根结点的标号是+，所以机器指令`ADD R0，R0，M`和根结点匹配。使用这个指令，在只有一个可用寄存器的情况下对根结点求值的最小代价的计算方法如下：对其右子树求值并存放到内存的最小代价，加上计算其左子树并保存到寄存器的最小代价，再加上该指令的代价1。不存在其他的最小代价的计算方式。在根结点的左右子结点上的代价向量说明在只有一个可用寄存器的情况下对根结点求值的最小代价是5+2+1=8。

现在考虑有两个可用寄存器时对根结点求值的最小代价。根据用于计算根结点的不同指令，以及对根结点的左右子树求值的不同顺序，需要考虑三种情况。

1）使用两个可用寄存器计算左子树的值并放到寄存器`R0`中，使用一个可用寄存器计算右子树的值并放到寄存器`R1`中，并使用指令`ADD R0，R0，R1`来计算根结点。这个指令序列的代价是5+2+1=8。

2）使用两个可用寄存器计算右子树的值并存放到`R1`中，使用一个可用寄存器计算左子树的值并存放到`R0`中，并使用指令`ADD R0，R0，R1`计算根结点。这个指令序列的代价为4+2+1=7。

3）计算右子树的值并保存到内存位置`M`中，使用两个可用寄存器计算左子树的值并保存到寄存器R0中，并使用指令`ADD R0，R0，M`计算根结点的值。这个指令序列的代价是5+2+1=8。

可见，第二种选择给出了最小的代价7。

计算根结点的值并保存到内存中的代价等于使用所有可用寄存器计算根结点的值的最小代价再加上1。也就是说，我们首先计算根结点并将其存放到一个寄存器中，然后保存结果。因此，在根结点处的代价向量是（8，8，7）。

根据代价向量，我们可以很容易地通过对树的遍历构造出代码序列。假设有两个可用寄存器，图8-26的树的最优代码序列是：

![386-1](../Images/image04629.jpeg)

动态规划技术已经在很多编译器中使用，这些编译器包括可移植C编译器版本2，即PCC2。因为动态规划技术可以用到很多类型的机器上，这个技术促进了编译器的可重定向特性的发展。
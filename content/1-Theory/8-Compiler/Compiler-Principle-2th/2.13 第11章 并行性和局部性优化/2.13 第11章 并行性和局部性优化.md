   

# 第11章　并行性和局部性优化

本章将介绍一个编译器如何增强处理数组的计算密集型程序中的并行性和局部性，以便提高目标程序在多处理器系统上的远行速度。很多科学、工程和商业领域的应用对计算能力的要求是永无止境的。这些例子包括气象预报，用于药物设计的蛋白质折叠，用于设计航空推进系统的流体动力学和用于高能物理中强相互作用研究的量子色动力学。

加快计算过程的方法之一就是使用并行技术。遗憾的是，开发可以利用并行机器的软件并不是容易的事情。把计算过程分割为多个可以在不同并行处理器上执行的单元已经是很困难的事情了，但是这样的分割还不一定能保证提高速度。我们还必须把处理器之间的通信量减到最小，因为通信开销很容易使并行代码运行得甚至比串行代码还慢！

尽可能降低通信开销可以被当作是提高程序的数据局部性（data locality）的一个特殊情况。一般来说，如果一个处理器经常访问它最近使用的同一组数据，我们就说这个程序具有良好的数据局部性。如果并行机上的一个处理器具有良好的局部性，它就不需要和其他处理器频繁通信。因此，并行性和数据局部性必须放在一起考虑。数据局部性本身对于单个处理器的性能也是很重要的。现代处理器的内存层次结构中都有一层或多层高速缓存，一次内存访问可能会需要几十个机器周期，而在高速缓存中命中的运算只需要几个机器周期。如果一个程序没有良好的数据局部性，并经常在缓存访问中脱靶，那么它的性能就会受到影响。

在本章中同时处理并行性和数据局部性的另一个理由是它们使用的理论相同。如果我们知道如何优化数据局部性，也就知道了并行性在哪里。在本章，你将看到第9章中为进行数据流分析而使用的程序模型对并行化和局部性优化来说是不够的。原因是在数据流分析中的工作假设我们不需要区分到达一个给定语句的不同路径。实际上，第9章中的那些技术利用了不需要区分同一个语句的（例如，在循环中的）不同执行的事实。为了实现代码并行化，需要考虑同一语句的不同动态执行实例之间的依赖关系，以决定它们是否可以在不同处理器上同时执行。

本章关注的是用于优化某一类数值应用的技术。这类应用使用数组作为数据结构，并且以一种简单且规则的模式访问这些数据结构。更明确地说，我们研究的程序中包含的数组访问与外围循环的下标变量之间具有仿射关系。例如，如果i和j是外围循环的下标变量，那么Z［i］［j］和Z［i］［i+j］都是仿射访问。如果关于一个或多个变量x1、x2、…、xn的函数可以被表示为一个常数加上常数乘以这些变量的和，即c0+c1x1+c2x2+…+cnxn，其中c0，c1，c2，…，cn是常数，那么这个函数就是仿射的。仿射函数通常称为线性函数，虽然严格地讲线性函数不能有c0项。

下面是这个领域内的循环的一个简单的例子：

![502-1](../Images/image04858.jpeg)

因为这个循环的各个迭代对不同的内存位置进行写运算，不同的处理器可以并发地执行不同的迭代。另一方面，如果有另一个语句Z［j］=1正在执行，我们就要担心i是否可能和j相同，以及如果相同的话，要按照什么顺序来执行这两个具有相同数组下标值的语句的实例。

知道哪些迭代可能指向同一个内存位置是很重要的。这个知识使我们可以描述调度代码时必须遵守的数据依赖，不管被调度的代码是在单处理器上运行还是在多处理器上运行。我们的目标是找到一个遵守所有数据依赖关系的调度方案，使得访问相同内存位置或高速缓存线的运算尽可能靠近执行；并且在多处理器的情况下，把这些代码放在同一个处理器上执行。

本章中给出的理论是基于线性代数和整数规划技术的。我们把一个深度为n的循环嵌套结构中的迭代建模为一个n维多面体。该多面体的边界用代码中循环的界限来描述。仿射函数把每个迭代映射成为它所访问的数组位置。我们可以使用整数线性规划技术来确定是否存在可能指向同一个位置的两个迭代。

我们在这里讨论的代码转换方法的集合可以分成两类：仿射分划（affine partitioning）和分块（blocking）。仿射分划把迭代的多面体分割成为多个部分，在不同的机器上执行各个部分，或者一个一个地顺序执行各个部分。另一方面，分块技术创建了一个由迭代组成的层次结构。假设有一个以逐行方式扫描整个数组的循环。我们可以把这个数组分成多个块，并且逐块访问其中的元素。最后得到的代码由遍历这些块的外层循环和扫描各块中元素的内层循环组成。线性代数技术用来确定最好的仿射分划和最好的分块方案。

在接下来的内容中，我们先在11.1节中概述关于并行计算和局部性优化的概念。然后，在11.2节中给出一个具体例子——矩阵乘法。这个例子用于说明循环转换，即对一个循环内的计算过程进行重新排序，是如何既提高局部性又提高并行化效率的。

11.3节到11.6节给出了循环转换所必需的基本信息。11.3节介绍如何对一个循环嵌套结构中的各个迭代进行建模；11.4介绍如何对数组下标函数建模。这类函数把每个循环迭代映射到被该迭代访问的数组位置；11.5节介绍如何使用标准线性代数算法来确定一个循环中的哪些迭代访问了相同的数组位置或高速缓存线；11.6节说明如何找到一个程序中的数组引用之间的所有数据依赖关系。

本章的其余部分应用这些基本技术来进行优化。11.7节首先考虑一个比较简单的问题，即寻找不需要同步的并行性。为了找到最佳的仿射分划方案，我们只需要找到满足下面约束的解：具有数据依赖关系的运算必须被分配到同一个处理器上。

当然，没有多少程序能够在不需要任何同步的情况下实现并行化。因此，在11.8节到11.9.9节将探讨寻找需要同步的并行性的一般情况。我们引入了流水线化的概念，说明如何寻找能够达到一个程序所允许的最大流水线化程度的仿射分划。我们将在11.10节中说明如何优化数据局部性。最后，我们讨论如何把仿射变换用于其他形式的并行性。
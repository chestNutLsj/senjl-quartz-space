### 11.1.4　数据局部性

在对程序进行并行化的时候，需要考虑两种略微不同的数据局部性概念。当同一个数据在短时间内被多次使用时就产生了时间局部性（temporal locality）。当位置相近的不同数据元素在短时间内被使用的时候就产生了空间局部性（spatial locality）。空间局部性的一个很重要的形式是在同一个高速缓存线中出现的所有数据元素被一起使用。这种形式之所以重要的理由是当需要一个来自某高速缓存线的元素时，这个高速缓存线的所有元素都会被加载到高速缓存中。如果很快就会使用这些元素，那么它们很可能还在高速缓存中。这种空间局部性的效果使得高速缓存脱靶的概率降到最小，也使得该程序得到了较好的加速比。

程序的内核经常可以使用多种不同的方式来书写。它们之间在语义上等价，但是数据局部性和性能却相差很大。例11.2给出了例11.1中的计算过程的另一种表示方法。

例11.2　和例11.1类似，下面的代码也能够计算得到向量X和Y的元素之间的差的平方。

![507-1](../Images/image04864.jpeg)

第一个循环计算元素之间的差，第二个循环计算差的平方。这样的代码经常会在实际程序中遇到，因为这就是我们为向量机（vector machine）优化程序的办法。向量机是一种超级计算机，拥有可以一次性对整个向量进行简单算术运算的指令。我们可以看到，这里的两个循环在例11.1中被融合（fuse）为一个循环。

我们已经知道这两个程序完成同样的计算工作，那么哪一个程序比较好呢？例11.1中被融合在一起的循环拥有比较好的性能，因为它具有较好的数据局部性。每个差值一生成就立刻进行平方运算。实际上，我们可以将差值存放在一个寄存器中，求它的平方，并把结果一次性写入内存位置Z［i］。反过来，本例中的代码需要获取Z［i］值一次，并对它写两次。不仅如此，如果数组的大小比高速缓存大，那么当Z［i］在这个例子中被第二次使用时，需要从内存中重新获取这个值。因此，这个代码的运行速度可能低很多。

例11.3　假设我们希望把按行存放（回忆一下6.4.3节）的数组Z设置为全零。图11-3a和图11-3b分别对这个数组进行逐列和逐行扫描。我们可以对图11-3a中的循环进行变换得到图11-3b的循环。从空间局部性的角度看，以逐行方式执行置零运算是比较好的，因为在一个高速缓存线中的所有字都被顺序置零了。在逐列处理的方法中，虽然每个高速缓存线都被外层循环的下一个迭代复用，但当列的大小比高速缓存大的时候，高速缓存线在被复用之前就会被抛出高速缓存。为了得到最好的性能，我们使用类似于例11.1中所使用的方法，把图11-3b的外层循环并行化，结果如图11-3c所示。

![508-1](../Images/image04865.jpeg)

图11-3　将一个数组置零的顺序代码和并行代码

上面的两个例子解释了和操作数组的数值应用相关的几个重要性质：

- 数组代码经常有很多可并行化的循环。
- 当循环具有并行性的时候，它们的迭代可以按照任意的顺序执行。它们可以通过重新排序大幅提高数据局部性。
- 当我们创建出大的相互独立的并行计算单元时，以串行方式执行它们往往会得到良好的数据局部性。
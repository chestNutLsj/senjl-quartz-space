### 11.7.5　一个简单的代码生成算法

算法11.43生成了能够把计算任务分割成独立分划单元的仿射分划。因为分划单元之间是相互独立的，因此它们可以被任意分配到不同处理器上。一个处理器可以被分配给多个分划单元，并且处理器可以交替执行分配给它的分划单元。但是每个分划单元中的运算需要顺序执行，这是因为它们之间通常具有数据依赖关系。

为一个给定的仿射分划生成一个正确的程序相对容易一些。我们首先介绍算法11.45。这是一个简单的代码生成方法，它能够为单处理器系统生成顺序地执行各个独立分划单元的代码。这样的代码优化了时间局部性，因为对相同数组元素的多次数组访问在时间上相当靠近。不仅如此，这个代码很容易被转换成为一个SPMD程序，这个程序在不同的处理器上执行各个分划单元。遗憾的是，这样生成的代码是低效的，我们下一步将讨论使这些代码高效执行的优化方法。

我们的基本思想如下。我们已经知道了一个循环嵌套结构的各个下标变量的界限，也在算法11.43中确定了某个语句s中的访问的分划。假设我们希望生成一个能够顺序执行各个处理器上的动作的代码，那么可以创建一个最外层的循环，该循环遍历各个处理器ID。也就是说，这个循环的每个迭代执行了分配给某个处理器ID的运算。原来的程序作为这个循环的循环体被插入到代码中。另外，对代码中的每个运算都增加了一个测试条件作为卫式，以保证每个处理器只执行赋予它的运算。通过这个方法，我们保证一个处理器按照原来的顺序执行了所有赋予它的指令。

例11.44　我们希望生成能够顺序执行例11.41中的各个独立分划单元的代码。原来的顺序程序来自图11-26，我们在图11-28中重复这段代码。

![547-1](../Images/image04959.jpeg)

图11-28　重复图11-26

在例11.42中，仿射分划算法找到了度数为一的并行性。因此，处理器空间可以用单个变量p表示。请回忆一下，我们在那个例子中选择了如下的仿射分划，对于所有满足1≤i≤100和1≤j≤100的下标变量i和j：

1）将语句s1的实例（i，j）分配给处理器p=i-j-1。

2）将语句s2的实例（i，j）分配给处理器p=i-j。

我们可以分三步生成代码：

1）对于每个语句，找出所有参与该语句计算的处理器的ID。我们把约束1≤i≤100及1≤j≤100和等式p=i-j-1和p=i-j中的一个组合起来，并通过投影消除i和j，得到新的约束。

① 如果我们使用为语句s1得到的函数p=i-j-1，那么得到-100≤p≤98。

② 如果我们使用语句s2的函数p=i-j，那么得到-99≤p≤99。

2）找出所有参与了任一语句的计算工作的处理器的ID。我们取这些范围的并集，得到-100≤p≤99，这些界限足以覆盖语句s1和s2的所有的实例。

3）生成能够顺序遍历每个分划单元中的计算工作的代码。图11-29中显示的代码有一个外层循环，它迭代遍历了所有参与计算的分划单元的ID（第1行）。在第2行和第3行，每个分划单元都会经历原串行程序生成所有迭代下标的过程，然后它可以选出应该由处理器p执行的迭代。第4行和第6行的代码保证了只有当处理器p应该执行语句s1和s2时，这两个语句才可以执行。

![548-1](../Images/image04960.jpeg)

图11-29　图11-28中的代码的简单改写，它在执行时遍历处理器空间

虽然生成的代码是正确的，但是特别低效。首先，虽然每个处理器最多执行99个迭代的计算任务，但是它生成了100×100个迭代的循环下标值，比必须的下标值数目多了一个量级。其次，最内层循环的每一个加法都带有一个条件测试，在原有开销上又增加了一个常量因子。这两种低效率问题的处理将分别在11.7.6节和11.7.7节中处理。

虽然图11-29的代码看起来被设计成在单处理器上执行的代码，但我们将把第2行到第8行的内层循环拿出来在200个不同的处理器上执行它们。每个处理器都有一个不同的从-100～99的p值。只要我们安排得当，使得每个处理器都知道各自负责p的哪些值，并且只执行对应于这些值的第2行到第8行代码，那么就可以在少于200个处理器上分划内层循环的计算。

算法11.45　创建顺序执行一个程序的各个分划单元的代码。

输入：一个具有仿射数组访问的程序P。程序中的每个语句s具有形如Bsi+bs≥0的界限，其中i是s所在循环嵌套结构的循环下标变量的向量。每个语句s还附有一个分划Csi+cs=p，其中p是一个由表示处理器ID的变量组成的m维向量。m是程序P中的各个语句的分划的秩的最大值。

输出：一个等价于P的程序，但是它在处理器空间上（而不是原来的循环下标上）进行迭代遍历。

方法：执行下列各步骤：

1）对于每个语句，使用Fourier-Motzkin消除法从界限中通过投影消除所有的循环下标变量。

2）使用算法11.13来决定分划单元ID的界限。

3）为处理器空间的m个维度中的每一维生成一个循环。令p=［p1,p2,…，pm］为这些循环的变量的向量。也就是说，对于处理器空间的每一个维度都有一个变量。每个循环变量pi遍历程序P中所有语句的分划空间的并集。

请注意，分划空间的并集不一定是凸的。为了保证算法简单，我们不必做到只枚举那些确实有计算任务的分划单元；我们可以把每个pi的下界设置为由各个语句确定的全部下界的最小值，并把每个pi的上界设置为由各个语句确定的全部上界的最大值。因此p的某些取值可能没有运算。

由每个分划单元执行的代码就是原来的串行程序。但每个语句都带有一个断言作为卫式条件，以保证只有属于这个分划单元的代码才会被执行。

我们很快就会给出算法11.45的一个例子。但是请记住，要得到典型例子的优化代码还有很多工作要做。
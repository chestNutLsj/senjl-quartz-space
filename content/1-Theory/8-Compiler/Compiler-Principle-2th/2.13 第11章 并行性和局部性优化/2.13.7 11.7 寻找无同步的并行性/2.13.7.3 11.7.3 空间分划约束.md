### 11.7.3　空间分划约束

因为要求没有通信，所以每一对具有数据依赖关系的运算都必须被分配在同一个处理器上。我们把这些约束称为“空间分划约束”。任何满足这些约束的映射所创建的分划都是相互独立的。请注意，只要把所有运算都放到一个分划单元，就可以满足这样的约束。遗憾的是，这样的“解”没有给出任何并行性。我们的目标是在满足这些空间分划约束的同时得到尽可能多的独立分划。也就是说，只有在必要的时候才会把不同的运算放到同一个处理器上。

当我们限制自己只考虑仿射分划时，可以将并行性的度数（即维度）最大化，而不是将独立单元的数目最大化。如果我们使用分段（piecewise）仿射分划，有时有可能创建出更多的独立单元。一个分段仿射分划把单个访问的实例分割成为不同的集合，并允许对每个集合使用不同的仿射分划。但是这里我们不考虑这样的选项。

正式地讲，一个程序的仿射分划是无同步的（synchronization free）当且仅当对于两个具有数据依赖关系的（不一定不同的）访问，即在循环嵌套结构d1中的语句s1中的访问![542-3](../Images/image04941.jpeg)=<F1，f1,B1,b1> 和循环嵌套结构d2中的语句s2中的访问![542-4](../Images/image04942.jpeg)，对语句s1和s2的分划<C1,c1>和<C2,c2>满足下面的空间分划约束（space-partition constraint）：

- 对于所有满足下列条件的![542-5](../Images/image04943.jpeg)中的i1和![542-6](../Images/image04944.jpeg)的i2：

1）B1i1+b1≥0

2）B2i2+b2≥0

3）F1i1+f1=F2i2+f2

C1i1+c1=C2i2+c2一定成立。

并行化算法的目标是为每个语句找出满足这些约束的具有最高秩的分划。

图11-25中的图说明了空间分划约束的本质。假设有两个静态访问分别处于两个循环嵌套结构中，它们的下标向量分别为i1和i2。假设它们共同访问了至少一个数组元素，且至少其中之一是写运算，那么它们之间具有依赖关系。根据仿射访问函数F1i1+f1和F2i2+f2，该图显示了在这两个循环中恰巧访问同一个数组元素的动态访问。除非这两个静态访问的仿射分划C1i1+c1 和C2i2+c2把它们的动态访问分配到同一个处理器上，否则不同处理器之间必须进行同步。

![543-1](../Images/image04945.jpeg)

图11-25　空间分划约束

如果我们选择一个仿射分划，它的秩为所有语句的秩的最大值，那么就得到了最大可能的并行性。但是，在这种划分下，有些处理器有时可能会空闲，而其他处理器却忙于执行那些具有较小秩的仿射分划的语句。如果执行这些语句的时间相对较短，这种情况还是可接受的。否则，我们可以选择秩小于最大可能值的仿射分划，只要这个分划的秩大于0即可。

在例11.41中，我们给出了一个用于说明这个技术的功能的小程序。实际应用通常要比这个程序简单，但是它们的边界条件可能和这里显示的一些问题类似。我们将在本章的各个部分使用这个例子来说明下面的事实：具有仿射访问的程序具有相对简单的空间分划约束，这些约束可以通过标准线性代数技术来解决，并且最终需要的SPMD程序能够从仿射分划中机械化地生成。

例11.41　这个例子说明了我们如何把一个程序的空间分划约束用公式表达出来。这个程序显示在图11-26中，它由具有两个语句s1和s2的小循环嵌套结构组成。

![543-2](../Images/image04946.jpeg)

图11-26　一个用以说明相互依赖的长运算链的循环嵌套结构

我们在图11-27中显示了程序中的数据依赖关系。在图中，每个黑点表示语句s1的一个实例，而每个白点表示了语句s2的一个实例。在坐标（i,j）处的点表示该语句在下标变量的取值为（i,j）时的实例。但是请注意，s2的实例位于对应于相同（i,j）对的s1的实例的下方，因此图中对应于j的垂直刻度要比对应于i的水平刻度长。

![543-3](../Images/image04947.jpeg)

图11-27　例11.41的代码中的依赖关系

请注意，X［i,j］是由s1（i,j）写入的，s1（i,j）就是语句s1对应于循环下标值i和j的实例。之后它被s2（i,j+1）读出，因此s1（i,j）必须在s2（i,j+1）之前执行。这个事实解释了图中从黑点到白点的垂直箭头。类似地，Y［i,j］被s2（i,j）写入再由s1（i+1,j）读出，这个事实解释了从白点到黑点的箭头。

从图中很容易看出，代码可以被并行化为无同步关系的几个部分，方法是把各个相互依赖的运算链分配给同一个处理器。但是，写出一个实现这样的映射方案的SPMD程序并不容易。在原来的程序中每个循环有100个迭代，因此存在200个运算链。在这些运算链中，其中的一半由s1开始并以s1结束，另一半从s2开始并以s2结束。这些链的长度从1～100个迭代不等。

因为有两个语句，所以我们需要为每个语句寻找一个仿射分划。我们只需要表示出一维仿射分划的空间分划约束。这些约束稍后将由试图寻找所有独立的一维仿射分划的解方法所使用。这个方法还将把这些一维分划组合起来得到多维仿射分划。因此，我们可以把每个语句的仿射分划表示为一个1×2的矩阵和一个1×1的向量，并把下标向量［i,j］转换成为一个处理器的编号。令<［C11C12］,［c1］>，<［C21C22］,［c2］>分别为语句s1和s2的一维仿射分划。

我们将应用六个数据依赖测试：

1）语句s1中的写访问X［i，j］和其自身之间的依赖关系。

2）语句s1中的写访问X［i，j］和读访问X［i，j］之间的依赖关系。

3）语句s1中的写访问X［i，j］和语句s2中的读访问X［i，j-1］之间的依赖关系。

4）语句s2中的写访问Y［i，j］和其自身之间的依赖关系。

5）语句s2中的写访问Y［i，j］和读访问Y［i，j］之间的依赖关系。

6）语句s2中的写访问Y［i，j］和语句s1中的写访问Y［i-1，j］之间的依赖关系。

我们可以看到，这些依赖关系测试都很简单，而且高度重复。这个代码中出现的依赖关系发生在第（3）种情况下访问X［i，j］和X［i，j-1］的实例之间以及第（6）种情况下访问Y［i，j］和Y［i-1，j］的实例之间。

由语句s1中的X［i，j］和s2中的X［i，j-1］之间的数据依赖关系而导致的空间分划约束可以表示成下列各项：

对于所有满足下面条件的（i，j）和（i′，j′）

1≤i≤100　1≤j≤100

1≤i′≤100　1≤j′≤100

i = i′　j = j′-1

我们有

![544-1](../Images/image04948.jpeg)

也就是说，前四个条件是说（i，j）和（i′，j′）处于这个循环嵌套结构的迭代空间中，后两个条件是说动态访问X［i，j］和X［i，j-1］触及同一个数据元素。我们可用类似的方法得到针对语句s2中的访问Y［i-1，j］和语句s1中的访问Y［i，j］的空间分划约束。
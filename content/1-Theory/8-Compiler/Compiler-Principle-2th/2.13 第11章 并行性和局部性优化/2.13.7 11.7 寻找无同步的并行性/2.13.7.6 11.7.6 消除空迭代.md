### 11.7.6　消除空迭代

现在我们讨论生成高效SPMD代码所必须的两个转换中的第一个。每个处理器执行的代码循环遍历原程序中的所有迭代，并选择应该由它执行的运算。如果代码具有k度的并行性，这么做的后果就是每个处理器的工作量增大了k个数量级。第一个转换的目的是收紧循环的界限以便消除所有的空迭代。

首先我们逐条考虑程序中的语句。由一个分划单元执行的一个语句的迭代空间是原来的迭代空间加上仿射分划给出的约束。我们可以把算法11.13应用到新的迭代空间，为每个语句生成一个紧致的界限。新的下标向量和原顺序程序的下标向量类似，但加上了处理器ID作为最外层的下标。请注意，这个算法会为每个下标生成以外围下标表示的紧致的界限。

在找到不同语句的迭代空间之后，我们按照逐个循环的方式把它们组合起来，使得下标的界限为各个语句的界限的并集。如下面的例11.46所示，最后有些循环可能只有一个迭代，我们可以简单地消除这个循环，并直接把循环下标设置为该迭代对应的值。

例11.46　对于图11-30a中的循环，算法11.43将生成仿射分划

s1:p=i

s2:p=j

算法11.45将生成图11-30b中的代码。对语句s1应用算法11.13得到界限p≤i≤p，即i=p。类似地，这个算法确定对于语句s2有j=p。这样我们就得到了图11-30c所示的代码。对变量i和j的传播将会消除不必要的测试而得到图11-30d中的代码。

![549-1](../Images/image04961.jpeg)

图11-30　例11.46的代码

现在我们回到例11.44，并说明把不同语句的多个迭代空间合并到一起的步骤。

例11.47　现在让我们收紧例11.44中代码的循环界限。由分划单元p执行的语句s1的迭代空间由下面的等式和不等式定义：

-100≤p≤99

1≤i≤100

1≤j≤100

i-p-1=j

对上面的算式应用算法11.13生成了图11-31a中显示的约束。算法11.13根据i-p-1=j和1≤j≤100生成约束p+2≤i≤100+p+1，并把p的上界收紧为98。类似地，对于语句s2的各个变量的界限在图11-31b中显示。

图11-31中语句s1和s2的迭代空间是相似的，但是如图11-27中所期望的，两个空间在某些界限上相差1。图11-32中的代码在这两个迭代空间的并集上运行。比如，使用max（1,p+1）作为i的下界，min（100,100+p+1）作为其上界。请注意，最内层循环在第一次和最后一次执行时只有一个迭代，而在其他情况下有两个迭代。生成循环下标的开销因此降低了一个数量级。因为被执行的迭代空间比s1和s2的迭代空间都大，在执行这些语句的时候仍然需要使用条件判断来进行选择。

![550-1](../Images/image04962.jpeg)

图11-31　图11-29中p、i和j的较紧致的界限
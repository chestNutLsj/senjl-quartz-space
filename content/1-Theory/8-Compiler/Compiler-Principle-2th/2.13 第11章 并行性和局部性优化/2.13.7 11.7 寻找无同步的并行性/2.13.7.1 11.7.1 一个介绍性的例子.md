   

### 11.7.1　一个介绍性的例子

图11-23中显示的是从一个5000行的Fortran代码程序中摘录的并以C语言表示的程序片段。为清晰起见，代码中仍然保留了Fortran风格的数组访问语法。原来的程序实现了用来解决三维欧拉方程的多重网格算法。这个程序的大部分运行时间都花费在少数几个如图所示的子程序上。它是很多数值程序的典型代表。这些数值程序经常由很多处在不同嵌套层次上的for循环组成。它们包含了很多数组访问，所有数组访问的下标都是外围循环下标的仿射表达式。为了使这个例子比较简短，我们已经从原来的程序中删除了一些具有类似性质的代码行。

![540-1](../Images/image04937.jpeg)

图11-23　一个多重网格算法的代码片断

图11-23的代码在一个标量变量T和一些具有不同维度的多个数组上运行。我们首先来看一下对变量T的使用。因为一个循环中的每个迭代使用同一个变量T，我们不能并行执行这些迭代。但是T只是用于存放在一个迭代中使用两次的公共子表达式的值。在图11-23中的前两个循环嵌套中，最内层循环的各个迭代向T中写入一个值，然后立刻在同一个迭代中两次使用这个值。我们可以把对T的每次使用替换为前面对T的赋值语句的右部表达式，从而在不改变程序语义的前提下消除依赖关系。我们也可以把标量T替换为一个数组。然后我们让每个迭代（j,i）使用它自己的数组元素T［j,i］。

经过这样的修改，每个赋值语句中对一个数组元素的计算只依赖于最后两个下标分量值（分别是j和i）相同的其他数组元素。因此，我们可以把对各个数组的第（j,i）个元素进行操作的所有运算组合成为一个计算单元，并按照原来的串行顺序执行它们。这个修改产生了（j1-1）×（i1-1）个相互独立的计算单元。请注意，原程序里第二和第三个循环嵌套结构涉及下标为k的第三个循环。但是，因为具有同样的j和i值的动态访问之间不存在依赖关系，所以可以安全地在j和i的循环内部——就是说在一个计算单元中——执行k的循环。

知道这些计算单元是独立的，我们就可以对代码进行多个合法的转换。比如，一个单处理器系统可以不按照原来的代码执行，而是逐个执行独立的运算单元，最终完成同样的计算工作。转换所得代码显示在图11-24中。这个代码具有更好的时间局部性，因为计算中生成的结果立刻就被用掉了。

![541-1](../Images/image04938.jpeg)

图11-24　经过改写的图11-23的代码，最外层是并行循环

这些独立的计算单元也可以被分配给不同的处理器并行执行。这些处理器之间不需要任何同步或通信。因为有`（j1-1）×（i1-1）`个相互独立的计算单元，我们最多可以利用`（j1-1）×（i1-1）`个处理器。我们可以按照二维数组的方式组织处理器，每个处理器的ID是（j,i），其中2≤j≤`j1`，2≤i≤`i1`。由各个处理器执行的SPMD程序就是图11-24中的内层循环的循环体。

上面的例子说明了寻找无同步的并行性的基本方法。我们首先把计算任务分解成尽可能多的独立单元。这个分解揭示了可行的调度选择。然后，我们依照拥有的处理器数目把这些计算单元分配给各个处理器。最后，我们生成一个在各个处理器上执行的SPMD程序。
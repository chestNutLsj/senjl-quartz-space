### 11.7.4　求解空间分划约束

一旦抽取得到空间分划约束之后，我们就可以使用标准线性代数技术来寻找满足这个约束的仿射分划。让我们首先说明如何找出例11.41的解。

例11.42　我们可以使用下面的步骤来找出例11.41的仿射分划：

1）建立例11.41中显示的空间分划约束。我们在决定数据依赖关系的时候使用了循环界限，但是在算法的其余部分不再使用循环界限。

2）在不等式中的未知变量是i、i′、j、j′、C11、C12、c1、C21、C22和c2。根据访问函数可得到等式i=i′和j=j′-1。使用这些等式来减少未知量的数目。我们使用高斯消除法来完成这个工作，它把四个变量减少为两个变量，也就是说t1=i=i′和t2=j=j′-1。分划的等式变为

![545-1](../Images/image04949.jpeg)

3）上面的等式对于所有的t1和t2组合都成立。因此必然有下面的结论：

C11-C21=0

C12-C22=0

c1-c2-C22=0

如果我们对访问Y［i-1,j］和Y［i,j］之间的约束执行同样的处理步骤，我们得到

C11-C21=0

C12-C22=0

c1-c2+C21=0

把所有这些约束一起进行简化，我们得到下面的关系：

C11=C21=-C22=-C12=c2-c1

4）找出那些只涉及系数矩阵中的未知量的等式的所有独立解。在这一步中忽略常量向量中的未知量。在系数矩阵中只有一个独立的选择，因此我们寻找的仿射分划的秩最多为一。为了使得分划尽量简单，我们把C11设置为1。我们不能把0赋值给C11，因为这会建立一个零秩的系数矩阵。零秩矩阵会把所有的迭代都映射到同一个处理器上。由C11=1可得C21=1，C22=-1，C12=-1。

5）找出常数项。我们知道常数项之间的差c2-c1必须是-1。但是我们必须选择实际的值。为了使分划简单，我们选择c2=0，因此c1=-1。

令p为执行迭代（i,j）的处理器的ID。这个仿射分划用p表示就是

![545-2](../Images/image04950.jpeg)

也就是说，s1的第（i,j）个迭代被分配给处理器p=i-j-1；而s2的第（i,j）个迭代被分配给处理器p=i-j。

算法11.43　找出一个程序的具有最高秩的无同步仿射分划。

输入：一个带有仿射数组访问的程序。

输出：一个分划。

方法：执行下列步骤：

1）找出程序中所有的具有数据依赖关系的访问对。对于每一对具有数据依赖关系的访问：嵌套在循环d1中的语句s1的访问![545-3](../Images/image04951.jpeg)和嵌套在循环d2中的语句s2的访问![545-4](../Images/image04952.jpeg)。令<C1,c1>和<C2,c2>分别是语句s1和s2的（当前未知的）分划。相应的空间分划约束表明对于分别处于各自循环界限中的i1和i2，如果

F1i1+f1=F2i2+f2

那么

C1i1+c1=C2i2+c2

我们将扩展迭代的域，使之包含![545-5](../Images/image04953.jpeg)中的所有i1和![545-6](../Images/image04954.jpeg)中的所有i2。也就是说，假设所有的界限都是从负无穷大到正无穷大。这样的假设是有道理的，因为一个仿射分划不能利用如下的性质：一个下标变量的取值范围是一个有限整数集合。

2）对于每一对相互依赖的访问，我们减少其下标向量中的未知量的数目。

（a）请注意Fi+f和向量

![546-1](../Images/image04955.jpeg)

相同。也就是说，通过在列向量i的底部加上一个额外的分量1，我们可以使列向量f成为附加到矩阵F中的最后一列。这样，可以把访问函数的等式F1i1+f1=F2i2+f2改写为

![546-2](../Images/image04956.jpeg)

（b）一般来说，上面的等式具有多个解。但是，我们仍然可以使用高斯消除法尽可能地求解这个关于分量i1和i2的方程组。也就是说，尽量多地消除变量，直到只剩下无法消除的变量为止。最后得到的i1和i2的解将具有如下形式

![546-3](../Images/image04957.jpeg)

其中U是一个上三角形矩阵，t是一个由取值范围为所有整数的自由变量组成的向量。

（c）我们可以使用步骤2（a）中的技巧来改写关于分划的等式。用步骤2（b）的结果替代向量（i1,i2,1），我们可以把关于分划的约束写成

![546-4](../Images/image04958.jpeg)

3）舍弃和分划无关的变量。上面的等式对所有的t都成立的条件是

［C1-C2　（c1-c2）］U=0

把这些等式改写成Ax=0的形式，其中x是一个由仿射分划的所有未知系数组成的向量。

4）找出这个仿射分划的秩并求解系数矩阵。因为一个仿射分划的秩和分划中常量项的值无关，所以消除所有来自于c1和c2等常量向量的未知量，从而把Ax=0替换为经过简化的约束A′x′=0。找出A′x′=0的解，并把它们表示为B，也就是可以生成A′的零空间的一组基本向量的集合。

5）找出常量项。从B中的每个基本向量中得到所求仿射分划的一行，并使用Ax=0来获得常量项。

请注意，步骤3忽略了因循环界限而加在变量t上的约束。由此而得到的仿射分划约束会更加严格，因此这个算法一定是安全的。也就是说，我们在假设t可取任意值的情况下生成了对C和c的约束。可以想象，如果考虑到对变量t的约束会使得t不可能取某些值，那么可能还会存在一些C和c的其他解。没有搜寻这样的解会使我们失去一些优化的机会，但不会使得被处理的程序所完成工作和原程序不同。
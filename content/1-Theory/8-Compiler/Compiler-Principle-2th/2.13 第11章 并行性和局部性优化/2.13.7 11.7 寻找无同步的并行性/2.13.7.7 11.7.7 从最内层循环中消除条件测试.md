### 11.7.7　从最内层循环中消除条件测试

第二个转换是从内层循环中消除条件测试。如上面的例子所示，如果循环中各个语句的迭代空间相交但是不重合，就需要保留条件测试语句。为了消除对条件测试的需求，我们把迭代空间分割成为子空间，每个子空间执行同样的语句集合。这个优化过程要求复制代码，且只应该用于消除内层循环的条件测试。

为了分割一个迭代空间以消除内层循环的条件测试，我们重复应用下列步骤直到消除内层循环中的所有条件测试：

1）选择一个由界限不同的多个语句组成的循环。

2）使用一个条件来分割循环，使得某个语句从至少一个分循环中被剔除。我们从相互重叠的不同多面体的边界中选择这个条件。如果某个语句的所有迭代都只位于这个条件的某个半个平面中，那么这个条件就是有用的。

3）为每一个迭代空间生成代码。

例11.48　让我们从图11-32的代码中删除条件测试。除了在两端的边界分划单元，语句

s1和s2被映射到同一个分划单元ID。因此，我们把分划空间分成三个子空间：

![550-2](../Images/image04963.jpeg)

图11-32　通过收紧循环界限进行改进之后的图11-29的代码

1）p=-100

2）-99≤p≤98

3）p=99

然后，就可以针对每个子空间中所包含的p的值对它的代码进行特化。图11-33中显示了这三个迭代空间的代码。

请注意，第一个和第三个空间不需要i或j的循环，因为定义这两个空间的p值是确定的，这些循环都是退化的，它们只有一个迭代。比如，在空间1中，在循环界限中把p替换为-100会把i限制为1，从而把j限定为100。在空间1和3中对p的赋值显然是死代码，因此可以被消除。

下面我们在空间2中分割下标为i的循环。循环下标i的第一次和最后一次迭代是不同的。因此，我们把这个循环分割为三个子空间：

1）max（1,p+1）≤i<p+2，其中只有s2被执行。

2）max（1,p+2）≤i≤min（100,100+p），其中s1和s2都被执行。

3）101+p<i≤min（101+p,100），其中只有s1被执行。

图11-33中第二个空间的循环嵌套因此可以被写成图11-34a所示的代码。

![551-1](../Images/image04964.jpeg)

图11-33　根据p的值分割迭代空间

图11-34b显示了经过优化的程序。我们已经用图11-34a替换了图11-33中相应的循环迭代结构。我们也已经把对p、i和j的赋值传播到数组访问中。当在中间代码层次上进行优化时，其中的一些赋值会被识别为公共子表达式，并从数组访问代码中重新抽取出来。

![551-2](../Images/image04965.jpeg)

图11-34　例11.48的代码

![552-1](../Images/image04966.jpeg)

图11-34　（续）
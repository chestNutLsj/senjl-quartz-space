### 11.10.2　数组收缩

数组收缩优化给出了另一个在存储和并行性之间进行折衷处理的例子。这种折衷方案首先在10.2.3节中讨论指令级并行性时引入。使用更多寄存器可以得到更大的指令级并行性。同样，使用更多的内存可以得到更多的循环级并行性。如11.7.1节中的多网格例子所示，把一个临时的标量变量变成一个数组就可以允许不同的迭代使用这个临时变量的不同实例，也就允许它们同时执行。反过来，如果我们有一个每次只操作一个数组元素的顺序执行过程，就可以收缩这个数组，把它替换为一个标量，并让各个迭代使用同一个位置。

在图11-24中显示的转换得到的多网格程序中，内层循环的每个迭代生成并消耗了AP、AM、T以及D的一行中的不同元素。如果这些数组不会在这个代码段之外使用，这些迭代就可以串行地复用同一个数据存储位置，而不是把这些值分别存放在不同的元素中或者不同行中。图11-62显示了减少这些数组的维度之后的结果。这个代码比原来的代码运行得更快，因为它读写的数据更少。特别是当一个数组被归约成一个标量变量时，我们可以把这个变量放在一个寄存器中，并完全消除了对内存访问的需求。

![576-1](../Images/image05034.jpeg)

图11-62　对图11-23进行分划（图11-24）和数组收缩之后的得到的代码

因为使用的内存更少，所以可用的并行性也变少了。转换得到的图11-62中的代码的迭代之间有了数据依赖关系，因此不能再并行执行。为了把代码在P个处理器上并行执行，我们可以把每个标量变量扩展出P个副本，并让每个处理器访问自己的副本。这样，内存扩展的数量就和被利用的并行性直接相关了。

通常，要寻找数组收缩机会的理由有三个：

1）用于科学应用的高级程序设计语言（比如Matlab和Fortran90）支持数组层次的运算。数组运算的每个子表达式都生成一个临时数组。因为这些数组可能很大，每个数组运算，比如乘法或加法，需要读写很多内存位置，同时对算术运算的需求相对较少。因此，我们对运算进行重新排序以便数据被生成后立刻就被消耗掉，同时也就把这些数组收缩成了标量变量。这样的处理是很重要的。

2）在20世纪80和90年代构造的超级计算机都是向量机，因此那时开发的很多科学计算应用都是针对这样的机器进行优化的。虽然存在向量化编译器，但很多程序员依然把他们的代码写成每次完成一次向量运算的方式。本章中多网格代码的例子就是这种风格的程序的例子。

3）收缩优化的机会也会由编译器引入。如多重网格例子中的变量T所演示的，一个编译器可能会扩展数组以提高并行性。如果这种空间扩展是不必要的，那么我们就必须对这个数组进行收缩处理。

例11.67　数组表达式Z=W+X+Y被翻译成为

![576-2](../Images/image05035.jpeg)

把这个代码改写成

![576-3](../Images/image05036.jpeg)

可以极大地提高代码的运行速度。当然，在C代码的层次上我们甚至不需要使用临时变量T，而是可以把对Z［i］的赋值语句写成单个语句。但这里我们正试图对中间代码层次进行建模。在这个层次上一个向量处理器将会处理这些运算。

算法11.68　数组收缩。

输入：一个由算法11.64转换得到的程序。

输出：一个等价的程序，但降低了数组的维度。

方法：一个数组的维度可以被收缩为一个元素的条件如下：

1）每个独立的分划单元只使用这个数组的一个元素。

2）这个元素在分划单元入口处的值没有被这个分划单元使用，且

3）这个元素的值在这个单元的出口处不活跃。

找出可收缩的维度，也就是满足上面三个条件的维度，并把它们替换为单个元素。

算法11.68假设这个程序首先由算法11.64进行转换，把所有相互依赖的运算都分配到同一个分划单元中，并顺序地执行这些分划单元。它找出了其元素在不同迭代中活跃范围不相交的数组变量。如果这些变量在循环之后不再活跃，它就可以收缩这个数组并让处理器在同一个标量位置上进行运算。在数组收缩之后，可能还有必要选择性地扩展一些数组，以应对并行性和其他局部性优化问题。

这里要进行的活跃性分析比9.2.5节中所描述的分析更加复杂。如果数组被定义为一个全局变量，或者它是一个参数，我们就需要使用过程间分析技术来保证不使用出口处的值。不仅如此，我们还需要计算单个数组元素的活跃性，保守地把数组当作一个标量进行活跃性分析会使结果不够精确。
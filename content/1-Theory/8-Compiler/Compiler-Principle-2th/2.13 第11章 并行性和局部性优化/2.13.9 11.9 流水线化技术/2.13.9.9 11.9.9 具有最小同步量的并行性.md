### 11.9.9　具有最小同步量的并行性

在前面的三节中，我们已经描述了三个功能强大的并行化算法：算法11.43可以找出所有不需要同步的并行性，算法11.54找出了所有只需要固定多次同步的并行性，而算法11.59找出了所有需要O（n）次同步的可流水线化的并行性，其中n是最外层循环的迭代数量。粗略地说，我们的目标是尽可能多地把一个计算过程并行化，同时尽量少地引入同步运算。

下面的算法11.64从最粗糙的并行性粒度开始，找出了一个程序中存在的所有并行度。在实践中，在为某个多处理器系统并行化一个代码时，我们并不需要利用所有层次上的并行性。我们总是利用最外层的并行性，直到所有的计算任务都被并行化，并且所有的处理器都被完全利用为止。

算法11.64　找出一个程序中存在的所有并行度，同时所有并行性的粒度都尽可能地粗糙。

输入：一个要进行并行化的程序。

输出：同一个程序的并行化版本。

方法：完成下列步骤：

1）找出不需要同步运算的并行性的最大度数，对这个程序应用算法11.43。

2）找出需要O（1）次同步运算的并行性的最大度数：对步骤1中找出的所有空间分划单元应用算法11.54。（如果在步骤1中没有找到无同步的并行性，那么所有的计算任务都在同一个分划单元中。）

3）找出需要O（n）次同步运算的最大并行性度数。对步骤2中找到的每个分划单元应用算法11.59，以找出可流水线化的并行性。然后对分配给各个处理器的分划单元逐个应用算法11.54。如果前面没有找到流水线化的并行性，就对串行循环的循环体应用算法11.54。

4）在逐步增加同步度数的情况下寻找最大的并行性度数。递归地把步骤3应用到上一步生成的各个空间分划单元中的计算任务上。

例11.65　现在让我们回到例11.56。算法11.64的步骤1和2都没有找到并行性。也就是说，为了并行化这个代码，我们需要的同步量大于一个常量。在步骤3中，应用算法11.59确定了只有一个合法的外层循环，这个循环就是图11-53中的原代码中的循环。因此，这个循环不具有可流水线化的并行性。在步骤3的第二部分，我们应用算法11.54来并行化内层循环。我们像处理整个程序那样来处理一个分划单元中的代码，不同之处仅在于我们像处理符号常量那样处理了分划单元的编号。在这个例子中，我们发现内层循环是可并行化的，因此这个代码可以使用n个同步栅障进行并行化。

算法11.64找出了一个程序中在各个同步层面上的并行性。这个算法优先求出需要较少同步量的并行化方案，但是最少同步运算并不表示通信量是最少的。这里我们讨论这个算法的两个扩展，以解决此算法的弱点。

考虑通信开销

如果没有发现无同步的并行性，算法11.64的步骤2对每个强连通分量独立地进行并行化。但是，某些这样的分量仍然可能在无同步和通信的情况下被并行化。解决方法之一是尽可能地在程序依赖图中共享大部分数据的子集之间寻找无同步的并行性。

如果强连通分量之间的通信是必须的，我们注意到有些通信的开销要高过其他通信的开销。比如，转置一个矩阵的开销要比两个相邻处理器之间通信的开销高得多。假设s1和s2分别是两个分离的强连通图中的语句，它们分别在迭代i1和i2中访问相同的数据。如果我们不能分别为语句s1和s2找到分划映射<C1,c1>和<C2,c2>使得

C1i1+c1-C2i2-c2=0

我们就试图满足约束

C1i1+c1-C2i2-c2≤δ

其中δ是一个小的常量。

用通信量交换同步量

有些时候，我们宁愿多进行一些同步运算以降低通信量。例11.66讨论了一个这样的例子。因此，如果我们不能在只允许相邻的强连通分量之间进行通信的情况下对一个代码进行并行化，我们将试图把这个计算任务流水线化，而不是独立地并行化各个分量。如例11.66所示，流水线化技术可以被应用到一个循环序列中。

例11.66　对于例11.49中的ADI集成算法，我们已经说明对第一和第二个循环嵌套结构进行独立优化可以在每个嵌套结构中找到并行性。但是，这样的方案要求在循环之间进行矩阵转置，从而出现O（n2）的数据流量。如果我们使用算法11.59来寻找可流水线化的并行性，就可以把整个程序转换成为一个完全可交换的循环嵌套结构，如图11-59所示。然后，我们可以应用分块技术来降低通信开销。这个方案将带来O（n）次的同步，但是需要的通信量要小很多。

![574-1](../Images/image05030.jpeg)

图11-59　例11.49的代码的一个完全可交换循环嵌套结构
### 11.9.8　代码转换

如果一个循环嵌套结构的时间分划约束存在k个独立解，那么就可能把这个循环嵌套结构转换成为具有k个最外层完全可交换循环的结构。可以对这个结构进行转换得到k-1度的流水线，或得到k-1个可并行化的内层循环。而且，我们还可以对完全可交换循环应用分块技术，以提高单处理器系统的数据局部性或降低并行执行中的处理器之间的同步开销。

利用完全可交换循环

如果一个循环嵌套结构的时间分划约束具有k个独立解，我们就可以容易地根据这些解生成一个循环嵌套结构，其最外层的k个循环是完全可交换的循环。通过直接把第k个解变成新转换的第k行，我们就可以得到这样的转换。一旦构造出这个仿射变换，我们就可以使用算法11.45来生成代码。

例11.61　在例11.58中为我们的SOR例子找到的解是

![569-3](../Images/image05023.jpeg)

令第一个解为转换后的第一行且第二个解为转换后的第二行，我们得到转换

![570-1](../Images/image05024.jpeg)

这个转换生成图11-51a中的代码。

如果我们把第二个解作为第一行，我们可以得到转换

![570-2](../Images/image05025.jpeg)

它生成图11-51c中的代码。

显然，这样的转换产生了一个合法的顺序程序。第一行按照第一个解来分划整个迭代空间。时间约束保证这样的分解不会违反任何数据依赖关系。然后，我们根据第二个解对各个最外层循环中的迭代进行分划。这个分划必然是合法的，原因是我们处理的是原来的迭代空间的子集。对于矩阵中的其余各行，以上讨论仍然成立。因为我们可以任意排列这些解，所以这些循环是完全可交换的。

利用流水线化技术

我们可以轻易地把一个具有k个最外层完全可交换循环的循环嵌套结构转换成为一个具有k-1度流水线并行性的代码。

例11.62　让我们回到SOR的例子。在例子中的循环都被转换为完全可交换的循环之后，我们知道只要在迭代［i1,i2-1］和［i1-1,i2］执行之后，迭代［i1,i2］就可以被执行。我们可以用如下方法在一个流水线中保证这个顺序。我们把迭代i1分配给处理器p1。每个处理器按照原来的顺序执行内层循环中的迭代，因此保证了迭代［i1,i2］在迭代［i1,i2-1］之后执行。另外，我们要求处理器p在执行迭代［p,i2］之前必须等待处理器p-1的信号，这个信号表明处理器p-1已经执行了迭代［p-1,i2］。这个技术可以根据图11-51a和图11-51b中的完全可交换循环分别生成图11-52a和图11-52b中的代码。

一般来说，给定k个最外层的完全可交换循环，具有下标值（i1,…,ik）的迭代可以执行且不违反数据依赖约束的前提是下列迭代

［i1-1,i2,…,ik］，［i1,i2-1,i3,…,ik］，…，［i1，…，ik-1，ik-1］

已经执行完毕。因此，我们可以按照如下方法把这个迭代空间的前k-1个维度的分划分配到O（nk-1）个处理器上。每个处理器负责一个迭代的集合，该集合中迭代的下标值在前k-1个维度上相同，而第k个下标值则包括了该下标的全部可能值。每个处理器顺序地执行第k个循环中的迭代。前k-1个循环下标值［p1,p2,…,pk-1］所对应的处理器可以执行第k个循环的第i个迭代的前提是它收到了处理器

［p1-1,p2,…,pk-1］，…，［p1,…，pk-2,pk-1-1］

发出的信号，表明它们已经执行完了各自的第k个循环中的第i个迭代。

波阵面化

根据一个具有k个最外层完全可交换循环的循环结构生成k-1个可并行化内层循环是比较容易的。虽然我们更倾向于使用流水线化，但为完整起见，我们仍在这里给出这个方法。

我们使用一个新的下标变量i′来分划一个具有k个最外层完全可交换循环的循环结构的计算任务，其中i′被定义为这k个可交换循环中所有下标的某种组合。比如，i′=i1+…+ik就是这样的一个组合。

我们创建一个最外层的顺序循环，该循环以升序遍历这个i′分划，在各个分划单元中的计算任务依然按以前的顺序执行。每个分划单元中的前k-1个循环一定是可并行化的。直观地讲，如果给定一个二维的迭代空间，这个转换沿着135°的斜线把迭代组合起来，作为外层循环的一次执行。这个策略保证了在最外层循环中的各个迭代之间没有数据依赖。

分块

一个深度为k的完全可交换的循环嵌套结构可以在k个维度上进行分块。我们可以把多个迭代的块组合成为一个单元，而不是根据最外层或者最内层的循环下标值把迭代分配给处理器。分块技术可以用于增强数据局部性并最小化流水线的开销。

假设我们有一个二维完全可交换的循环嵌套结构，如图11-55a所示，且我们希望把这个结构的计算任务分成b×b块。分块后的代码的执行顺序如图11-56所示，等价的代码显示在图11-55b中。

![571-1](../Images/image05026.jpeg)

图11-55　一个二维循环嵌套结构和它的分块版本

![571-2](../Images/image05027.jpeg)

图11-56　在对一个深度为2的循环嵌套结构分块之前和分块之后的执行顺序

如果我们把每个块分配给一个处理器，那么在同一个块中从一个迭代到另一个迭代的数据传递不需要处理器之间的通信。我们还可以把块的一列分配给一个处理器，以便加粗流水线的粒度。请注意，每个处理器只在块的边界上和它的前驱及后继进行通信。因此，分块的另一个优点是程序只需要在块和它的邻居块的边界上交换被访问的数据。处于块内部的数据仅由一个处理器处理。

例11.63　现在我们使用一个真实的数值算法——Cholesky分解——来说明算法11.59是如何在只有流水线化并行性的情况下处理单循环嵌套结构的。图11-57中显示的代码实现了一个O（n3）的算法，该算法对一个二维数据数组进行运算。被执行的迭代空间是一个三角形的金字塔结构，因为j只会遍历到外层循环下标i的值，而k只会遍历到j的值。这个循环结构有四个语句，各个语句都嵌套在不同的循环中。

![571-3](../Images/image05028.jpeg)

图11-57　Cholesky分解

对这个程序应用算法11.59可以找到三个合法的时间维度。它把所有的运算都嵌入到一个三维的完全可交换的循环嵌套结构中去。其中的某些运算在原程序中是嵌套在深度为1或2的循环结构中的。图11-58中显示了得到的代码和相应的映射。

![572-1](../Images/image05029.jpeg)

图11-58　写成完全可交换循环结构的图11-57的代码

代码生成例程保证了运算的执行都位于原来的循环界限中，以保证新的程序只执行原来代码中的运算。我们可以把这个代码流水线化，方法是把这个三维结构映射到二维的处理器空间中。迭代（i2,j2,k2）被分配给ID为（i2,j2）的处理器。每个处理器执行循环下标为k2的最内层的循环。在它执行第k个迭代之前，这个处理器会等待ID为（i2-1,j2）和（i2,j2-1）的处理器发来的信号。在它执行了它的迭代之后，它会给处理器（i2+1,j2）和（i2,j2+1）发出信号。
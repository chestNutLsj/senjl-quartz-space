### 11.9.6　时间分划约束

现在我们关注寻找流水线化并行性的问题。我们的目标是把一个计算任务转变成为一组可流水线化的任务。为了找到流水线化的并行性，我们没有像处理循环并行性时那样直接求出各个处理器上将执行哪些计算，而是提出了下面的根本性问题：所有可能的遵循循环中原有数据依赖关系的执行序列有哪些？显然，原来的执行序列满足所有的数据依赖关系。问题是是否存在这样的仿射转换，由它可以创建另一种调度，使得最外层循环的各个迭代执行的运算集合和原来不同，但是依然满足所有的依赖关系。如果我们能够找到这样的转换，就能够把这个循环结构流水线化。要点在于如果在调度运算时存在自由度，那么就存在并行性。后面将会解释如何从这样的转换中获取流水线化并行性的细节问题。

为了找出可接受的外层循环的重新排序，我们希望为每个语句找到一个一维仿射变换，这个变换把原来的循环下标值映射到最外层循环的迭代编号上。如果这样的分配能够满足程序中的所有数据依赖关系，那么变换就是合法的。下面显示的“时间分划约束”就是说如果一个运算依赖于另一个运算，那么分配给前一个运算的最外层循环的迭代必须不早于分配给第二个运算的迭代。如果它们被分配到同一个迭代，我们都知道在此迭代中第一个运算必须在第二个之后执行。

程序的一个仿射分划映射是一个合法的时间分划（legal-time partition）当且仅当对于任意两个具有依赖关系的（可能相同的）访问，比如嵌套在循环结构d1中的语句s1中的访问

![565-1](../Images/image05006.jpeg)

和嵌套在循环结构d2中的语句s2的访问

![565-2](../Images/image05007.jpeg)

分别对应于语句s1和s2的一维分划映射<C1,c1>和<C2,c2>满足下面的时间分划约束（time-partition constraint）：

- 对于满足下列条件的![565-5](../Images/image05008.jpeg)中所有的i1和![565-6](../Images/image05009.jpeg)中的所有i2

1）![565-3](../Images/image05010.jpeg)

2）B1i1+b1≥0

3）B2i2+b2≥0

4）F1i1+f1=F2i2+f2

必然有C1i1+c1≤C2i2+c2。

图11-54中显示的这个约束和空间分划约束看起来非常相似。它是空间分划约束的一个放松版本。如果两个迭代指向同一个位置，这个约束不要求它们被映射到同一个分划单元。我们只要求这两个迭代之间的相对执行顺序保持不变。也就是说，在空间分划约束中使用=的地方，这个约束使用≤。

![565-4](../Images/image05011.jpeg)

图11-54　时间分划约束

我们知道，这个时间分划约束至少存在一个解。我们可以把最外层循环的每个迭代中的运算映射到同一个迭代中去，此时所有的数据依赖关系都得到满足。对于那些不能被流水线化的程序，这个解是它们的时间分划约束的唯一解。另一方面，如果我们能够找到时间分划约束的多个独立解，这个程序就能够被流水线化。每个独立解对应于最外层完全可交换循环嵌套结构中的一个循环。如你所期望的，因为例11.56中的程序没有可流水线化的并行性，因此从中抽取得到的时间分划约束只有一个独立解。而上面的SOR代码的例子则存在两个独立解。

例11.57　我们考虑一下例11.56，特别是考虑语句s1和s2中对数组X的引用之间的依赖关系。因为语句s2中的访问不是仿射的，所以在涉及语句s2的依赖分析中，我们把矩阵X建模为一个标量变量，从而近似地处理这个访问。令（i,j）为s1的一个动态实例的下标值，令i′为s2的一个动态实例的下标值。令语句s1和s2的计算任务的映射分别为<［C11,C12］,c1>和<［C21］,c2>。

让我们首先考虑从s1到s2的依赖关系所决定的时间分划约束。这样，如果i≤i′，那么转换之后的s1的第（i,j）个迭代不得晚于转换之后的s2的第i′个迭代。也就是说

![566-1](../Images/image05012.jpeg)

展开后得到

C11i+C12j+c1≤C21i′+c2

因为j和i及i′无关，所以可以取任意大的值，因此C12=0必须成立。可知，这个约束的一个可能的解是

C11=C21=1且C12=c1=c2=0

对于从s2到s1以及从s2到其自身的依赖关系的分析将得到类似的结果。外层循环的第i个迭代由s2的第i个实例和s1的所有实例（i,j）组成。在这个特定的解中，这个迭代将被分配给第i个时间步骤。选择其他的C11、C12、C21、c1、c2的值会得到类似的分配方法，但是会存在一些不进行任何运算的时间步骤。也就是说，调度这个外层循环的所有方法都要求其中的迭代按照与原代码同样的顺序进行。不管全部的100个迭代是在同一个处理器上执行，还是在100个不同的处理器上执行，又或在1～100之间的任意多个处理器上运行，上面的论断都成立。

例11.58　在图11-50a中显示的SOR代码中，写引用X［j+1］和它本身，以及代码中的三个读引用之间具有依赖关系。我们要为该赋值语句寻找计算任务的映射<［C1,C2］,c>，使得如果存在从（i,j）到（i′,j′）的依赖关系，那么

![566-2](../Images/image05013.jpeg)

根据定义，![566-3](../Images/image05014.jpeg)，也就是说，要么i<i′，要么（i=i′∧j<j′）。

让我们考虑三对数据依赖关系：

1）从写访问X［j+1］到读访问X［j+2］之间的真依赖关系。因为它们的实例必须访问同一个位置，因此j+1=j′+2，或者说j=j′+1。把j=j′+1替换到时间约束中，我们得到

C1（i′-i）-C2≥0

由j=j′+1可知j>j′，上面的先后关系约束归约为i<i′。因此

C1-C2≥0

2）从读访问X［j+2］到写访问X［j+1］的反依赖关系。这里j+2=j′+1，即j=j′-1。把j=j′-1代入时间约束我们得到

C1（i′-i）+C2≥0

当i=i′时得

C2≥0

当i<i′时，因为C2≥0，我们得到

C1≥0

3）从写访问X［j+1］到自身的输出依赖。这里j=j′。时间约束被归约为

C1（i′-i）≥0

因为只有i<i′是相关的，我们还是得到

C1≥0

其余的依赖关系没有产生任何新的约束。总共有三个约束：

C1≥0

C2≥0

C1-C2≥0

下面是这些约束的两个独立解：

![567-1](../Images/image05015.jpeg)

第一个解保持了最外层循环的迭代执行顺序。图11-50a中原来的SOR代码和图11-51a中转换得到的代码都是这种安排的例子。第二个解把沿着135°斜线上的迭代放置在外层循环的同一个迭代中。图11-51b中显示的是具有这种最外层循环组成方式的代码的一个例子。

请注意，存在多个其他可能的独立解对，比如

![567-2](../Images/image05016.jpeg)

也是具有同样约束的独立解。我们选择最简单的向量来简化代码转换。
## 11.13　第11章参考文献

要得到关于多处理器体系结构的详细讨论，读者可参阅Hennessy和Patterson的教科书［9］。

Lamport［13］和Kuck、Muraoka及Chen［10］引入了数据依赖分析的概念。早期的数据依赖分析测试使用启发式规则，通过确定丢番图方程和线性实数不等式系统是否无解来确定一对引用是否独立：［5，6，26］。Maydan、Hennessy和Lam［18］把数据依赖关系测试写成了整数线性规划的形式，并证明这个问题在实践中可以精确高效地求解。本章描述的数据依赖关系分析基于Maydan、Hennessy、Lam［18］和Pugh及Wonnacott［23］的工作。这些分析技术使用了Fourier-Motzkin消除算法［7］和Shostak的算法［25］。

在20世纪70年代和80年代早期已经有人利用循环转换来改进向量化和并行化：循环融合［3］、循环裂变［1］、条状挖掘［17］和循环互换［28］。在当时进行了三个主要的实验性的并行化/向量化项目：在Illinois Urbana-Champaingn大学由Kuck领导的Parafrase项目［21］，由Rice大学的Kennedy领导的PFC项目［4］和在IBM研究院由Allen领导的PTRAN项目［2］。

McKellar和Coffman［19］最先讨论了使用分块技术来提高数据局部性的理论。Lam、Rothbert和Wolf［12］率先在现代体系结构的高速缓存上对分块技术进行了深入的实验分析。Wolf和Lam［27］使用线性代数技术来计算循环中的数据复用。Sarkar和Gao［24］引入了数组收缩优化技术。

Lamport［13］首先把循环建模为迭代空间，并使用混合规划技术（仿射转换的一个特殊情况）来为多处理器系统寻找并行性。仿射转换的最原始出处是心跳阵列算法的设计［11］。作为直接实现在VLSI上的并行算法，心跳阵列要求在并行化的同时最小化通信量。代数技术用于把计算映射到空间和时间坐标上。仿射调度方案的概念以及在仿射转换中使用Farkas引理首先由Feautrier［8］提出。本章描述的仿射转换算法基于Lim等人的工作［15，14，16］。

Porterfield提出了第一个预取数据的编译器算法。Mowry、Lam和Gupta［20］应用复用分析来使预取数据的开销降到最小，并在整体上提高了性能。

![585-1](../Images/image05049.jpeg)

![586-1](../Images/image05050.jpeg)

![587-1](../Images/image05051.jpeg)

---

[^1]: 你可以复习一下7.4节中对高速缓存和高速缓存线的讨论。

[^2]: 在本章中的程序中，我们通常将使用C语言的语法，但是为了使得多维数组访问（这是本章大部分内容的中心问题）的代码更加易于理解，我们将使用Fortran风格的数组访问，也就是说，使用Z［i,j］而不是Z［i］［j］。

[^3]: 这里有一个微妙之处。根据加法的交换率，不管我们按照什么顺序执行加法，我们依然得到相同的结果。但是，这种情况是很特别的。一般来说，让编译器来决定在一个写运算之前的一系列算术运算步骤完成哪些计算过于复杂。我们也不能依赖于会有任何代数规则来帮助我们安全地重新排列这些步骤。

[^4]: 在这里可以观察到一件很有意思的事情。虽然这个例子有一个解，但如果我们把第三个分量i+j改成i+j+1，解就不存在了。也就是说，在这个给定的例子中，两个访问所触及的数组元素都存在于一个二维的子空间S中。该空间可以定义为“第三个分量是前面两个分量的和”。如果我们把i+j改成i+j+1，则第二个访问所触及的元素都不在S中，因此也不存在任何复用。

[^5]: 回忆一下静态访问和动态访问之间的区别。一个静态访问是程序中某个位置上的数组引用，而一个动态访问是这个引用的一次执行。

[^6]: 请记住，我们没有利用加法的交换率和结合率。

[^7]: 即不断下移一步再右移两步所得到的点的序列。
### 11.5.4　组复用

我们只在同一个循环中的具有相同系数矩阵的数组访问之间计算组复用。给定两个动态访问Fi1+f1和Fi2+f2，它们复用相同的数据的条件是

Fi1+f1=Fi2+f2

或者说

F（i1-i2）=（f2-f1）

假设v是这个等式的一个解，如果w是F的零空间中的任意向量，那么w+v也是一个解。实际上，这样的向量就是该方程的全部解。

例11.27　下面的深度为2的循环嵌套结构

![529-1](../Images/image04912.jpeg)

有两个数组访问Z［i,j］和Z［i-1,j］。请注意，这两个访问都可以使用系数矩阵

![529-2](../Images/image04913.jpeg)

来刻划。这个矩阵和图11-19中的第二个访问Y［i,j］的矩阵一样。这个矩阵的秩为2，因此没有自时间复用。

但是，每个访问都展示了自空间复用。如11.5.3节中所述，当我们删除该矩阵的最下面一行后，只留下最上面的一行［1,0］，其秩为1。因为［0,1］位于这个被截短矩阵的零空间中，所以我们期望找到空间复用。内层循环下标j的每次增加都会把第二个下标的值增加1，实际上确实访问了连续的数组元素，并将充分利用每个高速缓存线。

虽然两个访问都没有自时间复用性，请注意这两个访问Z［i,j］和Z［i-1,j］所访问的几乎是同一个集合的数组元素。也就是说，除了i=1的情况之外，数组访问Z［i-1,j］所读取的数据和数组访问Z［i,j］所写入的数据相同，因此它们之间存在组时间复用。这个简单的访问模式对于整个迭代空间都成立，可以利用这个模式来提高代码的数据局部性。正式地讲，如果不考虑循环界限，那么只要

![529-3](../Images/image04914.jpeg)

成立，分别位于迭代（i1,j1）和迭代（i2,j2）中的两个数组访问Z［i,j］和Z［i-1,j］指向同一个位置。改写这些项，我们得到

![529-4](../Images/image04915.jpeg)

也就是说，j1=j2且i2=i1+1。

请注意，这个复用是沿着迭代空间的i轴发生的。也就是说，迭代（i2,j2）在迭代（i1,j1）发生之后的n次（内层循环的）迭代之后才发生。因此，在被写入数据被复用之前要执行很多个迭代。此时这个数据有可能在（也有可能不在）高速缓存中了。如果高速缓存中存放了矩阵Z的连续两行，那么数组访问Z［i-1,j］不会发生高速缓存脱靶现象，整个循环嵌套结构的总的高速缓存脱靶数量为n2/c，其中c是每个高速缓存线中的元素数量。否则，脱靶次数将会为原来的两倍，因为这两个静态访问对于每c个动态访问都要求加载一个新的高速缓存线。

例11.28　假设在一个深度为3的循环嵌套结构中有两个访问A［i,j,i+j］和A［i+1,j-1,i+j］。该嵌套结构的下标从外到内分别是i、j、k。那么对于两个访问i1=［i1,j1,k1］和i2=［i2,j2,k2］，只要

![530-1](../Images/image04916.jpeg)

成立，它们就能复用同一个数组元素。

这个方程成立时，向量v=［i1-i2,j1-j2,k1-k2］的一个解为v=［1,-1,0］。也就是说i1=i2+1，j1=j2-1且k1=k2。[^4]然而，矩阵

![530-2](../Images/image04917.jpeg)

的零空间是由基本向量［0,0,1］生成的。也就是说，第三个循环下标k可以是任意值。因此，上面方程的解v可以是［1,-1,m］，其中m为任意值。换句话说，在一个下标为i、j、k的循环嵌套结构中，A［i,j,i+j］的一个动态访问不仅被A［i,j,i+j］的具有同样i、j值和不同k值的其他动态访问所复用，也被A［i+1,j-1,i+j］的其循环下标值为i+1、j-1和任意k值的动态访问所复用。

我们可以用类似的方法来考虑组空间复用，虽然不会在这里这么做。和针对自空间复用的讨论一样，我们只需要舍弃被考虑矩阵的最后一维就可以了。

对于不同种类的复用，复用的程度是不同的。自时间复用的好处最多：一个具有k维零空间的数组访问对同一个数据会复用O（nk）次。自空间复用的程度受到高速缓存线长度的限制。最后，组复用的程度受一个组中共享该复用的数组访问数目的限制。
## 11.5　数据复用

从数组访问函数中我们得到了两种可用于局部性优化和并行化的有用信息：

1）数据复用：对于局部性优化，我们希望识别出访问相同数据或相同高速缓存线的迭代集合。

2）数据依赖：为了并行化和局部性循环转换的正确性，我们希望找出代码中的所有数据依赖关系。回顾一下，如果两个（不一定不同的）访问的实例可能指向相同的内存位置，并且其中至少有一个是写运算，那么这两个访问之间具有数据依赖关系。

在很多情况下，只要我们找到了复用相同数据的迭代，就知道它们之间必然存在数据依赖关系。

只要存在数据依赖关系，显然就会有相同的数据被复用。比如，在矩阵乘法中，输出数组中的同一个元素被写O（n）次。这些写运算必须按照原来的顺序执行[^3]，我们可以分配一个寄存器，令它在计算输出数组的一个元素时存放该元素。这个就可以利用这个数据复用机会。

不过，并不是所有的数据复用都可以用到局部性优化中，下面的例子说明了这个问题。

例11.19　考虑下面的循环：

![524-1](../Images/image04901.jpeg)

我们观察到这个循环在每次迭代时都对不同的内存位置进行写运算，因此在不同的写操作之间没有复用或者依赖关系。但是，这个循环从位置5、8、11、14、17、…读取数据，而向位置3、10、17、24…写入数据。不同迭代的读运算和写运算访问了共同的元素17、38和59…。也就是说，对于j=0,1,2,…，形如17+21j（j=0，1，2，…）的整数就是所有既可以写作7i1+3，又可以写作3i2+5的整数，这里i1，i2是两个整数。但是这种复用很少发生，因此即使有可能利用这种复用，也不容易做到。

数据依赖和复用分析的不同之处在于：具有数据依赖关系的访问中必须有一个访问是写访问。更重要的是，数据依赖关系必须既正确又精确。为了保持正确性，它必须找到所有的依赖关系。但是，它又不应该找出假的依赖关系，因为这些假依赖关系会引起不必要的串行执行。

考虑数据复用时，我们只需要找出大部分可利用的复用在哪里。这个问题就简单多了，因此我们在本节中就讨论这个主题，接下来再讨论数据依赖问题。因为循环界限很少改变复用区域的形状，所以可以通过忽视循环界限来简化对复用的分析。可以被仿射分划利用的很多数据复用位于相同数组访问的不同实例之间，以及使用相同的系数矩阵（即在仿射下标函数中通常被称为F的矩阵）的访问之间。上面介绍过，像7i+3和3i+5这样的访问模式没有令人感兴趣的复用。
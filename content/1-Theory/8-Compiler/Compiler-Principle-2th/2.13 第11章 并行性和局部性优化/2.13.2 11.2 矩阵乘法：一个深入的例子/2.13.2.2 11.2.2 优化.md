### 11.2.2　优化

图11-5中的矩阵相乘算法说明了这样的事实：即使一个算法可能复用同样的数据，它的数据局部性仍然可能很差。要使得一次数据复用能够在高速缓存中命中，它就必须在该数据被转移出高速缓存之前发生。在本例中，n2个乘-加法把对矩阵Y中同一个元素的复用分开了，因此数据局部性变得很差。实际上，n次运算把对Y中同一高速缓存线内的数据的复用分开。另外，在一个多处理器系统中，只有当数据被同一个处理器复用时才可能发生高速缓存命中事件。当我们在11.2.1节中考虑一个并行实现时，我们看到Y的元素必须被每一个处理器使用。因此，对Y的复用并没有转化为局部性。

改变数据布局

改善一个程序的局部性的方法之一是改变它的数据结构的布局。比如，把Y按列存放将提高对矩阵Y的高速缓存线的复用。这个方法的应用范围是有限的，因为同一个矩阵通常会在不同的运算中使用。如果在另一个矩阵乘法运算中Y扮演了X的角色，那么又会因为按列存放而损害效率，因为在一个乘法运算中的第一个矩阵按行存放比较好。

分块

有时可以通过改变指令执行的顺序来改善数据局部性。但是循环互换的技术并不能提高矩阵乘法例程的效率。假设把这个例程改写成每次生成矩阵Z的一列，而不是一行。也就是说，把j循环变成外层循环而i循环变成内层循环。假设这些矩阵仍旧按行存放，矩阵Y就有比较好的空间局部性和时间局部性，但会损害矩阵X的局部性。

分块（blocking）是另一种对循环中的迭代重新排序的方法，它可以大大提高一个程序的局部性。我们不再一次计算结果矩阵的一行或者一列，而是按照图11-7中所示把矩阵分割成为子矩阵，或者说块。然后，我们对运算重新排序，使得整个块只在一小段时间内使用。通常情况下，这些块是边长为B的正方形。如果B整除n，那么所有的块都是正方形。如果B不能整除n，那么在矩阵下面或右面的边上的块的一条或者两条边的长度小于B。

![512-1](../Images/image04871.jpeg)

图11-7　一个被分割成边长为B的块的矩阵

图11-8显示了基本矩阵相乘算法的一个版本。在这个版本中，全部三个矩阵被划分为边长为B的正方形。和图11-5中一样，假设Z已经被初始化为全0矩阵。我们假设B整除n，如果不是这样的话，就需要把第（4）行中的上限修改为min（ii + B,n），并对第5和6行做类似的修改。

![513-1](../Images/image04872.jpeg)

图11-8　基于分块技术的矩阵乘法

外面的三层循环，即第1行到第3行，使用下标变量ii、jj和kk。这些变量的增量总是B，因此它们总是表示了某个块的左面或上面的边。对于固定的ii、jj、kk的值，第4行到第7行计算了以X［ii,kk］和Y［kk,jj］为左上角的两个块的乘积并加到以Z［ii,jj］为左上角的块中去。

当不能够把X、Y、Z一起放到高速缓存中时，如果我们选择了适当的B值，和基本算法相比，我们可以明显地降低高速缓存脱靶的数量。选择B使得可以把每个矩阵的各个块一起放到缓存中去。因为上面的算法中各个循环的顺序，我们实际上只需要把Z中的每个块放到高速缓存中一次就可以了。因此（像我们在11.2.1节中对基本算法所作的分析那样）我们将不需要计算因为Z而产生的高速缓存脱靶。

把X或Y的一个块载入到高速缓存需要B2/c次高速缓存脱靶。请记住，c是一个高速缓存线中的元素的个数。但是，对于确定的分别来自X和Y的块，我们在图11-8的第4行到第7行中进行了B3次乘-加法运算。因为整个矩阵乘法需要n3次乘-加法运算，所以把两个块加载进缓存的次数是n3/ B3。因为每次加载一个块时会碰到2B2/c次高速缓存脱靶，所以总的缓存脱靶数量是2n3/Bc。

把这个数字2n3/Bc和11.2.1节中给出的估计值相比是很有意思的。在那一节中，我们说，如果整个矩阵可以一起放到高速缓存中的话，就将出现O（n2/c）次高速缓存脱靶。然而，在那种情况下，我们可以令B=n，即把每个矩阵当成一个块。我们仍然可以得到前面估算的O（n2/c）次高速缓存脱靶。另一方面，我们观察到如果不能把整个矩阵放到高速缓存中，就需要O（n3/c）次高速缓存脱靶，甚至O（n3）次脱靶。在这种情况下，假设我们可以选择相当大的B值（比如B可以是200，此时仍然可以把三个8字节数字的块放到一个1MB的高速缓存中），在矩阵乘法中使用分块技术有很大的优越性。

分块技术可以被应用到内存层次结构的各个层次上。比如，我们可能希望通过把一个2×2矩阵乘法的运算分量都放到寄存器中，以优化对寄存器的使用。对于不同层次的高速缓存和物理内存，我们使用逐渐增大的分块尺寸。

类似地，我们可以把各个块分布到不同的处理器上，以便使数据流量达到最小。实验显示，这样的优化在单处理器情况下的性能加速比可以达到3，而在多处理器系统上的加速比几乎和所使用的处理器数量成线性关系。

基于块的矩阵乘法的另一个视点

我们可以想象图11-8中的矩阵X、Y、Z并不是n×n的浮点数的矩阵，而是（n/B）×（n/B）的矩阵，而这个矩阵的元素本身又是B×B的浮点数的矩阵。那么，图11-8中的第1行到第3行就像是图11-5中的基本算法的三个循环，但是它们处理的矩阵的大小是n/B，而不是n。我们可以把图11-8的第4行到第7行看作是图11-5中的单个乘-加法运算的实现。请注意，在这个运算中的单个乘法步骤对应于一个矩阵乘法步骤，使用了图11-5中对元素为浮点数的两个矩阵相乘的基本算法。矩阵加法就是各个元素上的浮点数加法。
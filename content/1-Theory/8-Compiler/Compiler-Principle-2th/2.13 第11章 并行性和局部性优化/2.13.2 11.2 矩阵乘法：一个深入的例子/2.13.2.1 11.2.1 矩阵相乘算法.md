### 11.2.1　矩阵相乘算法

在图11-5中，我们看到一个典型的矩阵乘法程序[^2]。

![510-2](../Images/image04869.jpeg)

图11-5　基本的矩阵相乘算法

图11-5中的代码生成n2个结果，每个结果都是矩阵X的某行和矩阵Y的某列的内积。显然，矩阵Z的每一个元素的计算都是独立的，因此可以并行执行。

n的值越大，算法访问各个元素的次数就越多。也就是说，这三个矩阵中有3n2个位置，但是这个算法执行n3次运算，每次运算把X的一个元素和Y的一个元素相乘并把乘积加到Z的一个元素中。因此算法是计算密集型的，从原则上来讲内存访问不应该成为瓶颈。

矩阵乘法的串行执行

我们首先考虑这个程序在单处理器上顺序运行时是如何工作的。最内层循环读写Z的同一个元素，并使用X的一行和Y的一列。可以很容易地把Z［i,j］放到一个寄存器中，不需要进行内存访问。不失一般性，假设这个矩阵是按行存放的，并假设c是高速缓存线中的数组元素的个数。

图11-6给出了当我们执行图11-5中的外层循环的一个迭代时的访问模式。这张图显示的是第一个迭代的情况，此时i=0。每次我们从X的第一行的一个元素移动到下一个元素时，都会访问Y的某一列中的各个元素。在图11-6中可以看到假设的将各个矩阵组织成高速缓存线的方法。也就是说，每个小矩形表示了一个存放四个数组元素的高速缓存线（即在此图中，c=4且n=12）。

![511-1](../Images/image04870.jpeg)

图11-6　在矩阵乘法中的数据访问模式

对X的访问几乎没有增加高速缓存的负担。X的一行只分布在n/c个高速缓存线中。如果这一行元素可以被一起放到高速缓存中，对于一个给定的下标i的值只会发生n/c次高速缓存脱靶，而整个X的脱靶数量在最少情况下为n2/c（为方便起见，我们假设n可以被c整除）。

但是，当使用X的一行时，该矩阵相乘算法逐列访问Y的所有元素。也就是说，当j=0时，内层循环把Y的整个第一列都搬到了高速缓存中。请注意，该列的所有元素存放在n个不同的高速缓存线中。如果高速缓存大到（或者n小到）可以存放所有这n个高速缓存线，并且没有对高速缓存的其他使用使得某些高速缓存线被清除出高速缓存，那么当需要Y的第二列时，对应于j=0的列仍然在高速缓存中。在此情况下，在j=c之前就不会产生n次对Y的脱靶。当j=c时，我们需要把对应于Y的另一组完全不同的高速缓存线载入到高速缓存中。因此，完成外层循环的第一个迭代（即i=0）所碰到的高速缓存脱靶次数在n2/c到n2之间。具体的脱靶次数取决于Y的高速缓存线列能否从第二个循环的一次迭代存活到下一个迭代。

不仅如此，当我们完成i=1，2，…外层循环时，在读取Y的元素时可能会碰到更多的高速缓存脱靶，也可能完全没有脱靶。如果高速缓存大到可以把Y的所有n2/c个高速缓存线一起存放在高速缓存中，那么就不会再碰到任何脱靶。因此，整个脱靶次数是2n2/c，一半在访问X时发生，另一半在访问Y时发生。但是，如果目标机器的高速缓存只能存放Y的一列，而不是全部Y，那么每次执行外层循环的一个迭代时，我们需要把Y的所有元素再次载入到高速缓存中。也就是说，高速缓存脱靶的次数是n2/c+n3/c，其中的第一项是访问X时的脱靶次数，而第二项是访问Y时的脱靶次数。在最坏情况下，如果我们甚至不能把Y的一列一起存放在高速缓存中，那么外层循环的每次迭代都有n2个高速缓存脱靶，总计有n2/c+n3次脱靶。

逐行并行化

现在我们考虑可以如何使用多个处理器（比如说p个）来加快图11-5中程序的执行。一个很显然的并行化矩阵乘法的方法是把Z的各行分配给不同的处理器。每个处理器负责n/p个连续的行（为方便起见，我们假设n可以被p整除）。通过这样分配工作量，每个处理器只需要访问矩阵X和Z的n/p行，但是要访问整个Y矩阵。每个处理器将计算Z的n2/p个元素。为了计算得到这些元素，它需要进行n3/p次乘-加法运算。

这样做之后，虽然计算时间减少和p成正比，但通信开销的增长实际上和p成正比。也就是说，每个p处理器必须读取n2/p个X的元素，但是要读取Y的所有n2个元素。必须被加载到这p个处理器的高速缓存中的高速缓存线的总数最少为n2/c+pn3/c，这两项分别对应于加载X和加载Y副本的数量。当p的值趋近于n时，计算时间变为O（n2），但是通信开销为O（n3）。也就是说，在内存和处理器高速缓存之间移动数据的总线成为性能瓶颈。因此，对于给定的数据布局而言，使用大量的处理器来平分计算量实际上会降低计算速度，而不是加快计算速度。
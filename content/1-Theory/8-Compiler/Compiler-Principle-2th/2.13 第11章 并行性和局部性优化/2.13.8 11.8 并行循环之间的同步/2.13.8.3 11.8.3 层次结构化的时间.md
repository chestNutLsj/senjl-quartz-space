### 11.8.3　层次结构化的时间

在一般情况下，关系![558-4](../Images/image04988.jpeg)的计算是很困难的。但是对于某些类型的程序而言，我们有一个直接的方法来计算这种依赖关系。本节中的优化技术经常被应用于这一类程序。假设这个程序是块结构的，由循环和简单的算术运算组成，并且不包含其他控制结构。该程序中的语句要么是一个赋值语句，要么是一个语句序列，要么是一个其循环体为单个语句的循环结构。这样，这个程序的控制结构就形成了一个层次结构。这个层次结构的顶层结点表示对应于整个程序的语句。单个赋值语句是一个叶子结点。如果某语句是一个语句序列，那么它的子结点就是该序列中的语句。这些子结点按照语句的词典排序从左到右排列。如果某语句是一个循环结构，那么它的子结点就是循环体对应的子图，通常是由一个或多个语句组成的序列。

例11.53　图11-43中程序的层次结构显示在图11-44中。执行序列的层次结构特性在图11-45中着重显示。语句s0的唯一实例在所有其他运算之前进行，因为它是被执行的第一个语句。接下来，我们执行来自外层循环的第一个迭代的所有指令，然后再执行第二个迭代中的指令，这样一直向前执行。对于循环下标i的值为0的所有动态实例，语句s1、L2、L3和s5按照正文顺序执行。我们可以重复上面的讨论，生成执行顺序的其他部分。

![558-3](../Images/image04989.jpeg)

图11-43　一个按层次结构组织的程序

![559-1](../Images/image04990.jpeg)

图11-44　例11.53中的程序的层次结构

![559-4](../Images/image04991.jpeg)

图11-45　例11.53中的程序的执行顺序

我们可以用一种层次结构化的方式来解决由两个不同语句生成的两个实例之间的顺序问题。如果两个语句处于同一个循环中，我们从最外层循环开始比较它们的共同循环的下标变量的值。当我们发现它们的某个下标具有不同值时，这个差值就决定了它们之间的顺序。只有当较外层循环的下标值都相同的时候，我们才需要比较下一个内层循环的下标值。这个过程类似于我们比较以小时/分钟/秒的方式所表示的时间。比较两个时间时，我们首先比较小时数，只有当它们的小时数相同的时候，我们才比较分钟，以此类推。如果所有公共循环的下标值都相同，那么我们根据它们的相对正文位置来决定它们之间的顺序。因此，我们一直在讨论的简单嵌套循环程序的执行顺序经常被称为“层次结构化”的时间。

令s1为一个嵌套在深度为d1的循环中的语句，而s2嵌套在深度为d2的循环中，它们之间有d个公共（外层）循环。当然d≤d1且d≤d2。假设![559-5](../Images/image04992.jpeg)为s1的一个实例，而![559-6](../Images/image04993.jpeg)为s2的一个实例。

![559-2](../Images/image04994.jpeg)当且仅当下列条件之一成立：

1）![559-3](../Images/image04995.jpeg)，或者

2）［i1,i2,…id］=［j1,j2,…jd］，且在正文上s1出现在s2之前。

断言![559-3](../Images/image04995.jpeg)可以写成如下的线性不等式的析取式。

（i1<j1）∨（i1=j1∧i2<j2）∨…∨

（i1=j1∧…∧id-1=jd-1∧id<jd）

只要数据依赖关系的条件和上面的析取式中的某个子句同时成立，就存在一个从s1到s2的PDG边。因此，我们可能需要求解多达d或d+1个整数线性规划问题来决定某一条边是否存在。要求解的问题个数依赖于语句s1是否按照正文顺序出现在s2之前。
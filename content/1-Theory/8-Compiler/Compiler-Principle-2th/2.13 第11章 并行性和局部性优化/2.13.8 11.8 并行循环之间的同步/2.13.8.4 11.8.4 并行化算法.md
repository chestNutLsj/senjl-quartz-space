### 11.8.4　并行化算法

现在我们给出一个简单的并行化算法。它首先把计算任务分解到尽可能多的不同循环中，然后独立地并行化各个循环。

算法11.54　在允许O（1）次同步的情况下最大化并行性的度数。

输入：一个带有数组访问的程序。

输出：带有固定多个同步栅障的SPMD代码。

方法：

1）构造程序的程序依赖图，并把语句分划为强连通分量（SCC）。回忆一下10.5.8节介绍过，一个强连通分量是原图的一个满足下列条件的最大的分量：其中的每个结点都可以到达所有其他结点。

2）转换代码，使之按照拓扑顺序执行各个SCC。必要时可以应用裂变转换。

3）对每个SCC应用算法11.43，寻找出所有的无同步并行性。在每个被并行化的SCC的前后都插入同步栅障。

虽然算法11.54能够找到带有O（1）次同步的所有并行性度数，它仍然存在一些缺点。第一，它可能引入不必要的同步。作为一个现实问题，如果我们把这个算法应用到一个可以被无同步地并行化的程序上，这个算法会对每个语句进行并行化，并且在执行各个语句的并行循环之间引入同步栅障。第二，虽然只会有固定多个同步，但得到的并行化方案会在每次同步的时候在不同的处理器之间传递很多数据。有些情况下，通信开销会使得并行化的代价太过昂贵，有时甚至不如在一个单处理器上顺序执行这个程序。在后面的各节中，我们将继续给出提高数据局部性的手段，从而降低通信量。
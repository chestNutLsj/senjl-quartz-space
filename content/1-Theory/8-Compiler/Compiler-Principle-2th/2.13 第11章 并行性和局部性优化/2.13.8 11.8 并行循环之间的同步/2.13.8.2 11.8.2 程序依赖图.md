### 11.8.2　程序依赖图

为了找出所有可以通过加入固定多个同步运算而变得可用的并行性，我们可以尽可能地对原程序应用裂变转换。把循环尽可能分解为独立循环，然后独立地并行化每个循环。

为了揭示出所有可以进行循环裂变的机会，我们使用程序依赖图（Program Dependence Graph，PDG）的抽象表示方法。程序的程序依赖图中的各个结点是程序的赋值语句，图中的边表示语句之间的数据依赖关系以及依赖的方向。只要语句s1的某个动态实例和后面的语句s2的一个动态实例之间存在数据依赖关系，就存在一条从语句s1到语句s2的边。

构造一个程序的PDG时，我们首先找出每一对语句中的两个静态访问之间的数据依赖关系。一个语句对中的两个语句可以相同，这两个静态访问也可以相同。假设确定了语句s1中的访问![557-1](../Images/image04979.jpeg)和语句s2中的访问![557-6](../Images/image04980.jpeg)之间有依赖关系。请注意，一个语句的实例可以使用下标向量i=［i1,i2,…,im］来刻画，其中ik是该语句所在循环嵌套结构中从最外层开始的第k个循环的下标。

1）如果有两个语句实例，s1的实例i1和s2的实例i2，它们之间具有数据依赖关系，并且在原程序中，i1在i2之前执行，记作![557-2](../Images/image04981.jpeg)，那么有一条从s1到s2的边。

2）类似地，如果有两个语句实例，s1的实例i1和s2的实例i2，它们之间具有数据依赖关系，记作![557-3](../Images/image04982.jpeg)，那么有一条从s2到s1的边。

请注意，有可能根据两个语句s1和s2之间的数据依赖关系，在PDG中既生成了从s1到s2的边，又生成了从s2到s1的边。

在语句s1和s2相同的特殊情况下，![557-4](../Images/image04983.jpeg)当且仅当![557-7](../Images/image04984.jpeg)（即i1按照词典排序比i2小）。在一般情况下，s1和s2可以是不同的语句，有可能属于不同的循环嵌套结构。

例11.51　对于例11.50中的程序，在语句s1的实例之间没有依赖关系。但是，语句s2的第i个实例必须在语句s1的第i个实例之后发生。更糟糕的是，因为数组引用W［A［i］］可以对数组的W的每个元素进行写运算，s2的第i个实例依赖于所有之前的s2的实例。也就是说，语句s2依赖于它本身。例11.50的程序的PDG显示在图11-40中。请注意图中有一个只包含s2的环。

![557-5](../Images/image04985.jpeg)

图11-40　例11.50的程序的PDG

程序依赖图使得我们可以很容易地确定是否可以分割一个循环中的多个语句。在一个PDG中，一个环所连接的各个语句不能被分割开。如果s1→s2是一个环中两个语句之间的依赖关系，那么s1的某些实例必须在s2的某些实例之后发生，反过来也成立。请注意，只有当s1和s2嵌入在同一个循环中的时候才可能有这种相互依赖关系。因为有这种相互依赖关系，我们不能先执行完一个语句的所有实例之后再执行另一个语句的所有实例，因此不允许进行循环裂变转换。另一方面，如果依赖关系s1→s2是单向的，我们就可以对这个循环进行分割，首先执行s1的所有实例，然后执行s2的实例。

例11.52　图11-41b显示了图11-41a中程序的程序依赖图。图中语句s1和s3属于一个环，因此不能被放到不同的循环中去。但是我们可以把语句s2分割出去，并在执行其他计算之前执行它的所有实例，如图11-42所示。第一个循环是可以并行化的，但是第二个循环不能被并行化。我们可以在第一个循环的并行执行之前和之后放上一个同步栅障，从而把第一个循环并行化。

![558-1](../Images/image04986.jpeg)

图11-41　例11.5.2的程序和依赖图

![558-2](../Images/image04987.jpeg)

图11-42　对一个循环嵌套结构的强连通子图进行分组
### 11.8.1　固定多个同步运算

没有无同步并行性的程序可能包含一系列循环。如果独立地考虑这些循环，其中的某些循环是可以并行化的。我们可以在这些循环执行之前和之后引入同步栅障，从而把这些循环并行化。例11.49说明了这一点。

例11.49　图11-38给出了一个实现了ADI（交替方向隐式方法，一种数值计算方法，Alternating Dirrection Implicit）积分算法的典型程序。它没有无同步并行性。在第一个循环嵌套结构中的依赖关系要求每个处理器在数组X的一列上工作；但是在第二个循环嵌套结构中的依赖关系要求每个处理器在数组X的一行上工作。如果要求没有通信运算，整个数组必须放在同一个处理器上，因此不存在并行性。但是，我们观察到两个循环都是可以单独并行化的。

![556-1](../Images/image04976.jpeg)

图11-38　两个顺序的循环嵌套结构

并行化代码的方法之一是在第一个循环中让不同的处理器在数组的不同列上工作，同步并等待所有的处理器完成任务后，各个处理器再在各个行上进行运算。使用这个方法，只需要引入一个同步操作就可以使算法中的所有计算都被并行化。但是，我们注意到虽然只进行了一次同步，但是这个并行化方案要求几乎所有的矩阵X中的数据在不同的处理器之间传递。通过引入更多的同步计算有可能降低通信量。我们将在11.9.9节中讨论这个问题。

看起来，这个方法可能只适用于由一系列循环嵌套组成的程序。但是，我们可以通过代码转换创造出更多的优化机会。我们可以应用循环裂变转换把原程序中的循环分解成为几个较小的循环。利用同步栅障把它们隔开，然后逐一将它们并行化。我们用例11.50来解释这个技术。

例11.50　考虑下面的循环：

![556-2](../Images/image04977.jpeg)

因为不知道数组A中的值，我们必须假设语句s2中的访问可以写到W的任何元素上。因此，s2的实例的执行顺序必须和它们在原程序中的顺序一致。

代码中没有无同步的并行性，算法11.43将简单地把所有的计算任务都赋予同一个处理器。但是，至少语句s1的实例可以并行执行。我们可以把这个代码的一部分并行化，方法是让不同的处理器执行语句s1的不同实例。然后在另一个独立的顺序循环中，用一个处理器（比如说0号处理器）执行s2。相应的SPMD代码显示在图11-39中。

![556-3](../Images/image04978.jpeg)

图11-39　例11.50中的循环的SPMD代码，其中p是存放处理器ID的变量
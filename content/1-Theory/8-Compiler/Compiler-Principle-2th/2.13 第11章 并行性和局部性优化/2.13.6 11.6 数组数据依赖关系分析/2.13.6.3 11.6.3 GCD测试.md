### 11.6.3　GCD测试

第一个子程序检验是否存在满足约束中各个等式的整数解。只考虑整数解的方程称为丢番图方程（Diophantine equation）。下面的例子说明了只考虑整数解会带来什么问题；同时它也说明，虽然很多例子中每次只涉及单个循环嵌套结构，数据依赖关系的公式表达还可以被应用到位于不同循环中的数组访问。

例11.30　考虑下面的代码片段：

![533-1](../Images/image04924.jpeg)

访问Z［2*i］只触及Z的偶数号元素，而访问Z［2*j+1］只触及奇数号元素。显然，如果省略号表示的右部不涉及Z的运算，那么不管循环的界限如何，这两个访问之间没有数据依赖关系。我们可以在第一个循环执行之前就执行第二个循环，或者交叉执行这两个循环的迭代。这个例子看起来是人为设计的、没有实际意义，其实不然。数组的偶数号元素与奇数号元素被分开处理的一个实际例子是复数数组，其中各个复数的实部和虚部各占一个元素，并列存放。

为了证明这个例子中没有数据依赖关系，我们做如下论证。假设存在整数i和j使得Z［2*i］和Z［2*j+1］是同一个数组元素，我们得到丢番图方程

2i = 2j + 1

没有整数i和j可以满足上面的方程。证明如下：如果i是一个整数，那么2i就是偶数。如果j是一个整数，那么2j是偶数，因此2j+1是奇数。没有哪个偶数同时也是奇数。因此，这个方程没有整数解，因此这两个写访问之间没有依赖关系。

为了描述一个线性丢番图方程什么时候有解，我们需要引入两个或多个整数的最大公约数的概念。多个整数a1，a2，…，an的GCD，记为gcd（a1,a2,…,an），是能够整除这些整数的最大整数。GCD可以使用著名的欧几里德算法（见下面的“欧几里德算法”部分）快速地计算。

例11.31　gcd（24,36,54）= 6，因为24/6、36/6和54/6的余数都是0，而且用任何大于6的整数去除24、36、54时，至少有一个余数非零。比如，12能够整除24和36，但是不能整除54。

GCD的重要性体现在下面的定理中。

定理11.32　线性丢番图方程

a1x1+a2x2+…+anxn = c

有x1，x2，…，xn的一个整数解，当且仅当gcd（a1,a2,…,an）能够整除c。

例11.33　在例11.30中，我们看到线性丢番图方程2i=2j+1无解。我们可以把这个方程写作

2i - 2j = 1

现在gcd（2,-2）=2且2不能整除1。因此方程无解。

再看另一个例子，考虑方程

24x+36y+54z = 30

因为gcd（24,36,54）=6且30/6=5，因此存在x、y和z的整数解。其中的一个解是x=-1，y=0且z=1，但是存在无穷多个其他的解。

数据依赖关系问题的第一步是使用一个诸如高斯消除算法的标准方法来求解给定的方程组。每构造出一个线性方程，就应用定理11.32尽可能地排除整数解的存在。如果我们能够排除这样的整数解，那么答案就是“否”。否则我们使用这些方程的解来减少不等式中的变量数目。

例11.34　考虑两个方程

x - 2y + z = 0

3x+2y+z = 5

从各个方程本身来看是存在解的。对于第一个方程，gcd（1,-2,1）=1能够整除0，而对于第二个方程，gcd（3,2,1）=1能够整除5。但是，如果我们求解第一个方程得到z=2y-x，并以此替代第二个方程中的z，我们得到2x+4y=5。因为gcd（2,4）=2不能整除5，所以这个丢番图方程无解。

欧几里德算法

欧几里德算法按照下面的方法找出gcd（a,b）的值。首先，假设a和b为正整数，且a≥b。请注意，多个负数的GCD，或一个负数与一个正数的GCD等于它们的绝对值的GCD，因此可以假设所有的整数都是正的。

如果a=b，那么gcd（a,b）=a。如果a>b，令c为a/b的余数。如果c=0，那么b整除a，因此gcd（a,b）=b。否则，计算gcd（b,c）得到的结果也是gcd（a,b）。

为了计算n>2时的gcd（a1,a2,…,an），使用欧几里德算法来计算gcd（a1,a2）=c，然后递归地计算gcd（c,a3,a4，…,an）。
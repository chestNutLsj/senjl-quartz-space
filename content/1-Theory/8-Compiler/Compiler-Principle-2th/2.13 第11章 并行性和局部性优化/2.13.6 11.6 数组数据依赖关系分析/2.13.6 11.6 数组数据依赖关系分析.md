## 11.6　数组数据依赖关系分析

并行化或局部性优化经常对原程序中执行的运算重新排序。和所有的优化一样，只有当对运算的重新排序不会改变程序输出时才可以对这些运算重新排序。一般来说，我们不可能深入理解一个程序到底做了什么，代码优化通常选用一个较简单的、保守的测试方法来决定在什么时候可以肯定程序的输出不会受到优化的影响：检查在原程序中和在修改后的程序中，对同一内存位置的各个运算被执行的顺序是否一样。在当前的研究中，我们关注的是数组访问，因此数组元素就是需要考虑的内存位置。

如果两个访问（不管是读还是写）指向两个不同的位置，显然它们是相互独立的（可以被重新排序）。另外，读运算不会改变内存的状态，因此各个读运算之间是独立的。根据11.5节的介绍，如果两个访问指向同一个内存位置并且其中至少有一个写运算，那么就说这两个访问是数据依赖的。为了保证修改后的程序和原程序做同样的事情，每一对有数据依赖关系的运算在原程序中的执行顺序必须在新的程序中得到保持。

回顾一下10.2.1节，可知存在三种类型的数据依赖：

1）真依赖，一个写运算后面跟一个对同一个内存位置的读运算。

2）反依赖，一个读运算后面跟一个对同一个内存位置的写运算。

3）输出依赖，是两个针对同一个位置的写运算。

在上面的讨论中，数据依赖是针对动态访问定义的。只要一个程序的某个静态访问的某个动态实例依赖于另一个静态访问的某个动态实例，我们就说第一个静态访问依赖于第二个静态访问[^5]。

我们可以很容易看出数据依赖关系如何应用到并行化中。比如，如果在一个循环的各个访问之间没有发现数据依赖关系，那么就可以很容易地把不同的迭代分配给不同的处理器。11.7节将讨论如何系统化地将这个信息应用到并行化中。
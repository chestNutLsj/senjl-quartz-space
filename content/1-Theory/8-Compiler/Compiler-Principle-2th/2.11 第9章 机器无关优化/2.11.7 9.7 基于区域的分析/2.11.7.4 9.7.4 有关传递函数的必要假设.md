### 9.7.4　有关传递函数的必要假设

为了使得基于区域的分析能够解决问题，我们要对框架中的传递函数集合的性质作出某些假设。明确地说，我们需要作用于传递函数之上的三个基本原子运算：组合、交汇运算和闭包运算。使用迭代算法的数据流框架只需要其中的第一个运算。

组合

一个结点序列的传递函数可以把表示各个结点的传递函数组合起来得到。令f1和f2是结点n1和n2的传递函数。执行n1再执行n2的效果可以用函数![447-3](../Images/image04733.jpeg)来表示。函数组合已经在9.2.2节中讨论过，并且在9.2.4节中用到达定值给出了一个例子。为了回顾一下，令geni和killi是fi的gen和kill集合。那么

![447-4](../Images/image04734.jpeg)

因此，![447-3](../Images/image04733.jpeg)的gen和kill集合分别是（gen2∪（gen1-kill2））和（kill1∪kill2）。对于所有具有gen-kill形式的传递函数，这个想法都是可行的。其他形式的传递函数可能也对组合运算封闭，但是我们必须单独考虑各种情况。

交汇运算

这里，传递函数集合本身就是一个具有交汇运算∧f的半格的值域。两个传递函数f1和f2的交，即f1∧f f2，被定义为（f1∧f f2）（x）=f1（x）∧ f2（x），其中∧是数据流值的交汇运算。传递函数上的交汇运算用来把具有相同结尾点的不同执行路径的执行效果组合起来。从现在开始，在不会引起歧义时我们把传递函数的交汇运算也写成∧。对于到达定值框架，我们有

（f1∧f2）（x）=f1（x）∧ f2（x）

=（gen1∪（x-kill1））∪（gen2∪（x-kill2））

=（gen1∪gen2）∪（x-（kill1∩kill2））

也就是说，f1∧f2的gen和kill集合分别是gen1∪gen2和kill1∩kill2。仍然和处理组合运算一样，对于任何gen-kill形式的传递函数集合都可以进行同样的处理。

闭包

如果f表示一个环的传递函数，那么fn表示沿着这个环执行n次的效果。当不知道迭代次数的时候，我们必须假设这个环将被执行0到多次。我们用f*，即f的闭包来表示这样的循环的传递函数。闭包f*的定义如下

![447-1](../Images/image04735.jpeg)

请注意，f0必须是单元传递函数，因为它代表把这个循环执行0次的效果，即从入口处开始但不运行的效果。如果令I表示单元传递函数，那么可以把上式写成

![447-2](../Images/image04736.jpeg)

假设在一个到达定值框架中的传递函数f有一个gen集和一个kill集。那么，

f2（x）=f（f（x））

=gen∪（（gen∪（x-kill））-kill）

=gen∪（x-kill）

f3（x）=f（f2（x））

=gen∪（x-kill）

以此类推，即所有的fn都是gen∪（x-kill）。也就是说，如果传递函数具有gen-kill形式，那么沿着一个循环执行的次数对该函数没有影响。因此，

f*（x）=I∧f1（x）∧f2（x）∧…

=x∪（gen∪（x-kill））

=gen∪x

也就是说，传递函数f*的gen和kill集合分别是gen和![408-4](../Images/image04681.jpeg)。直观地讲，因为我们可能根本不沿着这个循环执行，x中的任何元素都可以到达这个循环的入口处。在此后的所有迭代中，到达定值中总是包括所有在gen集合中的元素。
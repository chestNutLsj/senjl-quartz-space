### 9.7.5　一个基于区域的分析算法

下面的算法根据某个满足9.7.4节中假设的框架，解决了一个可归约流图上的前向数据流分析问题。回顾一下，fR，IN［R′］和fR，OUT［B］是两个传递函数，它们把区域R的入口点上的数据流值分别转换为在子区域R′入口处和出口基本块B的出口处的数据流值。

算法9.53　基于区域的分析。

输入：一个具有9.7.4节中所列性质的数据流框架和一个可归约流图G。

输出：G中的每个基本块B的数据流值IN［B］。

方法：

1）使用算法9.52来构造G的自底向上的区域序列，假设它们是R1，R2，…，Rn，其中Rn是最顶层的区域。

2）进行自底向上的分析，计算概括了每个区域的执行效果的传递函数。对于按照自底向上顺序排列的每个区域R1，R2，…，Rn，进行下列计算：

（a）如果R是一个对应于基本块B的叶子区域，令fR，IN［B］=I，fR，OUT［B］=fB。其中，fB是基本块B的传递函数。

（b）如果R是一个循环体区域，执行图9-50a中的计算。

![448-1](../Images/image04737.jpeg)

图9-50　基于区域的数据流计算的细节

（c）如果R是一个循环区域，执行图9-50b中的计算。

3）进行自顶向下的扫描，找出各个区域开始处的数据流值。

（a）IN［Rn］=IN［ENTRY］。

（b）按照自顶向下的顺序，对｛R1，R2，…，Rn-1｝中的每个区域R计算

IN［R］=fR′，IN［R］（IN［R′］）

其中R′是直接包含区域R的区域。

让我们首先看一下算法中自底向上分析过程的工作细节。在图9-50a的第（1）行中，我们按照某个拓扑排序访问一个循环体区域的各个子区域。第（2）行中计算的传递函数代表了所有从R的头结点到S的头结点的可能路径的执行效果；第（3）和（4）行中计算的传递函数代表了所有从R的头结点到R的出口点（即所有的某个后继在S之外的基本块的出口点）的可能路径的执行效果。请注意，按照第（1）行所构造的拓扑排序，R的所有前驱B′必然在S之前的区域中。这样，fR，OUT［B′］一定已经在算法的外层循环的前面某次迭代中由第（4）行计算完毕。

对于循环区域，我们执行图9-50b中第（1）到（4）行的各个步骤。其中，第（2）行计算了沿着循环体区域S重复执行零次或多次的效果。第（3）和第（4）行计算了进行一次或多次迭代之后在循环出口处的效果。

在算法的自顶向下扫描中，步骤3（a）首先把问题的边界条件作为最顶层区域的输入。然后，如果R直接包含于R′，我们只需要将传递函数fR′，IN［R］应用到IN［R′］就可以计算得到IN［R］。

例9.54　让我们应用算法9.53来寻找图9-48a中流图的到达定值。第一步构造出自底向上访问各个区域的顺序；这个顺序将作为各个区域的下标，比如R1，R2，…，Rn。

五个基本块的gen集和kill集的值概括如下：

![449-1](../Images/image04738.jpeg)

请回忆一下9.7.4节中对gen-kill形式的传递函数的简化后的规则：

- 要计算传递函数的交汇，只要计算gen集合的并集和kill集合的交集。
- 组合传递函数时，计算两个函数的gen集的并集和kill集的并集。但是这个规则有一个例外，当一个表达式被第一个函数生成且没有被第二个函数生成，同时又被第二个函数杀死的时候，这个表达式不在最后的gen中。
- 在计算一个传递函数的闭包时，保持原来的gen集合，但是用![408-4](../Images/image04681.jpeg)替代原来的kill集合。

前面的五个区域R1，…，R5分别是基本块B1，…，B5。对于1≤i≤5，![449-2](../Images/image04739.jpeg)都是单元函数，![449-4](../Images/image04740.jpeg)是Bi的传递函数：

![449-3](../Images/image04741.jpeg)

算法9.53的第二步构造的其他传递函数如图9-51中。区域R6由区域R2、R3和R4组成，R6代表该循环的循环体，因此不包含回边B4→B2。对这些区域的处理顺序就是它们的唯一的拓扑排序：R2、R3、R4。首先请记住边B4→B2到达了R6之外，R2在R6中没有前驱。因此![449-5](../Images/image04742.jpeg)是单元函数[^14]是B2本身的传递函数。

![450-1](../Images/image04744.jpeg)

图9-51　使用基于区域的流分析计算图9-48a中流图的传递函数

区域B3的头结点有一个R6中的前驱，即R2。到达它的入口处的传递函数就是到达B2出口处的传递函数![449-7](../Images/image04745.jpeg)。这个函数已经被计算出来。我们把这个函数和B3的传递函数组合起来，计算出到达B3出口处的传递函数。B3就在由它自身组成的区域中。

最后，因为B2和B3都是R4的头结点B4的前驱，对于到达R4入口处的传递函数，我们必须计算

![450-2](../Images/image04746.jpeg)

这个传递函数和传递函数![450-3](../Images/image04747.jpeg)组合，得到我们想要的函数![450-4](../Images/image04748.jpeg)。请注意，比如，d3没有在这个函数中被杀死，因为路径B2→B4没有对变量a重新定值。

现在考虑循环区域R7。它只包含一个表示它的循环体的区域R6。因为只有一个到达R6的头结点的回边B4→B2，代表这个循环体执行0次或者多次的传递函数就是![450-5](../Images/image04749.jpeg)：这个函数的gen集合是｛d4，d5，d6｝，而kill集合是![408-4](../Images/image04681.jpeg)。区域R7有两个出口，即基本块B3和B4。因此，这个传递函数和R6的各个传递函数相组合，得到对应于R7的传递函数。请注意某些定值，比如d6，是怎样因为路径B2→B4→B2→B3，甚至路径B2→B3→B4→B2→B3的原因而被加入到函数![450-6](../Images/image04750.jpeg)的gen集中去的。

最后考虑区域R8，即整个流图。它的子区域是R1、R7和R5。我们将按照这个拓扑顺序考虑这些子区域。和前面一样，传递函数![450-7](../Images/image04751.jpeg)是一个单元函数，而传递函数![450-8](../Images/image04752.jpeg)是![450-9](../Images/image04753.jpeg)，也就是![450-10](../Images/image04754.jpeg)。

R7的头结点B2只有一个前驱B1，因此到达它的入口的传递函数就是R8中从B1离开的传递函数。我们把![450-8](../Images/image04752.jpeg)和R7中到达B3和B4出口处的传递函数相组合，得到它们在R8中相应的传递函数。最后我们考虑R5，它的头结点B5在R8中有两个前驱，即B3和B4。因此，我们计算![450-11](../Images/image04755.jpeg)可以得到![450-12](../Images/image04756.jpeg)。因为基本块B5的传递函数是单元函数，因此![450-13](../Images/image04757.jpeg)。

第三步根据传递函数计算实际的到达定值。在步骤3（a），IN［R8］=![408-4](../Images/image04681.jpeg)，因为在程序的开头没有到达定值。图9-52显示了步骤3（b）是如何计算其余的数据流值的。这个步骤从R8的各个子区域开始。因为从R8的开始处到它的各个子区域开始处的传递函数已经计算出来了，通过简单地应用这些传递函数就可以找到各个子区域的开始处的数据流值。我们重复这个步骤，直到得到各个叶子区域的数据流值为止。这些叶子区域就是各个基本块。请注意，图9-52中显示的数据流值和我们对相同流图应用迭代数据流分析技术而得到的值是完全一致的。当然，这两组值必须一致。

![451-1](../Images/image04758.jpeg)

图9-52　基于区域的流分析的最后一步
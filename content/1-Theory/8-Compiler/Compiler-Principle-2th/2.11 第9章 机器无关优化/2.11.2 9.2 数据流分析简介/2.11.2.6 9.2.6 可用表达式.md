### 9.2.6　可用表达式

如果从流图入口结点到达程序点p的每条路径都对表达式x+y求值，且从最后一个这样的求值之后到p点的路径上没有再次对x或y赋值[^6]，那么x+y在点p上可用（available）。对于可用表达式数据流模式而言，如果一个基本块对x或y赋值（或可能对它们赋值），并且之后没有再重新计算x+y，我们就说该基本块“杀死”了表达式x+y。如果一个基本块一定对x+y求值，并且之后没有再对x或y定值，那么这个基本块生成表达式x+y。

请注意，“杀死”或“生成”一个可用表达式的概念和达到定值中的概念并不完全相同。尽管如此，这些“杀死”或“生成”的概念在行为上和到达定值中的相应概念在本质上是一致的。

可用表达式信息的主要用途是寻找全局公共子表达式。比如，在图9-17a中，如果4*i在基本块B3的入口点可用，那么基本块B3中的表达式4*i就是一个公共子表达式。它在该处可用的条件是i在基本块B2中没有被赋予一个新值，或者像图9-17b所示的那样在B2中对i赋值后又重新计算了4*i。

![406-2](../Images/image04674.jpeg)

图9-17　跨越多个基本块的潜在的公共子表达式

我们可以从头到尾地处理基本块内的各个语句，计算一个基本块内各个点上生成的表达式的集合。在基本块前面的点上没有任何生成的表达式。如果在点p处可用表达式的集合是S，而q是p之后的点，且它们之间是语句`x=y+z`，那么通过下面的两个步骤可得到点q上的可用表达式集合。

1）把表达式y+z添加到S中。

2）从S中删除任何涉及变量x的表达式。

请注意，因为x可能和y或z相同，所以上面的步骤必须按照正确的顺序执行。在我们到达基本块的结尾处时，S就是该基本块生成的表达式集合。而被杀死的表达式的集合就是所有类似于y+z的表达式，其中y或z在基本块中被定值，并且这个基本块没有生成y+z。

例9.15　考虑图9-18中的四个语句。在第一个语句之后b+c可用。在第二个语句之后a-d变得可用，但是因为b被重新定值，b+c变得不再可用。第三个语句并没有使b+c可用，因为c的值立刻就被改变了。在最后一个语句之后，因为d的值已经改变，a-d不再可用。因此这个基本块没有生成任何可用表达式，所有涉及a、b、c、d的表达式都被杀死了。

![407-1](../Images/image04675.jpeg)

图9-18　可用表达式的计算

我们可以用类似于计算到达定值的方法来寻找可用表达式。假设U是所有出现在程序中一个或多个语句的右部的表达式的全集。对于每个基本块B，令IN［B］表示在B的开始处可用的U中的表达式的集合。令OUT［B］表示在B的结尾处可用的表达式集合。定义e_genB为B生成的表达式的集合，而e_killB为被B杀死的U中的表达式的集合。请注意，IN、OUT、e_gen和e_kill都可以使用位向量表示。下面的方程给出了未知的IN和OUT值之间，以及它们和已知量e_gen与e_kill之间的关系：

![407-4](../Images/image04676.jpeg)

并且对于除ENTRY之外的所有基本块B，有

OUT［B］=e_genB∪（IN［B］-e_killB）

![407-2](../Images/image04677.jpeg)

上面的方程和到达定值方程组看起来几乎一样。和到达定值类似，这个方程组的边界条件也是![407-3](../Images/image04678.jpeg)，这是因为在ENTRY的出口处没有任何可用表达式。其中最重要的不同之处在于这个方程组的交汇运算是交集运算，而不是并集运算。因为只有当一个表达式在一个基本块的所有前驱的结尾处都可用，它才会在该基本块的开头可用，因此使用交集运算是正确的。相反，只要一个定值到达了一个基本块的任何一个前驱的结尾处，它就到达了该基本块的开头，所以在到达定值方程组中使用并集运算作为交汇运算。

使用∩而不是∪使得可用表达式方程组的表现和到达定值方程组的表现不同。虽然两组方程都没有唯一解，但到达定值方程组的解是符合“到达”的定义的最小集合。在求解到达定值方程的过程中，我们首先假设任何地方都没有定值到达，然后逐渐增大到达定值的集合，最终构建得到该解。在这个方法里，除非找到一条能把某个定值d传播到某个点p的实际路径，否则我们从来不假设d能够到达p。相反，对于可用表达式方程组，我们希望得到具有最大可用表达式集合的解。因此，我们首先给出较大的近似值，然后逐步消减。

首先，我们假设“在除了入口基本块结尾处之外的所有地方，所有表达式（即集合U）都是可用的”。只有当我们发现有一条路径使得某个表达式不可用时，我们才删除这个表达式。这种方法看起来不是那么显而易见，但是我们可以得到一个真正的可用表达式的集合。在处理可用表达式时，生成一个可用表达式的精确集合的子集是保守的。之所以说使用子集是保守的，是因为我们将把这个信息用于把一个可用表达式的计算替换为之前计算得到的值。不知道一个表达式是可用的只会使我们失去改进代码的机会，而把一个不可用的表达式认为可用则会使我们改变程序的计算结果。

例9.16　我们将把注意力集中在图9-19中的基本块B2上，说明OUT［B2］的初始近似值对IN［B2］的影响。令G和K分别为![407-5](../Images/image04679.jpeg)的缩写。B2的数据流方程为

![408-1](../Images/image04680.jpeg)

图9-19　将OUT集合初始化为![408-4](../Images/image04681.jpeg)局限性太大

IN［B2］=OUT［B1］∩OUT［B2］

OUT［B2］=G∪（IN［B2］-K）

令Ij和Oj分别表示IN［B2］和OUT［B2］的第j次循环计算得到的近似值，这些方程式可以被写成下列的迭代计算式：

Ij+1=OUT［B1］∩Oj

Oj+1=G∪（Ij+1-K）

从![408-2](../Images/image04682.jpeg)开始，我们得到![408-3](../Images/image04683.jpeg)。但是，如果我们从O0=U开始，那么我们得到I1=OUT［B1］∩O0=OUT［B1］，而这才是我们应该得到的值。直观地讲，以O0=U作为初始值得到的解更符合我们的期望，因为这个解正确地反映了下面的事实：如果OUT［B1］中的某个表达式没有被B2杀死，那么它在B2的结尾处可用。

算法9.17　可用表达式。

输入：一个流图，对其中的每个基本块B，e_killB和e_genB的值已经计算得到。流图的初始基本块是B1。

输出：在流图的各个基本块B的入口处和出口处的可用表达式集合，即IN［B］和OUT［B］。

方法：执行图9-20中的算法。图9-20中各个步骤的解释类似于图9-14的算法中的解释。

![408-5](../Images/image04684.jpeg)

图9-20　计算可用表达式的迭代算法
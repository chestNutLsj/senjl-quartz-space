### 9.2.4　到达定值

“到达定值”是最常见和有用的数据流模式之一。只要知道当控制到达程序中每个点的时候，每个变量x可能在程序中的哪些地方被定值，我们就可以确定很多有关x的性质。下面仅仅给出两个例子：一个编译器能够根据到达定值信息知道x在点p上的值是否为常量，而如果x在点p上被使用，则调试器可以指出x是否未经定值就被使用。

如果存在一条从紧随在定值d后面的程序点到达某一个程序点p的路径，并且在这条路径上d没有被“杀死”，我们就说定值d到达程序点p。如果在这条路径上有对变量x的其他定值，我们就说变量x的这个定值被“杀死”了[^4]。直观地讲，如果某个变量x的一个定值d到达点p，在点p处使用的x的值可能就是由d最后定值的。

探测未定值先使用

下面介绍我们如何使用到达定值问题的解来探测未定值先使用的情况。其窍门是在流图的入口处对每个变量x引入一个哑定值。如果x的哑定值到达了一个可能使用x的程序点p，那么x就可能在定值之前被使用。请注意，我们永远不能绝对肯定这个程序包含一个错误。因为有可能存在某种原因使得到达p点而没有真正对x赋值的路径实际上并不存在。这个原因可能涉及复杂的逻辑问题。

变量x的一个定值是（可能）将一个值赋给x的语句。过程参数、数组访问和间接引用都可以有别名，因此指出一个语句是否向特定程序变量x赋值并不是件容易的事情。程序分析必须是保守的。如果我们不知道一个语句是否给x赋了一个值，我们必须假设它可能对x赋值。也就是说，在语句s之后，变量x的值可能还是s执行之前的原值，但也可能变成了s所产生的新值。为简单起见，在本章的其余部分我们假设仅仅处理没有别名的程序变量。这类变量包括大多数语言中的局部标量变量。在处理C或者C++语言时，有些局部变量的地址会被计算出来，这种局部变量不属于这类变量。

例9.9　图9-13中显示的是一个具有7个定值的流图。让我们注意观察所有到达基本块B2的定值。所有在B1中的定值都到达了基本块B2的开头。因为在转回基本块B2的循环中找不到其他的对j的定值，基本块B2中的定值d5：`j=j-1`也可以到达基本块B2的开头。但是，这个定值杀死了定值d2：`j=n`，使得d2不能到达B3和B4。B2中的语句d4：`i=i+1`却不能到达B2的开头，这是因为变量i总是被d7：`i=u3`重新定值。最后，定值d6：`a=u2`也能够到达B2的开头。

![401-1](../Images/image04658.jpeg)

图9-13　演示到达定值的流图

我们在前面定义到达定值时，有时允许一定的不精确性。但是它们都是在“安全”或者说“保守”的方向上不精确。比如，请注意我们假设一个流图的所有边都可以通过。在实践中这个假设可能是不正确的。再比如，在下面的程序片断中，没有哪个a和b的取值可以使得控制流真的能够到达statement 2：

![401-2](../Images/image04659.jpeg)

在一般情况下，决定一个流图的每条路径是否都可以被执行是一个不可判定问题。因此，我们简单地假设流图中的每条路径都可能在程序的某次执行时通过。在大部分到达定值的应用中，在一个定值不可能到达某点的情况下假设其能够到达是保守的。因此，我们可以允许那些在程序实际执行中根本不会被遍历的路径，我们也可以安全地允许定值穿越某个对同一变量的不明确定值。

数据流分析中的保守主义

实际数据流值是通过程序的所有可能执行路径来定义的。所有的数据流模式计算得到的都是对实际数据流值的估算。我们必须保证所有的估算误差都在“安全”的方向上。如果一个策略性决定不允许我们改变程序计算出的内容，它就被认为是“安全的”（或者说“保守的”）。遗憾的是，安全的策略会让我们错失一些能够保持程序含义的代码改进机会。但实际上对所有的代码优化技术而言，没有哪个安全的策略可以不错失任何机会。使用不安全策略就是以改变程序含义的代价来加快代码速度。一般来说，这是不可接受的。

因此在设计一个数据流模式的时候，我们必须知道这些信息将如何被使用，并保证我们做出的任何估算都是在“保守”或者说“安全”的方向上。每个模式和应用都要单独考虑。比如，如果我们把到达定值信息用于常量折叠，那么把一个实际不可到达的定值当作可到达就是安全的（我们可能在x实际是一个常量且可以被折叠的情况下认为x不是一个常量），但是把一个实际可到达的定值当作不可到达就是不安全的（我们可能把x替换为一个常量，但是实际上程序有时会赋予x一个不同于该常量的值）。

到达定值的传递方程

现在我们为到达定值问题设置约束。我们首先检查单个语句的细节。考虑一个定值

![402-1](../Images/image04660.jpeg)

在这里，+号代表了一个一般性的二元运算符。以后我们经常会这么做。

这个语句“生成”了一个变量u的定值d，并“杀死”了程序中其他对u的定值，而进入这个语句的其他定值都没有受到影响。因此，定值d的传递函数可以被表示为

fd（x）=gend∪（x-killd）　（9.1）

其中gend=｛d｝，即由这个语句生成的定值的集合，而killd是程序中所有其他对u的定值。

我们在9.22节讨论过，一个基本块的传递函数可以通过把它包含的所有语句的传递函数组合起来而构造得到。下面我们会看到，形如（9.1）的函数的组合仍然是这种形式。我们把这种形式称为“生成-杀死形式”。假设有两个函数f1（x）=gen1∪（x-kill1）和f2（x）=gen2∪（x-kill2）。那么

f2（f1（x））=gen2∪（gen1∪（x-kill1）-kill2）

=（gen2∪（gen1-kill2））∪（x-（kill1∪kill2））

这个规则可以扩展到由任意多个语句组成的基本块。假设基本块B有n个语句，而第i个语句的传递函数为fi（x）=geni∪（x-killi），i=1，2，…，n，那么基本块B的传递函数可以写成：

fB（x）=genB∪（x-killB）

其中

killB=kill1∪kill2∪…∪killn

而

genB=genn∪（genn-1-killn）∪（genn-2-killn-1-killn）∪

…∪（gen1-kill2-kill3-…-killn）

因此，和单个语句一样，一个基本块也会生成一个定值集合并杀死一个定值集合。集合gen中包含了所有在紧靠基本块之后的点上“可见”的该基本块中的定值——我们把它们称为“向下可见”（downwards exposed）的。在一个基本块中，一个定值是向下可见的，仅当它没有被同一个基本块中较后的对同一变量的定值“杀死”。一个基本块的kill集就是所有被块中各个语句杀死的定值的集合。请注意，一个定值可能同时出现在基本块的gen集和kill集中。在这种情况下，该定值会被这个基本块生成，即优先考虑该定值是否在gen集中。这是因为在gen-kill形式中，kill集会在gen集之前被使用。

例9.10　基本块

![402-2](../Images/image04661.jpeg)

的gen集是｛d2｝，因为d1不是向下可见的。基本块的kill集包括了d1和d2，因为d1杀死了d2，d2杀死了d1。虽然如此，因为减去kill集的运算先于和gen集的并集运算，这个基本块的传递函数的结果中总是包含定值d2。

控制流方程

下面我们考虑根据基本块之间的控制流得到的约束集合。因为只有一个定值能够沿着至少一条路径到达某个程序点，那么这个定值就到达该程序点，所以只要从P到B有一条控制流边，OUT［P］⊆IN［B］就成立。然而，一个定值到达某个程序点的必要条件是它能够沿着某条路径到达这个程序点，因此IN［B］不应该大于B的所有前驱基本块出口点的到达定值的并集。也就是说，可以安全地假设如下的方程式成立：

![403-1](../Images/image04662.jpeg)

我们把并集运算称为到达定值的交汇运算（meet operator）。在任何数据流模式中，我们用交运算来汇总各条路径会合点上不同路径所作的贡献。

到达定值的迭代算法

我们假设每个控制流图都有两个空基本块，包括代表了这个图的开始点的ENTRY结点以及EXIT结点，所有离开这个图的控制流都流向它。因为没有定值到达这个图的开始，所以基本块ENTRY的传递函数是一个简单的返回空集![089-1](../Images/image04055.jpeg)的常函数，即OUT［ENTRY］=![089-1](../Images/image04055.jpeg)。

到达定值问题使用下面的方程定义：

OUT［ENTRY］=![089-1](../Images/image04055.jpeg)

且对于所有的不等于ENTRY的基本块B，有

OUT［B］=genB∪（IN［B］-killB）

![403-2](../Images/image04663.jpeg)

可以使用下面的算法来求这个方程组的解。这个算法的结果是这个方程组的最小不动点（least fixedpoint），即对于各个IN和OUT，这个解给出的值总是此方程组的其他解所给出的值的子集。下面这个算法的结果是可接受的，因为在某个IN或OUT集中的定值确实可以到达该IN或OUT所描述的程序点。这个解也是我们所期望的，因为它没有包含任何我们确定不会到达的定值。

算法9.11　到达定值。

输入：一个流图，其中每个基本块B的killB集和genB集都已经计算出来。

输出：到达流图中各个基本块B的入口点和出口点的定值的集合，即IN［B］和OUT［B］。

方法：我们使用迭代的方法来求解。一开始，我们“估计”对于所有基本块B都有OUT［B］=![089-1](../Images/image04055.jpeg)，并逐步逼近想要的IN和OUT的值。因为我们必须不停迭代直到各个IN值（因此各个OUT值也）收敛，所以我们可以使用一个布尔变量change来记录每次扫描各基本块时是否有OUT值发生改变。但是，在此算法及以后描述的类似算法中，我们假设用来跟踪变更情况的确切机制是可理解的，因此我们删除了这些细节。

图9-14中粗略地给出了这个算法。前两行对某些数据流值进行了初始化[^5]。从第（3）行开始是一个循环。在循环中我们不停地迭代直到各个值收敛。第（4）行到第（6）行组成的内层循环对入口结点之外的所有基本块应用数据流方程。

直观地讲，算法9.11尽量向前传播各个定值，直到该定值被杀死，这样做模拟了程序的所有可能的执行情况。算法9.11最终必然会终止，因为对于每个B，OUT［B］绝对不会变小。一旦某个定值被加入到OUT值中，它会一直待在那里。（见练习9.2.6。）因为所有定值的集合是有限的，最终必然有一趟while循环的执行没有向任何OUT加入任何内容。此时算法就终止了。在此时终止迭代是安全的，因为如果各个OUT值没有改变，下一趟中各个IN值也不会改变。而如果各个IN值没有改变，OUT值也不会改变，如此下去，所有后续的迭代都不会改变IN和OUT的值。

流图中的结点个数是while循环的迭代次数的上界。其理由是如果一个定值能够到达某个程序点，它必然可以通过无环的路径到达该点，而一个流图中的结点个数是无环路径中结点数的上界。在while循环的每次迭代中，每个定值至少沿着问题中的路径前进一个结点。而且，根据各个结点在内层循环中被访问的顺序，它经常一次前进多个结点。

实际上，如果我们适当地安排第（4）行中for循环访问基本块的顺序，经验表明while循环的平均迭代次数小于5（见9.6.7节）。因为定值的集合可以使用位向量表示，而这些集合的运算可以使用位向量上的逻辑运算来实现，算法9.11在实际应用中出奇地高效。

例9.12　我们将使用位向量来表示图9-13中的七个定值d1，d2，…，d7。其中左起第i个位表示di。集合的并运算通过相应的位向量的逻辑OR运算实现。两个集合的差S-T的计算方法是首先计算T的位向量的补，然后再将这个补和S的位向量进行逻辑AND运算。

图9-15中显示的是算法9.11中的IN和OUT集的取值。其初始值用上标0表示，如OUT［B］0。它们由图9-14中的第（2）行的循环赋值。它们都是空集，用比特向量000 0000表示。算法的后续迭代中的取值也使用上标表示，第一趟迭代的值标记为IN［B］1和OUT［B］1，第二趟迭代的值标记为IN［B］2和OUT［B］2。

![404-1](../Images/image04664.jpeg)

图9-14　计算到达定值的迭代算法

假设第（4）行到第（6）行的for循环在执行时，B依次取值

B1，B2，B3，B4，EXIT

当B=B1时，因为![404-2](../Images/image04665.jpeg)，所以IN［B1］1是空集，而OUT［B1］1等于![404-3](../Images/image04666.jpeg)。这个值和前面的值OUT［B1］0不同，因此我们知道在第一轮中有些值发生了变化（因此会继续进行第二次循环）

然后我们考虑B=B2，并计算

IN［B2］1=OUT［B1］1∪OUT［B4］0

=111 000+000 0000=111 0000

![404-4](../Images/image04667.jpeg)

这个计算过程在图9-15中做了概括。比如，在第一趟循环的最后，OUT［B2］1=001 1100，反应了d4和d5在B2中生成的事实，而d3到达了B2的开头但是没有在B2中被杀死。

请注意，在第二轮之后，OUT［B2］的值有所改变，反映了d6也到达B2的开头且没有被B2杀死。在第一趟中我们没有了解到这个事实，因为从d6到B2结尾的路径（即B3→B4→B2）没有在一趟中被顺序经过。也就是说，当我们知道d6到达B4的结尾时，我们已经在第一趟中计算了IN［B2］和OUT［B2］。

在第二趟之后，OUT集合中的所有值都没有改变。因此，算法在第三趟之后终止。此时，各个IN和OUT的值如图9-15中最后两列所示。

![405-1](../Images/image04668.jpeg)

图9-15　IN和OUT的计算过程
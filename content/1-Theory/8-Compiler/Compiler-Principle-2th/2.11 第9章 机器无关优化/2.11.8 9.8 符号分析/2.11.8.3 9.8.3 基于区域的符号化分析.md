### 9.8.3　基于区域的符号化分析

我们可以把9.7节中描述的基于区域的分析技术进行扩展，用以寻找一个循环的第i次迭代中各个变量的表达式。和其他基于区域的算法一样，一个基于区域的符号化分析也有一个自底向上的处理过程和一个自顶向下的处理过程。这个自底向上的处理过程用一个传递函数来概括一个区域的执行效果。这个传递函数把入口处的符号化映射转变为出口处的输出符号化映射。在自顶向下的处理过程中，符号化映射的值被向下传播到内层区域。

不同之处在于我们处理循环的方法。在9.7节，循环的效果是用闭包运算来概括的。给定一个其循环体传递函数为f的循环，f的闭包f*被定义为在任意多次应用f可能产生的所有效果之上无穷多次应用交汇运算而得到的结果。但是，为了找到一个归纳变量，我们需要确定一个变量的值是否为至今已执行的迭代次数的仿射函数。相应的符号化映射必须把正在执行的迭代的序号作为参数。不仅如此，只要我们知道一个循环执行迭代的总次数，就可以使用这个数字来找到循环之后归纳变量的值。比如，在例9.58中我们断定在执行了第i次迭代之后，a的值是i。因为循环共有100次迭代，在循环结束的时候a的值一定是100。

接下来，我们首先定义基本运算符：用于符号化分析的传递函数的交汇运算和组合运算。然后说明如何使用它们进行基于区域的归纳变量分析。

传递函数的交汇运算

当计算两个函数的交时，除非两个函数把一个变量映射成为同一个不是NAA的值，这个变量的值就是NAA。因此

![457-3](../Images/image04774.jpeg)

带参数的函数组合

为了把一个变量表示成为一个关于循环下标的仿射函数，我们要计算出将某个函数组合给定多次后的效果。如果一次迭代的效果可以用一个传递函数f概括，那么对某个i≥0，执行i次迭代的效果记为fi。请注意，当i=0时，fi=f0=I是一个单元函数。

程序中的变量可以分成四种类型：

1）如果f（m）（x）=m（x）+c，其中c是一个常数，那么对于所有的i≥0，fi（m）（x）=m（x）+ci。如果一个循环的循环体可以用传递函数f表示，我们说x是这个循环的一个基本归纳变量（basic induction variable）。

2）如果f（m）（x）=m（x），那么对于所有的i≥0，fi（m）（x）=m（x）。变量x没有被改变。如果循环的循环体具有传递函数f，那么x的值在循环的任意多次迭代结束之后依然保持不变。我们说x是该循环的符号化常量（symbolic constant）。

3）如果f（m）（x）=c0+c1m（x1）+…+cn m（xn），其中每个xk要么是基本归纳变量，要么是符号化常量，那么对于i>0，有

fi（m）（x）=c0+c1 fi（m）（x1）+…+cn fi（m）（xn）

我们说x虽然不是基本归纳变量，但它依然是一个归纳变量。请注意，上述公式对于i=0不成立。

4）在其他情况下，fi（m）（x）=NAA。

要得到执行固定多次迭代的效果，我们只需要把上面的i替换成为该迭代次数即可。当迭代次数未知时，在最后一次迭代开始时变量的值由f*给出。在这种情况下，其值仍然可以用仿射函数表示的变量只有那些循环不变变量。

![458-1](../Images/image04775.jpeg)

例9.62　对于例9.58的最内层循环，执行i（i>0）次迭代的效果由传递函数![458-5](../Images/image04776.jpeg)描述。根据![458-6](../Images/image04777.jpeg)的定义，我们看到a和b是符号化常量。因为c在每次迭代中增加一，所以它是一个基本归纳变量。因为d是符号化常量b和基本归纳变量c的仿射函数，所以它是一个归纳变量。由此可得：

![458-2](../Images/image04778.jpeg)

如果我们不能指出基本块B3的循环迭代了多少次，那么就不能使用fi，而必须使用f*来表示在循环结束时的条件。此时我们有

![458-3](../Images/image04779.jpeg)

一个基于区域的算法

算法9.63　基于区域的符号化分析。

输入：一个可归约的流图G。

输出：G的每个基本块B的符号化映射IN［B］。

方法：我们对算法9.53做出如下的修改。

1）我们改变了为一个循环区域构造传递函数的方法。在原来的算法中，我们使用传递函数fR，IN［S］来把循环区域R入口处的符号化映射变换为经过未知多次迭代之后位于循环体S的入口处的符号化映射。如图9-50b所示，这个函数被定义为代表了所有回到循环入口处的路径的传递函数的闭包。在这里，我们定义fR，i，IN［S］来表示从循环区域入口处开始直到第i次迭代的入口处的执行效果。因此，

![458-4](../Images/image04780.jpeg)

2）如果一个区域的迭代次数已知，该区域的执行效果的描述是把上面定义中的i替换为实际迭代次数。

3）在算法的自顶向下处理过程中，我们计算fR，i，IN［S］就可以找出与一个循环的第i次迭代的入口处相关的符号化映射。

4）如果一个变量的输入值m（v）被区域R中的某个符号化映射的右部使用，并且在该区域的入口处m（v）=NAA，则我们引入一个新的参考变量t，在区域R的开始处加上赋值语句`t=v`，并且所有对m（v）的引用都被替换为t。如果我们不在这个点上引入一个参考变量，那么v的取值NAA将被传递到内层循环。

例9.64　对于例9.58，我们在图9-62中显示了该程序的传递函数是如何在算法的自底向上处理过程中被计算出来的。区域R5是内层循环，它的循环体是B5。表示从区域R5的入口处到达第j（j≥1）次迭代开始处的路径的传递函数是![459-2](../Images/image04781.jpeg)；表示到达第j次迭代结尾处的路径的传递函数是![459-3](../Images/image04782.jpeg)。

![459-1](../Images/image04783.jpeg)

图9-62　例9.58的自底向上处理过程中的传递函数的关系

区域R6由基本块B2和B4以及它们之间的循环区域R5组成。从B2和R5的入口处开始的传递函数可以用原算法中的同样方法来计算。因为fB4是一个单元函数，所以传递函数![459-5](../Images/image04784.jpeg)表示了基本块B2和整个内层循环的执行效果的组合。因为已知内层循环将迭代10次，所以我们可以把j替换为10来精确描述内层循环的执行效果。其余的传递函数可以用类似的方式计算得到。计算得到的实际传递函数显示在图9-63中。

![459-4](../Images/image04785.jpeg)

图9-63　在例9.58的自底向上处理过程中计算得到的传递函数

在程序入口处的符号化映射就是mNAA。我们使用自顶向下处理过程来计算到达逐层嵌套的区域的入口处的符号化映射，直到我们得到了所有基本块的符号化映射为止。一开始的时候我们首先计算区域R8中的基本块B1的数据流值：

IN［B1］=mNAA

OUT［B1］=fB1（IN［B1］）

再向下到达区域R7和R6，我们得到

![459-6](../Images/image04786.jpeg)

最后，在区域R5中我们得到

![460-3](../Images/image04787.jpeg)

毫不奇怪，这些等式产生的就是我们在图9-58中显示的结果。

例9.58显示了一个简单的程序，其中的各个符号化映射中的每个变量都有一个仿射表达式。我们使用例9.65来说明为什么以及如何在算法9.63中引入参考变量。

例9.65　考虑图9-64a中的简单例子。令fj为描述内层循环迭代j次的执行效果的传递函数。即使a的值可能在该循环的执行中上下变动，我们看到b是一个基于a在此循环的入口处的取值的归纳变量。也就是说，fj（m）（b）=m（a）-1+j。因为a被赋予了一个输入值，所以在内层循环入口处的符号化映射把a映射为NAA。我们在该入口处引入一个新的参考变量t来保存a的值，并像图9-64b中那样进行替换。

![460-1](../Images/image04788.jpeg)

图9-64　引入参考变量的需求
### 9.3.2　传递函数

一个数据流框架中的传递函数族F：V→V具有下列性质：

1）F有一个单元函数I，使得对于V中的所有x，I（x）=x。

2）F对函数组合运算封闭。也就是说，对于F中的任意函数f和g，定义为h（x）=g（f（x））的函数h也在F中。

例9.21　在到达定值中，F有单元函数，即gen和kill都是空集的传递函数。对函数组合的封闭性实际上已经在9.2.4节中得到证明，我们在这里简单地重复一下证明过程。假设我们具有两个函数

f1（x）=G1∪（x-K1）和f2（x）=G2∪（x-K2）

那么

f2（f1（x））=G2∪（（G1∪（x-K1））-K2）

根据代数规则，上式的右部和下式等价：

（G2∪（G1-K2））∪（x-（K1∪K2））

如果我们令K=K1∪K2，G=G2∪（G1-K2），我们就证明了f1和f2的组合f（x）=G∪（x-K）的形式表明它是F的成员。如果我们考虑可用表达式的问题，上面用于到达定值的证明也同样可以证明F具有单元函数并且对函数组合运算封闭。

单调的框架

要使得数据流分析问题的迭代算法能够完成任务，我们还要求数据流框架再满足一个条件。对于一个框架，如果框架中的所有传递函数都是单调的，那么我们就说这个框架是单调的。F中的传递函数f是单调函数的条件是对于域V中的任意两个元素，如果第一个元素大于第二个元素，那么f作用于第一个元素的结果也大于它作用于第二元素所得到的结果。

正式的定义如下，一个数据流框架（D，F，V，∧）是单调的（monotone），如果

对于所有的V中的x和y以及F中的f，x≤y蕴含f（x）≤f（y）　（9.22）

单调性可以被等价地定义为

对于所有的V中的x和y以及F中的f，f（x∧y）≤f（x）∧f（y）　（9.23）

式（9.23）说明，如果我们对两个值应用交汇运算再应用函数f，那么得到的结果绝对不会大于首先将f分别应用于两个值，然后再对结果应用交汇运算而得到的值。这两个关于单调的定义看起来很不相同，它们各有各的用处。我们会发现这两个定义分别适用于不同的环境。稍后我们将给出一个简略的证明，表明它们确实是等价的。

我们将首先假设式（9.22）成立并证明式（9.23）成立。因为x∧y是x和y的最大下界，我们知道

x∧y≤x且x∧y≤y

因此由式（9.22）可知：

f（x∧y）≤f（x）且f（x∧y）≤f（y）

因为f（x）∧f（y）是f（x）和f（y）的最大下界，我们证明了（9.23）。

反过来，我们假设式（9.23）成立并证明式（9.22）。我们假设x≤y并使用式（9.23）来得到f（x）≤f（y）的结论，从而证明式（9.22）。式（9.23）告诉我们

f（x∧y）≤f（x）∧f（y）

但是因为我们已经假设了x≤y，根据定义有x∧y=x。因此，式（9.23）表明

f（x）≤f（x）∧f（y）

因为f（x）∧f（y）是f（x）和f（y）的最大下界，我们得到f（x）∧f（y）≤f（y）。这样

f（x）≤f（x）∧f（y）≤f（y）

因此式（9.23）蕴含式（9.22）。

可分配的框架

数据流分析框架经常会遵守一个比式（9.23）更强的条件，我们把这个条件称为可分配条件（distributivity condition），即对于V中的所有x和y以及F中的所有f，有

f（x∧y）=f（x）∧f（y）

当然，如果a=b，那么根据等幂性有a∧b=a，因此a≤b。这样，可分配性蕴含了单调性，但是反过来并不成立。

例9.24　令y和z为到达定值框架下的定值集合。令f是一个定义为f（x）=G∪（x-K）的函数，其中G和K为某个定值的集合。通过检验下面的等式

G∪（（y∪z）-K）=（G∪（y-K））∪（G∪（z-K））

我们就可以证明到达定值的框架满足可分配性条件。

虽然上面的等式看起来很难，但我们可以首先考虑在G中的那些定值。这些定值一定都在上面等式的左部和右部所定义的两个集合中。因此我们只需要考虑不在G中的定值的集合。在这种情况下，我们可以把G从所有的地方删除，并验证等式

（y∪z）-K=（y-K）∪（z-K）

通过Venn图就可以很容易地验证这个等式。
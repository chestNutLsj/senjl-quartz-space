### 9.3.3　通用框架的迭代算法

我们可以对算法9.11进行推广，使之能够处理各种数据流问题。

算法9.25　通用数据流框架的迭代解法。

输入：一个由下列部分组成的数据流框架：

1）一个数据流图，它有两个被特别标记为ENTRY和EXIT的结点。

2）数据流的方向D。

3）一个值集V。

4）一个交汇运算∧。

5）一个函数的集合F，其中fB表示基本块B的传递函数。

6）V中的一个常量值vENTRY或者vEXIT。它们分别表示前向和逆向框架的边界条件。

输出：上述数据流图中各个基本块B的IN［B］和OUT［B］的值。这些值在V中。

方法：解决前向和逆向数据流问题的算法分别显示在图9-23a和图9-23b中。和9.2节中的各个数据流迭代算法类似，我们通过不断近似逼近的方式来计算各个基本块的IN值和OUT值。

![416-1](../Images/image04689.jpeg)

图9-23　数据流问题迭代算法的前向和逆向的版本

也可以改写算法9.25，使得它把实现交汇运算的函数作为一个参数，同时也把实现各基本块的传递函数的函数作为参数。流图本身和边界值也都作为参数。使用这种方法，编译器的实现者就可以避免为编译器优化阶段所使用的每个数据流框架都从头编写基本迭代算法的代码。

我们可以使用至今为止讨论的抽象框架来证明该迭代算法的一组有用的性质：

1）如果算法9.25收敛，其结果就是数据流方程组的一个解。

2）如果框架是单调的，那么找到的解就是数据流方程组的最大不动点（Maximum FixedPoint，MFP）。一个最大不动点是一个具有下面性质的解：在任何其他解中，IN［B］和OUT［B］的值和MFP中对应的值之间具有≤关系。

3）如果框架的半格是单调的，且高度有穷，那么这个迭代算法必定收敛。

论证这些论点时，我们首先假设框架是前向的。对于逆向框架的论证实质上是一样的。第一个性质很容易证明。如果在while循环结束的时候方程组没有被满足，那么各个OUT值（对前向框架）或IN值（对逆向框架）中至少有一个值改变了，我们必须再次运行该循环。

为了证明第二个性质，我们首先证明，在运行算法迭代时任意的基本块B的IN［B］和OUT［B］所取的值只能（相对于格中的≤关系而言）下降。这个性质可以通过归纳方法证明。

归纳基础：归纳的基础步骤是证明IN［B］和OUT［B］的值在第一个迭代之后不大于初始值。这个论断的正确性是显而易见的，因为所有不等于ENTRY的基本块B的IN［B］和OUT［B］都被初始化为![411-1](../Images/image04687.jpeg)。

归纳步骤：假设经过k次迭代之后，那些值都不大于第（k-1）次迭代后的值，我们要证明第k+1次迭代和第k次迭代相比同样如此。图9-23a的第5行是：

![416-2](../Images/image04690.jpeg)

我们用IN［B］i和OUT［B］i标记IN［B］和OUT［B］在第i次迭代之后的值。假设OUT［P］k≤OUT［P］k-1，由交汇运算的性质可知IN［B］k+1≤IN［B］k。接下来，第（6）行说

OUT［B］=fB（IN［B］）

因为IN［B］k+1≤IN［B］k，由单调性可知OUT［B］k+1≤OUT［B］k。

请注意，每一个IN［B］和OUT［B］值的改变都必须满足上述等式。交汇运算返回的是其输入的最大下界，且传递函数返回的值是和基本块本身及它的给定输入一致的唯一解。因此，如果该迭代算法终止，其结果值至少和任何其他解的相应值一样大。也就是说，算法9.25的结果是数据流方程式的最大不动点。

最后考虑第三点，即数据流框架具有有穷高度的情况。因为每个IN［B］和OUT［B］的值在每次被改变时都会减小，而程序在某一轮循环中没有值改变时就会停止，因此算法的迭代次数不会大于框架高度和流图结点个数的乘积，因此算法必然终止。
### 9.3.1　半格

半格（semilattice）是满足下列条件的一个集合V和一个二元交汇运算∧。对于V中的所有x、y和z：

1）x∧x=x（交汇运算是等幂的）。

2）x∧y=y∧x（交汇运算是可交换的）。

3）x∧（y∧z）=（x∧y）∧z（交汇运算是符合结合律的）。

半格有一个顶元素，表示为![411-1](../Images/image04687.jpeg)，使得对于V中的所有x，![411-1](../Images/image04687.jpeg)∧x=x。

半格可能还有一个底元素，表示为⊥，使得对于V中的所有x，⊥∧x=⊥。

偏序

正如我们将看到的，一个半格的交汇运算定义了值域上的一个偏序。假设≤为V上的一个关系，如果对于V上的所有x、y和z都有：

1）x≤x（该偏序是自反的）。

2）如果x≤y且y≤x，那么x=y（该偏序是反对称的）。

3）如果x≤y且y≤z，那么x≤z（该偏序是传递的）

那么≤就是一个偏序（partial order）。

二元组（V，≤）被称为偏序集（partially ordered set，poset）。对于一个偏序集，定义如下的关系<会带来一些方便：

x<y当且仅当（x≤y）且x≠y

半格的偏序

为半格（V，∧）定义一个如下的偏序≤会有所帮助。对于V中的所有x和y，我们定义

x≤y当且仅当x∧y=x

因为交汇运算∧是等幂的、可交换的且满足结合律，上面定义的序≤就是自反的、反对称的和传递的。下面来说明其中的原因：

- 自反性：即对于所有的x，x≤x。因为交汇运算是等幂的，因此x∧x=x。
- 反对称性：即如果x≤y且y≤x，那么x=y。在证明中，x≤y意味着x∧y=x，而y≤x意味着y∧x=y。根据∧的可交换性，x=（x∧y）=（y∧x）=y。
- 传递性：即如果x≤y且y≤z，那么x≤z。证明如下：x≤y且y≤z意味着x∧y=x且y∧z=y。那么使用交汇运算的结合律得到（x∧z）=（（x∧y）∧z）=（x∧（y∧z））=（x∧y）=x。因为已经证明了x∧z=x，我们有x≤z，从而证明了传递性。

例9.18　在9.2节的例子中使用的交汇运算是集合的并集或交集运算。它们都是等幂的，可交换的和可结合的。对于集合的并运算，顶元素是![408-4](../Images/image04681.jpeg)，而底元素是全集U。这是因为对于U的任何子集x都有![408-4](../Images/image04681.jpeg)∪x=x且U∪x=U。对于集合的交汇运算，![411-1](../Images/image04687.jpeg)是U而⊥是![408-4](../Images/image04681.jpeg)。半格的值域V就是全集U的所有子集的集合。这个集合有时被称为U的幂集（power set），并用2U表示。

对于V中的所有x和y，x∪y=x意味着x⊇y。因此，并集运算确定的偏序为⊇，即集合的包含关系。相应地，集合的交集运算确定的偏序是⊆，即集合的被包含关系。也就是说，对于由交集运算所确定的偏序而言，元素较少的集合被认为是比较小的值；但是对于由并集运算确定的偏序而言，元素较多的集合却被认为是较小的。一个较大的集合在偏序中反而较小是违反直觉的。但是根据前面的定义，这种情况是不可避免的[^8]。

9.2节中讨论过，一个数据流方程组通常有多个解，而（根据偏序关系≤而言）最大的解是最精确的。比如，在到达定值问题中，所有的数据流方程的解中最精确的解是具有最少定值的解。这个解对应于由此问题的交汇运算（即并集运算）所定义的偏序中的最大元素。在可用表达式中，最精确的解是具有最多表达式的解。同样，它是相对于由交集运算（即此问题的交汇运算）定义的偏序的最大解。

最大下界

在交汇运算和它确定的偏序之间还有一个有用的关系。假设（V，∧）是一个半格。域元素x和y的最大下界（greatest lower bound，glb）是一个满足下列条件的元素g：

1）g≤x

2）g≤y，且

3）如果z是使得z≤x且z≤y成立的元素，那么z≤g。

我们的结论是，x和y的交汇运算值就是它们的唯一最大下界。为了说明其中的原因，令g=x∧y。可以观察到下列性质：

- 因为（x∧y）∧x=x∧y，所以g≤x。这个结论的证明只涉及结合性、可交换性和等幂性质。也就是，

g∧x=（（x∧y）∧x）=（x∧（y∧x））=（x∧（x∧y））=（（x∧x）∧y）=（x∧y）=g

- 通过类似的论证可以得到g≤y。
- 假设z是任意的满足z≤x和z≤y的元素。已知z≤g，因此除非z就是g，否则它不是x和y的一个最大下界。证明如下：（z∧g）=（z∧（x∧y））=（（z∧x）∧y）。因为z≤x，我们知道（z∧x）=z，因此（z∧g）=（z∧y）。因为z≤y，我们知道z∧y=z，因此z∧g=z。我们已经证明了z≤g，并且得出结论g=x∧y是x和y的唯一最大下界。

并函数、最小上界和格

和一个偏序集合中的元素的最大下界操作对应，我们可以把元素x和y的最小上界（least upper bound，lub）定义为满足下列条件的元素b：x≤b且y≤b，并且对于任何满足x≤z和y≤z的元素z都有b≤z。可以证明，如果存在最小上界，那么最多只有一个最小上界。

在一个真的格中有两个域元素上的运算：我们已经看到的交汇运算∧，以及记为∨的并函数。并（join）函数给出了两个元素的最小上界。因此格中的元素总是存在最小上界。至今为止我们一直讨论的是“半个”格，即只存在交汇运算和并函数之一。也就是说，我们的半格是一个交半格（meet semilattice）。人们也可以讨论并半格（join semilattice），即只有并函数的半格。实际上有些程序分析的文献就使用并半格的概念。因为传统的数据流文献讲的是交半格，所以在本书中我们也使用交半格。

格图

把域V画成一个格图对我们会有所帮助。格图的结点是V的元素，而它的边是向下的，即如果y≤x，那么从x到y有一个边。比如，图9-22给出了一个到达定值数据流模式的集合V。其中有三个定值：d1、d2和d3。因为半格中的偏序关系≤是⊇，从这三个定值的集合的子集到其所有超集有一个向下的边。因为≤是传递的，如果图中有一条从x到y的路径，我们可以按照惯例省略从x到y的边。因此，虽然在这个例子中｛ d1，d2，d3｝≤｛ d1｝，我们并没有画出这条边，因为这个边可以用经过｛ d1，d2｝的路径来表示。

![413-1](../Images/image04688.jpeg)

图9-22　定值的子集的格

有一点也很有用，即我们可以从这样的图中读出交汇值。因为x∧y就是它们的最大下界，因此这个值总是最高的、从x和y都有向下的路径到达的元素z。比如，如果x是｛d1｝而y是｛d2｝，那么图9-22中的z就是｛d1，d2｝。这是正确的，因为这里的交汇运算是并集运算。顶元素将出现在格图的顶部，也就是说，从![411-1](../Images/image04687.jpeg)到图中的每个元素都有一条向下的路径。类似地，底元素将出现在图的底部，从每个元素都有一条边到达⊥。

乘积格

图9-22中只涉及了三个定值，而一个典型程序的格图可能相当大。数据流值的集合是定值的幂集。因此如果一个程序中有n个定值，则该程序的数据流值集合包含2n个元素。但是，一个定值是否到达某个程序点和其他定值的可达性无关。我们因此可以用“乘积格”的方式来表示定值的格[^9]。这个乘积格由各个定值对应的简单格构造得到。也就是说，如果程序中只有一个定值d，那么相应的格将只包括两个元素：空集｛｝（它是顶元素）以及｛d｝（它是底元素）。

严格地讲，我们按照下面的方式构造乘积格。假设｛A，∧A｝和｛B，∧B｝是两个（半）格。这两个格的乘积格定义如下：

1）乘积格的域是A×B。

2）乘积格的交汇运算∧定义如下：如果（a，b）和（a′，b′）是乘积格域中的元素，那么

（a，b）∧（a′，b′）=（a∧Aa′，b∧Bb′）　（9.19）

乘积格的偏序可以很简单地用A的偏序≤A和B的偏序≤B来表示：

（a，b）≤（a′，b′）当且仅当a≤Aa′且b≤Bb′　（9.20）

为了看出为什么从式（9.19）可以推出式（9.20），请注意下面的性质：

（a，b）∧（a′，b′）=（a∧Aa′，b∧Bb′）

我们可能会问在什么情况下（a∧Aa′，b∧Bb′）=（a，b）？当且仅当a∧Aa′=a且b∧Bb′=b的时候这个等式成立。而这两个条件和a≤Aa′和b≤Bb′是一回事。

格的乘积是一个满足结合律的运算，因此我们可以证明规则（9.19）和（9.20）可以被扩展到任意多个格。也就是说，如果我们有格（Ai，∧i）（i=1，2，…，k），那么这k个格按照这个顺序的乘积的域为A1×A2×…×Ak，其交汇运算定义为：

（a1，a2，…，ak）∧（b1，b2，…，bk）=（a1∧1b1，a2∧2b2，…，ak∧kbk）

而偏序定义为

（a1，a2，…，ak）≤（b1，b2，…，bk）当且仅当对于所有的i，ai≤bi。

半格的高度

通过研究一个数据流问题中的半格的“高度”，我们可以知道一些关于数据流分析算法收敛速度的信息。偏序集（V，≤）的一个上升链（ascending chain）是一个满足x1<x2<…<xn的序列。一个半格的高度（height）是所有上升链中的<关系个数的最大值。也就是说，高度比链中的元素个数少一。比如，一个有n个定值的程序的到达定值半格的高度是n。

如果一个半格具有有穷的高度，就可以比较容易地证明相应的迭代数据流算法的收敛性。显然，一个由有穷值集组成的格具有有穷的高度；一个具有无穷多个值的格也可能具有有穷的高度。在常量传播算法中使用的格就是一个这样的例子，我们将在9.4节中详细地说明这个例子。
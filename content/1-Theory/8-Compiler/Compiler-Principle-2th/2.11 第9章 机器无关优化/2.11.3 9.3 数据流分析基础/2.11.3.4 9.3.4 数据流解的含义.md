### 9.3.4　数据流解的含义

现在我们知道使用前面的迭代算法得到的解是最大不动点，但从程序语义的角度来看，这个结果又代表了什么呢？为了理解一个数据流框架（D，F，V，∧）的解，我们首先描述一下一个框架的理想解应该是什么样子。我们将给出下面的性质，即一般情况下不能得到理想解，但是算法9.25保守地给出了理想解的近似值。

理想解

不失一般性，我们假设现在感兴趣的数据流框架是一个前向的数据流问题。考虑一个基本块B的入口点。求理想解的第一步是要找到从程序入口到达B的开头的所有可能的执行路径。只有当程序的某次执行能够准确地沿着某条路径进行，这条路径才被称为“可能的”。然后，理想的求解方法将计算每个可能路径尾端的数据流值，并对这些数据流值应用交汇运算得到它们的最大下界。那么，程序的任何执行都不可能在该程序点上产生一个更小的数据流值。另外，这个界限还是紧致的：根据流图中到达B的所有可能路径计算得到的数据流值的集合的最大下界不可能变得更大。

我们现在更为正式地定义理想解。对于一个流图中的每个基本块B，令fB是B的传递函数。考虑任意从初始结点ENTRY到某个基本块Bk中的路径

P=ENTRY→B1→B2→…→Bk-1→Bk

程序的路径可能包含环，因此一个基本块可能在路径P中多次出现。定义P的传递函数fP为![417-2](../Images/image04691.jpeg)的函数组合的结果。请注意，![417-3](../Images/image04692.jpeg)没有参与组合运算，这表明这条路径只到达Bk的开头，而不是其结尾。执行这条路径而创建的数据流值就是fP（vENTRY），其中vENTRY是代表初始结点ENTRY的常值传递函数的结果。因此，基本块B的理想结果是

![417-1](../Images/image04693.jpeg)

按照问题中数据流框架的格理论偏序关系≤，我们有下面的结论：

- 任何比IDEAL更大的答案都是错误的。
- 任何小于或者等于这个理想值的值都是保守的，即安全的。

直观地讲，越接近理想值的值就越精确[^10]。下面说明为什么方程的解和理想值之间必须具有≤关系。请注意，对于任何基本块，只要忽略程序可能执行的某些路径就可能得到该基本块的大于IDEAL的解。但是，如果我们基于这样的较大解来改进代码，就不能保证这些被忽略的路径中一定不会有某些执行效果使得我们的代码改进不正确。反过来，任何小于IDEAL的值都可以被看作是包含了某些不必要的路径，它们可能是流图中不存在的路径，也可能流图中存在此路径但程序却不会按这条路径执行。这些较小的解将只允许进行对程序的所有可能执行都正确的转换，但是它们会禁止IDEAL值原本允许的某些转换。

基于路径交汇运算的解

但是正如9.1节中所讨论的，寻找所有可能的执行路径是一个不可判定问题。因此，我们必须使用近似方法。在数据流抽象中，假设流图中的每条路径都可能被执行。因此，我们可以用如下方法定义B的基于路径交汇运算的解。

![418-1](../Images/image04694.jpeg)

请注意，和前面讨论IDEAL时一样，MOP［B］解给出的是前向数据流框架中IN［B］的值。如果我们要考虑反向数据流框架，那么我们会把MOP［B］当作OUT［B］的值。

在MOP解中考虑的路径是所有可能被执行路径的超集。因此，MOP解中交汇运算的输入不仅包括所有可执行路径的数据流值，还包括了一些和不可能执行路径相关的数据流值。把理想解和一些其他的值进行交汇运算不可能创造出一个大于理想值的解。因此，对所有的B，我们有MOP［B］≤IDEAL［B］。我们简单地说MOP≤IDEAL。

最大不动点和MOP解

请注意，如果流图包含环，那么在MOP解中需要考虑的路径数量仍然是无界的。因此，不能直接由MOP的定义得到算法。当然，迭代算法也不是先找到所有到达一个基本块的路径，然后再应用交汇运算的，而是采用如下方法：

1）这个迭代算法访问各个基本块，其访问的顺序并不一定是执行的顺序。

2）在每个路径交汇点，算法对当前已经得到的数据流值应用交汇运算。其中一部分被使用的值可能是在初始化过程中人为加入的，并不表示从程序开始的执行结果。

那么，MOP解和算法9.25产生的MFP解之间有何关系呢？

我们首先讨论一下访问结点的顺序。在一次迭代中，我们可能在访问一个结点的前驱之前就访问这个结点。如果其前驱为ENTRY结点，OUT［ENTRY］已被初始化为正确的常量值。其他结点的OUT值被初始化为顶元素![411-1](../Images/image04687.jpeg)，这个值不小于最后的结果。由单调性可知，使用![411-1](../Images/image04687.jpeg)作为输入得到的结果不小于期望解。从某种意义上说，我们把![411-1](../Images/image04687.jpeg)当作表示不包含任何信息的值。

提前应用交汇运算的效果是什么呢？考虑图9-24中的简单例子，并假设我们对IN［B4］的值感兴趣。根据MOP的定义：

![418-2](../Images/image04695.jpeg)

图9-24　说明提前应用路径交汇运算的效果的流图

![418-3](../Images/image04696.jpeg)

在迭代算法中，如果我们按照B1、B2、B3、B4的顺序访问结点，那么

![418-4](../Images/image04697.jpeg)

在MOP的定义中最后才应用交汇运算，而迭代算法则提早使用这个函数。只有当数据流框架为可分配时得到的解才是相同的。如果一个数据流框架单调但不可分配，我们仍然有IN［B4］≤MOP［B4］。回忆一下，总的来说，如果对所有的基本块B都有IN［B］≤IDEAL［B］，那么这个解就是安全的（保守的）。这个解当然是安全的，因为MOP［B］≤IDEAL［B］。

我们现在简略说明一下为什么迭代算法提供的MFP解总是安全的。对i进行简单的归纳就可以表明在第i次迭代之后得到的值小于或等于对所有长度小于等于i的路径进行交汇运算而得到的值。但是当迭代算法终止的时候，它得到的值和再进行任意多次迭代所得到的值相同。因此其结果不会大于MOP解。因为MOP≤IDEAL且MFP≤MOP，我们知道MFP≤IDEAL，因此由迭代算法提供的MFP解是安全的。
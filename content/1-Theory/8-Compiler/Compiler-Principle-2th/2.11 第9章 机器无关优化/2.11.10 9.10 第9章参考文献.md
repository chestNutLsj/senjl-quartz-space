## 9.10　第9章参考文献

两个对代码作充分优化的早期编译器是Alpha［7］和Fortran H［16］。关于循环优化技术（比如代码移动）的基础性论文是［1］，虽然论文中的某些思想的早期版本出现在［8］中。一本非正式发行的书［4］在传播代码优化思想方面很有影响。

对数据流分析的迭代算法的第一个描述来自于Vyssotsky和Wegner的未发表的技术报告［20］。对于数据流分析的科学研究被认为是从Allen［2］和Cocke［3］的两篇文章开始的。

本节描述的基于格理论的抽象是基于Kildall［13］的文章。文中假设这些框架具有可分配性，但是很多框架不满足这个性质。在很多这样的框架出现后，论文［5］和［11］把单调性条件加入到模型中去。

部分冗余消除是［17］首先提出的。而本章中描述的懒惰代码移动算法是基于［14］。

支配结点的概念由［13］中描述的编译器首先使用。但是这个思想最早出现在［18］中。

可归约流图的概念来自于［2］。像本章中表示的这些流图的结构来自于［9］和［10］。［12］和［15］首先把流图的可归约性与常见的嵌套式控制流结构联系起来。这种联系解释了为什么这一类流图是如此的常见。

通过T1-T2归约来定义流图可归约性的思想来自于［19］。在基于区域的分析技术中使用了这个定义。基于区域的方法首先被［21］中所描述的编译器使用。

在6.2.4节中介绍的静态单赋值（Static Single-Assignment，SSA）中间表示形式把数据流和控制流都合并到其表示方法中。SSA表示法支持了同一个公共框架中的很多种优化转换的实现［6］。

![463-1](../Images/image04789.jpeg)

![464-1](../Images/image04790.jpeg)

---

[^1]: R.Sedgewick，“Implementing Quicksort Programs”，Comm. ACM，21，1978，pp.847-857.

[^2]: 即使x被改变，如果我们把E的计算结果同时赋值给变量x和另一个新的变量y，我们仍然可以用y来替代对E的计算，从而复用该计算过程。

[^3]: 原文如此，但是似乎应该是“数据流值”。——译者注

[^4]: 注意，路径中可能包含循环，因此我们可能沿着这条路径到达d的另一次出现。这种情况下，d没有被“杀死”。

[^5]: 细心的读者可能会注意到，可以很容易把（1）、（2）两行合并。但是，在类似的数据流算法中，初始化入口结点或出口结点时用的方法可能和初始化其他结点的方法不同。因此我们依照所有的迭代算法的模式，即像行（1）那样应用“边界条件”的动作，与行（2）中的初始化动作分开进行。

[^6]: 请注意，如在本章中通常使用的，我们使用运算符+来代表一个一般性的运算符，不是一定指加法运算。

[^7]: 本练习在9.3节之后完成。

[^8]: 并且，如果我们把偏序定义为≥而不是≤，对于并集而言就不会产生这样的问题，但是对于交集而言还是会有这样的问题。

[^9]: 在这里及以后的讨论中，我们常常会把“半格”中的“半”字去掉，因为像我们现在讨论的那些格都有一个并（或者说lub）运算符，虽然我们不会使用这个运算符。

[^10]: 请注意，在一个前向的问题中，我们希望IN［B］的值等于IDEAL［B］的值。我们没有在这里讨论逆向的问题。在逆向的问题中，我们把IDEAL［B］定义为OUT［B］的理想值。

[^11]: 和往常一样，+表示一个一般性的运算符号，而不是只表示加法。

[^12]: 请注意，对表达式值的使用和对变量值的使用不同，它实际上是说该表达式出现在某个语句的右部。——译者注

[^13]: D.E.Knuth, “An empirical study of FORTRAN programs,”, Software: Practice and Experience 1: 2（1971）, pp.105-133.

[^14]: ，但是对类似于R2这样的单基本块区域，如果我们在这个上下文环境下使用基本块名字而不是区域名字的话，文字表述通常会更清楚。
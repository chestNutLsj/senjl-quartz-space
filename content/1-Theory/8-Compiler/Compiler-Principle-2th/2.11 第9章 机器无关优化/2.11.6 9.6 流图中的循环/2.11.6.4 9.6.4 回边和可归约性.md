### 9.6.4　回边和可归约性

回边是指一条边a→b，它的头b支配了它的尾a。对于任何流图，每条回边都是后退边，但并不是所有的后退边都是回边。如果一个流图的任何深度优先生成树中所有后退边都是回边，那么该流图被称为可归约的（reducible）。换句话说，如果一个流图是可归约的，那么它的所有DFST的后退边的集合都是相同的，并且就是流图的回边集合。但如果流图是不可归约的（即不是可归约的），那么所有的回边在任何DFST中都是后退边，但是每个DFST中都可能另有一些后退边不是回边。这样的后退边集合在不同的DFST中有所不同。因此，如果我们删除流图中所有回边后得到的流图带有环，那么该图就是不可归约的。反过来也成立。

为什么回边是后退边

假设a→b是一条回边，即它的头支配它的尾。当图9-43中的search函数到达a时，对search的调用序列必然是流图中的一条路径。当然，这条路径必然包含a的所有支配结点。由此可知，当search（a）被调用时，对serach（b）的调用必然已经开始但尚未结束。因此，当a被加入到树中时b已经在树中，并且a是作为b的一个后代被加入的。因此a→b必然是一条后退边。

在实践中出现的流图几乎都是可归约的。如果只使用诸如if-then-else、while-do、continue和break语句这样的结构化控制流语句，那么得到的程序的流图总是可归约的。即使使用了goto语句，程序也经常是可归约的，因为程序员在逻辑上会使用循环和分支的方式思考问题。

例9.43　图9-38的流图是可归约的。图中的所有后退边都是回边。也就是说，这些边的头支配各自边的尾。

例9.44　考虑图9-45中的流图，它的初始结点是1。结点1支配结点2和3，但是2不支配3，3也不支配2。因此，这个流图没有回边，因为没有哪条边的头支配其尾结点。根据我们选择从search（1）首先调用search（2）还是search（3），可以得到两个可能的深度优先生成树。在第一种情况下，边3→2是一个后退边但不是回边；在第二种情况下，2→3是一个后退边但不是回边。直观地讲，使得这个流图不可归约的原因是环2-3可以由两个不同的地方进入：结点2和结点3。

![438-1](../Images/image04726.jpeg)

图9-45　不可归约流图的规范形式
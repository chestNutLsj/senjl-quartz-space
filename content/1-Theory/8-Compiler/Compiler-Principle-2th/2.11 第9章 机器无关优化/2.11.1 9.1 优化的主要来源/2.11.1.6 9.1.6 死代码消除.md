### 9.1.6　死代码消除

如果一个变量在某一程序点上的值可能会在以后被使用，那么我们就说这个变量在该点上活跃（live）。否则，它在该点上就是死的（dead）。与此相关的一个想法就是死（或者说无用）代码。所谓死代码就是其计算结果永远不会被使用的语句。程序员不大可能有意引入死代码，死代码多半是因为前面执行过的某些转换而造成的。

例9.4　假设变量`debug`在程序的不同点上被设置为`TRUE`或者`FALSE`，并在如下的语句中使用：

![394-2](../Images/image04645.jpeg)

编译器可能能够推导出这样的结果：每次程序运行到这个语句时，`debug`的值都是`FALSE`。通常，出现这种情况的原因是不管程序实际上沿着什么分支运行，在测试`debug`的取值之前的最后一个对`debug`赋值的语句总是：

![394-3](../Images/image04646.jpeg)

如果复制传播把`debug`替换为`FALSE`，那么因为`print`语句不可能被运行到，所以它就成为死代码。我们可以把这个测试和print语句从目标代码中全部消除。更加一般地讲，如果在编译时刻推导出一个表达式的值是常量，就可以使用该常量来替代这个表达式。这个技术被称为常量折叠。

复制传播的好处之一就是它经常把一些复制语句变成死代码。比如，先进行复制传播再进行死代码消除就可以去掉图9-7的代码中对x的赋值，并将其转换成为

![394-4](../Images/image04647.jpeg)

这个代码是对图9-5中的基本块B5的进一步改进。
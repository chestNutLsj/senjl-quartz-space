### 9.1.8　归纳变量和强度消减

另一个重要的优化是在循环中找到归纳变量并优化它们的计算。对于一个变量x，如果存在一个正的或负的常数c使得每次x被赋值时它的值总是增加c，那么x就称为“归纳变量”。比如，在图9-5中，i和t2都是B2组成的循环中的归纳变量。归纳变量可以通过每次迭代进行一次简单的增量运算（加法或减法）来计算。把一个高代价的运算（比如乘法）替换为一个代价较低的运算（比如加法）的转换被称为强度消减（strength reduction）。但是归纳变量不仅允许我们在适当的时候进行强度消减优化；在我们沿着循环运行时，如果有一组归纳变量的值的变化保持步调一致，我们常常可以将这组变量删剩一个。

在处理循环时，按照“从里到外”的方式进行工作是很有用的。也就是说，我们应该从内部循环开始，然后逐步处理较大的外围循环。这样，我们将看到这个优化是如何从最内层的循环之一（即B3）开始被应用到我们的快速排序例子中的。请注意，j和t4的值的步调保持一致；因为4*j被赋给t4，每次j的值减少1时t4的值就减少4。变量j和t4就形成了一个很好的归纳变量对的例子。

当一个循环中存在两个或更多的归纳变量时，有可能只留下一个而删除其他的变量。对于图9-5中的内层循环B3，我们不能把j或t4完全删除。t4在B3中使用，而j在B4中使用。但是，我们可以用这个例子来说明强度消减优化以及归纳变量消除的部分过程。当考虑由B2、B3、B4、B5组成的外层循环时，j最终会被消除。

例9.6　在图9-5中，关系t4=4*j在对t4赋值之后一定成立，并且t4没有在内层循环B3中的其他地方被改变，这意味着关系t4=4*j+4在紧跟语句j=j-1之后必然成立。因此我们可以用t4=t4-4来替代赋值语句t4=4*j。唯一的问题是在我们第一次进入基本块B3时，t4还没有值。

因为我们必须在进入基本块B3的时候保证关系t4=4*j成立，所以在初始化j本身的基本块的尾部放置了一个对t4的初始化语句。这个语句在图9-8中以附加在基本块B1上的虚线框表示。

![395-1](../Images/image04650.jpeg)

图9-8　对基本块B3中的4*j应用强度消减优化

虽然我们增加了一个指令，但是它只会在基本块B1中执行一次。只要乘法运算比加法或者减法需要更多的时间，那么把一个乘法运算替换为减法运算就能加快目标代码的执行速度。而这个结论在很多机器上都成立。

我们用另一个归纳变量消除的例子来结束本节。在这个例子中，我们将在包含了B2、B3、B4和B5的外层循环中处理i和j。

例9.7　在强度消减优化被应用到分别环绕B2、B3的两个内部循环之后，i和j的唯一用途是计算基本块B4中的测试的结果。我们知道i和t2的值满足关系t2=4*i，而j和t4的值满足关系t4=4*j。因此，测试i≥j可以被替换为t2≥t4。一旦进行这个替换，B2中的i和B3中的j就变成了死变量，而在这些基本块中对它们的赋值就变成了可以删除的死代码。最后得到的流图如图9-9所示。

![396-1](../Images/image04651.jpeg)

图9-9　归纳变量消除之后的流图

我们已经讨论的代码改进转换都是很有效的。和图9-3中原来的流图相比，图9-9中基本块B2和B3中的指令数目由4条减少为3条。B5中的指令数目由9条减少到3条，而B6中的指令数目由8条减少到3条。确实，B1中的指令从4条指令增长为6条指令，但是在这个代码片断中B1只被执行一次，因此总的运行时间几乎不会受到B1的大小的影响。
### 9.1.4　全局公共子表达式

如果表达式E在某次出现之前已经被计算过，并且E中变量的值从那次计算之后就一直没被改变，那么E的该次出现就称为一个公共子表达式（common subexpression）。如果将E的上一次计算结果赋予变量x，且x的值在中间没有被改变[^2]，那么我们就可以使用前面计算得到的值，从而避免重新计算E。

例9.1　在图9-4a中对`t7`和`t10`的赋值分别计算了公共子表达式4*i和4*j。这些步骤已经在图9-4b中被消除了。消除后的代码使用`t6`来替代`t7`，使用`t8`来替代`t10`。

例9.2　图9-5显示了从图9-3中流图的基本块B5和B6中消除全局和局部公共子表达式之后的结果。我们首先讨论对B5的转换，然后再讨论一些和数组相关的精妙之处。

如图9-4b所示，在消除局部公共子表达式之后，B5仍然对4*i和4*j进行求值。它们都是公共子表达式。更明确地讲，使用在B3中计算得到的t4的值，B5中的三个语句

![392-2](../Images/image04638.jpeg)

可以替换为

![392-3](../Images/image04639.jpeg)

观察一下图9-5，我们会发现当控制流从B3中计算4*j的点传递到B5中时，j和t4的值都没有改变。因此，当需要4*j时可以使用t4来替代。

在用t4替换t8之后，B5中的另一个公共子表达式就显露出来了。新的子表达式是a［t4］，对应于源代码层次上的值a［j］。当控制流离开B3进入B5时，不仅仅j保留了它的值，a［j］也保留了原来的值。这个值在计算出来之后保存到临时变量t5中。因为中间没有对数组a中元素的赋值，因此a［j］的值不变。B5中的语句

![392-4](../Images/image04640.jpeg)

可以被替换为

![392-5](../Images/image04641.jpeg)

类似地，可以看出图9-4b的基本块B5中赋给x的值和B2中赋给t3的值相同。图9-5中的B5是从图9-4b的B5中消除了与源代码级表达式a［i］和a［j］值对应的公共子表达式之后的结果。对于图9-5中的B6也进行了一系列类似的转换。

图9-5的B1和B6中的表达式a［t1］不被认为是公共子表达式，虽然在这两个地方都可以使用t1。在控制流离开B1到达B6之前，它还可能经过B5，而B5中存在对a的赋值。因此，a［t1］到达B6时的值可能和它离开B1时的值有所不同。把a［t1］作为一个公共子表达式是不安全的。

![393-1](../Images/image04642.jpeg)

图9-5　经过公共子表达式消除之后的B5和B6
### 9.5.5　懒惰代码移动算法

至此，这里的讨论给出了一个包含四个步骤的算法。第一步使用执行预期来确定表达式可以被放在哪里；第二步寻找最前的能够在不复制代码且不引入不必要计算的情况下消除最多的冗余运算的割集。这个步骤把表达式的计算放置在最前的预期执行这些表达式的程序点上。第三步把割集尽量向后推，直到继续后推会改变程序语义或引入新的冗余为止。最后的第四步很简单，它删除那些给只使用一次的对临时变量赋值的语句，达到清洗代码的目的。每一个步骤都伴随一个数据流分析过程：第一个和第四个是逆向数据流问题，而第二个和第三个是前向的数据流问题。

算法概览

1）使用一个逆向数据流分析过程找到各个程序点上预期执行的所有表达式。

2）第二步把对表达式的计算放置在满足下面条件的程序点上。对于每个这样的点，总存在某条路径使得这些点是此路径中第一个预期执行这个表达式的点。我们在一个表达式最先被预期执行的地方放置了该表达式的拷贝之后，假设有一个这样的程序点p，所有到达它的原有路径中该表达式都被预期执行，那么现在该表达式在程序点p上可用。可用性可以用一个前向的数据流分析过程完成。如果我们希望把这个表达式放置在尽量靠前的地方，我们只要找出满足下面条件的程序点就可以了：在这些点上此表达式被预期执行但是不可用。

3）在一个表达式最早被预期执行的地方对表达式求值可能会使得表达式的值在被使用之前很久就被生成了。一个表达式可被后延到某个程序点的条件如下：在到达这个点的所有路径上，这个表达式在这个程序点之前已经被预期执行，但是还没有使用这个值。可后延表达式通过使用一个前向的数据流分析过程找到。我们把表达式放置在不能再后延的程序点上。

4）使用一个简单的逆向数据流分析过程来删除那些给程序中只使用一次的临时变量赋值的语句。

预处理步骤

我们现在给出完整的懒惰代码移动算法。为了使算法简单一些，我们假设开始时每个语句自己组成一个基本块，而且我们只在基本块的开头引入新的表达式计算指令。为了保证这个简化不会降低这个技术的有效性，如果一个边的目标结点有多个前驱，我们就在这个边的源结点和目标结点之间插入一个新的基本块。这么做显然也考虑了对程序中所有的关键边。

我们把每个基本块B的语义抽象为两个集合：e_useB表示B中计算的表达式，而e_killB表示被B杀死的表达式，即某个运算分量在B中定值的表达式的集合。在对懒惰代码移动技术中的四个数据流分析模式进行讨论时，将会一直使用例9.30。这四个数据流分析模式在图9-34中进行了简单的定义。

例9.30　在图9-33a的流图中，表达式b+c出现三次。因为基本块B9是一个循环的一部分，块中的表达式b+c可能被执行很多次。在B9中对此表达式的计算不仅是循环不变的，它还是一个冗余表达式，因为表达式的值已经在基本块B7中使用。对于这个例子来说，我们只需要计算b+c两次：一次在基本块B5中计算，而另一次在B2之后到B7之前的路径上计算。本节讨论的懒惰代码移动算法将把表达式计算放置在基本块B4和B5的开头。

![429-1](../Images/image04713.jpeg)

图9-33　例9.30的流图

预期执行的（anticipated）表达式

回顾一下预期执行的定义。如果从程序点p出发的所有路径最终都会计算表达式b+c的值，并且计算时b和c的值就是它们在点p上的值，那么我们说表达式b+c在程序点p上被预期执行。

在图9-33a中，所有在其入口处预期执行表达式b+c的基本块都用浅灰色方块表示。表达式b+c在基本块B3、B4、B5、B6、B7和B9中被预期执行。它在B2的入口处没有被预期执行，这是因为c的值在该基本块内被重新计算，因此假如在B2的开始处计算b+c的值，这个计算结果不会在任何路径上被使用。在B1的入口处也没有预期执行b+c，因为在从B1到B2的分支上这个计算是不必要的（虽然在路径B1→B5→B6上使用了这个计算）。类似地，因为有B8到B11的分支，该表达式也没有在B8的开头被预期执行。一条路径上的各个结点是否预期执行一个表达式可能会不断交替变化，如路径B7→B8→B9所示。

预期执行表达式问题的数据流方程组如图9-34b所示。问题的分析过程是逆向的。只有当一个表达式在基本块B的出口处被预期执行，且它不在e_killB集合中，那么它在基本块的入口处也被预期执行。基本块B同时也生成一个表达式集合e_useB，表示基本块B新使用了其中的表达式。在一个程序的出口处没有表达式被预期执行。我们关心的是在所有后继路径中都被预期执行的表达式，因此交汇运算是交集运算。因此，和我们在9.2.6节中讨论可用表达式时类似，内部程序点的初始值是表达式的全集U。

![430-1](../Images/image04714.jpeg)

图9-34　部分冗余消除中的四个数据流分析过程

可用（avaiable）表达式

第二步之后，一个表达式的多个拷贝会被分别放置到该表达式首次被预期执行的程序点上。这么做之后，如果原来的程序中所有到达程序点p的路径都预期执行这个表达式，那么现在这个表达式就在点p上可用。这个问题和9.2.6节中描述的可用表达式问题类似。但是这里使用的传递函数略有不同。一个表达式在一个基本块的出口处可用的条件有两个：

1）下列条件之一成立

① 在入口处可用。

② 在基本块的入口处所预期执行的表达式集合中（即如果我们选择在入口处计算这个表达式，它就会在入口处变得可用）。

2）没有被这个基本块杀死。

用于可用表达式的数据流方程组如图9-34b所示。为了避免混淆IN的含义，我们在数据流分析问题的名字后加上“［B］.in”，以这个方式来表示某次分析所得到的结果。

依据最前放置的策略而在一个基本块B上放置的表达式的集合（即earliest［B］）被定义为被预期执行但不可用的表达式集合，即

earliest［B］=anticipated［B］.in-available［B］.in.

例9.31　图9-35的流图中表达式b+c在基本块B3的入口点没有被预期执行，但是在基本块B4的入口处被预期执行。然而，没有必要在基本块B4中计算表达式b+c，因为B2使得表达式b+c在此处变得可用。

![430-3](../Images/image04715.jpeg)

图9-35　例9.31的流图，用以说明可用表达式的使用

例9.32　图9-33a中带有黑色阴影的各个基本块上的表达式b+c不可用，这些基本块是B1、B2、B3和B5。该表达式的靠前放置的位置使用带有黑色阴影的灰色方块表示，它们是B3和B5。请注意，b+c被认为在B4的入口处可用，因为在一条路径B1→B2→B3→B4中，b+c至少被预期执行一次——在这个例子里是B3——并且从B3的入口点开始，b和c都没有被重新计算。

2×2方块的补全

被预期执行的表达式（其他文献中也称之为“很忙的表达式”）是一类我们之前没有看到的数据流分析。虽然我们已经看到了活跃变量分析（见9.2.5节）这样的逆向框架，且我们看到了可用表达式分析（9.2.6节）那样使用交集运算作为交汇运算的框架。这是第一个具有这两个特点的有用分析技术的例子。几乎我们使用的所有分析技术都可以放到四个分组中的某一个中。这四个组按照下面的方法进行刻划：它们是前向的还是逆向的，它们是使用并集运算还是交集运算作为交汇运算（可以按照这两个特性的不同取值把各个数据流分析模式分别放到一个2×2方块中的某个空格中，而本节的分析技术填补了方阵中的一个空格，译者注）。同时请注意，使用并集的分析总是涉及是否存在一条路径使得某件事情为真，而使用交集的分析考虑的是某些事情是否对于所有的路径都为真。

可后延（postponable）表达式

算法的第三步在保持原程序语义并将冗余最小化的情况下把表达式的计算尽量地延后。例9.33说明了这个步骤的重要性。

例9.33　在图9-36所示的流图中，表达式b+c在路径B1→B5→B6→B7中被计算两次。表达式b+c甚至在基本块B1的开头就被预期执行了。如果我们在表达式被预期执行的时候立刻计算它的值，那么我们就要在B1中计算b+c的值。计算结果将在一开始就被保存起来，经过由基本块B2、B3组成的循环的执行，最后由基本块B7使用。在另一种方法中，我们可以把表达式b+c的计算推迟到B5的开始以及控制流即将从B4到达B7的时候。

![431-1](../Images/image04716.jpeg)

图9-36　例9.33的流图，用以说明后延一个表达式的需求

正式地讲，一个表达式x+y可后延到程序点p的前提如下：在所有从程序入口结点到达p的路径中都会碰到一个位置较前的x+y，并且在最后一个这样的位置到p之间没有对x+y的使用。

例9.34　让我们再次考虑图9-33中的表达式b+c。其中可放置b+c的两个最前的点是B3和B5。请注意，这两个基本块在图9-33a中都被表示为带有黑色阴影的灰色方块，这表示在且只在这两个基本块上b+c被预期执行但不可用。我们不能把b+c从B5后延到B6，因为b+c在B5中被使用了。但是我们可以把它从B3后延到B4。

但是，我们不能把b+c从B4后延到B7。原因是虽然b+c在B4中没有使用，把它放到B7中而不是B4中会引起路径B5→B6→B7上的冗余计算。我们将看到，B4是我们能够计算b+c的最后位置之一。

可后延表达式问题的数据流方程组如图9-34c所示。这个分析过程是前向的。我们不能把一个表达式“后延”到程序的入口处，因此OUT［ENTRY］=![408-4](../Images/image04681.jpeg)。如果一个表达式在B中没有使用，且它可以后延到B的入口处，或者它在earliest［B］中，那么它就可以被后延到B的出口处。除非一个基本块的所有前驱结点出口处的可后延集合中都包含某个表达式，否则该表达式不能被后延到这个基本块的入口处。因此，这个数据流分析的交汇运算是交集运算，并且各个内部程序点必须被初始化为相应半格的顶元素——全集。

粗略地说，一个表达式将被放置在边界上，即一个表达式从可后延转变成为不可后延的地方。更加明确地说，表达式e可以被放置在基本块B的开始处的前提条件是该表达式在B入口处的earliest集合或可后延集合中。另外，当下列条件之一成立时，B在e的后延边界中：

1）e不在集合postponable［B］.out中。换句话说，e在e_useB中。

2）e不能被后延到B的某个后继基本块。换句话说，存在一个B的后继基本块使得e不在该后继入口处的earliest集合和可后延集合中。

因为在算法的预处理阶段引入了新的基本块，所以在上述两种情形中，表达式e可以放在基本块B的前面。

例9.35　图9-33b显示了上述分析的结果。其中的灰色方块表示了相应earliest集合中包含b+c的基本块，而黑色阴影的方块表示了相应可后延集合中包含b+c的基本块。因此，表达式b+c的最后放置位置在基本块B4和B5的入口处，这是因为

1）b+c在B4的可后延集合中，但是不在B7的可后延集中，并且

2）B5的earliest集合包含了b+c，并且它使用了b+c。

如图所示，该表达式的值在基本块B4和B5中被存放到临时变量t中，在任何其他地方的b+c都被替换为t。

被使用的（used）表达式

最后，用一个逆向分析过程来确定一个被引入的临时变量是否在它所在基本块之外的其他地方使用。如果从程序点p出发的一条路径在表达式被重新求值之前使用了该表达式，那么我们说该表达式在点p上被使用。这个分析实质上是活跃性分析（是对表达式而言，而不是对变量而言）。

被使用的表达式问题的数据流方程组如图9-34d所示。这个分析过程是逆向的。如果一个在基本块B的出口点被使用的表达式不在B的最后放置（latest）集合中，那么它也是一个在B的入口点处被使用的表达式。一个基本块生成了e_useB集合中的全部表达式，就是说新近使用了这些表达式。在程序的出口处没有表达式被使用。因为我们关心的是找出被任何后续路径所使用的表达式，因此这个问题的交汇运算是并集运算。因此，各个内部点必须被初始化为相应的半格的顶元素——空集。

综合全部步骤

本算法的各个步骤在算法9.36中进行了汇总。

算法9.36　懒惰代码移动。

输入：一个流图，其中每个基本块B的e_useB和e_killB已经计算得到了。

输出：一个经过修改且满足9.5.3节所描述的懒惰代码移动的四个条件的数据流图。

方法：

1）在每条进入某个具有多个前驱的基本块的边上插入一个空基本块。

2）按照9-34a中的定义，计算出所有基本块B的anticipated［B］.in的值。

3）按照9-34b中的定义，计算出所有基本块B的available［B］.in的值。

4）为每个基本块B计算它的最早放置位置；

earliest［B］=anticipated［B］.in-available［B］.in

5）按照图9-34c的定义，计算出所有基本块B的postponable［B］.in的值。

6）计算所有基本块B的最后放置集合：

![433-1](../Images/image04717.jpeg)

请注意，其中的¬表示的是以程序中所计算的全部表达式的集合作为全集的补集运算。

7）按照图9-34d中的定义，找到所有基本块B的used［B］.out值。

8）对于程序计算的每个表达式，比如x+y，做下列处理：

① 为x+y创建一个新的临时变量，比如说t。

② 对于所有基本块B，如果x+y在latest［B］∩used［B］.out中，就把t=x+y加入到B的开头。

③ 对于所有基本块B，如果x+y在集合e_useB∩（¬latest［B］∪used.out［B］）中，就用t来替换原来的每个x+y。

总结

部分冗余消除技术用统一的算法归纳出不同类型的冗余计算。这个算法说明了如何使用多个数据流问题来寻找最优的表达式位置。

1）有关位置的约束由预期执行表达式分析提供。预期执行表达式分析是一个逆向的数据流分析，并使用交集运算作为交汇运算。因为它确定的是对于各个程序点，一个表达式是否在该点之后的所有路径中被使用。

2）一个表达式的最前放置位置就是该表达式在其上被预期执行但又不可用的程序点。可用表达式是通过一个前向数据流分析找到的，它使用交集运算作为交汇运算。对各个程序点，这个数据流分析技术计算了一个表达式是否在所有路径中都在该点之前被预期执行。

3）一个表达式的最后放置位置就是该表达式在其上不可再后延的程序点。如果到达一个程序点的所有路径都没有碰到某个表达式，那么该表达式在此程序点上可以后延。可后延表达式是通过一个前向的数据流分析技术找到的，这个分析技术使用交集运算作为交汇运算。

4）除非一个临时赋值语句被其后的某条路径使用，否则该赋值语句可以被消除。我们通过一个逆向的数据流分析来发现被使用的表达式，它使用并集运算作为交汇运算。
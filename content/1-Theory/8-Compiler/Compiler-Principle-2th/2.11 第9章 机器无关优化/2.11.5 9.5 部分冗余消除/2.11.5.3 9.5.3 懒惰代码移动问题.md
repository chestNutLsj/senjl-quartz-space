### 9.5.3　懒惰代码移动问题

我们期望使用部分冗余消除算法进行优化而得到的程序能够具有下列性质：

1）所有不复制代码就可以消除的表达式冗余计算都被消除掉了。

2）优化后的程序不会执行原来的程序中不执行的任何计算。

3）表达式的计算时刻应该尽量靠后。

最后一个性质是很重要的，因为找到的冗余表达式的值通常会在被使用之前一直存放在寄存器中。尽量靠后地计算一个值可以尽可能地降低该值的生命周期，即从该值被定值的时刻到它最后被使用的时刻之间的时间间隔。缩短生命期也就尽可能降低了它使用寄存器的时间。我们把以尽可能延迟计算为目标的部分冗余消除优化称为懒惰代码移动。

为了形成对于这个问题的直观理解，我们首先讨论如何推导单条路径上的某个表达式是否具有部分冗余性。为方便起见，我们在下面的讨论中假设每个语句都是由它自己组成的单语句基本块。

完全冗余

如果在到达基本块B的所有路径中，一个表达式e已经被求过值且e的运算分量在其后没有被重新定值，那么B中的e就是冗余的。令S是那些使得基本块B中的e变得冗余，并且包含表达式e的基本块的集合。所有的从S中的某个基本块离开的边必然形成一个割集（cut set）。如果把这些边删除，那么基本块B必然和程序的入口点分离。而且，在从S中的基本块到B的路径中，e的所有运算分量都没有被重新定值。

部分冗余

如果基本块B中的一个表达式e只是部分冗余，那么懒惰代码移动算法将在该流图中放置这个表达式的附加拷贝，试图使得B中的e成为完全冗余的。如果该尝试成功，那么经过优化后的流图也会有一个基本块的集合S，其中的每个基本块都包含表达式e，并且离开它们的边成为程序入口和B的割集。和完全冗余的情况一样，e的所有运算分量都不会在从S中的基本块到B的路径上被重新定值。
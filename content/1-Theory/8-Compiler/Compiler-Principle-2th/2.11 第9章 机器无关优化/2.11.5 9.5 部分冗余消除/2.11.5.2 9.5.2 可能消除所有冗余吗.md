### 9.5.2　可能消除所有冗余吗

可能消除各条路径上的所有冗余计算吗？除非我们能够通过创建新的基本块来改变流图，否则答案是“不能”。

例9.28　在图9-31a显示的例子中，如果程序的执行路径是B1→B2→B4，则表达式b+c在基本块B4中冗余地计算。但是，我们不能简单地把b+c的计算指令移动到B3，因为这么做会在执行路径为B1→B3→B5时多计算一次b+c。

![426-1](../Images/image04710.jpeg)

图9-31　B3→B4是一条关键边

我们想做的是在基本块B3和B4之间的边上插入b+c的计算指令。为了插入这个指令，我们可以创建一个新的基本块，比如B6，把该指令放到B6中，并使得从B3开始的控制流首先经过B6再到达B4。这个转换显示在图9-31b中。

我们把所有从一个具有多个后继的结点到达另一个具有多个前驱的结点的边定义为流图的关键边（critical edge）。通过在关键边上引入新的基本块，我们总是可以找到一个基本块作为放置表达式的适当位置。比如在图9-31b中从B3到B4的边就是关键边，因为B3具有两个后继而B4有两个前驱。

仅靠增加基本块可能不足以消除所有的冗余计算。如例9.29所示，我们要复制代码，以便把找到的具有冗余特性的路径隔离开来。

例9.29　在图9-32a所示的例子中，表达式b+c沿着路径B1→B2→B4→B6被冗余地计算。我们可能愿意从这条路径的基本块B6中删除b+c的冗余计算，并只在路径B1→B3→B4→B4上计算这个表达式。但是，源程序中没有哪个程序点或边唯一地对应于第二条路径。为了创建这样一个程序点，我们可以复制一对基本块B4和B6，其中的一对经过B2到达，而另一对经过B3到达，如图9-32b所示。基本块B2中的表达式b+c的结果存放在t中，并在![426-3](../Images/image04711.jpeg)中被移动到变量d中。![426-3](../Images/image04711.jpeg)是从B2到达的B6的拷贝。

![426-2](../Images/image04712.jpeg)

图9-32　为消除冗余所做的代码复制

因为路径数目和程序中条件分支的数目之间具有指数关系，所以消除所有的冗余表达式可能会大大增加优化后代码的大小。因此我们对所讨论的冗余消除技术做了一些限制，即只允许引入新的基本块，但是不允许复制控制流图的任何部分。
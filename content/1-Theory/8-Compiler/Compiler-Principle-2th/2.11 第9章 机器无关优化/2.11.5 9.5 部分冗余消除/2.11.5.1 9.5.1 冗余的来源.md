### 9.5.1　冗余的来源

图9-30演示了冗余的三种形式：公共子表达式、循环不变表达式和部分冗余表达式。该图中给出了优化之前和之后的代码。

![424-1](../Images/image04705.jpeg)

图9-30　各种冗余的例子

全局公共子表达式

在图9-30a中，基本块B4中计算的表达式b+c是冗余的。不管按照哪条路径，当控制流到达B4时这个表达式在之前已经被求过值了。正如我们在这个例子中观察到的，在不同的路径上表达式可能取不同的值。我们可以按照下面的方法优化代码。在基本块B2和B3中把b+c的计算结果存放到同一个临时变量（比如说t）中。然后在基本块B4中不再重新计算这个表达式，而是直接把t的值赋给e。如果在对b+c的最后一次求值之后以及基本块B4之前对b或c有一个赋值运算，那么B4中的这个表达式就不再是冗余的。

正式地讲，如果按照9.2.6节的说法，一个表达式b+c在程序点p上是一个可用表达式，我们就说该表达式在该点上是（完全）冗余的。也就是说，在所有到达p的路径中，表达式b+c已经被求过值，并且在最后一次求值之后变量b和c没有被重新定值。后一个条件是必须的，因为虽然从字面上看表达式b+c在到达点p时已经执行过了，但在p点计算得到的b+c的值可能是不同的，因为运算分量可能已经改变了。

寻找“深层”公共子表达式

使用可用表达式分析来寻找冗余表达式时只能够找出字面上相同的可用表达式。比如，如果两个代码片断

![424-2](../Images/image04706.jpeg)

和

![424-3](../Images/image04707.jpeg)

之间b和c没有被重新定值，那么应用公共子表达式消除可以发现在第一个代码片断中的t1和第二个代码片断中的t2具有相同的值。但是它无法发现a和e的值也相同。如果要找出这一类“深层”的公共子表达式，我们可以重复应用公共子表达式消除技术，直到某一次应用时找不到新的公共子表达式为止。另一种可能的方法是使用练习9.4.2中的框架来找出“深层”公共子表达式。

循环不变表达式

图9-30b给出了一个循环不变表达式的例子。假设变量b和c在循环中没有被重新定值，那么b+c就是循环不变的。我们可以把循环中的所有重复执行替换为循环外的单次计算，从而优化程序。我们把计算的结果赋予一个临时变量，比如说t，然后把循环中的表达式替换为t。当进行与此类似的“代码移动”优化时，我们还需要考虑另一个问题。我们不应该执行任何在未优化时不执行的指令。比如，如果有可能在不执行这个循环不变指令时就离开循环，那么我们就不应该把该指令移动到循环之外。这样做有两个原因。

1）如果该指令会引发一个异常，那么执行此指令可能会抛出一个原程序中本来不会发生的异常。

2）如果循环提早退出，“优化”过的程序需要的执行时间比原程序更多。

为了保证while循环中的循环不变表达式可以被优化，编译器通常把语句

![425-1](../Images/image04708.jpeg)

表示成为下面的等价语句

![425-2](../Images/image04709.jpeg)

通过这种方法，各个循环不变表达式可以直接放置在repeat-until结构之前。

在公共子表达式消除中，一个冗余的表达式计算被直接丢弃。循环不变表达式消除和公共子表达式消除不同，它要求把循环内的一个表达式移动到循环之外。因此，这个优化通常叫做“循环不变代码移动”。循环不变代码移动可能需要重复进行，因为一旦一个变量被确定具有循环不变的值，使用这个变量的某些表达式也可能成为循环不变的。

部分冗余表达式

一个部分冗余表达式的例子如图9-30c所示。基本块B4中的表达式b+c在路径B1→B2→B4上冗余，但是在路径B1→B3→B4上不冗余。我们可以在基本块B3上放一个计算b+c的指令，从而消除前一条路径上的冗余。所有b+c的计算结果都被写进临时变量t，并且B4中对b+c的计算用t替代。因此，和循环不变代码移动一样，部分冗余消除需要放置一些新的表达式计算指令。
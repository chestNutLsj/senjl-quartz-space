### 4.7.5　高效构造LALR语法分析表的方法

我们可以对算法4.59进行多处修改，使得在创建LALR（1）语法分析表的过程中不需要构造出完整的规范LR（1）项集族。

- 首先，我们可以只使用内核项来表示任意的LR（0）或LR（1）项集。也就是说，只使用初始项［S′→·S］或［S′→·S，$］以及那些点不在产生式体左端的项来表示项集。
- 我们可以使用一个“传播和自发生成”的过程（我们稍后将描述这个方法）来生成向前看符号，根据LR（0）项的内核生成LALR（1）项的内核。
- 如果我们有了LALR（1）内核，我们可以使用图4-40中的CLOSURE函数对各个内核求闭包，然后再把这些LALR（1）项集当作规范LR（1）项集族，使用算法4.56来计算分析表条目，从而得到LALR（1）语法分析表。

例4.61　我们将使用例子4.48中的非SLR文法作为一个例子，说明高效的LALR（1）语法分析表构造方法。下面我们重新给出这个文法的增广形式：

S′→S

S→L=R | R

L→*R | id

R→L

这个文法的完整LR（0）项集显示在图4-39中。这些项集的内核显示在图4-44中。

![188-1](../Images/image04247.jpeg)

图4-44　文法（4.49）的LR（0）项集的内核

现在我们必须给这些用内核表示的LR（0）项加上正确的向前看符号，创建出LALR（1）项集的内核。在两种情况下，向前看符号b可以添加到某个LALR（1）项集J中的LR（0）项B→γ·δ之上：

1）存在一个包含内核项［A→α·β，a］的项集I，并且J=GOTO（I，X）。不管a为何值，在按照图4-40的算法构造

GOTO（CLOSURE（{［A→α·β，a］}，X）

时得到的结果中总是包含［B→γ·δ，b］。对于B→γ·δ而言，这个向前看符号b被称为自发生成的。作为一个特殊情况，向前看符号$对于初始项集中的项［S′→·S］而言是自发生成的。

2）其余条件和（1）相同，但是a=b，且按照图4-40所示计算GOTO（CLOSURE（{［A→α·β，b］}），X）得到的结果中包含［B→γ·δ，b］的原因是项A→α·β有一个向前看符号b。在这种情况下，我们说向前看符号从I的内核中的A→α·β传播到了J的内核中的B→γ·δ上。请注意，传播关系并不取决于某个特定的向前看符号，要么所有的向前看符号都从一个项传播到另一个项，要么都不传播。

我们需要确定每个LR（0）项集中自发生成的向前看符号，同时也要确定向前看符号从哪些项传播到了哪些项。这个检测实际上相当简单。令#为一个不在当前文法中的符号。令A→α·β为项集I中的一个内核LR（0）项。对每个X计算J=GOTO（CLOSURE（{［A→α·β，#］}），X）。对于J中的每个内核项，我们检查它的向前看符号集合。如果#是它的向前看符号，那么向前看符号就从A→α·β传播到了这个项。所有其他的向前看符号都是自发生成的。这个思想在下面的算法中被精确地表达了出来。这个算法还用到了一个性质：J中的所有内核项中点的左边都是X，也就是说，它们必然是形如B→γX·δ的项。

算法4.62　确定向前看符号。

输入：一个LR（0）项集I的内核K以及一个文法符号X。

输出：由I中的项为GOTO（I，X）中内核项自发生成的向前看符号，以及I中将其向前看符号传播到GOTO（I，X）中内核项的项。

方法：算法在图4-45中给出。

![189-1](../Images/image04248.jpeg)

图4-45　发现传播的和自发生成的向前看符号

现在我们可以把向前看符号附加到LR（0）项集的内核上，从而得到LALR（1）项集。首先，我们知道$是初始LR（0）项集中的S′→·S的向前看符号。算法4.62给出了所有自发生成的向前看符号。将所有这些向前看符号列出之后，我们必须让它们不断传播，直到不能继续传播为止。有很多方法可以实现这个传播过程。从某种意义上说，所有这些方法都跟踪已经传播到某个项但是尚未传播出去的“新”向前看符号。下面的算法描述了一个将向前看符号传播到所有项中的技术。

算法4.63　LALR（1）项集族的内核的高效计算方法。

输入：一个增广文法G′。

输出：文法G′的LALR（1）项集族的内核。

方法：

1）构造G的LR（0）项集族的内核。如果空间资源不紧张，最简单的方法是像4.6.2节那样构造LR（0）项集，然后再删除其中的非内核项。如果内存空间非常紧张，我们可以只保存各个项集的内核项，并在计算一个项集I的GOTO之前先计算I的闭包。

2）将算法4.62应用于每个LR（0）项集的内核和每个文法符号X，确定GOTO（I，X）中各内核项的哪些向前看符号是自发生成的，并确定向前看符号从I中的哪个项被传播到GOTO（I，X）中的内核项上。

3）初始化一个表格，表中给出了每个项集中的每个内核项相关的向前看符号。最初，每个项的向前看符号只包括那些被我们在步骤（2）中确定为自发生成的符号。

4）不断扫描所有项集的内核项。当我们访问一个项i时，使用步骤（2）中得到的、用表格表示的信息，确定i将它的向前看符号传播到了哪些内核项中。项i的当前向前看符号集合被加到和这些被传播的内核项相关联的向前看符号集合中。我们继续在内核项上进行扫描，直到没有新的向前看符号被传播为止。

例4.64　我们为例子4.61的文法构造LALR（1）项集的内核。这个文法的LR（0）项集的内核如图4-44所示。当我们将算法4.62应用于项集I0的内核时，我们首先计算CLOSURE（{［S′→·S，#］}），即

![190-3](../Images/image04249.jpeg)

在这个闭包的项中，我们看到两个项中的向前看符号=是自发生成的。第一个项是L→·*R。这个项中点的右边是*，它生成了［L→*·R，=］。也就是说，=是I4中L→*·R的自发生成的向前看符号。类似地，［L→·id，=］告诉我们=是I5中L→id·的自发生成的向前看符号。

因为#是这个闭包中六个项的向前看符号，所以我们确定I0中的项S′→·S将它的向前看符号传播到下面的六个项中：

![190-4](../Images/image04250.jpeg)

在图4-47中，我们说明了算法4.63的步骤（3）和（4）。标号为INIT的列给出了各个内核项的自发生成的向前看符号。这些符号中只包括前面讨论过的=的两次出现，以及初始项S′→·S的自发生成的向前看符号$。

在第一趟扫描中，向前看符号$从I0中的S′→·S传播到图4-46中列出的六个项上。向前看符号=从I4中的L→*·R传播到I7中的L→*R·和I8中的R→L·上。它还传递到它自身以及I5中的L→id· 上，但是这些向前看符号本来就已经存在了。在第二和第三趟扫描时，唯一被传播的新向前看符号是$，它在第二趟扫描时被传播到I2和I4的后继中，并在第三趟扫描时到达I6的后继中。在第四趟扫描时没有新的向前看符号被传播，因此最终的向前看符号集合如图4-47最右边的列所示。

![190-1](../Images/image04251.jpeg)

图4-46　向前看符号的传播

![190-2](../Images/image04252.jpeg)

图4-47　向前看符号的计算

请注意，在例4-48中，使用SLR方法时发现的移入/归约冲突在使用LALR技术时消失了。虽然I2中的S→L·=R生成了在输入=上的移入动作，但是I2中R→L·的向前看符号只包括$，因此两者之间不再有冲突。
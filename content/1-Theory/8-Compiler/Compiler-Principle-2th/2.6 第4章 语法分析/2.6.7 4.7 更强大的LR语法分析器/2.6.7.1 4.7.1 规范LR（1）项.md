### 4.7.1　规范LR（1）项

现在我们将给出最通用的为文法构造LR语法分析表的技术。回顾一下，在SLR方法中，如果项集Ii包含项［A→α·］，且当前输入符号a在FOLLOW（A）中，那么状态i就要按照A→α进行归约。然而在某些情况下，当状态i出现在栈顶时，栈中的可行前缀是βα且在任何最右句型中a都不可能跟在βA之后，那么当输入为a时不应该按照A→α进行归约。

例4.51　让我们重新考虑例子4.48，其中的状态2包含项R→L·。这个项对应于上面讨论的A→α，而和a对应的是FOLLOW（R）中的符号=。因此，SLR语法分析器在下一个输入为=且状态为2时要求按照R→L进行归约（因为状态2中还包含项S→L·=R，它同时还要求执行移入动作）。然而，例4.48的文法没有以R=…开头的最右句型。因此状态2只和可行前缀L对应，它实际上不应该执行从L到R的归约。

如果在状态中包含更多的信息，我们就可能排除掉一些这样的不正确的A→α归约。在必要时，我们可以通过分裂某些状态，设法让LR语法分析器的每个状态精确地指明哪些输入符号可以跟在句柄α的后面，从而使α可能被归约成为A。

将这个额外的信息加入状态中的方法是对项进行精化，使它包含第二个分量，这个分量的值为一个终结符号。项的一般形式变成了［A→α·β，a］，其中A→αβ是一个产生式，而a是一个终结符号或右端结束标记$。我们称这样的对象为LR（1）项。其中的1指的是第二个分量的长度。第二个分量称为这个项的向前看符号[^6]。在形如［A→α·β，a］且β≠∈的项中，向前看符号没有任何作用，但是一个形如［A→α·，a］的项只有在下一个输入符号等于a时才要求按照A→α进行归约。因此，只有当栈顶状态中包含一个LR（1）项［A→α·，a］，我们才会在输入为a时按照A→α进行归约。这样的a的集合总是FOLLOW（A）的子集，而且如例4.51所示，它很可能是一个真子集。

正式地讲，我们说LR（1）项［A→α·β，a］对于一个可行前缀γ有效的条件是存在一个推导![181-1](../Images/image04237.jpeg)，其中

1）γ = δα，且

2）要么a是w的第一个符号，要么w为∈且a等于$。

例4.52　让我们考虑文法

S→B B

B→a B | b

该文法有一个最右推导![181-2](../Images/image04238.jpeg)。在上面的定义中，令δ=aa，A=B，w=ab，α=a且β=B，我们可知项［B→α·B，a］对于可行前缀γ=aaa是有效的。另外还有一个最右推导![181-3](../Images/image04239.jpeg)。根据这个推导，我们知道项［B→α·B，$］是可行前缀Baa的有效项。
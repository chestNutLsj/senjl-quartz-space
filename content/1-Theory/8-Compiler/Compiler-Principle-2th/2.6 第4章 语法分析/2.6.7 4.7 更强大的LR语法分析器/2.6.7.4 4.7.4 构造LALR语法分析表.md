### 4.7.4　构造LALR语法分析表

现在我们介绍最后一种语法分析器构造方法，即LALR（向前看-LR）技术。这个方法经常在实践中使用，因为用这种方法得到的分析表比规范LR分析表小很多，而且大部分常见的程序设计语言构造都可以方便地使用一个LALR文法表示。对于SLR文法，这一点也基本成立，只是仍然存在少量构造不能够方便地使用SLR技术来处理（例如，见例4.48）。

我们对语法分析器的大小做一下比较。一个文法的SLR和LALR分析表总是具有相同数量的状态，对于像C这样的语言来说，通常有几百个状态。对于同样大小的语言，规范LR分析表通常有几千个状态。因此，构造SLR和LALR分析表要比构造规范LR分析表更容易，而且更经济。

为了介绍LALR技术，让我们再次考虑文法（4.55）。该文法的LR（1）项集如图4-41所示。让我们查看两个看起来差不多的状态，比如I4和I7。它们都只有一个项，其第一个分量都是C→d·。在I4中，向前看符号是c或d；在I7中，$是唯一的向前看符号。

为了了解I4和I7在语法分析器中担负的不同角色，请注意这个文法生成了正则语言c*dc*d。当读入输入cc…cdcc…cd的时候，语法分析器首先将第一组c以及跟在它们后面的d移入栈中。语法分析器在读入d之后进入状态4。然后，当下一个输入符号是c或d时，语法分析器按照产生式C→d进行一次归约。要求c或d跟在后面是有道理的，因为它们可能是c*d中的串的开始符号。如果$跟在第一个d后面，我们就有形如ccd的输入，而它们不在这个语言中。如果$是下一个输入符号，状态4就会正确地报告一个错误。

语法分析器在读入第二个d之后进入状态7。然后，语法分析器必须在输入中看到$，否则输入开头的符号串就不具有c*dc*d的形式。因此状态7应该在输入为$时按照C→d进行归约，而在输入为c或d的时候报告错误。

现在，我们将I4和I7替换为I47，即I4和I7的并集。这个项集包含了［C→d·，c/d/$］所代表的三个项。原来在输入d上从I0、I2、I3到达I4或I7的goto关系现在都到达I47。状态47在所有输入上的动作都是归约。这个经过修改的语法分析器行为在本质上和原分析器一样。虽然在有些情况下，原分析器会报告错误，而新分析器却将d归约为C。比如，在处理ccd或cdcdc这样的输入时就会出现这样的情况。新的分析器最终能够找到这个错误，实际上这个错误会在移入任何新的输入符号之前就被发现。

更一般地说，我们可以寻找具有相同核心（core）的LR（1）项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合。比如在图4-41中，I4和I7就是这样一对项集，它们的核心是{C→d·}。类似地，I3和I6是另一对这样的项集，它们的核心是{C→c·C，C→·cC，C→·d}。另外，还有一对项集I8和I9，它们的公共核心是{C→cC·}。请注意，一般而言，一个核心就是当前正处理的文法的LR（0）项集，一个LR（1）文法可能产生多个具有相同核心的项集。

因为GOTO（I，X）的核心只由I的核心决定，一组被合并的项集的GOTO目标也可以被合并。因此，当我们合并项集时可以相应地修改GOTO函数。动作函数也需要加以修改，以反映出被合并的所有项集的非报错动作。

假设我们有一个LR（1）文法，也就是说，这个文法的LR（1）项集没有产生语法分析动作冲突。如果我们将所有具有相同核心的状态替换为它们的并集，那么得到的并集有可能产生冲突。但是因为下面的原因，这种情况不大可能发生：假设在并集中有一个项［A→α·，a］要求按照A→α进行归约，同时另一个项［B→β·aγ，b］要求进行移入，那么就会出现在向前看符号a上的冲突。此时必然存在某个被合并进来的项集中包含项［A→α·，a］，同时因为所有这些状态的核心都是相同的，所以这个被合并进来的项集中必然还包含项［B→β·aγ，c］，其中c是某个终结符号。如果这样的话，这个状态中同样也有在输入a上的移入/归约冲突，因此这个文法不是我们假设的LR（1）文法。因此，合并具有相同核心的状态不会产生出原有状态中没有出现的移入/归约冲突，因为移入动作仅由核心决定，不考虑向前看符号。

然而，如下面的例子所示，合并项集可能会产生归约/归约冲突。

例4.58　考虑文法

S′→S

S→a A d | b B d | a B e | b A e

A→c

B→c

该文法产生四个串acd、ace、bcd和bce。读者可以构造出这个文法的LR（1）项集，以验证该文法是LR（1）的。完成这些工作之后，我们发现项集{［A→c·，d］，［B→c·，e］}是可行前缀ac的有效项，{［A→c·，e］，［B→c·，d］}是bc的有效项。这两个项集都没有冲突，并且它们的核心是相同的。然而，它们的并集，即

A→c·，d/e

B→c·，d/e

产生了一个归约/归约冲突，因为当输入为d或e的时候，这个合并项集既要求按照A→c进行归约，又要求按照B→c进行归约。

我们将给出两个LALR分析表构造算法，现在来介绍其中的第一个。这个算法的基本思想是构造出LR（1）项集，如果没有出现冲突，就将具有相同核心的项集合并。然后我们根据合并后得到的项集族构造语法分析表。我们将要描述的方法的主要用途是定义LRLA（1）文法。构造整个LR（1）项集族需要的空间和时间太多，因此很少在实践中使用。

算法4.59　一个简单，但空间需求大的LALR分析表的构造方法。

输入：一个增广文法G′。

输出：文法G′的LALR语法分析表函数ACTION和GOTO。

方法：

1）构造LR（1）项集族C={I0，I1，…，In}。

2）对于LR（1）项集中的每个核心，找出所有具有这个核心的项集，并将这些项集替换为它们的并集。

3）令C′={J0，J1，…，Jm}是得到的LR（1）项集族。状态i的语法分析动作是按照和算法4.56中的方法根据Ji构造得到的。如果存在一个分析动作冲突，这个算法就不能生成语法分析器，这个文法就不是LALR（1）的。

4）GOTO表的构造方法如下。如果J是一个或多个LR（1）项集的并集，也就是说J=I1∪I2∪…∪Ik，那么GOTO（I1，X），GOTO（I2，X），…，GOTO（Ik，X）的核心是相同的，因为I1、I2、…、Ik具有相同的核心。令K是所有和GOTO（I1，X）具有相同核心的项集的并集，那么GOTO（J，X）=K。

算法4.59生成的分析表称为G的LALR语法分析表。如果没有语法分析动作冲突，那么给定的文法就称为LALR（1）文法。在第（3）步中构造得到的项集族被称为LALR（1）项集族。

例4.60　再次考虑文法（4.55）。该文法的GOTO图已经显示在图4-41中。我们前面提到过，有三对可以合并的项集。I3和I6被替换为它们的并集：

I36：C→c·C，c/d/$

C→·cC，c/d/$

C→·d，c/d/$

I4和I7被替换为它们的并集：

I47：C→d·，c/d/$

I8和I9被替换为它们的并集：

I89：C→cC·，c/d/$

这些压缩过的项集的LALR动作和GOTO函数显示在图4-43中。

要了解如何计算GOTO关系，考虑GOTO（I36，C）。在原来的LR（1）项集中，GOTO（I3，C）=I8，而现在I8是I89的一部分，因此我们令GOTO（I36，C）为I89。如果我们考虑I6，即I36的另一部分，我们仍然可以得到相同的结论。也就是说，GOTO（I6，C）=I9，I9现在是I89的一部分。再举一个例子。考虑GOTO（I2，c），即在状态I2上输入为c时执行移入之后的状态。在原来的LR（1）项集中，GOTO（I2，C）=I6。因为I6现在是I36的一部分，所以GOTO（I2，c）变成了I36。因此，图4-43中对应于状态2和输入c的条目被设置为s36，表示移入并将状态36压入栈中。

![187-1](../Images/image04246.jpeg)

图4-43　例子4.54的文法的LALR分析表

当处理语言c*dc*d中的一个串时，图4-42的LR语法分析器和图4-43的LALR语法分析器执行完全相同的移入和归约动作序列，尽管栈中状态的名字有所不同。比如，在LR语法分析器将I3或I6压入栈中时，LALR语法分析器将I36压入栈中。这个关系对于所有的LALR文法都成立。在处理正确的输入时，LR语法分析器和LALR语法分析器将相互模拟。

在处理错误的输入时，LALR语法分析器可能在LR语法分析器报错之后继续执行一些归约动作。然而，LALR语法分析器决不会在LR语法分析器报错之后移入任何符号。比如，在输入为ccd且后面跟有$时，图4-42的LR语法分析器将

0 3 3 4

压入栈中，并且在状态4上发现一个错误，因为下一个输入符号是$而状态4在$上的动作为报错。相应地，图4-43中的LALR语法分析器将执行对应的操作，将

0 36 36 47

压入栈中。但是状态47在输入为$时的动作为归约C→d。因此，LALR语法分析器将把栈中内容改为

0 36 36 89

现在，状态89在输入$上的动作为归约C→cC。栈中内容变为

0 36 89

此时仍要求进行一个类似的归约，得到栈

0 2

最后，状态2在输入$上的动作为报错，因此现在发现了这个错误。
### 4.4.4　非递归的预测分析

我们可以构造出一个非递归的预测分析器，它显式地维护一个栈结构，而不是通过递归调用的方式隐式地维护栈。这样的语法分析器可以模拟最左推导的过程。如果w是至今为止已经匹配完成的输入部分，那么栈中保存的文法符号序列α满足

![159-1](../Images/image04194.jpeg)

图4-19中的由分析表驱动的语法分析器有一个输入缓冲区，一个包含了文法符号序列的栈，一个由算法4.31构造得到的分析表，以及一个输出流。它的输入缓冲区中包含要进行语法分析的串，串后面跟有结束标记$。我们复用符号$来标记栈底。在开始时刻，栈中$的上方是开始符号S。

![159-2](../Images/image04195.jpeg)

图4-19　一个分析表驱动的预测分析器的模型

语法分析器由一个程序控制。该程序考虑栈顶符号X和当前输入符号a。如果X是一个非终结符号，该分析器查询分析表M中的条目M［X，a］来选择一个X产生式。（这里可以执行一些附加的代码，比如构造一个语法分析树结点的代码。）否则，它检查终结符号X和当前输入符号a是否匹配。

这个语法分析器的行为可以使用它的格局（configuration）来描述。格局描述了栈中的内容和余下的输入。下面的算法描述了如何处理格局。

算法4.34　表驱动的预测语法分析。

输入：一个串w，文法G的预测分析表M。

输出：如果w在L（G）中，输出w的一个最左推导；否则给出一个错误指示。

方法：最初，语法分析器的格局如下：输入缓冲区中是w$，而G的开始符号S位于栈顶，它的下面是$。图4-20中的程序使用预测分析表M生成了处理这个输入的预测分析过程。

![159-3](../Images/image04196.jpeg)

图4-20　预测分析算法

例4.35　考虑文法（4.28）。我们已经在图4-17中看到了它的预测分析表。处理输入id + id * id时，算法4.34的非递归预测分析器顺序执行图4-21中显示的各个步骤。这些步骤对应于一个最左推导（完整的推导过程见图4-12）：

![160-1](../Images/image04197.jpeg)

图4-21　对输入id+id*id进行预测分析时执行的步骤

![160-2](../Images/image04198.jpeg)

请注意，这个推导中的各个句型对应于已经被匹配的输入部分（见图中的已匹配列）加上栈中的内容。我们显示已匹配输入就是为了强调这种对应关系。因为同样的原因，在图中将栈顶显示在左边。当我们考虑自底向上语法分析时，将栈顶显示在右边会更加自然。分析器的输入指针指向“输入”列中的串的最左边的符号。
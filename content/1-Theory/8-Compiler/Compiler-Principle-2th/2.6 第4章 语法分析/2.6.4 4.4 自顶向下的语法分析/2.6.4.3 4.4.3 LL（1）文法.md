### 4.4.3　LL（1）文法

对于称为LL（1）的文法，我们可以构造出预测分析器，即不需要回溯的递归下降语法分析器。LL（1）中的第一个“L”表示从左向右扫描输入，第二个“L”表示产生最左推导，而“1”则表示在每一步中只需要向前看一个输入符号来决定语法分析动作。

预测分析器的转换图

转换图有助于将预测分析器可视化。比如，图4-16a中显示了文法（4.28）中非终结符号E和E' 的转换图。要构造一个文法的转换图，首先要消除左递归，然后对文法提取左公因子。然后对每个非终结符号A：

1）创建一个初始状态和一个结束（返回）状态。

2）对于每个产生式A→ X1X2…Xn，创建一个从初始状态到结束状态的路径，路径中各条边的标号为X1、X2、…、Xn。如果A→∈，那么这条路径就是一条标号为∈的边。

预测分析器的转换图和词法分析器的转换图是不同的。分析器的转换图对每个非终结符号都有一个图。图中边的标号可以是词法单元，也可以是非终结符号。词法单元上的转换表示当该词法单元是下一个输入符号时我们应该执行这个转换。非终结符号A上的转换表示对A的过程的一次调用。

对于一个LL（1）文法，将∈边作为默认选择可以解决是否选择一个∈边的二义性问题。

转换图可以化简，前提是各条路径上的文法符号序列必须保持不变。我们也可以将一条标号为非终结符号A的边替换为A的转换图。图4-16a和图4-16b中的转换图是等价的：如果我们跟踪从E到结束状态的路径，并替换E'，那么在这两组图中，沿着这些路径的文法符号都组成了形如T+T+…+T的串。图4-16b中的图可以从图4-16a通过转换而得到。转换的方法类似于2.5.4节所述的方法。在该节中，我们使用尾递归消除和过程体替代的方法来优化一个非终结符号的相应过程。

![157-1](../Images/image04187.jpeg)

图4-16　文法4.28的非终结符号E和E′的转换图

LL（1）文法已经足以描述大部分程序设计语言构造，虽然在为源语言设计适当的文法时需要多加小心。比如，左递归的文法和二义性的文法都不可能是LL（1）的。

一个文法G是LL（1）的，当且仅当G的任意两个不同的产生式A→α | β满足下面的条件：

1）不存在终结符号a使得α和β都能够推导出以a开头的串。

2）α和β中最多只有一个可以推导出空串。

3）如果![157-2](../Images/image04188.jpeg)，那么α不能推导出任何以FOLLOW（A）中某个终结符号开头的串。类似地，如果![157-3](../Images/image04189.jpeg)，那么β不能推导出任何以FOLLOW（A）中某个终结符号开头的串。

前两个条件等价于说FIRST（α）和FIRST（β）是不相交的集合。第三个条件等价于说如果∈在FIRST（β）中，那么FIRST（α）和FOLLOW（A）是不相交的集合，并且当∈在FIRST（α）中时类似结论成立。

之所以能够为LL（1）文法构造预测分析器，原因是只需要检查当前输入符号就可以为一个非终结符号选择正确的产生式。因为有关控制流的各个语言构造带有不同的关键字，它们通常满足LL（1）的约束。比如，如果我们有如下产生式

![157-5](../Images/image04190.jpeg)

那么关键字if、while和符号{告诉我们：如果在输入中找到一个语句，哪个产生式是唯一可能匹配成功的。

接下来给出的算法把FIRST和FOLLOW集合中的信息放到一个预测分析表M［A，a］中。这是一个二维数组，其中A是一个非终结符号，a是一个终结符号或特殊符号$，即输入的结束标记。该算法基于如下的思想：只有当下一个输入符号a在FIRST（α）中时才选择产生式A→α。只有当α=∈时，或更加一般化的![157-4](../Images/image04191.jpeg)时，情况才有些复杂。在这种情况下，如果当前输入符号在FOLLOW（A）中，或者已经到达输入中的$符号且$在FOLLOW（A）中，那么我们仍应该选择A→α。

算法4.31　构造一个预测分析表。

输入：文法G。

输出：预测分析表M。

方法：对于文法G的每个产生式A→α，进行如下处理：

1）对于FIRST（α）中的每个终结符号a，将A→α加入到M［A，a］中。

2）如果∈在FIRST（α）中，那么对于FOLLOW（A）中的每个终结符号b，将A→α加入到M［A，b］中。如果∈在FIRST（α）中，且$在FOLLOW（A）中，也将A→α加入到M［A，$］中。

在完成上面的操作之后，如果M［A，a］中没有产生式，那么将M［A，a］设置为error（我们通常在表中用一个空条目表示）。

例4.32　对于表达式文法（4.28），算法4.31生成了图4-17中的预测分析表。空白条目表示错误条目；非空白的条目中指明了应该用其中的产生式来扩展相应的非终结符号。

![158-1](../Images/image04192.jpeg)

图4-17　例4.32的预测分析表M

考虑产生式E→TE′。因为

FIRST（TE′）= FIRST（T）= {（，id}

这个产生式被加到M［E，（］和M［E，id］中。因为FIRST（+TE′）={+}，产生式E′→+ TE′被加入到M［E′，+］中。因为FOLLOW（E′）={），$}，产生式E′→∈被加入到M［E′，）］和M［E′，$］中。

算法4.31可以应用于任何文法G，生成该文法的语法分析表M。对于每个LL（1）文法，分析表中的每个条目都唯一地指定了一个产生式，或者标明一个语法错误。然而，对于某些文法，M中可能会有一些多重定义的条目。比如，如果G是左递归的或二义性的，那么M至少会包含一个多重定义的条目。虽然可以轻松对其进行消除左递归和提取左公因子的操作，但是仍然存在一些这样的文法，它们不存在等价的LL（1）文法。

下面例子中的语言根本没有相应的LL（1）文法。

例4.33　下面重复一下例子4.22中的文法。该文法抽象地表示了悬空-else的问题。

S→iEtSS′ | a

S′ →eS | ∈

E→b

这个文法的语法分析表显示在图4-18中。M［S′，e］的条目同时包含了S′→eS和S′→∈。

![158-2](../Images/image04193.jpeg)

图4-18　例4.33的分析表M

这个文法是二义性的。当在输入中看到e（代表else）时，解决选择使用哪个产生式的问题就会显露出此文法的二义性。解决这个二义性问题时，我们可以选择产生式S′→eS。这个选择就相当于把else和前面最近的then关联起来。请注意，选择S′→∈将使得e永远不可能被放到栈中或者从输入中被消除，因此选择这个产生式一定是错误的。
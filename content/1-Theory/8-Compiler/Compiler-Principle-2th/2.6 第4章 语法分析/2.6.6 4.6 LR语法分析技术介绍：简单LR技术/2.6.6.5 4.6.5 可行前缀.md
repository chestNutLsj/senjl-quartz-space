### 4.6.5　可行前缀

为什么可以使用LR（0）自动机来做出移入-归约决定？对于一个文法的移入-归约语法分析器，该文法的LR（0）自动机可以刻画出可能出现在分析器栈中的文法符号串。栈中内容一定是某个最右句型的前缀。如果栈中的内容是α而余下的输入是x，那么存在一个将αx归约到开始符号S的归约序列。用推导的方式表示就是![178-1](../Images/image04233.jpeg)

然而，不是所有的最右句型的前缀都可以出现在栈中，因为语法分析器在移入时不能越过句柄。比如，假设

![178-2](../Images/image04234.jpeg)

那么在语法分析的不同时刻，栈中存放的内容可以是（、（E和（E），但不会是（E）*，因为（E）是句柄，语法分析器必须在移入*之前将它归约为F。

可以出现在一个移入-归约语法分析器的栈中的最右句型前缀被称为可行前缀（viable prefix）。它们的定义如下：一个可行前缀是一个最右句型的前缀，并且它没有越过该最右句型的最右句柄的右端。根据这个定义，我们总是可以在一个可行前缀之后增加一些终结符号来得到一个最右句型。

SLR分析技术基于LR（0）自动机能够识别可行前缀这一事实。如果存在一个推导过程![178-3](../Images/image04235.jpeg)，我们就说项A→β1.β2对于可行前缀αβ1有效。一般来说，一个项可以对多个可行前缀有效。

项A→β1·β2对αβ1有效的事实可以告诉我们很多信息。当我们在语法分析栈中发现αβ1时，这些信息可以帮助我们决定是进行归约还是移入。特别是，如果β2≠∈，那么它告诉我们句柄还没有被全部移入到栈中，因此我们应该选择移入。如果β2=∈，那么看起来A→β1就是句柄，我们应该按照这个产生式进行归约。当然，可能会有两个有效项要求我们对同一个可行前缀做不同的事情。有些这样的冲突可以通过查看下一个输入符号来解决，还有一些冲突可以通过4.8节中的方法来解决，但是我们不应该认为将LR方法应用于任意文法所产生的语法分析动作冲突都可以得到解决。

对于可能出现在LR语法分析栈中的各个可行前缀，我们可以很容易地计算出对应于这些可行前缀的有效项的集合。实际上，LR语法分析理论的核心定理是：如果我们在某个文法的LR（0）自动机中从初始状态开始沿着标号为某个可行前缀γ的路径到达一个状态，那么该状态对应的项集就是γ的有效项集。实质上，有效项集包含了所有能够从栈中收集到的有用信息。我们不会在这里证明这个定理，但我们将给出一个例子。

将项看作一个NFA的状态

如果将项本身看作状态，我们就可以构造出一个识别可行前缀的不确定有穷自动机N。从A→α·Xβ到A→αX·β有一个标号为X的转换，并且从A→α·Bβ到B→·γ有一个标号为∈的转换。那么项（N的状态）的集合I的CLOSURE（I）恰恰就是3.7.1节中定义的一个NFA状态集合的∈闭包。由NFA N通过子集构造法可以得到一个DFA。GOTO（I,X）给出了这个DFA中状态I在符号X上的转换。从这个角度看，图4-33中的过程items（G'）就是将子集构造方法应用于以项作为状态的NFA N并构造出DFA的过程。

例4.50　让我们再次考虑增广表达式文法。该文法的项集和GOTO函数如图4-31所示。显然，串E+T*是该文法的一个可行前缀。图4-31中的自动机在读入E+T*之后将位于状态7上。状态7中包含了项

T→T * ·F

F→·（E）

F→·id

它们恰恰就是E+T*的有效项。为了说明原因，考虑如下三个最右推导：

![179-1](../Images/image04236.jpeg)

第一个推导说明T→T *· F是有效的，第二个推导说明F→·（E）是有效的，第三个推导说明了F→·id是有效的。可以证明E+T*没有其他的有效项，但我们并不会在这里证明这个事实。
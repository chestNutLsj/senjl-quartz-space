### 4.6.3　LR语法分析算法

图4-35中显示了一个LR语法分析器的示意图。它由一个输入、一个输出、一个栈、一个驱动程序和一个语法分析表组成。这个分析表包括两个部分（ACTION和GOTO）。所有LR语法分析器的驱动程序都是相同的，而语法分析表是随语法分析器的不同而变化的。语法分析器从输入缓冲区逐个读入符号。当一个移入-归约语法分析器移入一个符号时，LR语法分析器移入的是一个对应的状态。每个状态都是对栈中该状态之下的内容所含信息的摘要。

![173-1](../Images/image04228.jpeg)

图4-35　一个LR语法分析器的模型

分析器的栈存放了一个状态序列s0s1…sm，其中sm位于栈顶。在SLR方法中，栈中保存的是LR（0）自动机中的状态，规范LR和LALR方法和SLR方法类似。根据构造方法，每个状态都有一个对应的文法符号。回顾一下，各个状态都和某个项集对应，并且有一个从状态i到状态j的转换当且仅当GOTO（Ii，X）=Ij。所有到达状态j的转换一定对应于同一个文法符号X。因此，除了开始状态0之外，每个状态都和唯一的文法符号相关联[^4]。

LR语法分析表的结构

语法分析表由两个部分组成：一个语法分析动作函数ACTION和一个转换函数GOTO。

1）ACTION函数有两个参数：一个是状态i，另一个是终结符号a（或者是输入结束标记$）。ACTION［i，a］的取值可以有下列四种形式：

① 移入j，其中j是一个状态。语法分析器采取的动作是把输入符号a高效地移入栈中，但是使用状态j来代表a。

② 归约A→β。语法分析器的动作是把栈顶的β高效地归约为产生式头A。

③ 接受。语法分析器接受输入并完成语法分析过程。

④ 报错。语法分析器在它的输入中发现了一个错误并执行某个纠正动作。我们将在4.8.3节和4.9.4节中进一步讨论这样的错误恢复例程是如何工作的。

2）我们把定义在项集上的GOTO函数扩展为定义在状态集上的函数：如果GOTO［Ii，A］=Ij，那么GOTO也把状态i和一个非终结符号A映射到状态j。

LR语法分析器的格局

描述LR语法分析器的行为时，我们需要一个能够表示LR语法分析器的完整状态的方法。语法分析器的完整状态包括：它的栈和余下的输入。LR语法分析器的格局（configuration）是一个形如：

（s0s1…sm，aiai+1…an $）

的对。其中，第一个分量是栈中的内容（右侧是栈顶），第二个分量是余下的输入。这个格局表示了如下的最右句型：

X1X2…Xmaiai+1…an

它表示最右句型的方法本质上和一个移入-归约语法分析器的表示方法相同。唯一的不同之处在于栈中存放的是状态而不是文法符号，从这些状态能够复原出相应的文法符号。也就是说，Xi是状态si所代表的文法符号。请注意，s0（即分析器的开始状态）不代表任何文法符号，它只是作为栈底标记，同时也在语法分析过程中担负了重要的角色。

LR语法分析器的行为

语法分析器根据上面的格局决定下一个动作时，首先读入当前输入符号ai和栈顶的状态sm，然后在分析动作表中查询条目ACTOIN［sm，ai］。对于前面提到的四种动作，每个动作结束之后的格局如下：

1）如果ACTION［sm，ai］=移入s，那么语法分析器执行一次移入动作；它将下一个状态s移入栈中，进入格局

（s0s1…sms，ai+1…an$）

符号ai不需要存放在栈中，因为在需要时（在实践中从不需要ai）可以根据s恢复出ai。现在，当前的输入符号是ai+1。

2）如果ACTION［sm，ai］=规约A→β，那么语法分析器执行一次归约动作，进入格局

（s0s1…sm-rs，aiai+1…an$）

其中，r是β的长度，且s=GOTO［sm-r，A］。在这里，语法分析器首先将r个状态符号弹出栈，使状态sm-r位于栈顶。然后，语法分析器将s（即条目GOTO［sm-r，A］的值）压入栈中。在一个归约动作中，当前的输入符号不会改变。对于我们将构造的LR语法分析器，对应于被弹出栈的状态的文法符号序列Xm-r+1…Xm总是等于β，即归约使用的产生式的右部。

在一次归约动作之后，LR语法分析器将执行和归约所用产生式关联的语义动作，生成相应的输出。我们暂时假设输出的内容仅仅包括打印出归约产生式。

3）如果ACTION［sm，ai］=接受，那么语法分析过程完成。

4）如果ACTION［sm，ai］=报错，则说明语法分析器发现了一个语法错误，并调用一个错误恢复例程。

LR语法分析算法总结如下。所有的LR语法分析器都按照这个方式执行，两个LR语法分析器之间的唯一区别是它们的语法分析表的ACTION表项和GOTO表项中包含的信息不同。

算法4.44　LR语法分析算法。

输入：一个输入串w和一个LR语法分析表，这个表描述了文法G的ACTION函数和GOTO函数。

输出：如果w在L（G）中，则输出w的自底向上语法分析过程中的归约步骤；否则给出一个错误指示。

方法：最初，语法分析器栈中的内容为初始状态s0，输入缓冲区中的内容为w$。然后，语法分析器执行图4-36中的程序。

![175-1](../Images/image04229.jpeg)

图4-36　LR语法分析程序

例4.45　图4-37显示了表达式文法（4.1）的一个LR语法分析表中的ACTION和GOTO函数。下面再次给出文法（4.1），并对它们的产生式进行编号：

（1）E→E + T

（2）E →T

（3）T→T*F

（4）T→F

（5）F→（E）

（6）F→id

各种动作在此图中的编码方法如下：

1）si表示移入并将状态i压栈。

2）rj表示按照编号为j的产生式进行归约。

3）acc表示接受。

4）空白表示报错。

请注意，对于终结符号a，GOTO［s，a］的值在ACTION表项中给出，这个值和在输入a上对应于状态s的移入动作一起给出。GOTO条目给出了对应于非终结符号A的GOTO［s，A］的值。我们还没有解释图4-37的表中各个条目是如何得到的，但很快就会来处理这个问题。

![175-2](../Images/image04230.jpeg)

图4-37　表达式文法的语法分析表

在处理输入id * id + id时，栈和输入内容的序列显示在图4-38中。为清晰起见，图中还显示了与栈中状态对应的文法符号的序列。比如，在第1行中，LR语法分析器位于状态0上。这是初始状态，没有对应的文法符号，而第一个输入符号是id。图4-37中的动作部分第0行、id列中的动作是s5，表示应该移入，将状态5压栈。在第2行，状态符号5被压入到栈中，而id从输入中被删除。

![175-3](../Images/image04231.jpeg)

图4-38　一个LR语法分析器处理输入id*id+id的各个步骤

然后，*变成了当前的输入符号，而状态5在输入为*时的动作是根据产生式F→id进行归约。一个状态符号被弹出栈。然后，状态0成为栈顶。因为状态0对于F的GOTO值是3，因此状态3被压到栈中。现在我们得到第3行中的格局。下面的各个动作的执行方式与此类似。
### 4.6.2　项和LR（0）自动机

一个移入-归约语法分析器怎么知道何时进行移入、何时进行归约呢？比如，当图4-28中栈的内容为$T而下一个输入符号是*时，语法分析器是怎么知道位于栈顶的T不是句柄，因此正确的动作是移入而不是将T归约到E呢？

一个LR语法分析器通过维护一些状态，用这些状态来表明我们在语法分析过程中所处的位置，从而做出移入-归约决定。这些状态代表了“项”（item）的集合。一个文法G的一个LR（0）项（简称为项）是G的一个产生式再加上一个位于它的体中某处的点。因此，产生式A→XYZ产生了四个项：

A→·XYZ

A→X·YZ

A→XY·Z

A→XYZ·

产生式A→∈只生成一个项A→·。

项集的表示

一个生成自底向上语法分析器的生成工具可能需要便利地表示项和项集。请注意，一个项可以表示为一对整数，第一个整数是基础文法的产生式编号，第二个整数是点的位置。项集可以用这些数对的列表来表示。然而，如我们将看到的，需要用到的项集通常包含“闭包”项，这些项的点位于产生式体的开始处。这些项总是可以根据项集中的其他项重新构造出来，因此我们不必将它们包含在这个列表中。

直观地讲，项指明了在语法分析过程中的给定点上，我们已经看到了一个产生式的哪些部分。比如，项A→·XYZ表明我们希望接下来在输入中看到一个从XYZ推导得到的串。项A→X·YZ说明我们刚刚在输入中看到了一个可以由X推导得到的串，并且我们希望接下来看到一个能从YZ推导得到的串。项A→XYZ·表示我们已经看到了产生式体XYZ，已经是时候把XYZ归约为A了。

一个称为规范LR（0）项集族（canonical LR（0）collection）的一组项集提供了构建一个确定有穷自动机的基础。该自动机可用于做出语法分析决定。这样的有穷自动机称为LR（0）自动机[^3]。更明确地说，这个LR（0）自动机的每个状态代表了规范LR（0）项集族中的一个项集。表达式文法（4.1）的对应的自动机显示在图4-31中。我们将把它用做讨论规范LR（0）项集族的连续使用的例子。

![170-1](../Images/image04224.jpeg)

图4-31　表达式文法（4.1）的LR（0）自动机

为了构造一个文法的规范LR（0）项集族，我们定义了一个增广文法（augmented grammar）和两个函数：CLOSURE和GOTO。如果G是一个以S为开始符号的文法，那么G的增广文法G′就是在G中加上新开始符号S′和产生式S′→S而得到的文法。引入这个新的开始产生式的目的是告诉语法分析器何时应该停止语法分析并宣称接受输入符号串。也就是说，当且仅当语法分析器要使用规则S′→S进行归约时，输入符号串被接受。

项集的闭包

如果I是文法G的一个项集，那么CLOSURE（I）就是根据下面的两个规则从I构造得到的项集：

1）一开始，将I中的各个项加入到CLOSURE（I）中。

2）如果A→α·Bβ在CLOSURE（I）中，B→γ是一个产生式，并且项B→·γ不在CLOSURE（I）中，就将这个项加入其中。不断应用这个规则，直到没有新项可以加入到CLOSURE（I）中为止。

直观地讲，CLOSURE（I）中的项A→α·Bβ表明在语法分析过程的某点上，我们认为接下来可能会在输入中看到一个能够从Bβ推导得到的子串。这个可从Bβ推导得到的子串的某个前缀可以从B推导得到，而推导时必然要应用某个B产生式。因此我们加入了各个B产生式对应的项，也就是说，如果B→γ是一个产生式，那么我们把B→·γ加入到CLOSURE（I）中。

例4.40　考虑增广的表达式文法：

E′→E

E→E + T | T

T→T * F | F

F→（E）| id

如果I是由一个项组成的项集{［E′→.E］}，那么CLOSURE（I）包含了图4-31中的项集I0。

下面说明一下如何计算这个闭包。根据规则（1），E′→·E被放到CLOSURE（I）中。因为点的右边有一个E，我们加入如下的E产生式，点位于产生式体的左端：E→·E+T和E→·T。现在，后一个项中有一个T在点的右边，因此我们加入T→·T*F和T→·F。接下来，位于点右边的F令我们加入F→·（E）和F→·id，然后就不再需要加入任何新的项。

闭包可以按照图4-32中的方法计算。实现函数closure的一个便利方法是设置一个布尔数组added，该数组的下标是G的非终结符号。当我们为各个B产生式B→γ加入对应的项B→·γ时，added［B］被设置为true。

![171-1](../Images/image04225.jpeg)

图4-32　CLOSURE的计算

请注意，如果点在最左端的某个B产生式被加入到I的闭包中，那么所有B产生式都会被加入到这个闭包中。因此在某些情况下，不需要真的将那些被CLOSURE函数加入到I中的项B→·γ列出来，只需要列出这些被加入的产生式的左部非终结符号就足够了。我们将感兴趣的各个项分为如下两类：

1）内核项：包括初始项S′→·S以及点不在最左端的所有项。

2）非内核项：除了S′→·S之外的点在最左端的所有项。

不仅如此，我们感兴趣的每一个项集都是某个内核项集合的闭包，当然，在求闭包时加入的项不可能是内核项。因此，如果我们抛弃所有非内核项，就可以用很少的内存来表示真正感兴趣的项的集合，因为我们已知这些非内核项可以通过闭包运算重新生成。在图4-31中，非内核项位于表示状态的方框的阴影部分中。

GOTO函数

第二个有用的函数是GOTO（I，X），其中I是一个项集而X是一个文法符号。GOTO（I，X）被定义为I中所有形如［A→α·Xβ］的项所对应的项［A→αX·β］的集合的闭包。直观地讲，GOTO函数用于定义一个文法的LR（0）自动机中的转换。这个自动机的状态对应于项集，而GOTO（I，X）描述了当输入为X时离开状态I的转换。

例4.41　如果I是两个项的集合{［E′→E·］，［E→E·+T］}，那么GOTO（I，+）包含如下项：

E→E+·T

T→·T*F

T→·F

F→·（E）

F→·id

我们查找I中点的右边紧跟+的项，就可以计算得到GOTO（I，+）。E′→E·不是这样的项，但E→E·+T是这样的项。我们将点移过+号得到E→E+·T，然后求出这个单元素集合的闭包。

现在我们可以给出构造一个增广文法G′的规范LR（0）项集族C的算法。这个算法如图4-33所示。

例4.42　文法（4.1）的规范LR（0）项集族和GOTO函数如图4-31所示。其中，GOTO函数用图中的转换表示。

![172-1](../Images/image04226.jpeg)

图4-33　规范LR（0）项集族的计算

LR（0）自动机的用法

“简单LR语法分析技术”（即SLR分析技术）的中心思想是根据文法构造出LR（0）自动机。这个自动机的状态是规范LR（0）项集族中的元素，而它的转换由GOTO函数给出。表达式文法（4.1）的LR（0）自动机已经在前面的图4-31中显示过了。

这个LR（0）自动机的开始状态是CLOSURE（{［S′→·S］}），其中S′是增广文法的开始符号。所有的状态都是接受状态。我们说的“状态j”指的是对应于项集Ij的状态。

LR（0）自动机是如何帮助做出移入-归约决定的呢？移入-规约决定可以按照如下方式做出。假设文法符号串γ使LR（0）自动机从开始状态0运行到某个状态j。那么如果下一个输入符号为a且状态j有一个在a上的转换，就移入a。否则我们就选择归约动作。状态j的项将告诉我们使用哪个产生式进行归约。

将在4.6.3节中介绍的LR语法分析算法用它的栈来跟踪状态及文法符号。实际上，文法符号可以从相应状态中获取，因此它的栈只保存状态。下面的例子将展示如何使用一个LR（0）自动机和一个状态栈来做出移入-归约语法分析决定。

例4.43　图4-34给出了一个使用图4-31中的LR（0）自动机的移入-归约语法分析器在分析id * id时采取的动作。我们使用一个栈来保存状态。为清晰起见，栈中状态所对应的文法符号显示在“符号”列中。在第1行，栈中存放了自动机的开始状态0，相应的符号是栈底标记$。

![172-2](../Images/image04227.jpeg)

图4-34　id*id的语法分析

下一个输入符号是id，而状态0在id上有一个到达状态5的转换。因此我们选择移入。在第2行，状态5（符号id）已经被压入到栈中。从状态5出发没有输入*上的转换，因此我们选择归约。根据状态5中的项［F→id·］，这次归约应用产生式F→id。

如果栈中保存的是文法符号，那么归约就是通过将相应产生式的体（在第2行中，产生式的体是id）弹出栈并将产生式头（在这个例子中是F）压入栈中来实现的。现在栈中保存的是状态，我们弹出和符号id对应的状态5，使得状态0成为栈顶。然后我们寻找一个F（即该产生式的头部）上的转换。在图4-31中，状态0有一个F上的到达状态3的转换，因此我们压入状态3。这个状态对应的符号是F，见第3行。

我们看另一个例子，考虑第5行，状态7（符号*）位于栈顶。这个状态有一个id上的到达状态5的转换，因此我们将状态5（符号id）压入栈中。状态5没有转换，因此我们按照F→id进行归约。当我们弹出对应于产生式体id的状态5后，状态7到达栈顶。因为状态7有一个F上的转换到达状态10，我们压入状态10（符号F）。
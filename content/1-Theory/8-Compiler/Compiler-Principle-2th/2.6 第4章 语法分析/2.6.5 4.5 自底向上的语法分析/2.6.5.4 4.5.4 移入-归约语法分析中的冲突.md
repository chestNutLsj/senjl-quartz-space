### 4.5.4　移入-归约语法分析中的冲突

有些上下文无关文法不能使用移入-归约语法分析技术。对于这样的文法，每个移入-归约语法分析器都会得到如下的格局：即使知道了栈中的所有内容以及接下来的k个输入符号，我们仍然无法判断应该进行移入还是归约操作（移入/归约冲突），或者无法在多个可能的归约方法中选择正确的归约动作（归约/归约冲突）。现在我们给出一些语法构造的例子，这些构造的文法可能会出现这样的冲突。从技术上来讲，这些文法不在4.7节定义的LR（k）文法类中，我们把它们称为非LR文法。LR（k）中的k表示在输入中向前看k个符号。在编译中使用的文法通常属于LR（1）文法类，即最多只需要向前看一个符号。

例4.38　一个二义性文法不可能是LR的。比如，考虑4.3节中的悬空-else文法（4.14）：

![166-8](../Images/image04219.jpeg)

如果我们有一个移入-归约语法分析器处于格局

![167-1](../Images/image04220.jpeg)

中，那么不管栈中if expr then stmt之下是什么内容，我们都不能确定它是否是句柄。这里就出现了一个移入/归约冲突。根据输入中else之后的内容的不同，可能应该将if expr then stmt归约为stmt，也可能应该将else移入然后再寻找另一个stmt，从而找到完整的stmt产生式体if expr then stmt else stmt。

请注意，经过修正的移入-归约语法分析技术可以对某些二义性文法进行语法分析，比如上面的if-then-else文法。如果我们在碰到else时选择移入来解决移入/归约冲突，语法分析器就会按照我们的期望运行，也就是将每个else和前一个尚未匹配的then相关联。我们将在4.8节讨论能够处理这种二义性文法的语法分析器。

另一个常见的冲突情况发生在我们确认已经找到句柄的时候。在这种情况下我们不能够根据栈中内容和下一个输入符号确定应该使用哪个产生式进行归约。下面的例子说明了这种情况。

例4.39　假设我们有这样一个词法分析器，它不考虑各个名字的类型，而是对所有的名字都返回词法单元名id。假设我们的语言在调用过程时会给出过程名字，并把调用参数放在括号内。并且假设引用数组的语法与此相同。因为在数组引用中对下标的翻译不同于过程调用中对参数的翻译，我们希望使用不同的产生式分别生成实在参数列表和下标列表。因此，我们的文法包含了图4-30中所示的产生式（还包含其他产生式）。

![167-2](../Images/image04221.jpeg)

图4-30　有关过程调用和数组引用的产生式

一个以`p（i，j）`开头的语句将以词法单元流id（id，id）的方式输入到语法分析器中。在将前三个词法单元移入到栈中后，移入-归约语法分析器将处于如下格局中：

![167-3](../Images/image04222.jpeg)

显然，栈顶的id必须被归约，但使用哪个产生式呢？如果`p`是一个过程，那么正确的选择是产生式（5）；但如果`p`是一个数组，就该选择产生式（7）。栈中的内容并没有指出`p`是什么，必须使用从`p`的声明中获得的符号表中的信息来确定。

解决方法之一是将产生式（1）中的词法单元id改成procid，并使用一个更加复杂的词法分析器。该词法分析器在识别到一个过程名字的词素时返回词法单元名procid。这就要求词法分析器在返回一个词法单元之前先查询符号表。

如果我们做了这样的修改，那么在处理`p（i，j）`的时候，语法分析器要么进入格局

![167-4](../Images/image04223.jpeg)

要么进入前面描述的格局。在前一种情况下，我们选择产生式（5）进行归约；在后一种情况下，则选择产生式（7）进行归约。请注意，在这个例子里，栈顶之下的第三个符号决定了应该执行什么归约，虽然它本身并没有被归约。移入-归约的语法分析技术可以使用栈中离栈顶很远的信息来引导语法分析过程。
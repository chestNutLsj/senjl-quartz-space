### 4.8.2　“悬空-else”的二义性

再次考虑下面的条件语句文法：

![194-3](../Images/image04264.jpeg)

如我们在4.3.2节中指出的，这个文法是二义性的，因为它没有解决悬空-else的二义性问题。为了简化这个讨论，我们考虑这个文法的一个抽象表示，其中i表示if expr then，e表示else，a表示“所有其他的产生式”。那么我可以用增广产生式S′→S重写这个文法：

S′→S

S→i S e S | i S | a　（4.67）

文法（4.67）的LR（0）项集显示在图4-50中。因为文法（4.67）的二义性，在I4中有一个移入/归约冲突。在该项集中，S→iS·eS要求将e移入，又因为FOLLOW（S）={e，$}，项S→iS·要求在输入为e的时候用S→iS进行归约。

![195-1](../Images/image04265.jpeg)

图4-50　增广文法（4.67）的LR（0）状态

把这些讨论翻译回if-then-else的术语，假设栈中内容为

if expr then stmt

且else是第一个输入符号，我们应该将else移入栈中（即移入e）呢？还是应该将if expr then stmt归约（即按照S→iS归约）呢？答案是我们应该移入else，因为它是和前一个then“相关”的。按照文法（4.67）的术语，输入中代表else的e只能作为以iS开头的产生式体的一部分，而现在栈顶内容就是iS。如果输入中跟在e后面的符号不能被归约为S，使得分析器无法归约得到完整的产生式体iSeS，那么可以证明别的语法分析过程也不可能得到这个产生式体。

我们可以确定在解决I4中的移入/归约冲突时应该在输入为e时执行移入动作。使用这个方式解决了I4在输入e上的语法分析动作冲突之后，根据图4-50的项集构造得到的SLR语法分析表显示在图4-51中。产生式1～3分别是S→iSeS、S→iS和S→a。

![195-2](../Images/image04266.jpeg)

图4-51　悬空else文法的LR分析表

比如，在处理输入iiaea时，根据正确的“悬空-else”冲突的解决方法，语法分析器执行了图4-52中所示的步骤。在第5行，状态4在输入e上选择了移入动作；而在第9行，状态4在输入$上要求按照S→iS进行归约。

![195-3](../Images/image04267.jpeg)

图4-52　处理输入iiaea时的语法分析动作

我们做一个比较，如果我们不能使用二义性文法来描述条件语句，那么我们将不得不使用例4.16中给出的笨拙的文法来描述。
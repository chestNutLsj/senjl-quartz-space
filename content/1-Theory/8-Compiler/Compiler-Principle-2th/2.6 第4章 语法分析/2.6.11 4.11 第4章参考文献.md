## 4.11　第4章参考文献

上下文无关文法的形式化表示是作为自然语言研究的一部分由Chomsky［5］提出的。在两个早期语言的语法描述中也使用了这种思想。这两个语言是Backus的Fortran［2］和Naur的Algol 60［26］。学者Panini也在公元前400到200年之间发明了一种等价的语法表示方法，用来描述梵语文法的规则。

文法二义性现象最早是由Cantor［4］和Floyd［13］观察到的。Chomsky范式（练习4.4.8）的思想来自［6］。［17］中总结了上下文无关文法的理论。

递归下降语法分析技术是早期编译器（比如［16］）和编译器编写系统（比如META［28］和TMG［25］）所选择的方法。LL文法由Lewis和Stearns［24］引入。练习4.4.5中的递归下降方法的线性时间模拟方法来自［3］。

由Floyd［14］提出的最早的一种语法分析技术考虑了运算符的优先级问题。Wirth和Weber［29］将这个思想推广到了语言中不包含运算符的部分。现在已经很少使用这些技术了，但是它们可以被看作是使LR分析技术取得进展的先驱技术。

LR语法分析器是由Knuth［22］引入的，该著作首先给出了规范-LR语法分析表。因为这个语法分析表要比当时常用计算机的主存大，所以这个方法被认为不可行的，直到Korenjak［23］给出了一个方法来为典型的程序设计语言生成适当大小的语法分析表。DeRemer发明了现在使用的LALR［8］和SLR［9］方法。为二义性文法构造LR语法分析表的方法来自［1］和［12］。

Jonhson的Yacc很快证明了使用LALR语法分析器生成工具来为编译器产品生成语法分析器的可行性。Yacc语法分析器生成工具的使用手册可以在［20］中找到。在［10］中描述了Yacc的开源版本Bison。一个类似的基于LALR技术的语法分析器生成工具被称为CUP［18］，它支持用Java编写的语义动作。自顶向下语法分析器生成工具包括Antlr［27］和LLGen。Antlr是一个递归下降语法分析器生成工具，它接受以C++、Java或C#编写的语义动作。LLGen是一个基于LL［1］的生成工具。

Dain［7］给出了一个关于语法错误处理的文献列表。

练习4.4.9中描述的通用动态规划语法分析算法是由J.Cocke（未发表）和Younger［30］以及Kasami［21］各自独立发明的，因此被命名为“CYK算法”。Earley［11］还发明了一种更加复杂的通用算法，它以表格的方式给出一个给定输入的各个子串的LR-项。虽然这个算法在一般情况下的复杂度是O（n3），但是对于无二义性文法，它的复杂度只有O（n2）。

![207-1](../Images/image04297.jpeg)

![208-1](../Images/image04298.jpeg)

---

[^1]: E和S的下标仅用于区分同一个非终结符号的不同出现，并不表示不同的非终结符号。

[^2]: 我们应该注意到，C语言和它的派生语言也属于这一类语言。虽然C系列的语言不使用关键字then，但then的作用是由if之后的条件表达式的括号对来承担的。

[^3]: 从技术上讲，根据3.6.4节的定义，这个自动机并不是确定自动机，因为我们没有对应于空项集的死状态。结果是有一些状态-输入对没有后继状态。

[^4]: 其逆命题不一定成立。也就是说，多个状态可能对应于同一个文法符号。例如，图4-31中的LR（0）自动机的状态1和8，进入它们的都是E上的转换；而对于状态2和9，它们都是通过T上的转换进入。

[^5]: 2.8.3节介绍过，一个左值表示了一个内存位置，而右值是一个可以存放在某个位置上的值。

[^6]: 当然可以使用长度大于1的向前看符号串。但是这里我们不考虑这样的向前看符号串。
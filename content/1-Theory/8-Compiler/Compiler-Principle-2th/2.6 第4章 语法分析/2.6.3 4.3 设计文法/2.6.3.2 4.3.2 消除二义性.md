### 4.3.2　消除二义性

有时，一个二义性文法可以被改写为无二义性的文法。例如，我们将消除下面的“悬空-else”文法中的二义性：

![148-1](../Images/image04167.jpeg)

这里“other”表示任何其他语句。根据这个文法，下面的复合条件语句

if E1 then S1 else if E2 then S2 else S3

的语法分析树如图4-8所示[^1]。文法（4.14）是二义性的，因为串

if E1 then if E2 then S1 else S2（4.15）

![148-2](../Images/image04168.jpeg)

图4-8　一个条件语句的语法分析树

具有图4-9所示的两棵语法分析树。

![148-3](../Images/image04169.jpeg)

图4-9　一个二义性句子的两颗语法分析树

在所有包含这种形式的条件语句的程序设计语言中，总是会选择第一棵语法分析树。通用的规则是“每个else和最近的尚未匹配的then匹配。”[^2]从理论上讲，这个消除二义性规则可以用一个文法直接表示，但是在实践中很少用产生式来表示该规则。

例4.16　我们可以将悬空-else文法（4.14）改写成如下的无二义性文法。基本思想是在一个then和一个else之间出现的语句必须是“已匹配的”。也就是说，中间的语句不能以一个尚未匹配的（或者说开放的）then结尾。一个已匹配的语句要么是一个不包含开放语句的if-then-else语句，要么是一个非条件语句。因此我们可以使用图4-10中的文法。这个文法和悬空-else文法（4.14）生成同样的串集合，但是它只允许对串（4.15）进行一种语法分析，也就是将每个else和前面最近的尚未匹配的then匹配。

![149-1](../Images/image04170.jpeg)

图4-10　if-then-else语句的无二义性方法
### 4.3.3　左递归的消除

如果一个文法中有一个非终结符号A使得对某个串α存在一个推导![149-2](../Images/image04171.jpeg)，那么这个文法就是左递归的（left recursive）。自顶向下语法分析方法不能处理左递归的文法，因此需要一个转换方法来消除左递归。在2.4.5节中，我们讨论了立即左递归，即存在形如A→Aα的产生式的情况。这里我们研究一般性的情形。在2.4.5节中，我们说明了如何把左递归的产生式对A→Aα | β替换为非左递归的产生式：

A →βA′

A′→αA′ | ∈

这样的替换不会改变可从A推导得到的串的集合。这个规则本身已经足以用来处理很多文法。

例4.17　这里重复一下非左递归的表达式文法（4.2）：

E　→　TE′

E′　→　+ T E′|∈

T　→　F T′+

T′　→　+ F T′|∈

F　→　（E）|id

它是通过消除表达式文法（4.1）中的立即左递归而得到的。左递归的产生式对E→E+T | T被替换为E→T E′和E′→+ T E′ | ∈。类似地，T和T′的新产生式也是通过消除立即左递归而得到的。

立即左递归可以使用下面的技术消除，该技术可以处理任意数量的A产生式。首先将A的全部产生式分组如下：

A→Aα1 | Aα2 | … | Aαm | β1 | β2 | … | βn

其中βi都不以A开头。然后，将这些A产生式替换为：

A→β1A′ | β2A′ | … | βnA′

A′→α1A′ | α2A′ | … | αmA′ | ∈

非终结符号A生成的串和替换之前生成的串一样，但不再是左递归的。这个过程消除了所有和A和A′的产生式相关的左递归（前提是αi都不是∈），但是它没有消除那些因为两步或多步推导而产生的左递归。比如，考虑文法

S→A a | b

A→A c | S d | ∈　（4.18）

因为S⇒Aa⇒Sda，所以非终结符号S是左递归的，但它不是立即左递归的。

下面的算法4.19系统地消除了文法中的左递归。如果文法中不存在环（即形如![150-1](../Images/image04172.jpeg)的推导）或∈产生式（即形如A→∈的产生式），就保证能够消除左递归。环和∈产生式都可以从文法中系统地消除（见练习4.4.6和练习4.4.7）。

算法4.19　消除左递归。

输入：没有环或∈产生式的文法G。

输出：一个等价的无左递归文法。

方法：对G应用图4-11中的算法。请注意，得到的非左递归文法可能具有∈产生式。

图4-11中的过程的工作原理如下。在i=1的第一次迭代中，第2～7行的外层循环消除了A1产生式之间的所有立即左递归。因此，余下的所有形如A1→Alα的产生式都一定满足l>1。在外层循环的第i-1次迭代之后，所有的非终结符号Ak（k<i）都被“清洗”过了。也就是说，任何产生式Ak→Alα都必然满足l>k。结果，在第i次迭代中，第3～5行的内层循环不断提高所有形如Ai→Amα的产生式中m的下界，直到m≥i成立为止。然后，第6行消除了Ai产生式中的立即左递归，保证m>i成立。

![150-2](../Images/image04173.jpeg)

图4-11　消除文法中的左递归的算法

例4.20　我们将算法4.19应用于文法（4.18）。从技术上讲，因为该算法有∈产生式，所以这个算法不一定能得到正确结果。但在这个例子中，最终会证明产生式A→∈是无害的。

我们将非终结符号排序为S，A。在S产生式之间没有立即左递归，因此在i=1的外层循环中不进行任何处理。当i=2时，我们替换A→Sd中的S，得到如下的A产生式。

A→A c | A a d | b d | ∈

消除这些A产生式之间的立即左递归，得到如下的文法：

S→A a | b

A→b d A′ | A′

A′→c A′ | a d A′ | ∈
---
url: https://fengmuzi2003.gitbook.io/csapp3e/di-3-zhang-ji-qi-ji-bian-cheng
title: 第 03 章：程序的机器级表示 - CSAPP 重点解读
date: 2023-09-11 22:53:21
tags:
---
**某种程度上讲，本章是本课程的核心内容之一，或者说是区别于其他课程的特色。**

很久很久以前（其实也没有那么久，毕竟计算机科学的发展也才那么几十年而已），程序员都是用二进制编码的，后来开始用汇编语言，今天，事情发生了很大的变化，人们开始使用高级语言，或者说已经工作在更高的抽象层次上了。你可能会有疑惑：为什么今天我们还要花力气来学习机器级别的编程方式呢？

这里的机器级编程包含了两种含义，一个是可以直接在机器上运行的二进制指令，另一个是汇编语言（就是编译器产生的代码），对于我们来说，两者都属于机器级别，两个概念可以互换，它们之所以很重要，因为它们是连接你所编写的高级语言代码和机器之间的纽带，是实实在在的基石，理解这里面的一些底层工作的原理还是很有必要的，实际上这也是 CSAPP 区别于其他课程的一个显著点，但这并不是要求你徒手写汇编代码（现代编译器可能比你更精通这一点，或许也比你更有耐心），只是希望当你遇到需要阅读一点点汇编代码的时候不至于惊慌无措，当然了，如果你想成为一名系统程序员或者想成为一名黑客，那么这个话题就很重要了。

历史上出现过很多知名的指令集架构，比如 Alpha， SPARC，PowerPC，MIPS 等，但是今天最流行的指令集架构是 **x86(-64)，ARM，RISC-V**，本课程把重点放在了英特尔 x86-64 上，毕竟讲课的话总是限定在某种处理器上讲起来也相对容易一些嘛，**指令集架构（ISA）的地位非常重要，就是在那里，软件遇见了硬件！**

![](1694444001572.png)

历史上出现过很多成功的指令集架构，但是时过境迁，当今主流的指令集架构，如下图所示：

![](1694444008979.png)

**Instructure Set Architecture**：指令集架构 (包括指令规格，寄存器等)，简称 ISA，它是软硬件之间的 “合同”

**Mircoarchitecture**：指令集架构的具体实现方式 (比如流水线级数，缓存大小等)，它是可变的

**Machine Code**：机器码，也就是机器可以直接执行的二进制指令

**Assembly Code**：汇编码，也就是机器码的文本形式 (主要是给人类阅读)

![](1694444011635.png)

**程序员的角度 vs 微体系结构 （程序员可见 vs 程序员不可见）**，在 CPU 方面，开放给程序员的编程接口只是 PC，寄存器，条件码，其他的内部信息比如 CPU 内部的 Cache 对程序员来说都是不可见的，内存角度来讲，大部分的 ISA 支持字节寻址方式 (即 Byte 寻址，实际上还有 Bit 寻址，32-bit 寻址，64-bit 寻址等，只是比较少见而已)，绝大多数的 ISA 具有确定的大小端模式 (有些 ISA 可变)。

其次，理解 C 程序的编译过程：源代码 `->` 编译 `->` 汇编 `->` 链接 `->` 可执行文件 `->` 装载 `->` 执行

![](1694444013966.png)

以下是 x86-64 平台编译后的汇编码和机器码，注意：不同的平台（ISA 不同）和不同的编译器会产生完全不同的机器码，但是无论如何大家可以看到最终产生的机器码无非就是 0 和 1 的组合，关键在于机器知道该怎样来解释它们。

![](1694444016013.png)

**重要思想**：程序就是一系列（被编码了的）字节序列 （看上去和数据一模一样），这就是所谓的冯诺依曼结构计算机，即程序存储型计算机，冯诺依曼结构由于 EDVAC 项目的技术报告分发而开始被人们熟知。

![](1694444017244.png)

**历史**：Intel 在开发自己的 64 位指令集架构 (Itanium) 的时候遭遇了失败，部分原因在于它和之前的 IA32 指令集不兼容，而且性能也达不到预期，最终不得不转而采用 AMD 的 64 位指令集 x64-86

**重点提示**：了解 Intel x86-64 的寄存器组（下图所示），基础指令集，包括数据传送（包括压栈和出栈），算术和逻辑运算，特别需要留意 <源操作数> 和<目的操作数>在具体指令中的方向！

学习 C 语言和 x86 汇编语言之间的关系的一个绝佳方式就是逆向工程，你可以使用 GNU 提供的工具例如 **objdump** 或者 **GDB** 查看反汇编代码来学习！

![](1694444019433.png)

**重点提示**：理解条件码 (**CF**，ZF，SF，**OF**)，分支（Conditional Move => 分支预测相关），循环

![](1694444020318.png)

**备注**：编译器比你想象的要聪明，例如，你写的 switch 语句可能会被优化为 jump table，还会消除无用的语句 (Dead code elimination) 等，汇编代码有时候不仅仅是 C 代码的直译，也就是说：编译器可以执行不同程度的优化，那么你很有可能会一下子很难理解编译器生成的汇编代码，请不要害怕，多点耐心，试着自己分析看看，说不定你会恍然大悟，赞叹编译器的聪明之处！关于编译器的优化在第 5 章会有更多的探讨。

![](1694444021863.png)

**重点提示**：函数调用的过程 ：控制权转移 (含返回地址的保存)，参数传递，内存管理 (栈)，控制权返回

**备注**：无论何种 ISA，函数调用过程大同小异，只是在具体的指令或者在 ABI (Application Binary Interface) 层面略有不同而已，比如不同的 ISA 会有不同的 Calling Convention，也就是调用规则，它是调用者 Caller 和被调者 Callee 之间的某种合约，比如哪些寄存器用来传递参数，哪些寄存器用来存放返回值，哪些寄存器调用者 / 被调者可以放心使用等 (Caller Saved & Callee Saved)，理解 Prologue & Epilogue！

![](1694444022981.png)

请务必理解对应的投影片中的内容，如果你真的理解了递归函数的调用过程，那么恭喜你，你学会了 !

**重点提示**：理解 C 语言中的数组和指针在机器级是如何表示的，理解字节对齐的作用 （有些指令集架构是强制要求字节对齐的，即使不要求也应该做到字节对齐，不仅能节省空间，更重要的是会影响访问性能）

![](1694444024212.png)

**重点提示**：理解典型的内存布局 (栈，共享库，堆，代码段，数据段 ...)，如下图所示：

![](1694444025440.png)

理解缓冲区溢出导致的安全问题，以下是一个简单的示例程序（gcc 编译参数： -fno-stack-protector）：

备注：我们这里讲缓冲区溢出的时候，重点讨论的是**栈**溢出的问题，实际上还有**堆**溢出的漏洞。

![](1694444026671.png)

![](1694444028104.png)

![](1694444032102.png)

1. 程序员层面，避免调用不安全的函数，比如，fgets 代替 gets，strncpy 代替 strcpy

2. 操作系统层面，增加保护机制，例如 ASLR (地址空间随机化)，让攻击者难以猜测地址（依然可以攻破）

实际上，今天的绝大多数系统在默认情况下是启用 ASLR 的，可以通过以下命令查看**：**

![](1694444037633.png)

*   1 保留的随机化，其中共享库、栈、mmap 以及 VDSO 将被随机化
    

*   2 完全的随机化，在 1 的基础上，通过 brk() 分配的内存空间也将被随机化
    

![](1694444038858.png)

3. 硬件层面，对栈区增加权限保护： _NX （_No-eXecute_），_gcc 编译选项 -z _execstack_/noexecstack

**思考**：如何绕过 NX？一种方式是 ROP（就是你在 Attack Lab 实验中的 Phase4~Phase5），另外一种攻击方式是 **ret2libc**（不能返回到我写的代码，返回 libc 的代码总可以吧 ... 这种方式需要自己构建栈帧 ...）

![](1694444040906.png)

4. 编译器层面，缓冲区溢出的检测（Stack Guard），又被称作栈 “金丝雀”（Canary）

![](1694444043166.png)

还是前面那个简单的示例程序（gcc 编译参数： -fstack-protector）：

![](1694444045289.png)

缓冲区溢出检测的例子（gcc 编译参数：-fstack-protector）

备注：所谓 “道高一尺魔高一丈”，黑客会利用其它的机器级别的特性来进行针对性的攻击，例如，ROP 攻击， ROP 全称 Return-Oriented Programming，就是对栈上的返回地址进行利用的一种攻击方式，ROP 的攻击方法是借用代码段里面的多个片段指令拼凑成一段有效的逻辑，从而达到攻击的目的，片段指令一般称之为 Gadget，即利用 Gadget + retq，我们可以利用多个 retq 跳到不同的 Gadget 来实现我们完整的攻击流。

![](1694444046271.png)

![](1694444048286.png)

![[30-Machine-level-representation-of-program-c-warnings.png]]

## 实验解读 Bomb Lab
提示用户输入正确的字符串来拆掉炸弹，如果任何一个不正确，炸弹就会 “爆炸”，你必须通过逆向工程来解除炸弹，这会让你理解汇编语言，学习如何使用 GDB 来调试程序，设计得很有意思。

![](1694444050991.png)

经过了 6 个步骤，拆除炸弹后大概是这个样子（实际上还隐藏了一个彩蛋，这里没有画出）

![](1694444053002.png)

要求大家利用 Code Injection Attacks （代码注入攻击）和 ROP（返回导向的编程）这两种方法来攻击程序，对现有程序进行控制流劫持，执行非法程序代码，模拟当黑客的感觉，同时学会如何预防这些攻击手段。

![](1694444054646.png)

![](1694444062421.png)

计算机安全中的不少攻击和防御方法表面上看起来不同， 但如果深入研究的话，会发现它们其实是相似的或有关联，反过来，有些内容看起来相似， 本质上却有所不同，这就是知识点的相关性，只有将不同的知识点联系起来， 才能在脑海中形成知识体系，计算机安全知识更新很快，每天都有新的漏洞和攻击出现。 有了扎实的知识体系，就不会疲于学习这些新知识，因为很多东西万变不离其宗。

抽象很重要，但是作为学生，请不要 “总是” 习惯忽略细节，导致只懂理论，不会实践，从 CMU 精心设计的实验可以看出，一个细节没搞清楚， 攻击就无法成功，作为一个主动学习者，我们有时候需要多问一个为什么，比如：**怎样让我写的程序不能被 GDB 追踪调试？**另外一方面，很多时候学生没有兴趣或者学不会，问题可能真的不在学生身上，而是老师没有认真思考如何教，让学生真正有学会的感觉，像是杜文亮教授这样的老师就让我很感动：[https://www.handsonsecurity.net/](https://www.handsonsecurity.net/)，你可以真正学到有价值的东西！

![](1694444063654.png)

*   关于 C 语言和 x86 汇编语言之间的关系 (含函数调用过程等)，还可以参考印度理工的：[C 语言和汇编语言](https://www.bilibili.com/video/BV1XN411Q7SH/)​
    

*   现代 C 语言相关的信息可以参考这本书（出自 INRIA，在法国的地位相当于我国的中科院）：[现代 C 语言](https://modernc.gforge.inria.fr/)​
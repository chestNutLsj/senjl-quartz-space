---
publish: "true"
tags:
  - 软件工程
date: 2024-02-03
---
## 单元测试概述

软件工程开发经验不足的人，可能会选择先把代码都拼接起来，再进行测试。但实际上，这样相当于将编码中可能出现的错误都累积到最后阶段再做检查，这必然会导致错误数量庞大、难以定位、难以纠错的问题：
- ![[30-Unit-Test-cost-phase.png]]

因此我们需要**单元测试**——单元是构造软件系统的基础，只有使每个单元得到足够的测试，系统的质量才能有可靠的保证，即单元测试是构筑产品质量的基石。

单元测试（Unit Testing）是对软件中的最小可测试单元进行检查和验证，这是程序员对自己代码质量负责的基本承诺。代码质量通常与单元测试质量呈正相关。

### 单元测试内容

![[30-Unit-Test-test-items.png]]

单元测试应当检查如下项目：
- 模块接口：对通过所有被测模块的数据流进行测试
- 局部数据结构：检查模块中的数据结构是否正确定义和使用
- 边界条件：检查数据流或控制流中条件或 数据处于边界时的出错可能性
- 独立路径：检查由于计算错误、判定错误、控制流错误导致的程序错误
- 出错处理：检查可能引发错误处理的路径以及进行错误处理的路径

### 单元测试原则

- **快速的**：单元测试应能快速运行，如果运行缓慢，就不会愿意频繁运行它
- **独立的**：单元测试应相互独立，某个测试不应为下一个测试设定条件。当测试相互依赖时，一个没通过就会导致一连串的失败，难以定位问题
- **可重复的**：单元测试应该是可以重复执行的，并且结果是可以重现的
- **自我验证的**：单元测试应该有布尔输出，无论是通过或失败，不应该查看日志文件或手工对比不同的文本文件来确认测试是否通过
- **及时的**：及时编写单元测试代码，应恰好==在开发实际的单元代码之前==

### 单元测试过程

![[30-Unit-Test-flow.png]]

### 单元测试质量评估

对单元测试质量的评价，通常有两个方面：
- **测试通过率**：指在测试过程中执行通过的测试用例所占比例，单元测试通常要求测试用例通过率达到 100%
- **测试覆盖率**：是用来度量测试完整性的一个手段，通过覆盖率数据，可以了解测试是否充分以及弱点在哪里。代码覆盖率是单元测试的一个衡量标准，但也不能一味地去追求覆盖率，一般在 70%~80% 就足够

![[30-Unit-Test-cover-rate.png]]

### 单元测试方法

单元测试的方法从是否真是地执行代码来看，有两类：
- **静态测试**：通过人工分析或程序正确性证明的方式来确认程序正确性
- **动态测试**：通过动态分析和程序测试等方法来检查和确认程序是否有问题

从是否理解代码真实含义的角度来看，也可以分为两类：
- **黑盒测试**（black box testing）：
	- 又称功能测试，它将测试对象看做一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，==只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明==
- **白盒测试**（white box testing）：
	- 又称结构测试，它把测试对象看做一个透明的盒子，允许==测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例==，对程序所有逻辑路径进行测试

另外，我们对特定模块进行测试时，它往往并非独立存在，而是有可能调用了下层模块、也有可能被上层模块调用，此时对被测模块进行单元测试的整体结构为：
- ![[30-Unit-Test-tested-module.png]]
- 形象地，下层模块被称为桩模块、上层模块称为驱动模块；

### xUnit

实现单元测试有不同的工具：
![[30-Unit-Test-xUnit.png]]

统称为 xUnit 。但是 xUnit 并非万能的：
- xUnit 通常适用于以下场景的测试：
	- 单个函数、一个类或者几个功能相关类的测试
	- 尤其适用于纯函数测试或者接口级别的测试
- xUnit 无法适用于复杂场景的测试：
	- 被测对象依赖关系复杂，甚至无法简单创建出这个对象
	- 对于一些失败场景的测试
	- 被测对象中涉及多线程合作
	- 被测对象通过消息与外界交互的场景

### Mock 测试

**Mock** 的本义是“愚弄、欺骗、模拟的”，在单元测试中即是在测试过程中对于某些不容易构造或者不容易获取的对象，用一个==虚拟的对象==来代替以便完成测试的方法。

在这些场景中，真实对象往往具有以下特点：
- 真实对象具有不可确定的行为（产生不可预测的结果）
- 真实对象很难被创建（如具体的 Web 容器）
- 真实对象的某些行为很难触发（如网络错误）
- 真实情况令程序的运行速度很慢
- 真实对象有用户界面
- 测试需要询问真实对象它是如何被调用的
- 真实对象实际上并不存在

例如以下这个案例：
- 支付宝接龙红包通过猜金额的小游戏方式，实现朋友之间的互动并领取春节红包。这种情况应如何测试？![[30-Unit-Test-red-envelop.png]]
- 这就要用到 Mock 对象，即**针对接口进行编程**，被测试的代码通过接口来引用对象，再使用 Mock 对象模拟所引用的对象及其行为，因此==被测试模块并不知道它所引用的究竟是真实对象还是 Mock 对象==：
	- ![[30-Unit-Test-mock.png]]

## 黑盒测试方法

### 测试用例

设计良好的测试用例是单元测试质量可以信任的关键。那么，完整的测试用例应该包含哪些内容？
- **测试用例值**：完成被测软件的某个执行所需的==输入值==
- **期望结果**：当且仅当程序满足其期望行为，执行测试时产生的结果
- **前缀值**：将软件置于合适的状态来接受测试用例值的任何必要的输入
- **后缀值**：测试用例值被发送以后，需要被发送到软件的任何输入

>[!note] 可选内容
>除了上述四项保证测试用例真实可用的内容外，还有两个补充的可选内容，它们可以让测试过程更加完善：
>- **验证值**：查看测试用例值结果所要用到的值
>- **结束命令**：终止程序或返回到稳定状态所要用到的值

以拨打电话为例说明一个完整的测试用例：
- ![[30-Unit-Test-call-phone.png]]
- 测试用例值：电话号码
- 期望结果：接通（或未接通）
- 前缀值：电话开启并进入拨号界面
- 后缀值：按下“呼叫”或“取消”按钮

因此，我们可以总结出以下几项测试用例设计的要求：
1. 具有代表性和典型性
2. 寻求系统设计和功能设计的弱点
3. 既有正确输入也有错误或异常输入
4. 考虑用户实际的诸多使用场景

### 黑盒测试具体方法

我们已经提到，黑盒测试不需要考虑内部逻辑结构是否正确，只需要知道给定正确的输入，能否得到正确的输出。黑盒测试技术有以下方法：
- 等价类划分
- 边界值分析
- 因果图决策表
- 场景法
- 组合设计法
- 状态转换测试

在单元测试中，我们具体学习前两种方法。

#### 等价类划分

**等价类划分**是将输入域划分成尽可能少的若干子域，在划分中要求每个子域两两互不相交，每个子域称为一个等价类：
- ![[30-Unit-Test-equiv-class.png]]
- 要注意，同一输入域的等价类划分可能不唯一，而不论如何划分，我们只需从每一个等价类中选取一个输入作为测试用例即可；

对于等价类，也有不同的分类：
- **有效等价类**是对规格说明有意义、合理的输入数据构成的集合，能够检验程序是否实现了规格说明中预先规定的功能和性能
- **无效等价类**是对规格说明无意义、不合理的输入数据构成的集合，以检查程序是否具有一定的容错性
- ![[30-Unit-Test-illegal-equiv-class.png]]

根据不同变量的输入条件，我们可以得到不同的有效等价类和无效等价类：
- 对于规定了取值范围的数值变量，可以确定一个有效等价类和两个无效等价类：
	- ![[30-Unit-Test-range-equiv.png]]
- 对于规定了输入规则的字符串变量，可以确定一个有效等价类和若干不同角度违反规则的无效等价类；
- 对于规定了可选内容的枚举变量，可以确定 $N$ 个有效等价类和一个无效等价类：
	- ![[30-Unit-Test-enum-equiv.png]]
- 对于规定了类型和长度的数组变量，其长度和元素类型都可以作为等价类划分的依据：
	- ![[30-Unit-Test-array-equiv.png]]
- 对于复合数据类型，我们要考虑输入数据的所有属性的合法、非法取值：
	- ![[30-Unit-Test-combine-equiv.png]]

通过对等价类的合理组合，我们才能生成合理、可信、可用的测试用例：
- 测试用例生成：测试对象通常有多个输入参数，如何对这些参数等价类进行组合测试，来保证等价类的覆盖率，是测试用例设计首先需要考虑的问题。
- 所有有效等价类的代表值都集成到测试用例中，即覆盖有效等价类的所有组合。==任何一个组合都将设计成一个有效的测试用例==，也称**正面测试用例**。
- 无效等价类的代表值只能和其他有效等价类的代表值（随意）进行组合。因此，==每个无效等价类将产生一个额外的无效测试用例==，也称**负面测试用例**。

>[!example] 案例：三角形类型判断
>我们以一个判断三角形类型的案例讨论：输入三个整数 a、b、c，分别作为三角形的三条边，现通过一个程序判断这三条边构成的三角形类型，包括等边三角形、等腰三角形、一般三角形（特殊的还包括 直角三角形）以及构不成三角形。
>现在要求输入的三个整数 a、b、c 必须满足以下条件： 
>- 条件 1：1≤a≤100
>- 条件 2：1≤b≤100
>- 条件 3：1≤c≤100
>- 条件 4：a<b+c
>- 条件 5：b<a+c
>- 条件 6：c<a+b
>
>请使用等价类划分方法，设计该程序的测试用例。
>
>首先，我们提出一些常见的等价类划分方法：
>1. 按输入取值划分：{0，>0，<0} 或 {0，1，>1，<0}
>2. 按输出的几何特性划分：{等腰且非等边三角形，等边三角形，一般三角形，非三角形}
>
>显然，第二种划分方法更适合本题，因此我们可以如下设置测试样例：
> ![[30-Unit-Test-triangle-UT.png]]
>为了程序的健壮性，我们应当结合无效等价类生成额外的测试：
>![[30-Unit-Test-triangle-UT-robust.png]]

#### 边界值分析

**边界值分析**是对输入或输出的边界值进行测试的一种方法，它==通常作为等价类划分法的补充==，这种情况下的测试用例来自等价类的边界。
- 先确定边界：通常输入或输出等价类的边界就是应该着重测试的边界情况
- 选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值
	- 这是因为实践表明，大多数故障往往发生在输入定义域或输出值域的边界上，而不是内部；
	- 因此，针对各种边界情况设计测试用例，通常会取得很好的测试效果。
- 对不同输入项，应当设计不同的边界值检查，比如下列这些可行的边界值设计思路：
	- ![[30-Unit-Test-border.png]]

不过，边界值通常有最大边界和最小边界两者，该如何选取呢？
- 边界值分析法是基于可靠性理论中称为“单故障”的假设，即有两个或两个以上故障同时出现而导致失效的情况很少，因此对于程序中每次保留一个变量，让其余的变量取正常值，被保留的变量依次取 min、min+ 、nom、max- 和 max，然后对所有变量都这样做一次检查；
- 例如对于 `x1`，`x2` 这两个变量，就可以进行这样的检查：![[30-Unit-Test-x1-x2-border-test.png]]

>[!example] 案例：判断三角形类型（补充）
>因此，对于之前探讨的三角形类型判断问题，我们可以如下设置边界值来进行检查：
>![[30-Unit-Test-border-triangle.png]]

### 健壮性测试

健壮性测试是作为边界值分析的一个简单的扩充，它除了对变量的5个边界值分析取值外，还要增加一个**略大于最大值**（max+）以及**略小于最小值**（min-）的取值，检查超过极限值时系统的情况：
- ![[30-Unit-Test-robust-test.png]]

## 白盒测试方法

1. 处理测试需求的难易程度
2. 生成测试的难易程度
3. 用测试发现缺陷的能力

## 单元测试工具
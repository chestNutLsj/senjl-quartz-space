## 文件系统
### read syscall
1. 若一个用户进程通过 read 系统调用读取一个磁盘文件中的数据，则下列说法正误判断：
- 若文件的数据不在内存，则该进程会进入睡眠等待状态；(✅)
- 请求 read 系统调用会导致 CPU 从用户态切换到核心态；(✅)
- read 系统调用的参数应该包括文件名称；(❌)

>[!note] read 系统调用的参数为什么不包括文件名？
>在用户进程通过 `read` 系统调用读取一个磁盘文件的数据时，`read` 系统调用并不直接接受文件名作为参数。实际上，`read` 系统调用是用于从文件描述符（file descriptor）对应的文件中读取数据的。文件描述符是一个非负整数，它在打开文件时由内核分配。
>
>通常的文件读取过程是这样的：
>1. 打开文件：用户进程需要使用 `open` 系统调用来打开文件，此时会得到一个文件描述符。
>2. 读取文件：一旦文件被打开，用户进程可以使用 `read` 系统调用来从文件描述符对应的文件中读取数据。
>
>所以，`read` 系统调用的参数是文件描述符、数据缓冲区和要读取的字节数。函数原型通常如下：
>```c
>ssize_t read (int fd, void *buf, size_t count);
>```
>
>- `fd` 是文件描述符，通过 `open` 系统调用得到。
>- `buf` 是一个指向数据缓冲区的指针，用于存储从文件中读取的数据。
>- `count` 表示要读取的最大字节数。
>
>在调用 `read` 之前，用户进程必须通过 `open` 系统调用打开文件，并且如果读取成功，`read` 系统调用会将数据从文件复制到提供的缓冲区（`buf`）中。
>
>因此，用户进程需要先打开文件获得文件描述符，然后再使用该文件描述符来调用 `read` 系统调用来读取文件的数据，而不是将文件名作为 `read` 系统调用的参数。

## I/O 系统
1. 操作系统的 I/O 子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口。其合理的层次组织排列顺序是:
```
A．用户级 I/O 软件、设备无关软件、设备驱动程序、中断处理程序
B．用户级 I/O 软件、设备无关软件、中断处理程序、设备驱动程序 
C．用户级 I/O 软件、设备驱动程序、设备无关软件、中断处理程序 
D．用户级 I/O 软件、中断处理程序、设备无关软件、设备驱动程序
```

![[io-software-hierachy.png]]

>[! note] I/O 子系统典型组织结构功能说明
>1. 用户级 I/O 软件：这是用户程序使用的高级 I/O 接口。它提供了简化的 I/O 操作，使应用程序能够方便地进行输入和输出，而无需了解底层硬件细节。
>2. 设备无关软件：这一层提供了对设备的抽象表示，使得上层的用户级 I/O 软件与底层设备驱动程序解耦。这样一来，用户级软件可以不关心具体的硬件细节，而只需要调用设备无关的接口来实现 I/O 操作。
>3. 中断处理程序：中断是计算机系统中用于处理异步事件的机制。在 I/O 子系统中，设备通常会发出中断来通知系统它们的状态发生了变化。中断处理程序负责处理这些中断请求，并与设备驱动程序进行交互，以执行相应的 I/O 操作。
>4. 设备驱动程序：这是最底层的层次，负责直接与物理设备进行通信。设备驱动程序了解硬件的细节，并执行实际的输入和输出操作，将数据从设备传输到内存或从内存传输到设备。
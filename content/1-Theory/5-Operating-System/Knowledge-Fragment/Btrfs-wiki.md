| 开发者         | SUSE、Meta、西部数据、甲骨文公司、富士通、Red Hat                |
|-------------|-------------------------------------------------|
| 全称          | Btrfs                                           |
| 发布          | 稳定版本：6.4，2023 年 6 月 ,不稳定版本：6.4，2023 年 6 月 (Linux) |
| 结构          |
| 目录内容        | B 树                                             |
| 文件分配        | extents                                         |
| 限制          |
| 最大文件尺寸      | 16 EiB[1]                                       |
| 最大文件数量      | 264（每个子卷）                                       |
| 最长文件名       | 255 字节                                          |
| 最大卷容量       | 16 EiB[1]                                       |
| 文件名字符集      | 除'/'和 NUL（'\0'）以外的所有字符                           |
| 功能          |
| 日期记录        | 内容更改时间（mtime）[2]，属性更改时间（ctime），访问时间（atime）      |
| 日期分辨率       | 纳秒                                              |
| 属性          | POSIX，扩展文件属性                                    |
| 文件系统权限      | POSIX，访问控制表                                     |
| 透明压缩        | 是                                               |
| 透明加密        | 否（计划支持）                                         |
| 单一实例存储（SIS） | 是（计划支持，通过补丁支持）                                  |
| 操作系统支持      | Linux                                           |

## 简介
**Btrfs**（B-tree 文件系统，通常念成 **Butter FS**，**Better FS** 或 **B-tree FS**），一种支持写入时复制（COW）的文件系统，运行在 Linux 操作系统，采用 GPL 授权。Oracle 于 2007 年对外宣布这项计划，并发布源代码，在 2014 年 8 月发布稳定版。目标是取代 Linux 目前的 ext3 文件系统，改善 ext3 的限制，特别是单个文件的大小，总文件系统大小或文件检查和加入 ext3 未支持的功能，像是可写快照（writable snapshots）、快照的快照（snapshots of snapshots）、内建磁盘阵列（RAID），以及子卷（subvolumes）。Btrfs 也宣称专注在 “容错、修复及易于管理”。

## 历史

Btrfs 的核心数据结构——写时复制 B 树 (COW-BTree)——最初是由 IBM 研究员 Ohad Rodeh 在 2007 年 USENIX 会议上提出的。Chris Mason 当时是 SUSE 公司的 ReiserFS 工程师，后来加入了 Oracle，并开始开发一种基于 B 树的新文件系统。

2008 年，ext3 和 ext4 文件系统的主要开发者曹子德表示，虽然 ext4 有改进的功能，但它不是一个重大的进步；它使用了旧技术，是一个权宜之计。曹子德说，Btrfs 是一个更好的方向，因为 “它在可扩展性、可靠性和易管理性方面提供了改进”。Btrfs 也有 “一些与 reiser3/4 相同的设计思想”。

Btrfs 1.0 版本具有最终确定的磁盘格式，于 2008 年底发布，并于 2009 年被接受进入 Linux 内核主线。几个 Linux 发行版开始在安装过程中提供 Btrfs 作为根文件系统的实验性选择。

2011 年 7 月，Btrfs ==自动碎片整理和擦除功能==被合并到 Linux 内核主线的 3.0 版本中。除了 Oracle 的 Mason 外，富士通的 Miao Xie 也贡献了性能改进。2012 年 6 月，Chris Mason 离开 Oracle 加入 Fusion-io，一年后又与 Josef Bacik 一起加入 Facebook。在这两家公司工作期间，Mason 继续他对 Btrfs 的工作。

2012 年，两个 Linux 发行版将 Btrfs 从实验性状态转变为生产或支持状态：3 月份的 Oracle Linux ，8 月份的 SUSE Linux Enterprise 。

2015 年，Btrfs 被采用为 SUSE Linux Enterprise Server（SLE）12 的默认文件系统。

2017 年 8 月，红帽公司在 Red Hat Enterprise Linux（RHEL）7.4 的发布说明中宣布，不再计划将 Btrfs 转变为一个完全支持的功能（它自 RHEL 6 beta 以来一直作为 “技术预览” 包含在内），并指出它将在 RHEL 7 发布系列中保持可用。2019 年 5 月，Btrfs 从 RHEL 8 中移除。RHEL 从 RHEL 6 中的 ext4 转移到 RHEL 7 中的 XFS。

2020 年，Btrfs 被选为 Fedora 33 桌面变体的默认文件系统。

## 特性
### 特性列表

#### 已实现
*   联机碎片整理
*   联机卷生长和收缩
*   联机块设备增加和删除
*   联机负载均衡（块设备间的对象移动以达到平衡）
*   文件系统级的镜像（类 RAID-1）、条带（类 RAID-0）
*   子卷（一个或多个单独可挂载基于每个物流分区）
*   透明压缩（目前支持 zlib、LZO 和 ZSTD (从 4.14 开始支持)）
*   快照（只读和可写，写复制，子卷复制）
*   文件克隆
*   数据和元数据的校验和（目前是 CRC-32C）
*   就地转换（带回滚）ext3/4 与 ReiserFS
*   只读存储的联合挂载，称为文件系统播种（只读存储用作可写 Btrfs 的写时复制支持）
*   用户定义的事务
*   块丢弃支持
*   发送 / 接收（将快照之间的差异保存为二进制流）
*   带外数据去重（需要用户空间工具）
*   能够处理交换文件和交换分区

#### 已实现但不建议在生产环境中使用
*   分层的每个子卷配额
*   RAID 5，RAID 6

#### 计划但尚未实现
*   带内数据去重
*   在线文件系统检查
*   最多六个奇偶校验设备的 RAID，超越了 RAID 5 和 RAID 6 的可靠性
*   对象级 RAID 0，RAID 1 和 RAID 10
*   透明加密
*   持久读写缓存（ L2ARC + ZIL，lvmcache 等）

### 克隆

Btrfs 提供了一个克隆操作，可以原子地创建一个文件的写时复制快照。这样的克隆文件有时被称为 `reflinks`，因为它们与拟议的相关 Linux 内核系统调用有关。

在克隆时，文件系统不会创建一个指向现有 `inode` 的新链接；相反，它会创建一个新的 `inode`，最初与原始文件共享相同的磁盘块。因此，克隆只能在同一个 Btrfs 文件系统的边界内工作，但是在某些情况下，自 Linux 内核 3.6 版本起，它可能会跨越子卷的边界。实际的数据块不会被复制；同时，由于 Btrfs 的写时复制（CoW）特性，对任何克隆文件的修改都不会在原始文件中可见，反之亦然。

克隆不应与硬链接混淆，硬链接是将多个文件名与单个文件关联的目录项。虽然硬链接可以被认为是同一文件的不同名称，但 Btrfs 中的克隆提供了最初共享所有磁盘块的独立文件。

GNU coreutils 自 7.5 版本支持了这个 Btrfs 特性，通过 `cp` 命令的 `--reflink` 选项可以使用克隆功能。

除了数据克隆（ FICLONE ），Btrfs 还支持通过 FIDEDUPERANGE 进行带外去重。这个功能允许两个具有（甚至部分）相同数据的文件共享存储空间。

### 子卷和快照 
![[10-Btrfs-wiki-snapshot.png]]
Btrfs 文件系统的快照示例，由 snapper 管理

Btrfs 子卷可以被认为是一个单独的 POSIX 文件命名空间，通过向 `mount` 命令传递 `subvol` 或 `subvolid` 选项来单独挂载。它也可以通过挂载顶层子卷来访问，这种情况下，子卷作为顶层子卷的子目录可见和可访问。

子卷可以在文件系统层次结构中的任何位置创建，也可以嵌套。嵌套的子卷在其父子卷中显示为子目录，类似于顶层子卷将其子卷显示为子目录的方式。在删除所有嵌套层次下的子卷之前，不能删除一个子卷；因此，不能删除顶层子卷。

任何 Btrfs 文件系统总是有一个默认的子卷，最初设置为顶层子卷，并且如果没有传递子卷选择选项，则默认挂载。默认子卷可以根据需要更改。

Btrfs [快照](/w/index. php? title=%E5%BF%AB%E7%85%A7&action=edit&redlink=1 "快照（页面不存在）")是一个与其他某个子卷共享数据（和元数据）的子卷，使用 Btrfs 的写时复制能力，对快照的修改在原始子卷中不可见。一旦创建了一个可写的快照，它就可以被视为原始文件系统的一个替代版本。例如，要回滚到一个快照，需要卸载修改过的原始子卷，并将快照挂载到它的位置。此时，也可以删除原始子卷。

Btrfs 的写时复制（CoW）特性意味着快照可以快速创建，同时最初消耗很少的磁盘空间。由于快照是一个子卷，因此也可以创建嵌套的快照。对一个子卷进行快照不是一个递归的过程；因此，如果创建了一个子卷的快照，该子卷已经包含的每个子卷或快照都会映射到同名的空目录中。

不能对一个目录进行快照，只有子卷才能有快照。然而，有一种涉及跨越子卷的 reflinks 的解决方案：创建一个新的子卷，包含指向目标目录内容的跨越子卷的 reflinks。有了这个，就可以创建这个新卷的快照。

Btrfs 中的子卷与传统的 LVM 逻辑卷非常不同。在 LVM 中，逻辑卷是一个单独的块设备，而 Btrfs 子卷更类似于 POSIX 命名空间。原始或副本中的任何一个在同一台计算机上挂载时，对 btrfs 进行 dd 或 LVM 快照会导致数据丢失。

### 子卷发送与接收

给定任意一对子卷（或快照），Btrfs 可以在它们之间生成二进制差异（通过使用 `btrfs send` 命令），稍后可以重放（通过使用 `btrfs receive`），可以接收到另一个 Btrfs 文件系统上。发送 - 接收功能实际上创建（并应用）了将一个子卷转换为另一个子卷所需的一组数据修改。

发送 / 接收功能可以与定期安排的快照一起使用，用于实现文件系统[复制](/wiki/%E5%A4%8D%E5%88%B6 "复制")的简单形式，或用于执行增量备份。

### 配额组
![[10-Btrfs-wiki-quota.png]]
Btrfs 配额组的示例

配额组可以对一个子卷或快照可能消耗的空间设定上限。新的快照最初不消耗配额，因为它的数据与其父卷共享，但之后会因为新文件和对现有文件的写时复制操作而产生空间上的开销。当配额功能启用时，每个新的子卷或快照都会自动创建一个配额组。这些初始的配额组是可以分组（使用 `btrfs qgroup` 命令）成层次结构来实现配额池的构建块。

配额组只适用于子卷和快照，而不能对单个子目录、用户或用户组强制执行配额。然而，可以通过使用不同的子卷来实现所有需要强制执行配额的用户或用户组。

### 原地转换 ext2/3/4 和 ReiserFS

由于在固定位置的元数据非常少，Btrfs 可以适应后端存储设备的各种的空间布局。`btrfs-convert` 工具可以通过在其未分配空间中嵌套等效的 Btrfs 元数据——同时保留原始文件系统的未修改副本，原地转换一个 ext2/3/4 或 [ReiserFS](/wiki/ReiserFS "ReiserFS") 文件系统。

转换涉及创建整个 ext2/3/4 元数据的副本，而 Btrfs 文件只是指向与 ext2/3/4 文件使用的相同的块。这使得在转换变为永久转换之前，大部分块在两个文件系统之间共享。由于 Btrfs 的写时复制特性，在所有文件修改过程中，原始版本的文件数据块都被保留。在转换变为永久转换之前，只有在 ext2/3/4 中标记为空闲的块才用于保存新的 Btrfs 修改，这意味着转换可以随时撤销转换（尽管这样做会擦除在转换为 Btrfs 后所做的任何更改）。

所有转换后的文件都在 Btrfs 的默认子卷中可用和可写。一个稀疏文件包含了对原始 ext2/3/4 文件系统的所有引用，它被创建在一个单独的子卷中，可以作为一个只读磁盘映像单独挂载，允许同时访问原始和转换后的文件系统。删除这个稀疏文件会释放空间并使转换变为永久。

在主线 Linux 内核的 4. x 版本中，原地 ext3/4 转换被认为是未经测试且很少使用的。然而，该功能在 2016 年的 `btrfs-progs` 4.6 从头重写。并且从那时起一直被认为是稳定的。

原地从 ReiserFS 转换在 2017 年 9 月引入到 Linux 4.13 内核中。

### 联合挂载 / 种子设备

在创建一个新的 Btrfs 时，可以使用一个已存在的 Btrfs 作为一个只读的 “种子” 文件系统。新的文件系统将作为种子上的一个写时复制覆盖层，作为一种联合挂载的形式。种子可以稍后从 Btrfs 中分离，在此之前，重平衡器将简单地复制任何仍然被新文件系统引用的种子数据，然后分离。Btrfs 的主要贡献者 Mason 认为这可能对 Live CD 安装程序有用，它可以从光盘上的一个只读 Btrfs 种子启动，在用户继续工作的同时，在后台将自己重平衡到安装磁盘上的目标分区，然后弹出光盘以完成安装而不需要重新启动。

### 加密

在 2009 年的采访中，Chris Mason 表示计划为 Btrfs 增加加密支持。目前，将加密与 Btrfs 结合使用的一种解决方案是使用诸如 dm-crypt / LUKS 之类的全盘加密机制在底层设备上，并在该层之上创建 Btrfs 文件系统。

截至 2020 年开发人员正在努力添加类似 [HMAC](/wiki/HMAC "HMAC")（[SHA256](/wiki/SHA256 "SHA256")）的键控哈希。

### 检查和恢复

Unix 系统传统上使用 fsck 程序来检查和修复文件系统。这个功能是通过 `btrfs check` 程序实现的。从 4.0 版本开始，这个功能被认为是相对稳定的。然而，截至 2023 年 6 月，btrfs 文档建议只有在 “开发者或经验丰富的用户” 建议时才使用其 `–repair` 选项。截至 2023 年 6 月，SLE 文档建议使用一个 Live CD，执行一个备份，并只在最后的手段时使用修复选项。

还有另一个工具 `btrfs-restore`，可以用于从一个不可挂载的文件系统中恢复文件，而不修改损坏的文件系统本身。

在正常使用中，Btrfs 基本上是自我修复的，并且可以在挂载时从损坏的根树结构中恢复，这是因为默认每 30 秒向永久存储刷新数据。因此，孤立的错误会导致下一次挂载时最多 30 秒的文件系统更改丢失。这个周期可以通过在 `commit` 挂载选项中指定所需的值（以秒为单位）来更改。

## 设计

Ohad Rodeh 在 2007 年的 USENIX 提出的原始方案指出，广泛用作数据库的磁盘数据结构的 B+ 树不能有效地实现基于写时复制的快照，因为它的叶子节点是连接在一起的：如果一个叶子被写时复制，它的兄弟节点和父节点也必须如此，以及它们递归的兄弟和父节点，直到整个树被复制。他建议使用一个修改过的 B 树（没有叶子链接），并且每个树节点都有一个引用计数，但是存储在一个专门的自由映射结构中，并且对树的平衡算法进行了一定的放松，使它们对写时复制友好。结果将是一个适合高性能对象存储的数据结构，可以执行写时复制快照，同时保持良好的并发性。

在当年晚些时候在 Oracle 工作的 Chris Mason 开始了一个能够使用这种数据结构的快照能力文件系统的工作，几乎完全采用这种数据结构——不仅用于元数据和文件数据，而且递归地用于跟踪树本身的空间分配。这允许所有遍历和修改都通过同一份代码，只需要实现一次诸如写时复制、校验和和镜像等特性，就可以在整个文件系统的各个地方使用。

Btrfs 是由这样的树组成的几层结构，所有这些树都使用相同的 B 树实现。树存储了按照 136 位键排序的通用 “项”。键中最重要的 64 位是一个唯一的“对象 id”。中间 8 位是一个项类型字段：它的用法是硬编码到代码中作为树查找中的项过滤器。“对象” 可以有多个类型的多个项。剩下的（最不重要的）64 位以类型特定的方式使用。因此，同一对象的项会在树中彼此相邻，按类型分组。通过选择某些键值，对象可以进一步按照特定顺序放置同一类型的项。

内部树节点只是键 - 指针对的平面列表，其中指针是子节点的逻辑块号。叶节点包含打包到节点前面的项键和打包到节点末尾的项数据，在叶填充时两者向彼此增长。

### 文件系统树

在每个目录中，目录条目以 “目录项” 的形式出现，它们的键值的最不重要的位是它们文件名的 CRC32C 哈希。它们的数据是一个 “位置键”，或者是它指向的 inode 项的键。目录项一起可以作为路径到 inode 查找的索引，但不用于迭代，因为它们按照它们的哈希排序，有效地随机排列它们。这意味着在一个大目录中迭代和打开文件的用户应用程序将产生更多的磁盘寻道，因此在非相邻文件之间寻道——这是其他文件系统中具有哈希排序目录的显著性能损耗，例如 ReiserFS， ext3（启用了 Htree 索引和 ext4，它们都有微型加密算法哈希过的文件名。为了避免这个问题，Btrfs 每个目录条目都有一个 "目录索引项"，其项的键值被设置为一个每个目录递增的计数器。因此，对这些索引项的迭代大致按照存储在磁盘上的相同顺序返回条目。

在多个目录中具有硬链接的文件有多个引用项，每个父目录一个。在同一目录中具有多个硬链接的文件将所有链接的文件名打包到同一个引用项中。这是一个设计缺陷，它将同一目录中的硬链接数量限制为多少个可以放入单个树块中。（在默认块大小为 4 KiB、平均文件名长度为 8 字节和每个文件名头部为 4 字节的情况下，这将少于 350 个。）观察到大量使用同一目录中多个硬链接的应用程序，在这个限制下会失败，例如 git、GNUS、GMame 和 BackupPC。这个限制最终被移除（截至 2012 年 10 月已经合并等待在 Linux 3.7 中发布）通过引入溢出的 "扩展引用项" 来保存不适合的硬链接文件名。

#### 区块

文件数据保存在树外的 “区块” 中，它们是连续的磁盘数据块。区块块默认大小为 4 KiB，没有头部，只包含（可能压缩的）文件数据。在压缩的区块中，单个块不是单独压缩的；相反，压缩流跨越整个区块。

文件有 “区块数据项” 来跟踪保存其内容的区块。项的键值是区块的起始字节偏移量。这使得在具有多个区块的大文件中进行有效的寻找，因为任何给定文件偏移量的正确区块可以用一个树查找来计算。

快照和克隆文件共享区块。当一个大的这样的区块的一小部分被覆盖时，结果的写时复制可能创建三个新的区块：一个小的包含被覆盖的数据，和两个大的包含覆盖两边未修改的数据。为了避免重写未修改的数据，写时复制可能会创建 “书签区块”，或者只是现有区块的切片。区块数据项允许这样做，通过包含一个到它们正在跟踪的区块的偏移量：书签项是那些具有非零偏移量的项。

### 区块分配树

“区块分配树” 充当文件系统的分配映射。与其他树不同，这个树中的项没有对象 id。它们表示空间区域：它们的键值保存了它们所代表的区域的起始偏移量和长度。

文件系统将其分配的空间划分为 “块组”，它们是可变大小的分配区域，交替地偏好元数据区块（树节点）和数据区块（文件内容）。数据和元数据块组的默认比例是 1:2。它们旨在使用奥尔洛夫块分配器的概念来分配相关文件，并通过在组之间留下空闲空间来抵抗碎片化。（然而，Ext3 块组有固定的位置，是根据文件系统的大小计算出来的，而 Btrfs 中的块组是动态的，并根据需要创建）每个块组都与一个 “块组项 “相关联。文件系统树中的 inode 项包含对它们当前块组的引用。

“区块项” 包含一个到占用该区块的树节点或文件的反向引用。如果区块在快照之间共享，可能有多个反向引用。如果有太多的反向引用不能适合于项中，它们会溢出到单独的 “区块数据引用项 “中。反过来，树节点也有对它们所包含的树的反向引用。这使得通过对一对括住该区域的偏移量进行 B 树范围查找，然后跟随反向引用，可以找到任何空间区域中的哪些区块或树节点。对于重新定位数据，这允许从重新定位的块进行有效的向上遍历，快速找到并修复对这些块的所有向下引用，而不必扫描整个文件系统。这反过来又允许文件系统有效地在线缩小、迁移和碎片整理其存储。

区块分配树，与文件系统中的所有其他树一样，是写时复制的。写入文件系统可能会导致一个级联，其中改变了树节点和文件数据导致新的区块被分配，导致区块树本身发生变化。为了避免创建一个反馈回路，仍然在内存中但尚未提交到磁盘的区块树节点可以就地更新，以反映新复制的写时复制区块。

从理论上讲，由于区块分配树充当了一个 B 树版本的 [BSP 树](/wiki/BSP%E6%A0%91 "BSP 树")，因此不需要传统的[可用空间位图](/w/index. php? title=%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%E4%BD%8D%E5%9B%BE&action=edit&redlink=1 "可用空间位图（页面不存在）") 。但实际上，为了加速分配，使用了[页](/wiki/%E9%A0%81 "页")大小位图的[红黑树](/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91 "红黑树")。这些位图被持久化到磁盘（从 Linux 2.6.37 开始，通过 `space_cache` 挂载选项。

### 校验和树和擦除

参见：[静默数据损坏](/w/index. php? title=%E9%9D%99%E9%BB%98%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%9D%8F&action=edit&redlink=1 "静默数据损坏（页面不存在）")

对数据和元数据都计算 CRC-32C 校验和，并存储为 “校验和树” 中的“校验和项”。元数据校验和有 256 位的空间，而数据校验和最多可以有一个完整的节点（大约 4 KB 或更多）。Btrfs 有为未来版本的文件系统添加额外的校验和算法的计划。

每个连续的已分配块都有一个校验和项，每个块的校验和紧密地打包到项数据中。如果有太多的校验和不能适合，它们会溢出到一个新叶子中的另一个校验和项中。如果文件系统在读取一个块时检测到一个校验和不匹配，在内部镜像或 RAID 技术正在使用的情况下，它首先尝试从另一个设备 – 获取（或创建）这个块的一个好的副本。

Btrfs 可以通过触发一个在后台执行的文件系统擦除作业来启动对整个文件系统的在线检查。擦除作业扫描整个文件系统的完整性，并自动尝试报告和修复它在沿途发现的任何坏块。

### 块和设备树

[块设备](/wiki/%E5%9D%97%E8%AE%BE%E5%A4%87 "块设备")被划分为 1 GiB 用于数据的物理块，和 256 MiB 用于元数据的物理块。多个设备上的物理块可以镜像或条带化成一个单一的 “逻辑块”。这些逻辑块被组合成一个单一的逻辑地址空间，供文件系统的其余部分使用。

“块树”通过将其中的每个设备存储为一个 “设备项” 和逻辑块作为 “块映射项” 来跟踪这一点，，提供了从逻辑到物理地址的正向映射。块映射项可以是以下几种类型之一：

- single
	- 1 个逻辑到 1 个物理块
- dup
	- 1 个逻辑块到 1 个块设备上的 2 个物理块
- raid0
	- N 个逻辑块到 N≥2 个设备上的 N≥2 个物理块
- raid1
	- 1 个逻辑块到 N≥2 个设备中的 2 个物理块，与传统的 RAID 1 不同，它有 N 个物理块
- raid1c3
	- 1 个逻辑块到 N≥3 个设备中的 3 个物理块 ;
- raid1c4
	- 1 个逻辑块到 N≥4 个设备中的 4 个物理块 ; 
- raid5
	- N（对于 N≥2）个逻辑块到 N+1 个设备上的 N+1 个物理块，其中 1 个物理块用作奇偶校验 ;
- raid6
	- N（对于 N≥2）个逻辑块到 N+2 个设备上的 N+2 个物理块，其中 2 个物理块用作奇偶校验 “N” 是在分配块时仍然有空闲空间的块设备的数量。如果 N 对于选择的镜像 / 映射不够大，那么文件系统就有效地没有空间了。

### 重定位树

碎片整理、缩小和重新平衡操作需要重新定位区块。然而，对正在重新定位的区块进行简单的写时复制将破坏快照之间的共享并消耗磁盘空间。为了保持共享，使用一个更新和交换算法，一个特殊的重定位树作为受影响的元数据的临时空间。首先将要重新定位的区块复制到它的目的地。然后，通过沿着受影响的子卷的文件系统树向上跟随反向引用，逐渐更新指向旧区块的元数据，使其指向新的区块；任何新更新的项都存储在重定位树中。一旦更新完成，重定位树中的项与受影响子卷中的对应项交换，然后丢弃重定位树。

### 超级块

文件系统中的所有树——包括块树本身——都存储在块中，这会产生一个引导问题，当挂载文件系统时。为了引导到一个挂载点，块树和根树所属的块的物理地址列表存储在超级块中。

超级块镜像保存在固定位置：每个块设备 64 KiB 处，以及 64 MiB、256 GiB 和 1 PiB 处的额外副本。当更新一个超级块镜像时，它的生成号递增。在挂载时，使用生成号最高的副本。除了 SSD 模式，所有超级块镜像都同时更新；而在 SSD 模式下，为了提供一定程度的磨损平衡，超级块镜像之间交替更新。
---
publish: "true"
tags:
  - DSA
  - 邓俊辉
  - Cpp
---

## 各章笔记
### 绪论

- [[10-Introduction]]

### 向量与列表

- [[20-Vector]]
- [[30-List]]

### 栈与队列

- [[40-Stack_Queue]]

### 树、二叉树、搜索树

- [[50-Tree]]
- [[60-Binary_Search_Tree]]
- [[61-Balanced-BST]]

### 散列

- [[70-Hash]]

### 图

- [[80-Graph]]

### 优先级队列

- [[90-Priority_Queue]]

### 串匹配

- [[A0-String]]

### 排序

- [[B0-Sort]]

## 知识点一览

### 算法问题

- [[10-Introduction#迭代与递归应用：总和最大区段|总和最大区段问题]]
- [[10-Introduction#求 fib(n)|动态规划求Fibonacci序列]]
- [[10-Introduction#最长公共子序列|最长公共子序列LCS问题]]
- [[10-Introduction#局限 1 缓存——就地循环位移|向量元素就地循环位移问题]]
- [[10-Introduction#从 O (n)到 O (r=logn)|快速幂计算问题]]
- [[10-Introduction#局限 3 随机数|(伪)随机数生成问题]]
- [[11-Intro-Exercise#1-12 countOnes 算法改进|快速计算整数二进制表示的1位数]]
- [[11-Intro-Exercise#更相减损术|更相减损术]]
- [[12-Instances-of-recursion#Hanoi 问题|Hanoi问题]]
- [[43-Probing-backtracking#八皇后问题|八皇后问题]]
- [[43-Probing-backtracking#迷宫寻径|迷宫寻径问题]]
- [[31-List-Exercise#3-18 实现列表逆置|如何实现列表/向量逆置？]]
- [[40-Stack_Queue#进制转换|进制转换]]
- [[40-Stack_Queue#括号匹配|括号匹配]]
- [[40-Stack_Queue#中缀表达式求值|中缀表达式求值]]
- [[40-Stack_Queue#自动|中缀表达式转后缀表达式]]
- [[40-Stack_Queue#直方图最大矩形|直方图最大矩形]]
- [[40-Stack_Queue#栈堆与队列堆|Steap&Queap:维护栈和队列的getMax()接口]]
- [[50-Tree#Huffman 树|Huffman树的构造策略]]
- [[50-Tree#圆桌骑士问题|圆桌骑士问题]]
- [[50-Tree#旅行骑士问题|旅行骑士问题]]
- [[65-Lowest-Common-Ancestor|最低公共祖先LCA问题]]
- [[70-Hash#最大缝隙问题|最大缝隙MaxGap问题（桶排序思路）]]
- [[70-Hash#对数密度的整数集排序|对数密度的整数集排序（基数排序思想）]]
- [[82-Graph-Exercise#6-9 BFS 在 O (n+e)内找到直径（无向图中最长通路）|BFS 如何在 O (n+e)内找到直径？]]
- [[82-Graph-Exercise#6-22 旅行商问题：找出哈密尔顿环路|旅行商问题：找出哈密尔顿环路]]

### 知识点细节

- [[11-Intro-Exercise#fib (k)的递归实例在执行中出现了多少次？|fib(k)二分递归实例出现次数问题]]
- [[11-Intro-Exercise#O (√n）|O(√n)的形式]]
- [[11-Intro-Exercise#递归与调用 1|递归调用：线性递归实例分析]]
- [[11-Intro-Exercise#递归与调用 4|递归调用：二分递归实例分析]]
- [[20-Vector#平均分析 Vs. 分摊分析|平均分析 Vs. 分摊分析]]
- [[20-Vector#二分查找 b|二分查找B和C的特点]]
- [[20-Vector#2-way merge|二路归并排序的复杂度、优缺点与改进]]
- [[21-Vector-Exercise#2-18 binSearch 查找长度分析|二分搜索的平均查找长度]]
- [[21-Vector-Exercise#2-20 对比 binSearch-A 与 fibSearch|二分查找A与Fib查找对比]]
- [[21-Vector-Exercise#2-24-c 插值查找搜索区间与复杂度分析|插值查找: 查找区间宽度缩减速度和整体复杂度]]
- [[21-Vector-Exercise#2-27 改进 mergeSort ()适应于大致有序情况|大致有序情况时归并排序的改进策略]]
- [[21-Vector-Exercise#2-41 基数排序思想|基数排序的思想基础]]
- [[30-List#稳定性|选择排序的稳定性如何保证？]]
- [[30-List#性能|插入排序的性能、交换次数分析]]
- [[30-List#无效交换|循环节：选择排序过程中出现无需交换的情形可能有多少次？]]
- [[30-List#冒泡排序与逆序对|逆序对与冒泡排序、插入排序]]
- [[31-List-Exercise#3-4 deduplicate ()分析|无序列表唯一化的最好情况是什么？]]
- [[31-List-Exercise#3-12 插入算法的比较次数|插入排序的比较次数]]
- [[40-Stack_Queue#栈混洗|栈混洗：总数、禁形判断、与括号匹配的关系]]
- [[40-Stack_Queue#catalan 数应用|Catalan数的实例]]
- [[40-Stack_Queue#实例|中缀表达式求值实例]]
- [[40-Stack_Queue#中缀表达式转后缀表达式|中缀表达式转后缀表达式]]
- [[40-Stack_Queue#双栈当队|双栈当队：实现与性能分析]]
- [[41-Stack-queue-Exercise#4-2 向量实现队列|循环向量实现队列]]
- [[50-Tree#^d0cd9e|树的深度与高度关系]]
- [[50-Tree#^b26f71|二叉树度数、节点数、边数的关系]]
- [[50-Tree#长子-兄弟表示法|长子兄弟表示法：找到根的复杂度、遍历复杂度]]
- [[50-Tree#^c031da|满二叉树与真二叉树的区别]]
- [[50-Tree#完全二叉树|完全二叉树的定义与特点]]
- [[50-Tree#迭代版|先序遍历迭代版]]
- [[50-Tree#中序遍历迭代版的思路|中序遍历迭代版]]
- [[50-Tree#后序遍历特点|后序遍历特点、迭代版]]
- [[50-Tree#应用：表达式树|后序遍历应用：表达式树]]
- [[50-Tree#结论速查|二叉树重构的结论]]
- [[50-Tree#先序 + 后序|为什么先序+后序不能唯一确定二叉树？]]
- [[50-Tree#(先序+后序) x 真二叉树|为什么真二叉树能够使先序+后序唯一确定二叉树？]]
- [[50-Tree#PFC 解码|PFC解码的流程，且是在线算法吗？]]
- [[50-Tree#最优编码树|最优编码树是真完全树？]]
- [[50-Tree#最优带权编码树|考虑权重，真完全树还是最优编码树吗？]]
- [[50-Tree#Huffman 树的特性|Huffman 树的特性：双子性、层次性]]
- [[50-Tree#Huffman 树构造的改进方案|Huffman树构造的改进方案：优先级队列改进方案的时间复杂度]]
- [[50-Tree#树的半径与BFS|树的半径与BFS]]
- [[60-Binary_Search_Tree#插入|BST插入的节点一定是叶节点吗？]]
- [[60-Binary_Search_Tree#删除|BST删除操作的两种情况]]
- [[60-Binary_Search_Tree#期望树高|BST随机生成和随机组成的区别]]
- [[61-Balanced-BST#高度与节点数|AVL-tree的高度与节点数关系]]
- [[62-BST-Exercise#7-13 证明 AVL 树插入节点后失衡的祖先数可能多达Ω(logn)个|Fib-AVL树的形态]]
- [[61-Balanced-BST#插入|AVL-tree树高增长的可能性：一定要失衡吗？]]
- [[61-Balanced-BST#删除|AVL-tree树高降低的可能性：一定要失衡吗？]]
- [[61-Balanced-BST#双层伸展|Splay-tree双层伸展的细节、单层伸展最多发生多少次？]]
- [[61-Balanced-BST#插入|Splay-tree的插入：在根部直接插入节点，省去第二次伸展]]
- [[61-Balanced-BST#删除|Splay-tree删除：先伸展再根部删除之]]
- [[61-Balanced-BST#势能分摊分析|Splay-tree的势能分析]]
- [[61-Balanced-BST#准确定义|BTree定义的细节：深度、高度]]
- [[61-Balanced-BST#树高|BTree树高、胖瘦问题]]
- [[61-Balanced-BST#分裂|BTree插入引起的上溢修复、树高增加的可能性]]
- [[61-Balanced-BST#删除|BTree删除引起的下溢修复、下溢到根的可能]]
- [[61-Balanced-BST#并发性|BST结构与并发性(访问延迟)的关系]]
- [[61-Balanced-BST#红黑树的高度|红黑树的高度、黑高度、黑深度、红高度]]
- [[61-Balanced-BST#双红修正|红黑树双红修正：黑高度增加的可能性]]
- [[61-Balanced-BST#删除|红黑树的删除操作如何引起双黑冲突]]
- [[61-Balanced-BST#双黑修复|红黑树双黑修复：黑高度降低的可能性]]
- [[61-Balanced-BST#^217ccd|红黑树插入、删除操作的总结]]
- [[62-BST-Exercise#7-12 高度 h 的 AVL 树任一叶节点深度均不小于 $ lceil frac{h}{2} rceil$|AVL树叶节点深度不小于h/2的证明]]
- [[62-BST-Exercise#7-15 证明 BST 在 n-1 次旋转内可以等价变换为左侧链|BST在n-1次旋转内就可以转换为左侧链]]
- [[62-BST-Exercise#7-15-b 规模 n 的任何两棵等价 BST 至多 2n-2 次调整就可彼此转换|任何两棵等价BST在2n-2次调整内即可彼此转换]]
- [[62-BST-Exercise#7-17 证明对于规模 n 的 AVL 树删除一节点后最多需要Ω(logn)次旋转才能恢复平衡|AVL树何种情况下删除节点需要调整O(logn)次才会复平衡？]]
- [[62-BST-Exercise#7-19 AVL 树中删除一个节点且调整后某祖先 g(x) 复平衡，是否可以停止上溯？|AVL树删除节点后调整至某一祖先复衡，是否可以停止上溯？]]
- [[62-BST-Exercise#7-20 证明递增插入 2 (h+1)-1 个关键码到空 AVL 树中必然得到高度 h 的满树|证明递增插入2^(h+1)-1个关键码到AVL树必能得到满树]]
- [[62-BST-Exercise#8-6 考查 BTree 节点插入导致的分裂次数|BTree 节点插入过程中导致的分裂次数的分析]]
- [[70-Hash#除余法|除余法中素数的作用、算法的缺陷]]
- [[70-Hash#MAD 法|MAD法中M、A这两个操作对除余法进行了什么改进？]]
- [[70-Hash#开放散列|开放散列与封闭散列的区别是什么？]]
- [[70-Hash#开放散列|开放散列的三种思路：多槽位、公共溢出区、独立链的特点]]
- [[70-Hash#开放定址|开放散列和开放定址的区别？]]
- [[70-Hash#线性试探|线性试探：思路、优劣、懒删除机制]]
- [[70-Hash#重散列|重散列与双散列的区别:rehash, bi-hash]]
- [[70-Hash#平方试探|平方试探中表长是素数、合数有什么影响？装填因子多少时可以保证找到？]]
- [[70-Hash#双向平方试探|双向平方试探什么情况下可以填满整个表？]]
- [[70-Hash#思路|基数排序的时间复杂度分析]]
- [[70-Hash#^37f503|基数排序如何确保正确性？底层排序一定要稳定吗？]]
- [[70-Hash#思路|计数排序的应用场景、思路与实例]]
- [[70-Hash#^dd99f2|计数排序每轮迭代的最后一步——扫描数据能否改为自前向后？]]
- [[70-Hash#空间性能|跳转表的空间性能：塔高期望]]
- [[70-Hash#查找|跳转表查找：纵向跳转次数和横向跳转次数]]
- [[71-Hash-Exercise#9-6 散列表中模余法以同间隔插入关键码|除余法导致的关键码冲突数、散列表利用率]]
- [[80-Graph#路径、环路|路径、环路：欧拉环路、哈密尔顿环路等概念]]
- [[80-Graph#邻接矩阵与关联矩阵|邻接矩阵：特点、空间复杂度和利用率、性能、缺点]]
- [[80-Graph#邻接表|邻接表：特点、空间复杂度、时间复杂度（琐碎）]]
- [[80-Graph#邻接矩阵与邻接表的取舍原则|邻接矩阵和邻接表的取舍原则]]
- [[80-Graph#实例|BFS过程中顶点状态、边记号的含义]]
- [[80-Graph#推广：全图BFS|bfs时间复杂度]]
- [[80-Graph#最短路径|图的最短路径思路、BFS过程中队列变化细节]]
- [[80-Graph#图的偏心率、半径、直径、中心|图的偏心率、半径、直径、中心]]
- [[80-Graph#实现|DFS顶点状态dTime、fTime细节、其他状态的含义]]
- [[80-Graph#^804025|DFS过程中边的状态细节]]
- [[80-Graph#括号引理|括号引理与活跃期]]
- [[80-Graph#何时选用 BFS/DFS？|BFS/DFS各自适用的场景]]
- [[80-Graph#^02bb00|如何判断图中出现环路？]]
- [[82-Graph-Exercise#6-10 DFS 在 O (n+e)内判断是否存在欧拉环路并构造之|如何判断是否存在欧拉环路？]]
- [[81-Graph-Application#DAG 中的偏序关系|DAG与拓扑排序的偏序、全序关系]]
- [[81-Graph-Application#策略（描述）|零出度拓扑排序的应用]]
- [[81-Graph-Application#定义|关节点、双连通图、双连通分量的定义、特点]]
- [[81-Graph-Application#改进：利用 DFS|DFC判断双连通图：内部节点何时为关节点？hca如何判断双连通分量？]]
- [[81-Graph-Application#复杂度|优先级搜索的时间复杂度]]
- [[81-Graph-Application#最短路径树|最短路径树的概念与Dijkstra算法的局限性]]
- [[81-Graph-Application#实现|Dijkstra算法的实例细节]]
- [[81-Graph-Application#蛮力算法|MST的蛮力算法：Cayley公式]]
- [[81-Graph-Application#改进思路：极短跨边|极短跨边理论：排除环路最长边、容纳割的最短边的思路]]
- [[81-Graph-Application#Kruskal 算法：|Kruskal算法的思路步骤、正确性、并查集实现]]
- [[82-Graph-Exercise#6-1 关联矩阵|有向图、无向图的关联矩阵与邻接矩阵的关系]]
- [[82-Graph-Exercise#6-16 Prim 算法通过扰动消除由重复边引起的歧义|Prim 算法通过扰动消除由重复边引起的歧义]]
- [[82-Graph-Exercise#6-23 合成数法消除 Prim 和 Dijkstra 算法的歧义性|合成数法消除 Prim 和 Dijkstra 算法的歧义性]]
- [[82-Graph-Exercise#6-24 考查负权边和负权环对 Prim 和 Dijkstra 算法的影响|考查负权边和负权环对 Prim 和 Dijkstra 算法的影响]]
- [[82-Graph-Exercise#6-27 证明 Prim 算法在多边等权时亦然成立|证明 Prim 算法在多边等权时亦然成立]]
- [[82-Graph-Exercise#6-29 说明最坏情况的 Kruskal 算法|最坏情况的 Kruskal 算法]]
- [[82-Graph-Exercise#6-31 最短路径树不唯一问题|最短路径树唯一确定吗？]]
- [[90-Priority_Queue#完全二叉堆|完全二叉堆的秩的关系：内部节点最大秩，父亲的秩，左右子的秩]]
- [[90-Priority_Queue#逐层上滤|二叉堆插入：逐层上滤步骤及效率]]
- [[90-Priority_Queue#逐层下滤|二叉堆删除：逐层下滤步骤及效率，注意ProperParent宏]]
- [[90-Priority_Queue#自下而上的下滤|Floyd建堆法详细步骤、效率、具体比较次数、不适用场景]]
- [[90-Priority_Queue#思考|大顶堆delMin操作可以达到O(logn)吗？具体是多少？]]
- [[90-Priority_Queue#性能|胜者树细节：重赛次数、性能、用以k选取的比较次数]]
- [[90-Priority_Queue#败者树|败者树细节：思路、亚军、比较次数]]
- [[90-Priority_Queue#利用优先级队列改进 PFS 框架的思路|二叉堆对图PFS的改进：优劣]]
- [[90-Priority_Queue#多叉堆形式|多叉堆秩的计算方式]]
- [[90-Priority_Queue#多叉堆特点|多叉堆特点：堆高、下滤性能、上滤性能]]
- [[90-Priority_Queue#多叉堆实现 PFS 的优势|多叉堆实现 PFS 的优势]]
- [[90-Priority_Queue#左式堆形态|左式堆的形态、实现]]
- [[90-Priority_Queue#空节点路径长度|npl的计算方式]]
- [[90-Priority_Queue#左式堆的左倾性|左式堆的左倾性如何控制？左倾性的细节性质]]
- [[90-Priority_Queue#最右侧通路——右侧链|左式堆节点数与高度关系：右侧链与长度、最浅外部节点]]
- [[90-Priority_Queue#实例|左式堆如何实现堆的合并]]
- [[90-Priority_Queue#左式堆合并的复杂度|左式堆合并的复杂度]]
- [[90-Priority_Queue#插入与删除|左式堆如何实现插入与删除]]
- [[91-PQ-Exercise#10-4 O (1)时间确定祖先的秩|二叉堆中如何在O(1)时间确定任何祖先的秩]]
- [[A0-String#理解 `next[]` 表|理解 next[] 表]]
- [[A0-String#构造 `next[]` 表|构造 next[] 表]]
- [[A0-String#分摊分析|KMP算法分摊分析复杂度]]
- [[A0-String#改进 `next[]`|改进 next[] 表]]
- [[A0-String#适用范围|KMP算法的适用情景]]
- [[A0-String#坏字符移动的思路|坏字符移动的思路]]
- [[A0-String#构建 `bc[]` 表|构建 bc[] 表、及时间复杂度]]
- [[A0-String#性能分析|坏字符策略的性能分析与适用场景]]
- [[A0-String#好后缀的经验|好后缀的思路]]
- [[A0-String#构造 `gs[]` 表——借助最大匹配后缀串|借助最大匹配后缀串构造 gs[] 表]]
- [[A0-String#如何构造 `ss[]`？|构造 ss[] 表的时间复杂度]]
- [[A0-String#性能分析|KMP、BM-BC、BM-GS策略性能分析与比较]]
- [[A0-String#利用散列优化|散列如何优化KR法？]]
- [[A0-String#快速指纹计算|快速指纹计算：方法、复杂度]]
- [[B0-Sort#轴点划分：LUG 版|轴点划分LUG版]]
- [[B0-Sort#轴点划分：DUP 版|轴点划分DUP版：应对情形、改进之处、特点]]
- [[B0-Sort#轴点划分：LGU 版|轴点划分LGU版：如何操作？]]
- [[B0-Sort#分析递归深度|快速排序递归深度的分析]]
- [[B0-Sort#分析比较次数|快速排序比较次数的分析：递推分析、后向分析]]
- [[B0-Sort#众数与中位数|众数与中位数：关系、确定众数候选的方法]]
- [[B0-Sort#中位数选取|中位数选取：减治策略及复杂度]]
- [[B0-Sort#快速选取法|k选取：基于快速化分的k选取策略、复杂度]]
- [[B0-Sort#线性选取|k选取：线性选取策略、复杂度]]
- [[B0-Sort#输入敏感性与希尔排序性能分析|输入敏感性与希尔排序性能分析]]
- [[B0-Sort#shell 序列|shell序列最后一趟复杂度为Ω(n^2)的原因]]
- [[B0-Sort#线性组合|互素元素线性组合的最大不可表示数]]
- [[B0-Sort#有序性的保持和加强|互素步长的排序后逆序对的间距]]
- [[B0-Sort#(g, h)-sorted 时 d-sorting 的排序成本|(g, h)-sorted 时 d-sorting 的排序成本]]
- [[B0-Sort#Papernov-Stasevic Seq|PS步长序列的时间复杂度]]
- [[B0-Sort#Pratt Seq|Pratt步长序列的时间复杂度]]
- [[B0-Sort#Sedgewick Seq|Sedgewick步长序列的时间复杂度]]
- [[B1-Sort-Exercise#12-10 基于 `median()` 算法设计 k-selection 算法|如何基于中位数选取算法实现k选取？]]
- [[B1-Sort-Exercise#12-14 Pratt 序列分析|Pratt序列的详细分析]]

### 拓展延伸

- [[16-Stirling-Approximation#Intro|Stirling渐进]]
- [[15-Little-o-notation|Little-o-notation]]
- [[14-Lowerbound-analyze#线性规约|线性规约Linear reduction]]
- [[14-Lowerbound-analyze#CBA排序算法下界|CBA排序算法下界分析(比较树)]]
- [[13-Dynamic-Programming|动态规划]]
- [[21-Vector-Exercise#2-6 permute 生成随机排列|Fisher 随机数生成算法与分析]]
- [[21-Vector-Exercise#2-12-d deduplicate ()可以改进到什么地步？|无序向量唯一化的时间下界]]
- [[21-Vector-Exercise#2-21 指数查找 expSearch|指数查找]]
- [[21-Vector-Exercise#2-22 马鞍查找——二维向量查找|马鞍查找]]
- [[21-Vector-Exercise#2-23 判断分支深入的代价严重不对称的查找|鸡蛋查找：分支深入代价严重不对称]]
- [[24-Bitmap|Bitmap]]
- [[22-In-place-mergeSort|In-place mergesort]]
- [[23-N-way-merge|N-way merge]]
- [[31-List-Exercise#3-6 自调整列表|自调整列表]]
- [[41-Stack-queue-Exercise#4-24 孪生栈|孪生栈]]
- [[41-Stack-queue-Exercise#4-18 费马-拉格朗日分解|费马-拉格朗日分解]]
- [[42-Catalan#Applications|Catalan数实例(14个)]]
- [[51-Tree-Exercise#5-30 键树 Trie|键树Trie]]
- [[62-BST-Exercise#7-15-补 证明对等价 BBST 不能在 O (logn)时间内互相转换|如何证明两棵等价BBST在O(logn)时间内不能完成彼此转换]]
- [[62-BST-Exercise#soulution 2 (correct)|何种插入关键码的次序使 BTree 高度最小]]
- [[62-BST-Exercise#8-9 B* 树|B* 树及其优点]]
- [[68-B+Tree|B+树]]
- [[64-Height-BBST-vs-Weight-BBST|Height-BBST vs. Weight-BBST]]
- [[66-Fib-sequence-and-worst-AVL-trees|斐波那契序列与最差AVL树的证明]]
- [[80-Graph#二分图|二分图]]
- [[86-SPT-OIwiki#Floyd-Warshall 算法|Floyd-Warshall 算法求 SPT]]
- [[82-Graph-Exercise#6-32 欧式最小支撑树|欧式最小支撑树]]
- [[84-并查集|并查集]]
- [[87-Strongly-Connected-Components|强连通分量的求解方法]]
- [[93-Fibonacci-heap|Fibonacci-heap]]
- [[92-Min-max-heap|Min-max heap]]
- [[95-Skew-heap|Skew heap]]

### 习题解析好题

- [[21-Vector-Exercise#2-5 分摊分析——二进制整数递增|分摊分析实例：二进制整数递增]]
- [[21-Vector-Exercise#2-15 CBA 算法下界分析|比较树高度分析: CBA排序]]
- [[21-Vector-Exercise#2-39 CBA 插入两元素到有序序列的比较次数分析|插入多个元素到有序序列的比较次数]]
- [[21-Vector-Exercise#2-40 CBA 找出最大者、次大者|找出向量中最大者、次大者的策略优化]]
- [[31-List-Exercise#3-10 插入排序性能分析|插入排序性能分析]]
- [[31-List-Exercise#3-11 逆序对与插入排序分析|逆序对与插入排序分析]]
- [[31-List-Exercise#3-14 循环节的应用|循环节：选择排序中无需交换的元素的数量]]
- [[31-List-Exercise#3-16 mergeSort 划分的影响|mergeSort不平衡划分的影响:O(n^2)]]
- [[41-Stack-queue-Exercise#4-3 栈混洗与禁形|栈混洗与禁形]]
- [[41-Stack-queue-Exercise#4-11 中缀表达式运算中根据括号数求栈规模|中缀表达式运算中根据括号数求栈规模]]
- [[51-Tree-Exercise#5.2 二叉树深度、节点数与高度关系|二叉树高度与节点数问题：引伸到真二叉树]]
- [[51-Tree-Exercise#5-6 PFC 编码一定解码成功吗？|PFC 编码一定解码成功吗？]]
- [[51-Tree-Exercise#5-15 迭代式遍历算法的栈的最小容量|易错：迭代式树遍历算法的栈的最小容量]]
- [[51-Tree-Exercise#5-16 分析 travIn_I3 的时间复杂度|分析 travIn_I3 的时间复杂度（succ接口对复杂度的影响）]]
- [[51-Tree-Exercise#5-18 层次遍历辅助队列容量问题|层次遍历辅助队列容量问题]]
- [[51-Tree-Exercise#5-19 证明完全二叉树层次遍历过程中辅助队列规模单峰对称|层次遍历过程中辅助队列规模单峰对称的性质]]
- [[51-Tree-Exercise#5-20 如何判断任一对节点间存在“祖先-后代”关系？|如何判断任一对节点间存在“祖先-后代”关系？]]
- [[51-Tree-Exercise#5-24 O (n)时间内判断是否树中所有节点的数值均不小于其真祖先的数值总和|O (n)时间内判断是否树中所有节点的数值均不小于其真祖先的数值总和]]
- [[51-Tree-Exercise#5-25 O (n)时间内将每个节点的数值替换为后代中最大数值|O (n)时间内将每个节点的数值替换为后代中最大数值]]
- [[62-BST-Exercise#7-10 扩充 searchAll(e)接口|如何在关键码可重复的BST中找到目标项的全部？]]
- [[62-BST-Exercise#8-13 考察 2012 个内部节点的红黑树高度|2012个内部节点的红黑树(黑)高度的极值问题]]
- [[62-BST-Exercise#8-14 考察红黑树重染色节点的数量|证明：分摊意义上红黑树重平衡中需要重染色的节点数为O(1)]]
- [[71-Hash-Exercise#9-7 表长不能取作 2 k 的分析|表长为什么不能取作2^k？]]
- [[71-Hash-Exercise#9-14 单向平方试探法表长为素数的查找链分析|单向平方试探法在素数长度的哈希表中的查找链分析]]
- [[71-Hash-Exercise#9-15 散列表长为合数时的平方试探|散列表长为合数时的平方试探]]
- [[71-Hash-Exercise#9-17 双向平方试探的表长分析|双向平方试探的表长分析：4k+3]]
- [[71-Hash-Exercise#9-23 计数排序|计数排序]]
- [[71-Hash-Exercise#9-18 散列表实例|单向平方试探为什么会陷入死循环]]
- [[82-Graph-Exercise#6-3 平面图的边数量|平面图的边数量为O(n)的证明]]
- [[82-Graph-Exercise#6-7 BFS 辅助队列的特性|BFS 辅助队列的特性]]
- [[82-Graph-Exercise#6-18 通过拓扑排序检查是否是 DAG|通过拓扑排序检查是否是 DAG]]
- [[82-Graph-Exercise#6-21 以 PFS 设计 prioUpdater 实现 BFS、DFS|以 PFS 设计 prioUpdater 实现 BFS、DFS]]
- [[82-Graph-Exercise#6-25、26 边权重复时极小支撑树问题|边权重复时极小支撑树问题]]
- [[91-PQ-Exercise#10-4-b 将 percolateUp 算法优化到 O (loglogn)|如何将上滤算法的比较次数优化到O(loglogn)]]
- [[91-PQ-Exercise#10-6 估算 percolateUp 的实际期望|估算 percolateUp 的实际期望]]
- [[91-PQ-Exercise#10-8 优先级队列与 Huffman 树|CBA式算法构建Huffman树的时间下界]]
- [[91-PQ-Exercise#10-9 利用频率已有序的性质在 O (n)完成构建 Huffman 树|利用频率已有序的性质在 O (n)完成构建 Huffman 树]]
- [[91-PQ-Exercise#10.17 利用多叉堆改进 Prim 算法|利用多叉堆改进 Prim 算法]]
- [[91-PQ-Exercise#10-19 为栈维护 getMax 接口|为栈维护 getMax 接口]]
- [[91-PQ-Exercise#10-20 为队列维护 getMax 接口|为队列维护 getMax 接口]]
- [[91-PQ-Exercise#10-21 合并 AVL 树|合并大节点AVL树和小节点AVL树]]
- [[91-PQ-Exercise#10-22 分裂 AVL 树|分裂大节点AVL树和小节点AVL树]]
- [[A1-String-Exercise#11-4 KMP 复杂度分析|KMP 复杂度的严谨分析]]
- [[A1-String-Exercise#11 -6 `gs[]` 构造算法的时间复杂度|ss[]和 gs[]表的构造算法复杂度]]
- [[A1-String-Exercise#11-7 模式枚举|模式枚举问题：匹配间隔的设置对复杂度的影响]]
- [[A1-String-Exercise#11-9 分析蛮力算法的实际效率|分析模式匹配蛮力算法的实际效率]]
- [[B1-Sort-Exercise#12-1 构造轴点的 LGU 策略|LGU策略能否应对大量元素重复的情况？]]
- [[B1-Sort-Exercise#12-1-补 三点取中法的失衡概率|三点取中法的失衡概率计算]]
- [[B1-Sort-Exercise#12-3 众数定义改为“不少于一半”的分析|众数定义修改为“不少于一半”的分析]]
- [[B1-Sort-Exercise#12-7 不等长向量长度的 `median()` 算法分析|不等长向量长度的 `median()` 算法分析]]
- [[B1-Sort-Exercise#12-12 基数排序推广：希尔排序的基本思想|基数排序推广：希尔排序的基本思想]]
- [[B1-Sort-Exercise#12-13 证明 g-sorted 的向量经过 h-sorting 后亦然保持 g-sorted|证明 g-sorted 的向量经过 h-sorting 后亦然保持 g-sorted]]

## 推荐资源

- 推荐资料：[What is an Algorithm?](https://www.programiz.com/dsa/algorithm)
- [Python Tutor code visualizer: Visualize code in Python, JavaScript, C, C++, and Java](https://pythontutor.com/render.html#)
- [visualising data structures and algorithms through animation - VisuAlgo](https://visualgo.net/)
- [Algorithm Visualizer](https://algorithm-visualizer.org/)
- [DSACPP](https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/index.htm)
- 算法导论习题答案：[CLRS Solutions](https://sites.math.rutgers.edu/~ajl213/CLRS/CLRS.html)
- OIWiki：[OI Wiki - OI Wiki](https://oi-wiki.org/)
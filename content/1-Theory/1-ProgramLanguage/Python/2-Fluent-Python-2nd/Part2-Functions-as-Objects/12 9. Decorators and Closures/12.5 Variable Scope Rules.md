# Variable Scope Rules

In [Example 9-3](#ex_global_undef), we define and test a function that reads two variables: a local variable `a`—defined as function parameter—and variable `b` that is not defined anywhere in the function.

##### Example 9-3. Function reading a local and a global variable

```
>>> 
```

The error we got is not surprising. Continuing from [Example 9-3](#ex_global_undef), if we assign a value to a global `b` and then call `f1`, it works:

```
>>> 
```

Now, let’s see an example that may surprise you.

Take a look at the `f2` function in [Example 9-4](#ex_local_unbound). Its first two lines are the same as `f1` in [Example 9-3](#ex_global_undef), then it makes an assignment to `b`. But it fails at the second `print`, before the assignment is made.

##### Example 9-4. Variable `b` is local, because it is assigned a value in the body of the function

```
>>> 
```

Note that the output starts with `3`, which proves that the `print(a)` statement was executed. But the second one, `print(b)`, never runs. When I first saw this I was surprised, thinking that `6` should be printed, because there is a global variable `b` and the assignment to the local `b` is made after `print(b)`.

But the fact is, when Python compiles the body of the function, it decides that `b` is a local variable because it is assigned within the function. The generated bytecode reflects this decision and will try to fetch `b` from the local scope. Later, when the call `f2(3)` is made, the body of `f2` fetches and prints the value of the local variable `a`, but when trying to fetch the value of local variable `b`, it discovers that `b` is unbound.

This is not a bug, but a design choice: Python does not require you to declare variables, but assumes that a variable assigned in the body of a function is local. This is much better than the behavior of JavaScript, which does not require variable declarations either, but if you do forget to declare that a variable is local (with `var`), you may clobber a global variable without knowing.

If we want the interpreter to treat `b` as a global variable and still assign a new value to it within the function, we use the `global` declaration:

```
>>> 
```

In the preceding examples, we can see two scopes in action:

The module global scope

Made of names assigned to values outside of any class or function block.

The f3 function local scope

Made of names assigned to values as parameters, or directly in the body of the function.

There is one other scope where variables can come from, which we call _nonlocal_ and is fundamental for closures; we’ll see it in a bit.

After this closer look at how variable scopes work in Python, we can tackle closures in the next section, [“Closures”](#closures_sec). If you are curious about the bytecode differences between the functions in Examples [9-3](#ex_global_undef) and [9-4](#ex_local_unbound), see the following sidebar.

##### Comparing Bytecodes

The `dis` module provides an easy way to disassemble the bytecode of Python functions. Read Examples [9-5](#ex_f1_dis) and [9-6](#ex_f2_dis) to see the bytecodes for `f1` and `f2` from Examples [9-3](#ex_global_undef) and [9-4](#ex_local_unbound).

##### Example 9-5. Disassembly of the `f1` function from [Example 9-3](#ex_global_undef)

```
>>
```

[![^1]

Load global name `print`.

[![^2]

Load local name `a`.

[![^3]

Load global name `b`.

Contrast the bytecode for `f1` shown in [Example 9-5](#ex_f1_dis) with the bytecode for `f2` in [Example 9-6](#ex_f2_dis).

##### Example 9-6. Disassembly of the `f2` function from [Example 9-4](#ex_local_unbound)

```
>>
```

[![^1]

Load _local_ name `b`. This shows that the compiler considers `b` a local variable, even if the assignment to `b` occurs later, because the nature of the variable—whether it is local or not—cannot change in the body of the function.

The CPython virtual machine (VM) that runs the bytecode is a stack machine, so `LOAD` and `POP` operations refer to the stack. It is beyond the scope of this book to further describe the Python opcodes, but they are documented along with the `dis` module in [“dis—Disassembler for Python bytecode”](https://fpy.li/9-1).
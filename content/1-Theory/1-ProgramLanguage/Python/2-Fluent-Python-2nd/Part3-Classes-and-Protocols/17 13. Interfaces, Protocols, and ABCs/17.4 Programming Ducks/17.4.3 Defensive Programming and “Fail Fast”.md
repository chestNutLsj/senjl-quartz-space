## Defensive Programming and “Fail Fast”

Defensive programming is like defensive driving: a set of practices to enhance safety even when faced with careless programmers—or drivers.

Many bugs cannot be caught except at runtime—even in mainstream statically typed languages.[^3] In a dynamically typed language, “fail fast” is excellent advice for safer and easier-to-maintain programs. Failing fast means raising runtime errors as soon as possible, for example, rejecting invalid arguments right a the beginning of a function body.

Here is one example: when you write code that accepts a sequence of items to process internally as a `list`, don’t enforce a `list` argument by type checking. Instead, take the argument and immediately build a `list` from it. One example of this code pattern is the `__init__` method in [Example 13-10](#ex_lotto), later in this chapter:

    `def` `__init__``(``self``,` `iterable``):`
        `self``.``_balls` `=` `list``(``iterable``)`

That way you make your code more flexible, because the `list()` constructor handles any iterable that fits in memory. If the argument is not iterable, the call will fail fast with a very clear `TypeError` exception, right when the object is initialized. If you want to be more explict, you can wrap the `list()` call with `try/except` to customize the error message—but I’d use that extra code only on an external API, because the problem would be easy to see for maintainers of the codebase. Either way, the offending call will appear near the end of the traceback, making it straightforward to fix. If you don’t catch the invalid argument in the class constructor, the program will blow up later, when some other method of the class needs to operate on `self._balls` and it is not a `list`. Then the root cause will be harder to find.

Of course, calling `list()` on the argument would be bad if the data shouldn’t be copied, either because it’s too large or because the function, by design, needs to change it in place for the benefit of the caller, like `random.shuffle` does. In that case, a runtime check like `isinstance(x, abc.MutableSequence)` would be the way to go.

If you are afraid to get an infinite generator—not a common issue—you can begin by calling `len()` on the argument. This would reject iterators, while safely dealing with tuples, arrays, and other existing or future classes that fully implement the `Sequence` interface. Calling `len()` is usually very cheap, and an invalid argument will raise an error immediately.

On the other hand, if any iterable is acceptable, then call `iter(x)` as soon as possible to obtain an iterator, as we’ll see in [“Why Sequences Are Iterable: The iter Function”](ch17.html#iter_func_sec). Again, if `x` is not iterable, this will fail fast with an easy-to-debug exception.

In the cases I just described, a type hint could catch some problems earlier, but not all problems. Recall that the type `Any` is _consistent-with_ every other type. Type inference may cause a variable to be tagged with the `Any` type. When that happens, the type checker is in the dark. In addition, type hints are not enforced at runtime. Fail fast is the last line of defense.

Defensive code leveraging duck types can also include logic to handle different types without using `isinstance()` or `hasattr()` tests.

One example is how we might emulate the handling of the `field_names` argument in [`collections.namedtuple`](https://fpy.li/13-8): `field_names` accepts a single string with identifiers separated by spaces or commas, or a sequence of identifiers. [Example 13-5](#ex_duck_typing_str_list) shows how I’d do it using duck typing.

##### Example 13-5. Duck typing to handle a string or an iterable of strings

```
    
```

[![^1]

Assume it’s a string (EAFP = it’s easier to ask forgiveness than permission).

[![^2]

Convert commas to spaces and split the result into a list of names.

[![^3]

Sorry, `field_names` doesn’t quack like a `str`: it has no `.replace`, or it returns something we can’t `.split`.

[![^4]

If `AttributeError` was raised, then `field_names` is not a `str` and we assume it was already an iterable of names.

[![^5]

To make sure it’s an iterable and to keep our own copy, create a tuple out of what we have. A `tuple` is more compact than `list`, and it also prevents my code from changing the names by mistake.

[![^6]

Use `str.isidentifier` to ensure every name is valid.

[Example 13-5](#ex_duck_typing_str_list) shows one situation where duck typing is more expressive than static type hints. There is no way to spell a type hint that says “`field_names` must be a string of identifiers separated by spaces or commas.” This is the relevant part of the `namedtuple` signature on typeshed (see the full source at [_stdlib/3/collections/__init__.pyi_](https://fpy.li/13-9)):

    `def` `namedtuple``(`
        `typename``:` `str``,`
        `field_names``:` `Union``[``str``,` `Iterable``[``str``]],`
        `*``,`
        `# rest of signature omitted`

As you can see, `field_names` is annotated as `Union[str, Iterable[str]]`, which is OK as far as it goes, but is not enough to catch all possible problems.

After reviewing dynamic protocols, we move to a more explicit form of runtime type checking: goose typing.
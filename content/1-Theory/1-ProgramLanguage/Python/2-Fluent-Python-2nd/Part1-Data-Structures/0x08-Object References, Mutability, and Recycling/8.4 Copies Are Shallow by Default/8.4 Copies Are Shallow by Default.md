# Copies Are Shallow by Default

The easiest way to copy a list (or most built-in mutable collections) is to use the built-in constructor for the type itself. For example:

`>>>` `l1` `=` `[``3``,` `[``55``,` `44``]``,` `(``7``,` `8``,` `9``)``]`
`>>>` `l2` `=` `list``(``l1``)`  [![^1]
`>>>` `l2`
`[3, [55, 44], (7, 8, 9)]`
`>>>` `l2` `==` `l1`  [![^2]
`True`
`>>>` `l2` `is` `l1`  [![^3]
`False`

[![^1]

`list(l1)` creates a copy of `l1`.

[![^2]

The copies are equal…

[![^3]

…but refer to two different objects.

For lists and other mutable sequences, the shortcut `l2 = l1[:]` also makes a copy.

However, using the constructor or `[:]` produces a _shallow copy_ (i.e., the outermost container is duplicated, but the copy is filled with references to the same items held by the original container). This saves memory and causes no problems if all the items are immutable. But if there are mutable items, this may lead to unpleasant surprises.

In [Example 6-6](#ex_shallow_copy), we create a shallow copy of a list containing another list and a tuple, and then make changes to see how they affect the referenced objects.

###### Tip

If you have a connected computer on hand, I highly recommend watching the interactive animation for [Example 6-6](#ex_shallow_copy) at the [Online Python Tutor](https://fpy.li/6-3). As I write this, direct linking to a prepared example at _pythontutor.com_ is not working reliably, but the tool is awesome, so taking the time to copy and paste the code is worthwhile.

##### Example 6-6. Making a shallow copy of a list containing another list; copy and paste this code to see it animated at the Online Python Tutor

```
l1
```

[![^1]

`l2` is a shallow copy of `l1`. This state is depicted in [Figure 6-3](#shallow_copy1).

[![^2]

Appending `100` to `l1` has no effect on `l2`.

[![^3]

Here we remove `55` from the inner list `l1[1]`. This affects `l2` because `l2[1]` is bound to the same list as `l1[1]`.

[![^4]

For a mutable object like the list referred by `l2[1]`, the operator `+=` changes the list in place. This change is visible at `l1[1]`, which is an alias for `l2[1]`.

[![^5]

`+=` on a tuple creates a new tuple and rebinds the variable `l2[2]` here. This is the same as doing `l2[2] = l2[2] + (10, 11)`. Now the tuples in the last position of `l1` and `l2` are no longer the same object. See [Figure 6-4](#shallow_copy2).

![References diagram](assets/flpy_0603.png)

###### Figure 6-3. Program state immediately after the assignment `l2 = list(l1)` in [Example 6-6](#ex_shallow_copy). `l1` and `l2` refer to distinct lists, but the lists share references to the same inner list object `[66, 55, 44]` and tuple `(7, 8, 9)`. (Diagram generated by the Online Python Tutor.)

The output of [Example 6-6](#ex_shallow_copy) is [Example 6-7](#ex_shallow_copy_out), and the final state of the objects is depicted in [Figure 6-4](#shallow_copy2).

##### Example 6-7. Output of [Example 6-6](#ex_shallow_copy)

```
l1
```

![References diagram](assets/flpy_0604.png)

###### Figure 6-4. Final state of `l1` and `l2`: they still share references to the same list object, now containing `[66, 44, 33, 22]`, but the operation `l2[2] += (10, 11)` created a new tuple with content `(7, 8, 9, 10, 11)`, unrelated to the tuple `(7, 8, 9)` referenced by `l1[2]`. (Diagram generated by the Online Python Tutor.)

It should be clear now that shallow copies are easy to make, but they may or may not be what you want. How to make deep copies is our next topic.
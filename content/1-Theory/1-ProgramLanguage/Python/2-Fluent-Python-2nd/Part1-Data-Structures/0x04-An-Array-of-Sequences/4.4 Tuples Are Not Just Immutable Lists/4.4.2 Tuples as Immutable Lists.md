## Tuples as Immutable Lists

The Python interpreter and standard library make extensive use of tuples as immutable lists, and so should you. This brings two key benefits:

Clarity

When you see a `tuple` in code, you know its length will never change.

Performance

A `tuple` uses less memory than a `list` of the same length, and it allows Python to do some optimizations.

However, be aware that the immutability of a `tuple` only applies to the references contained in it. References in a tuple cannot be deleted or replaced. But if one of those references points to a mutable object, and that object is changed, then the value of the `tuple` changes. The next snippet illustrates this point by creating two tuples—`a` and `b`—which are initially equal. [Figure 2-4](#tuple_mutable) represents the initial layout of the `b` tuple in memory.

![Reference diagram for a tuple with three items](assets/flpy_0204.png)

###### Figure 2-4. The content of the tuple itself is immutable, but that only means the references held by the tuple will always point to the same objects. However, if one of the referenced objects is mutable—like a list—its content may change.

When the last item in `b` is changed, `b` and `a` become different:

```
>>> 
```

Tuples with mutable items can be a source of bugs. As we’ll see in [“What Is Hashable”](ch03.html#what_is_hashable), an object is only hashable if its value cannot ever change. An unhashable tuple cannot be inserted as a `dict` key, or a `set` element.

If you want to determine explicitly if a tuple (or any object) has a fixed value, you can use the `hash` built-in to create a `fixed` function like this:

```
>>> 
```

We explore this issue further in [“The Relative Immutability of Tuples”](ch06.html#tuple-relative-immutable).

Despite this caveat, tuples are widely used as immutable lists. They offer some performance advantages explained by Python core developer Raymond Hettinger in a StackOverflow answer to the question: [“Are tuples more efficient than lists in Python?”](https://fpy.li/2-3). To summarize, Hettinger wrote:

- To evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation; but for a list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds the list.
    
- Given a tuple `t`, `tuple(t)` simply returns a reference to the same `t`. There’s no need to copy. In contrast, given a list `l`, the `list(l)` constructor must create a new copy of `l`.
    
- Because of its fixed length, a `tuple` instance is allocated the exact memory space it needs. Instances of `list`, on the other hand, are allocated with room to spare, to amortize the cost of future appends.
    
- The references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an array of references stored elsewhere. The indirection is necessary because when a list grows beyond the space currently allocated, Python needs to reallocate the array of references to make room. The extra indirection makes CPU caches less effective.
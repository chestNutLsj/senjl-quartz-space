## Processes, Threads, and Python’s Infamous GIL

Here is how the concepts we just saw apply to Python programming, in 10 points:

- Each instance of the Python interpreter is a process. You can start additional Python processes using the _multiprocessing_ or _concurrent.futures_ libraries. Python’s _subprocess_ library is designed to launch processes to run external programs, regardless of the languages used to write them.
    
- The Python interpreter uses a single thread to run the user’s program and the memory garbage collector. You can start additional Python threads using the _threading_ or _concurrent.futures_ libraries.
    2. Access to object reference counts and other internal interpreter state is controlled by a lock, the Global Interpreter Lock (GIL). Only one Python thread can hold the GIL at any time. This means that only one thread can execute Python code at any time, regardless of the number of CPU cores.
    
4. To prevent a Python thread from holding the GIL indefinitely, Python’s bytecode interpreter pauses the current Python thread every 5ms by default,[^4] releasing the GIL. The thread can then try to reacquire the GIL, but if there are other threads waiting for it, the OS scheduler may pick one of them to proceed.
    
5. When we write Python code, we have no control over the GIL. But a built-in function or an extension written in C—or any language that interfaces at the Python/C API level—can release the GIL while running time-consuming tasks.
    
6. Every Python standard library function that makes a syscall[^5]
    
7. Extensions that integrate at the Python/C API level can also launch other non-Python threads that are not affected by the GIL. Such GIL-free threads generally cannot change Python objects, but they can read from and write to the memory underlying objects that support the [buffer protocol](https://fpy.li/pep3118), such as `bytearray`, `array.array`, and _NumPy_ arrays.
    
8. The effect of the GIL on network programming with Python threads is relatively small, because the I/O functions release the GIL, and reading or writing to the network always implies high latency—compared to reading and writing to memory. Consequently, each individual thread spends a lot of time waiting anyway, so their execution can be interleaved without major impact on the overall throughput. That’s why David Beazley says: “Python threads are great at doing nothing.”[^7]
    
9. Contention over the GIL slows down compute-intensive Python threads. Sequential, single-threaded code is simpler and faster for such tasks.
    
10. To run CPU-intensive Python code on multiple cores, you must use multiple Python processes.
    

Here is a good summary from the `threading` module documentation:[^8]

> **CPython implementation detail**: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multicore machines, you are advised to use `multiprocessing` or `concurrent.futures.ProcessPoolExecutor`. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.

The previous paragraph starts with “CPython implementation detail” because the GIL is not part of the Python language definition. The Jython and IronPython implementations don’t have a GIL. Unfortunately, both are lagging behind—still tracking Python 2.7. The highly performant [PyPy interpreter](https://fpy.li/19-9) also has a GIL in its 2.7 and 3.7 versions—the latest as of June 2021.

###### Note

This section did not mention coroutines, because by default they share the same Python thread among themselves and with the supervising event loop provided by an asynchronous framework, therefore the GIL does not affect them. It is possible to use multiple threads in an asynchronous program, but the best practice is that one thread runs the event loop and all coroutines, while additional threads carry out specific tasks. This will be explained in [“Delegating Tasks to Executors”](ch21.html#delegating_to_executors_sec).

Enough concepts for now. Let’s see some code.
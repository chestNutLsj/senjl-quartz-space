## Traversing a Tree

In this section, we’ll see `yield from` in a script to traverse a tree structure. I will build it in baby steps.

The tree structure for this example is Python’s [exception hierarchy](https://fpy.li/17-14). But the pattern can be adapted to show a directory tree or any other tree structure.

Starting from `BaseException` at level zero, the exception hierarchy is five levels deep as of Python 3.10. Our first baby step is to show level zero.

Given a root class, the `tree` generator in [Example 17-27](#ex_tree_step0) yields its name and stops.

##### Example 17-27. tree/step0/tree.py: yield the name of the root class and stop

```
def
```

The output of [Example 17-27](#ex_tree_step0) is just one line:

BaseException

The next baby step takes us to level 1. The `tree` generator will yield the name of the root class and the names of each direct subclass. The names of the subclasses are indented to reveal the hierarchy. This is the output we want:

$ python3 tree.py
BaseException
    Exception
    GeneratorExit
    SystemExit
    KeyboardInterrupt

[Example 17-28](#ex_tree_step1) produces that output.

##### Example 17-28. tree/step1/tree.py: yield the name of root class and direct subclasses

```
def
```

[![^1]

To support the indented output, yield the name of the class and its level in the hierarchy.

[![^2]

Use the `__subclasses__` special method to get a list of subclasses.

[![^3]

Yield name of subclass and level 1.

[![^4]

Build indentation string of `4` spaces times `level`. At level zero, this will be an empty string.

In [Example 17-29](#ex_tree_step2), I refactor `tree` to separate the special case of the root class from the subclasses, which are now handled in the `sub_tree` generator. At `yield from`, the `tree` generator is suspended, and `sub_tree` takes over yielding values.

##### Example 17-29. tree/step2/tree.py: `tree` yields the root class name, then delegates to `sub_tree`

```
def
```

[![^1]

Delegate to `sub_tree` to yield the names of the subclasses.

[![^2]

Yield the name of each subclass and level 1. Because of the `yield from sub_tree(cls)` inside `tree`, these values bypass the `tree` generator function completely…

[![^3]

… and are received directly here.

In keeping with the baby steps method, I’ll write the simplest code I can imagine to reach level 2. For [depth-first](https://fpy.li/17-15) tree traversal, after yielding each node in level 1, I want to yield the children of that node in level 2, before resuming level 1. A nested `for` loop takes care of that, as in [Example 17-30](#ex_tree_step3).

##### Example 17-30. tree/step3/tree.py: `sub_tree` traverses levels 1 and 2 depth-first

```
def
```

This is the result of running _step3/tree.py_ from [Example 17-30](#ex_tree_step3):

$ python3 tree.py
BaseException
    Exception
        TypeError
        StopAsyncIteration
        StopIteration
        ImportError
        OSError
        EOFError
        RuntimeError
        NameError
        AttributeError
        SyntaxError
        LookupError
        ValueError
        AssertionError
        ArithmeticError
        SystemError
        ReferenceError
        MemoryError
        BufferError
        Warning
    GeneratorExit
    SystemExit
    KeyboardInterrupt

You may already know where this is going, but I will stick to baby steps one more time: let’s reach level 3 by adding yet another nested `for` loop. The rest of the program is unchanged, so [Example 17-31](#ex_tree_step4) shows only the `sub_tree` generator.

##### Example 17-31. `sub_tree` generator from _tree/step4/tree.py_

```
def
```

There is a clear pattern in [Example 17-31](#ex_tree_step4). We do a `for` loop to get the subclasses of level _N_. Each time around the loop, we yield a subclass of level _N_, then start another `for` loop to visit level _N_+1.

In [“Reinventing chain”](#reinventing_chain_sec), we saw how we can replace a nested `for` loop driving a generator with `yield from` on the same generator. We can apply that idea here, if we make `sub_tree` accept a `level` parameter, and `yield from` it recursively, passing the current subclass as the new root class with the next level number. See [Example 17-32](#ex_tree_step5).

##### Example 17-32. tree/step5/tree.py: recursive `sub_tree` goes as far as memory allows

```
def
```

[Example 17-32](#ex_tree_step5) can traverse trees of any depth, limited only by Python’s recursion limit. The default limit allows 1,000 pending functions.

Any good tutorial about recursion will stress the importance of having a base case to avoid infinite recursion. A base case is a conditional branch that returns without making a recursive call. The base case is often implemented with an `if` statement. In [Example 17-32](#ex_tree_step5), `sub_tree` has no `if`, but there is an implicit conditional in the `for` loop: if `cls.__subclasses__()` returns an empty list, the body of the loop is not executed, therefore no recursive call happens. The base case is when the `cls` class has no subclasses. In that case, `sub_tree` yields nothing. It just returns.

[Example 17-32](#ex_tree_step5) works as intended, but we can make it more concise by recalling the pattern we observed when we reached level 3 ([Example 17-31](#ex_tree_step4)): we yield a subclass with level _N_, then start a nested for loop to visit level _N_+1. In [Example 17-32](#ex_tree_step5) we replaced that nested loop with `yield from`. Now we can merge `tree` and `sub_tree` into a single generator. [Example 17-33](#ex_tree_step6) is the last step for this example.

##### Example 17-33. tree/step6/tree.py: recursive calls of `tree` pass an incremented `level` argument

```
def
```

At the start of [“Subgenerators with yield from”](#yield_from_sec0), we saw how `yield from` connects the subgenerator directly to the client code, bypassing the delegating generator. That connection becomes really important when generators are used as coroutines and not only produce but also consume values from the client code, as we’ll see in [“Classic Coroutines”](#classic_coroutines_sec).

After this first encounter with `yield from`, let’s turn to type hinting iterables and iterators.
## Using iter with a Callable

We can call `iter()` with two arguments to create an iterator from a function or any callable object. In this usage, the first argument must be a callable to be invoked repeatedly (with no arguments) to produce values, and the second argument is a [_sentinel_](https://fpy.li/17-2): a marker value which, when returned by the callable, causes the iterator to raise `StopIteration` instead of yielding the sentinel.

The following example shows how to use `iter` to roll a six-sided die until a `1` is rolled:

```
>>> 
```

Note that the `iter` function here returns a `callable_iterator`. The `for` loop in the example may run for a very long time, but it will never display `1`, because that is the sentinel value. As usual with iterators, the `d6_iter` object in the example becomes useless once exhausted. To start over, we must rebuild the iterator by invoking `iter()` again.

The [documentation for `iter`](https://fpy.li/17-3) includes the following explanation and example code:

> One useful application of the second form of `iter()` is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:

```
from
```

For clarity, I’ve added the `read64` assignment, which is not in the [original example](https://fpy.li/17-3). The `partial()` function is necessary because the callable given to `iter()` must not require arguments. In the example, an empty `bytes` object is the sentinel, because that’s what `f.read` returns when there are no more bytes to read.

The next section details the relationship between iterables and iterators.
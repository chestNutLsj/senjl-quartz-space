# Downloads with Progress Display and Error Handling

As mentioned, the scripts in [“Concurrent Web Downloads”](#ex_web_downloads_sec) have no error handling to make them easier to read and to contrast the structure of the three approaches: sequential, threaded, and asynchronous.

In order to test the handling of a variety of error conditions, I created the `flags2` examples:

flags2_common.py

This module contains common functions and settings used by all `flags2` examples, including a `main` function, which takes care of command-line parsing, timing, and reporting results. That is really support code, not directly relevant to the subject of this chapter, so I will not list the source code here, but you can read it in the [_fluentpython/example-code-2e_](https://fpy.li/code) repository: [_20-executors/getflags/flags2_common.py_](https://fpy.li/20-10).

flags2_sequential.py

A sequential HTTP client with proper error handling and progress bar display. Its `download_one` function is also used by `flags2_threadpool.py`.

flags2_threadpool.py

Concurrent HTTP client based on `futures.ThreadPoolExecutor` to demonstrate error handling and integration of the progress bar.

flags2_asyncio.py

Same functionality as the previous example, but implemented with `asyncio` and `httpx`. This will be covered in [“Enhancing the asyncio Downloader”](ch21.html#flags2_asyncio_sec), in [Chapter 21](ch21.html#async_ch).

# Be Careful when Testing Concurrent Clients

When testing concurrent HTTP clients on public web servers, you may generate many requests per second, and that’s how denial-of-service (DoS) attacks are made. Carefully throttle your clients when hitting public servers. For testing, set up a local HTTP server. See [“Setting Up Test Servers”](#setting_up_servers_box) for instructions.

The most visible feature of the `flags2` examples is that they have an animated, text-mode progress bar implemented with the [_tqdm_ package](https://fpy.li/20-11). I posted a [108s video on YouTube](https://fpy.li/20-12) to show the progress bar and contrast the speed of the three `flags2` scripts. In the video, I start with the sequential download, but I interrupt it after 32s because it was going to take more than 5 minutes to hit on 676 URLs and get 194 flags. I then run the threaded and `asyncio` scripts three times each, and every time they complete the job in 6s or less (i.e., more than 60 times faster). [Figure 20-1](#flags2_progress_fig) shows two screenshots: during and after running _flags2_threadpool.py_.

![flags2_threadpool.py running with progress bar](assets/flpy_2001.png)

###### Figure 20-1. Top-left: flags2_threadpool.py running with live progress bar generated by tqdm; bottom-right: same terminal window after the script is finished.

The simplest _tqdm_ example appears in an animated _.gif_ in the project’s [_README.md_](https://fpy.li/20-13). If you type the following code in the Python console after installing the _tqdm_ package, you’ll see an animated progress bar where the comment is:

```
>>> 
```

Besides the neat effect, the `tqdm` function is also interesting conceptually: it consumes any iterable and produces an iterator which, while it’s consumed, displays the progress bar and estimates the remaining time to complete all iterations. To compute that estimate, `tqdm` needs to get an iterable that has a `len`, or additionally receive the `total=` argument with the expected number of items. Integrating `tqdm` with our `flags2` examples provides an opportunity to look deeper into how the concurrent scripts actually work, by forcing us to use the [`futures.as_completed`](https://fpy.li/20-7) and the [`asyncio.as_completed`](https://fpy.li/20-15) functions so that `tqdm` can display progress as each future is completed.

The other feature of the `flags2` example is a command-line interface. All three scripts accept the same options, and you can see them by running any of the scripts with the `-h` option. [Example 20-10](#flags2_help_demo) shows the help text.

##### Example 20-10. Help screen for the scripts in the flags2 series

$ python3 flags2_threadpool.py -h
usage: flags2_threadpool.py [-h] [-a] [-e] [-l N] [-m CONCURRENT] [-s LABEL]
                            [-v]
                            [CC [CC ...]]

Download flags for country codes. Default: top 20 countries by population.

positional arguments:
  CC                    country code or 1st letter (eg. B for BA...BZ)

optional arguments:
  -h, --help            show this help message and exit
  -a, --all             get all available flags (AD to ZW)
  -e, --every           get flags for every possible code (AA...ZZ)
  -l N, --limit N       limit to N first codes
  -m CONCURRENT, --max_req CONCURRENT
                        maximum concurrent requests (default=30)
  -s LABEL, --server LABEL
                        Server to hit; one of DELAY, ERROR, LOCAL, REMOTE
                        (default=LOCAL)
  -v, --verbose         output detailed progress info

All arguments are optional. But the `-s/--server` is essential for testing: it lets you choose which HTTP server and port will be used in the test. Pass one of these case-insensitive labels to determine where the script will look for the flags:

`LOCAL`

Use `http://localhost:8000/flags`; this is the default. You should configure a local HTTP server to answer at port 8000. See the following note for instructions.

`REMOTE`

Use `http://fluentpython.com/data/flags`; that is a public website owned by me, hosted on a shared server. Please do not pound it with too many concurrent requests. The _fluentpython.com_ domain is handled by the [Cloudflare](https://fpy.li/20-16) CDN (Content Delivery Network) so you may notice that the first downloads are slower, but they get faster when the CDN cache warms up.

`DELAY`

Use `http://localhost:8001/flags`; a server delaying HTTP responses should be listening to port 8001. I wrote _slow_server.py_ to make it easier to experiment. You’ll find it in the _20-futures/getflags/_ directory of the [_Fluent Python_ code repository](https://fpy.li/code). See the following note for instructions.

`ERROR`

Use `http://localhost:8002/flags`; a server returning some HTTP errors should be listening on port 8002. Instructions are next.

# Setting Up Test Servers

If you don’t have a local HTTP server for testing, I wrote setup instructions using only Python ≥ 3.9 (no external libraries) in [_20-executors/getflags/README.adoc_](https://fpy.li/20-17) in the [_fluentpython/example-code-2e_](https://fpy.li/code) repository. In short, _README.adoc_ describes how to use:

`python3 -m http.server`

The `LOCAL` server on port 8000

`python3 slow_server.py`

The `DELAY` server on port 8001, which adds a random delay of .5s to 5s before each response

`python3 slow_server.py 8002 --error-rate .25`

The `ERROR` server on port 8002, which in addition to the random delay, has a 25% chance of returning a [“418 I’m a teapot”](https://fpy.li/20-18) error response

By default, each _flags2*.py_ script will fetch the flags of the 20 most populous countries from the `LOCAL` server (`http://localhost:8000/flags`) using a default number of concurrent connections, which varies from script to script. [Example 20-11](#flags2_sequential_run) shows a sample run of the _flags2_sequential.py_ script using all defaults. To run it, you need a local server, as explained in [“Be Careful when Testing Concurrent Clients”](#careful_testing_clients).

##### Example 20-11. Running flags2_sequential.py with all defaults: `LOCAL site`, top 20 flags, 1 concurrent connection

$ python3 flags2_sequential.py
LOCAL site: http://localhost:8000/flags
Searching for 20 flags: from BD to VN
1 concurrent connection will be used.
--------------------
20 flags downloaded.
Elapsed time: 0.10s

You can select which flags will be downloaded in several ways. [Example 20-12](#flags2_threadpool_run) shows how to download all flags with country codes starting with the letters A, B, or C.

##### Example 20-12. Run flags2_threadpool.py to fetch all flags with country codes prefixes A, B, or C from the `DELAY` server

$ python3 flags2_threadpool.py -s DELAY a b c
DELAY site: http://localhost:8001/flags
Searching for 78 flags: from AA to CZ
30 concurrent connections will be used.
--------------------
43 flags downloaded.
35 not found.
Elapsed time: 1.72s

Regardless of how the country codes are selected, the number of flags to fetch can be limited with the `-l/--limit` option. [Example 20-13](#flags2_asyncio_run) demonstrates how to run exactly 100 requests, combining the `-a` option to get all flags with `-l 100`.

##### Example 20-13. Run flags2_asyncio.py to get 100 flags (`-al 100`) from the `ERROR` server, using 100 concurrent requests (`-m 100`)

$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100
ERROR site: http://localhost:8002/flags
Searching for 100 flags: from AD to LK
100 concurrent connections will be used.
--------------------
73 flags downloaded.
27 errors.
Elapsed time: 0.64s

That’s the user interface of the `flags2` examples. Let’s see how they are implemented.
## Guido’s Trick to Read Asynchronous Code

There are a lot of new concepts to grasp in _asyncio_, but the overall logic of [Example 21-1](#blogdom_ex) is easy to follow if you employ a trick suggested by Guido van Rossum himself: squint and pretend the `async` and `await` keywords are not there. If you do that, you’ll realize that coroutines read like plain old sequential functions.

For example, imagine that the body of this coroutine…

```
async
```

…works like the following function, except that it magically never blocks:

```
def
```

Using the syntax `await loop.getaddrinfo(...)` avoids blocking because `await` suspends the current coroutine object. For example, during the execution of the `probe('if.dev')` coroutine, a new coroutine object is created by `getaddrinfo('if.dev', None)`. Awaiting it starts the low-level `addrinfo` query and yields control back to the event loop, not to the `probe(‘if.dev’)` coroutine, which is suspended. The event loop can then drive other pending coroutine objects, such as `probe('or.dev')`.

When the event loop gets a response for the `getaddrinfo('if.dev', None)` query, that specific coroutine object resumes and returns control back to the `probe('if.dev')`—which was suspended at `await`—and can now handle a possible exception and return the result tuple.

So far, we’ve only seen `asyncio.as_completed` and `await` applied to coroutines. But they handle any _awaitable_ object. That concept is explained next.
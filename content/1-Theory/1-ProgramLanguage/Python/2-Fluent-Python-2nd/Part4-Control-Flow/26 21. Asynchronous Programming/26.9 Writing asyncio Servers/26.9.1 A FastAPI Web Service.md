## A FastAPI Web Service

I wrote the next example—_web_mojifinder.py_—using [_FastAPI_](https://fpy.li/21-28): one of the Python ASGI Web frameworks mentioned in [“ASGI—Asynchronous Server Gateway Interface”](ch19.html#asgi_note). [Figure 21-2](#web_mojifinder_result) is a screenshot of the frontend. It’s a super simple SPA (Single Page Application): after the initial HTML download, the UI is updated by client-side JavaScript communicating with the server.

_FastAPI_ is designed to implement backends for SPA and mobile apps, which mostly consist of web API end points returning JSON responses instead of server-rendered HTML. _FastAPI_ leverages decorators, type hints, and code introspection to eliminate a lot of the boilerplate code for web APIs, and also automatically publishes interactive OpenAPI—a.k.a. [Swagger](https://fpy.li/21-29)—documentation for the APIs we create. [Figure 21-4](#web_mojifinder_schema) shows the autogenerated `/docs` page for _web_mojifinder.py_.

![Screenshot of Firefox showing OpenAPI schema for `/search` endpoint](assets/flpy_2104.png)

###### Figure 21-4. Autogenerated OpenAPI schema for the `/search` endpoint.

[Example 21-11](#web_mojifinder_ex) is the code for _web_mojifinder.py_, but that’s just the backend code. When you hit the root URL `/`, the server sends the _form.html_ file, which has 81 lines of code, including 54 lines of JavaScript to communicate with the server and fill a table with the results. If you’re interested in reading plain framework-less JavaScript, please find _21-async/mojifinder/static/form.html_ in the [_Fluent Python_ code repository](https://fpy.li/code).

To run _web_mojifinder.py_, you need to install two packages and their dependencies: _FastAPI_ and _uvicorn_.[^10] with _uvicorn_ in development mode:

$ uvicorn web_mojifinder:app --reload

The parameters are:

`web_mojifinder:app`

The package name, a colon, and the name of the ASGI application defined in it—`app` is the conventional name.

`--reload`

Make _uvicorn_ monitor changes to application source files and automatically reload them. Useful only during development.

Now let’s study the source code for _web_mojifinder.py_.

##### Example 21-11. web_mojifinder.py: complete source

```
from
```

[![^1]

Unrelated to the theme of this chapter, but worth noting: the elegant use of the overloaded `/` operator by `pathlib`.[^11]

[![^2]

This line defines the ASGI app. It could be as simple as `app = FastAPI()`. The parameters shown are metadata for the autogenerated documentation.

[![^3]

A _pydantic_ schema for a JSON response with `char` and `name` fields.[^12]

[![^4]

Build the `index` and load the static HTML form, attaching both to the `app.state` for later use.

[![^5]

Run `init` when this module is loaded by the ASGI server.

[![^6]

Route for the `/search` endpoint; `response_model` uses that `CharName` _pydantic_ model to describe the response format.

[![^7]

_FastAPI_ assumes that any parameters that appear in the function or coroutine signature that are not in the route path will be passed in the HTTP query string, e.g., `/search?q=cat`. Since `q` has no default, _FastAPI_ will return a 422 (Unprocessable Entity) status if `q` is missing from the query string.

[![^8]

Returning an iterable of `dicts` compatible with the `response_model` schema allows _FastAPI_ to build the JSON response according to the `response_model` in the `@app.get` decorator.

[![^9]

Regular functions (i.e., non-async) can also be used to produce responses.

[![^10]

This module has no main function. It is loaded and driven by the ASGI server—_uvicorn_ in this example.

[Example 21-11](#web_mojifinder_ex) has no direct calls to `asyncio`. _FastAPI_ is built on the _Starlette_ ASGI toolkit, which in turn uses `asyncio`.

Also note that the body of `search` doesn’t use `await`, `async with`, or `async for`, therefore it could be a plain function. I defined `search` as a coroutine just to show that _FastAPI_ knows how to handle it. In a real app, most endpoints will query databases or hit other remote servers, so it is a critical advantage of _FastAPI_—and ASGI frameworks in general—to support coroutines that can take advantage of asynchronous libraries for network I/O.

###### Tip

The `init` and `form` functions I wrote to load and serve the static HTML form are a hack to make the example short and easy to run. The recommended best practice is to have a proxy/load-balancer in front of the ASGI server to handle all static assets, and also use a CDN (Content Delivery Network) when possible. One such proxy/load-balancer is [_Traefik_](https://fpy.li/21-32), a self-described “edge router” that “receives requests on behalf of your system and finds out which components are responsible for handling them.” _FastAPI_ has [project generation](https://fpy.li/21-33) scripts that prepare your code to do that.

The typing enthusiast may have noticed that there are no return type hints in `search` and `form`. Instead, _FastAPI_ relies on the `response_model=` keyword argument in the route decorators. The [“Response Model”](https://fpy.li/21-34) page in the _FastAPI_ documentation explains:

> The response model is declared in this parameter instead of as a function return type annotation, because the path function may not actually return that response model but rather return a dict, database object or some other model, and then use the `response_model` to perform the field limiting and serialization.

For example, in `search`, I returned a generator of `dict` items, not a list of `CharName` objects, but that’s good enough for _FastAPI_ and _pydantic_ to validate my data and build the appropriate JSON response compatible with `response_model=list[CharName]`.

We’ll now focus on the _tcp_mojifinder.py_ script that is answering the queries in [Figure 21-5](#tcp_mojifinder_demo).
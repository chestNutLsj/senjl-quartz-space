# A Sequence of Words

We’ll start our exploration of iterables by implementing a `Sentence` class: you give its constructor a string with some text, and then you can iterate word by word. The first version will implement the sequence protocol, and it’s iterable because all sequences are iterable—as we’ve seen since [Chapter 1](ch01.html#data_model). Now we’ll see exactly why.

[Example 17-1](#ex_sentence0) shows a `Sentence` class that extracts words from a text by index.

##### Example 17-1. sentence.py: a `Sentence` as a sequence of words

```
import
```

[![^1]

`.findall` returns a list with all nonoverlapping matches of the regular expression, as a list of strings.

[![^2]

`self.words` holds the result of `.findall`, so we simply return the word at the given index.

[![^3]

To complete the sequence protocol, we implement `__len__` although it is not needed to make an iterable.

[![^4]

`reprlib.repr` is a utility function to generate abbreviated string representations of data structures that can be very large.[^2]

By default, `reprlib.repr` limits the generated string to 30 characters. See the console session in [Example 17-2](#demo_sentence0) to see how `Sentence` is used.

##### Example 17-2. Testing iteration on a `Sentence` instance

```
>>> 
```

[![^1]

A sentence is created from a string.

[![^2]

Note the output of `__repr__` using `...` generated by `reprlib.repr`.

[![^3]

`Sentence` instances are iterable; we’ll see why in a moment.

[![^4]

Being iterable, `Sentence` objects can be used as input to build lists and other iterable types.

In the following pages, we’ll develop other `Sentence` classes that pass the tests in [Example 17-2](#demo_sentence0). However, the implementation in [Example 17-1](#ex_sentence0) is different from the others because it’s also a sequence, so you can get words by index:

```
>>> 
```

Python programmers know that sequences are iterable. Now we’ll see precisely why.
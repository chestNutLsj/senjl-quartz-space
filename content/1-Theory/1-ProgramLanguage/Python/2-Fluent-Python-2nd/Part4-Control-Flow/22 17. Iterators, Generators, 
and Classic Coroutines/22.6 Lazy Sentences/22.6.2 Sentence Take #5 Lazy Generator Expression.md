## Sentence Take #5: Lazy Generator Expression

We can replace simple generator functions like the one in the previous `Sentence` class ([Example 17-8](#ex_sentence3)) with a generator expression. As a list comprehension builds lists, a generator expression builds generator objects. [Example 17-9](#ex_gen_ab_genexp) contrasts their behavior.

##### Example 17-9. The `gen_AB` generator function is used by a list comprehension, then by a generator expression

```
>>> 
```

[![^1]

This is the same `gen_AB` function from [Example 17-7](#ex_gen_ab).

[![^2]

The list comprehension eagerly iterates over the items yielded by the generator object returned by `gen_AB()`: `'A'` and `'B'`. Note the output in the next lines: `start`, `continue`, `end.`

[![^3]

This `for` loop iterates over the `res1` list built by the list comprehension.

[![^4]

The generator expression returns `res2`, a generator object. The generator is not consumed here.

[![^5]

Only when the `for` loop iterates over `res2`, this generator gets items from `gen_AB`. Each iteration of the `for` loop implicitly calls `next(res2)`, which in turn calls `next()` on the generator object returned by `gen_AB()`, advancing it to the next `yield`.

[![^6]

Note how the output of `gen_AB()` interleaves with the output of the `print` in the `for` loop.

We can use a generator expression to further reduce the code in the `Sentence` class. See [Example 17-10](#ex_sentence4).

##### Example 17-10. sentence_genexp.py: `Sentence` implemented using a generator expression

```
import
```

The only difference from [Example 17-8](#ex_sentence3) is the `__iter__` method, which here is not a generator function (it has no `yield`) but uses a generator expression to build a generator and then returns it. The end result is the same: the caller of `__iter__` gets a generator object.

Generator expressions are syntactic sugar: they can always be replaced by generator functions, but sometimes are more convenient. The next section is about generator expression usage.
## Arithmetic Progression with itertools

The `itertools` module in Python 3.10 has 20 generator functions that can be combined in a variety of interesting ways.

For example, the `itertools.count` function returns a generator that yields numbers. Without arguments, it yields a series of integers starting with `0`. But you can provide optional `start` and `step` values to achieve a result similar to our `aritprog_gen` functions:

```
>>> 
```

###### Warning

`itertools.count` never stops, so if you call `list(count())`, Python will try to build a `list` that would fill all the memory chips ever made. In practice, your machine will become very grumpy long before the call fails.

On the other hand, there is the `itertools.takewhile` function: it returns a generator that consumes another generator and stops when a given predicate evaluates to `False`. So we can combine the two and write this:

```
>>> 
```

Leveraging `takewhile` and `count`, [Example 17-14](#ex_almost_aritprog) is even more concise.

##### Example 17-14. aritprog_v3.py: this works like the previous `aritprog_gen` functions

```
import
```

Note that `aritprog_gen` in [Example 17-14](#ex_almost_aritprog) is not a generator function: it has no `yield` in its body. But it returns a generator, just as a generator function does.

However, recall that `itertools.count` adds the `step` repeatedly, so the floating-point series it produces are not as precise as [Example 17-13](#ex_ap_genfunc1).

The point of [Example 17-14](#ex_almost_aritprog) is: when implementing generators, know what is available in the standard library, otherwise there’s a good chance you’ll reinvent the wheel. That’s why the next section covers several ready-to-use generator functions.
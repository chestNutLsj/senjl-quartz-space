# Iterables Versus Iterators

From the explanation in [“Why Sequences Are Iterable: The iter Function”](#iter_func_sec) we can extrapolate a definition:

iterable

Any object from which the `iter` built-in function can obtain an iterator. Objects implementing an `__iter__` method returning an _iterator_ are iterable. Sequences are always iterable, as are objects implementing a `__getitem__` method that accepts 0-based indexes.

It’s important to be clear about the relationship between iterables and iterators: Python obtains iterators from iterables.

Here is a simple `for` loop iterating over a `str`. The `str` `'ABC'` is the iterable here. You don’t see it, but there is an iterator behind the curtain:

```
>>> 
```

If there was no `for` statement and we had to emulate the `for` machinery by hand with a `while` loop, this is what we’d have to write:

```
>>> 
```

[![^1]

Build an iterator `it` from the iterable.

[![^2]

Repeatedly call `next` on the iterator to obtain the next item.

[![^3]

The iterator raises `StopIteration` when there are no further items.

[![^4]

Release reference to `it`—the iterator object is discarded.

[![^5]

Exit the loop.

`StopIteration` signals that the iterator is exhausted. This exception is handled internally by the `iter()` built-in that is part of the logic of `for` loops and other iteration contexts like list comprehensions, iterable unpacking, etc.

Python’s standard interface for an iterator has two methods:

`__next__`

Returns the next item in the series, raising `StopIteration` if there are no more.

`__iter__`

Returns `self`; this allows iterators to be used where an iterable is expected, for example, in a `for` loop.

That interface is formalized in the `collections.abc.Iterator` ABC, which declares the `__next__` abstract method, and subclasses `Iterable`—where the abstract `__iter__` method is declared. See [Figure 17-1](#iterable_fig).

![Iterable UML diagram](assets/flpy_1701.png)

###### Figure 17-1. The `Iterable` and `Iterator` ABCs. Methods in italic are abstract. A concrete `Iterable.__iter__` should return a new `Iterator` instance. A concrete `Iterator` must implement `__next__`. The `Iterator.__iter__` method just returns the instance itself.

The source code for `collections.abc.Iterator` is in [Example 17-3](#abc_iterator_src).

##### Example 17-3. `abc.Iterator` class; extracted from [_Lib/_collections_abc.py_](https://fpy.li/17-5)

```
class
```

[![^1]

`__subclasshook__` supports structural type checks with `isinstance` and `issubclass`. We saw it in [“Structural Typing with ABCs”](ch13.html#subclasshook_sec).

[![^2]

`_check_methods` traverses the `__mro__` of the class to check whether the methods are implemented in its base classes. It’s defined in that same _Lib/_collections_abc.py_ module. If the methods are implemented, the `C` class will be recognized as a virtual subclass of `Iterator`. In other words, `issubclass(C, Iterable)` will return `True`.

###### Warning

The `Iterator` ABC abstract method is `it.__next__()` in Python 3 and `it.next()` in Python 2. As usual, you should avoid calling special methods directly. Just use the `next(it)`: this built-in function does the right thing in Python 2 and 3—which is useful for those migrating codebases from 2 to 3.

The [_Lib/types.py_](https://fpy.li/17-6) module source code in Python 3.9 has a comment that says:

# Iterators in Python aren't a matter of type but of protocol.  A large
# and changing number of builtin types implement *some* flavor of
# iterator.  Don't check the type!  Use hasattr to check for both
# "__iter__" and "__next__" attributes instead.

In fact, that’s exactly what the `__subclasshook__` method of the `abc.Iterator` ABC does.

###### Tip

Given the advice from _Lib/types.py_ and the logic implemented in _Lib/_collections_abc.py_, the best way to check if an object `x` is an iterator is to call `isinstance(x, abc.Iterator)`. Thanks to `Iterator.__subclasshook__`, this test works even if the class of `x` is not a real or virtual subclass of `Iterator`.

Back to our `Sentence` class from [Example 17-1](#ex_sentence0), you can clearly see how the iterator is built by `iter()` and consumed by `next()` using the Python console:

```
>>> 
```

[![^1]

Create a sentence `s3` with three words.

[![^2]

Obtain an iterator from `s3`.

[![^3]

`next(it)` fetches the next word.

[![^4]

There are no more words, so the iterator raises a `StopIteration` exception.

[![^5]

Once exhausted, an iterator will always raise `StopIteration`, which makes it look like it’s empty.

[![^6]

To go over the sentence again, a new iterator must be built.

Because the only methods required of an iterator are `__next__` and `__iter__`, there is no way to check whether there are remaining items, other than to call `next()` and catch `StopIteration`. Also, it’s not possible to “reset” an iterator. If you need to start over, you need to call `iter()` on the iterable that built the iterator in the first place. Calling `iter()` on the iterator itself won’t help either, because—as mentioned—`Iterator.__iter__` is implemented by returning `self`, so this will not reset a depleted iterator.

That minimal interface is sensible, because in reality not all iterators are resettable. For example, if an iterator is reading packets from the network, there’s no way to rewind it.[^3]

The first version of `Sentence` from [Example 17-1](#ex_sentence0) was iterable thanks to the special treatment the `iter()` built-in gives to sequences. Next, we will implement `Sentence` variations that implement `__iter__` to return iterators.
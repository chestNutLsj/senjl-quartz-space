# When to Use Generator Expressions

I used several generator expressions when implementing the `Vector` class in [Example 12-16](ch12.html#ex_vector_v5). Each of these methods has a generator expression: `__eq__`, `__hash__`, `__abs__`, `angle`, `angles`, `format`, `__add__`, and `__mul__`. In all those methods, a list comprehension would also work, at the cost of using more memory to store the intermediate list values.

In [Example 17-10](#ex_sentence4), we saw that a generator expression is a syntactic shortcut to create a generator without defining and calling a function. On the other hand, generator functions are more flexible: we can code complex logic with multiple statements, and we can even use them as _coroutines_, as we’ll see in [“Classic Coroutines”](#classic_coroutines_sec).

For the simpler cases, a generator expression is easier to read at a glance, as the `Vector` example shows.

My rule of thumb in choosing the syntax to use is simple: if the generator expression spans more than a couple of lines, I prefer to code a generator function for the sake of readability.

# Syntax Tip

When a generator expression is passed as the single argument to a function or constructor, you don’t need to write a set of parentheses for the function call and another to enclose the generator expression. A single pair will do, like in the `Vector` call from the `__mul__` method in [Example 12-16](ch12.html#ex_vector_v5), reproduced here:

```
def
```

However, if there are more function arguments after the generator expression, you need to enclose it in parentheses to avoid a `SyntaxError`.

The `Sentence` examples we’ve seen demonstrate generators playing the role of the classic Iterator pattern: retrieving items from a collection. But we can also use generators to yield values independent of a data source. The next section shows an example.

But first, a short discussion on the overlapping concepts of _iterator_ and _generator_.

##### Contrasting Iterators and Generators

In the official Python documentation and codebase, the terminology around iterators and generators is inconsistent and evolving. I’ve adopted the following definitions:

iterator

General term for any object that implements a `__next__` method. Iterators are designed to produce data that is consumed by the client code, i.e., the code that drives the iterator via a `for` loop or other iterative feature, or by explicitly calling `next(it)` on the iterator—although this explicit usage is much less common. In practice, most iterators we use in Python are _generators_.

generator

An iterator built by the Python compiler. To create a generator, we don’t implement `__next__`. Instead, we use the `yield` keyword to make a _generator function_, which is a factory of _generator objects_. A _generator expression_ is another way to build a generator object. Generator objects provide `__next__`, so they are iterators. Since Python 3.5, we also have _asynchronous generators_ declared with `async def`. We’ll study them in [Chapter 21, “Asynchronous Programming”](ch21.html#async_ch).

The [_Python Glossary_](https://fpy.li/17-8) recently introduced the term [_generator iterator_](https://fpy.li/17-9) to refer to generator objects built by generator functions, while the entry for [_generator expression_](https://fpy.li/17-10) says it returns an “iterator.”

But the objects returned in both cases are generator objects, according to Python:

```
>>> 
```
## Returning a Value from a Coroutine

We’ll now study another coroutine to compute an average. This version will not yield partial results. Instead, it returns a tuple with the number of terms and the average. I’ve split the listing in two parts: [Example 17-40](#ex_returning_averager_top) and [Example 17-41](#ex_returning_averager_coro).

##### Example 17-40. coroaverager2.py: top of the file

```
from
```

[![^1]

The `averager2` coroutine in [Example 17-41](#ex_returning_averager_coro) will return an instance of `Result`.

[![^2]

The `Result` is actually a subclass of `tuple`, which has a `.count()` method that I don’t need. The `# type: ignore` comment prevents Mypy from complaining about having a `count` field.[^15]

[![^3]

A class to make a sentinel value with a readable `__repr__`.

[![^4]

The sentinel value that I’ll use to make the coroutine stop collecting data and return a result.

[![^5]

I’ll use this type alias for the second type parameter of the coroutine `Generator` return type, the `SendType` parameter.

The `SendType` definition also works in Python 3.10, but if you don’t need to support earlier versions, it is better to write it like this, after importing `TypeAlias` from `typing`:

```
SendType
```

Using `|` instead of `typing.Union` is so concise and readable that I’d probably not create that type alias, but instead I’d write the signature of `averager2` like this:

```
def
```

Now, let’s study the coroutine code itself ([Example 17-41](#ex_returning_averager_coro)).

##### Example 17-41. coroaverager2.py: a coroutine that returns a result value

```
def
```

[![^1]

For this coroutine, the yield type is `None` because it does not yield data. It receives data of the `SendType` and returns a `Result` tuple when done.

[![^2]

Using `yield` like this only makes sense in coroutines, which are designed to consume data. This yields `None`, but receives a `term` from `.send(term)`.

[![^3]

If the `term` is a `Sentinel`, break from the loop. Thanks to this `isinstance` check…

[![^4]

…Mypy allows me to add `term` to the `total` without flagging an error that I can’t add a `float` to an object that may be a `float` or a `Sentinel`.

[![^5]

This line will be reached only if a `Sentinel` is sent to the coroutine.

Now let’s see how we can use this coroutine, starting with a simple example that doesn’t actually produce a result ([Example 17-42](#ex_coro_averager2_demo_1)).

##### Example 17-42. coroaverager2.py: doctest showing `.cancel()`

```
    
```

[![^1]

Recall that `averager2` does not yield partial results. It yields `None`, which Python’s console omits.

[![^2]

Calling `.close()` in this coroutine makes it stop but does not return a result, because the `GeneratorExit` exception is raised at the `yield` line in the coroutine, so the `return` statement is never reached.

Now let’s make it work in [Example 17-43](#ex_coro_averager2_demo_2).

##### Example 17-43. coroaverager2.py: doctest showing `StopIteration` with a `Result`

```
    
```

[![^1]

Sending the `STOP` sentinel makes the coroutine break from the loop and return a `Result`. The generator object that wraps the coroutine then raises `StopIteration`.

[![^2]

The `StopIteration` instance has a `value` attribute bound to the value of the `return` statement that terminated the coroutine.

[![^3]

Believe it or not!

This idea of “smuggling” the return value out of the coroutine wrapped in a `StopIteration` exception is a bizarre hack. Nevertheless, this bizarre hack is part of [PEP 342—Coroutines via Enhanced Generators](https://fpy.li/pep342), and is documented with the [`StopIteration` exception](https://fpy.li/17-22), and in the [“Yield expressions”](https://fpy.li/17-23) section of Chapter 6 of [_The Python Language Reference_](https://fpy.li/17-24).

A delegating generator can get the return value of a coroutine directly using the `yield from` syntax, as shown in [Example 17-44](#ex_coro_averager2_demo_3).

##### Example 17-44. coroaverager2.py: doctest showing `StopIteration` with a `Result`

```
    
```

[![^1]

`res` will collect the return value of `averager2`; the `yield from` machinery retrieves the return value when it handles the `StopIteration` exception that marks the termination of the coroutine. When `True`, the `verbose` parameter makes the coroutine print the value received, to make its operation visible.

[![^2]

Keep an eye out for the output of this line when this generator runs.

[![^3]

Return the result. This will also be wrapped in `StopIteration`.

[![^4]

Create the delegating coroutine object.

[![^5]

This loop will drive the delegating coroutine.

[![^6]

First value sent is `None`, to prime the coroutine; last is the sentinel to stop it.

[![^7]

Catch `StopIteration` to fetch the return value of `compute`.

[![^8]

After the lines output by `averager2` and `compute`, we get the `Result` instance.

Even though the examples here don’t do much, the code is hard to follow. Driving the coroutine with `.send()` calls and retrieving results is complicated, except with `yield from`—but we can only use that syntax inside a delegating generator/coroutine, which must ultimately be driven by some nontrivial code, as shown in [Example 17-44](#ex_coro_averager2_demo_3).

The previous examples show that using coroutines directly is cumbersome and confusing. Add exception handling and the coroutine `.throw()` method, and examples become even more convoluted. I won’t cover `.throw()` in this book because—like `.send()`—it is only useful to drive coroutines “by hand,” but I don’t recommend doing that, unless you are creating a new coroutine-based framework from scratch.

###### Note

If you are interested in deeper coverage of classic coroutines—including the `.throw()` method—please check out [“Classic Coroutines”](https://fpy.li/oldcoro) at the [_fluentpython.com_](http://fluentpython.com) companion website. That post includes Python-like pseudocode detailing how `yield from` drives generators and coroutines, as well as a a small discrete event simulation demonstrating a form of concurrency using coroutines without an asynchronous programming framework.

In practice, productive work with coroutines requires the support of a specialized framework. That is what `asyncio` provided for classic coroutines way back in Python 3.3. With the advent of native coroutines in Python 3.5, the Python core developers are gradually phasing out support for classic coroutines in `asyncio`. But the underlying mechanisms are very similar. The `async def` syntax makes native coroutines easier to spot in code, which is a great benefit. Inside, native coroutines use `await` instead of `yield from` to delegate to other coroutines. [Chapter 21](ch21.html#async_ch) is all about that.

Now let’s wrap up the chapter with a mind-bending section about covariance and contravariance in type hints for coroutines.
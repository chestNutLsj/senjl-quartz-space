# Classic Coroutines

###### Note

[PEP 342—Coroutines via Enhanced Generators](https://fpy.li/pep342) introduced the `.send()` and other features that made it possible to use generators as coroutines. PEP 342 uses the word “coroutine” with the same meaning I am using here.

It is unfortunate that Python’s official documentation and standard library now use inconsistent terminology to refer to generators used as coroutines, forcing me to adopt the “classic coroutine” qualifier to contrast with the newer “native coroutine” objects.

After Python 3.5 came out, the trend is to use “coroutine” as a synonym for “native coroutine.” But PEP 342 is not deprecated, and classic coroutines still work as originally designed, although they are no longer supported by `asyncio`.

Understanding classic coroutines in Python is confusing because they are actually generators used in a different way. So let’s step back and consider another feature of Python that can be used in two ways.

We saw in [“Tuples Are Not Just Immutable Lists”](ch02.html#tuples_more_than_lists_sec) that we can use `tuple` instances as records or as immutable sequences. When used as a record, a tuple is expected to have a specific number of items, and each item may have a different type. When used as immutable lists, a tuple can have any length, and all items are expected to have the same type. That’s why there are two different ways to annotate tuples with type hints:

```
# A city record with name, country, and population:
```

Something similar happens with generators. They are commonly used as iterators, but they can also be used as coroutines. A _coroutine_ is really a generator function, created with the `yield` keyword in its body. And a _coroutine object_ is physically a generator object. Despite sharing the same underlying implementation in C, the use cases of generators and coroutines in Python are so different that there are two ways to type hint them:

```
# The `readings` variable can be bound to an iterator
```

Adding to the confusion, the `typing` module authors decided to name that type `Generator`, when in fact it describes the API of a generator object intended to be used as a coroutine, while generators are more often used as simple iterators.

The [`typing` documentation](https://fpy.li/17-17) describes the formal type parameters of `Generator` like this:

```
Generator
```

The `SendType` is only relevant when the generator is used as a coroutine. That type parameter is the type of `x` in the call `gen.send(x)`. It is an error to call `.send()` on a generator that was coded to behave as an iterator instead of a coroutine. Likewise, `ReturnType` is only meaningful to annotate a coroutine, because iterators don’t return values like regular functions. The only sensible operation on a generator used as an iterator is to call `next(it)` directly or indirectly via `for` loops and other forms of iteration. The `YieldType` is the type of the value returned by a call to `next(it)`.

The `Generator` type has the same type parameters as [`typing.Coroutine`](https://fpy.li/typecoro):

```
Coroutine
```

The [`typing.Coroutine` documentation](https://fpy.li/typecoro) actually says: “The variance and order of type variables correspond to those of `Generator`.” But `typing.Coroutine` (deprecated) and `collections.abc.Coroutine` (generic since Python 3.9) are intended to annotate only native coroutines, not classic coroutines. If you want to use type hints with classic coroutines, you’ll suffer through the confusion of annotating them as `Generator[YieldType, SendType, ReturnType]`.

David Beazley created some of the best talks and most comprehensive workshops about classic coroutines. In his [PyCon 2009 course handout](https://fpy.li/17-18), he has a slide titled “Keeping It Straight,” which reads:

> - Generators produce data for iteration
>     
> - Coroutines are consumers of data
>     
> - To keep your brain from exploding, don’t mix the two concepts together
>     
> - Coroutines are not related to iteration
>     
> - Note: There is a use of having `yield` produce a value in a coroutine, but it’s not tied to iteration.[^12]
>     

Now let’s see how classic coroutines work.

**目录**
------

1.  [[Linux汇编开发指南#**一、简介**]]
2.  **Linux 语法格式**
3.  **Hello World！**
4.  **Linux 汇编工具**
5.  **系统调用**
6.  **命令行参数**
7.  **GCC 内联汇编**
8.  **小结**

## 一 、简介
--------

作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却毋庸置疑，因为它能够完成许多其他语言无法完成的功能。就拿 _Linux_ 内核来讲，虽然绝大部分代码是用 _C_ 语言编写的，但仍然不可避免的在某些地方使用了汇编代码，其中主要是在 _Linux_ 的启动部分。由于这部分代码与硬件的关系十分密切，即使是使用 _C_ 语言也会显得力不从心，因而只有汇编语言才能胜任这部分工作，最大限度的发挥出硬件的性能。

大多数情况下 Linux 程序员并不需要使用汇编语言，因为即使是硬件驱动这样的底层程序在 _Linux_ 操作系统中也可以完全用 _C_ 语言来实现，再加上 _GCC_ 这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化。但现实情况是 _Linux_ 程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和 _libc_ 无关性。假如要移植 _Linux_ 到某一特定的嵌入式硬件环境中，首先必然要考虑如何减小系统的大小、提高执行效率等问题，此时不可避免的就会涉及到汇编语言程序设计。

汇编语言直接同计算机的底层硬件进行交互，优点如下：

*   能够直接访问与硬件相关的存储器或 _I/O_ 端口；
*   能够不受编译器的限制，对生成的二进制代码进行完全的控制；
*   能够对关键代码进行更准确的控制，避免应线程共同访问或者硬件设备共享引起的死锁；
*   能够根据特定的应用对代码做最佳的优化，提高运行速度，最大限度发挥硬件的性能。

同时，因为汇编语言是一种非常低级的编程语言，抽象程度仅仅高于二进制的机器码，故不可避免地存在一些缺点：

*   编写的代码不易阅读，不易维护；
*   很容易产生 _Bug，_调试困难；
*   只能针对特定的体系结构和处理器进行优化；
*   开发效率极低，需要很大的耐心。

_Linux_ 下用汇编语言进行编程主要有两种方式，一种是纯汇编编程，还有一种是 _C_ 语言和汇编混合编程。

*   纯汇编程序完全用汇编语言编写，但是 _Linux_ 平台下的汇编工具为了方便也吸收了 _C_ 语言的长处，使得程序员可以使用 _#include_、_#ifdef_ 等预处理指令，并能够通过宏定义来简化代码;
*   _C_ 语言程序中还可以嵌入汇编代码片段，虽然 _ANSI_ 的 _C_ 语言标准中没有关于内联汇编代码的相应规定，但各种实际使用的 C 编译器都做了这方面的扩充，这其中就包括 _GCC_。

## 二 、Linux 汇编语法格式
------------------

_DOS/Windows_ 下的汇编语言代码都是 _Intel_ 风格的，而 _Linux_ 和 _Unix_ 系统中更多采用的是 _AT&T_ 格式，两者在语法格式上主要差异如下：

1.  在 _AT&T_ 汇编格式中，寄存器名要加上 "%" 号作为前缀；而在 _Intel_ 汇编格式中则不需要。

```
AT&T 格式           pushl %eax 

Intel格式           push eax
```

2. 在 _AT&T_ 汇编格式中，用 '$' 前缀表示一个立即数；_Intel_ 格式不用带任何前缀。

```
AT&T 格式           pushl $1

Intel格式           push 1
```

3. _AT&T_ 和 _Intel_ 格式中的源操作数和目标操作数的位置正好相反，在 _AT&T_ 汇编格式中源操作数在目标操作数的左边。

```
AT&T 格式           addl $1,%eax

Intel格式           add eax,1
```

4. 在 _AT&T_ 汇编中，操作数的字长由操作符的最后一个字母决定，后缀 '_b_'、'_w_'、'_l_'分别表示操作数为字节（_byte, 8 bits_）、字（_word, 16 bits_）和长字（_long, 32 bits_）；而在 _Intel_ 汇编格式中，操作数的字长是用 "_byte ptr_"和"_word ptr_" 等前缀来表示的。

```
AT&T 格式           movb val,%al

Intel格式           mov al,byte ptr val
```

5. 在 _AT&T_ 汇编格式中，绝对转移指令和调用指令（_jump/call_） 的操作数前要加上 '*' 作为前缀，_Intel_ 格式中不需要。

6. 远转移指令和远程调用指令的操作符，在 _AT&T_ 格式中分别为 "_ljump_"和"_lcall_"，而在 _Intel_ 格式中分别为 "_jump far_"和"_call far_"。

```
远转移指令                  远程调用指令
AT&T 格式           ljump $section,$offset     lcall $section,$offset

Intel格式           jump far section:offset    call far section:offset
```

与之对应的远程返回指令为：

```
AT&T 格式           lret $stack_adjust

Intel格式           ret far stack_adjust
```

7. 在 _AT&T_ 汇编格式中，内存操作数的寻址方式是：

```
section:disp(base, index, scale)
```

在 _Intel_ 汇编格式中，内存操作数的寻址方式为：

```
section:[base + index*scale + disp]
```

由于 _Linux_ 工作在保护模式下，用的是 32 位线性地址，所以在计算地址是不用考虑段基址和偏移量，而是采用如下的地址计算方法：

```
disp + base + index*scale
```

例子如下：

```
AT&T 格式                      Intel格式
movl -4(%ebp),%eax             mov eax,[ebp-4]
movl array(,%eax,4),%eax       mov eax,[eax*4 + array]
movw array(%ebx,%eax,4),%cx    mov cx,[ebx + 4*eax + array]
movb $4,%fs:(%eax)             mov fs:eax,4
```

## 三、 使用汇编语言在屏幕上打印 Hello World
-------------------------------

在 _Linux_ 系统中有很多办法可以实现在屏幕上显示字符串，但最简洁的办法是使用 _Linux_ 内核提供的系统调用。使用这种方法的好处是可以直接和操作系统的内核进行通讯，不需要链接诸如 _libc_ 这样的函数库，也不需要使用 _ELF_ 解释器，因而代码体积下且执行速度快。

_Linux_ 是一个运行在保护模式下的 _32_ 位操作系统（当然现在大部分 _Linux_ 都是 _64_ 位的），采用 _flat_ _memory_ 模式，目前最长用到的是 _ELF_ 格式的二进制代码。一个 _ELF_ 格式的可执行程序通常划分为如下几个部分：._text_ 、._data_ 和 ._bss_，其中 ._text_ 是只读的代码区，._data_ 是可读可写的数据区，而 ._bss_ 则是可读可写且没有初始化的数据区。代码区和数据区在 _ELF_ 中统称为 _section_ ，但一个 _ELF_ 可执行程序至少应该有一个 ._text_ 部分。下面我们给出第一个汇编程序，用的是 _AT&T_ 格式：

```
# AT&T 格式
# Hello.s
.data    # 数据段声明
         msg : .string "Hello World!\\n"       # 要输出的字符串
         len = . - msg                         # 字符串长度
.text                   # 代码段声明
.global _start          # 指定入口函数

_start:                 # 在屏幕上显示一个字符串
       movl $len, %edx  # 参数三：字符串长度
       movl $msg, %ecx  # 参数二：要显示的字符串
       movl $1, %ebx    # 参数一：文件描述符（stdout）
       movl $4, %eax    # 系统调用号（sys_write）
       int  $0x80       # 调用内核功能
                        # 退出程序
       movl $0, %ebx    # 参数一：退出代码
       movl $1, %eax    # 系统调用号（sys_exit）
       int  $0x80       # 调用内核功能
```

初次接触到 _AT&T_ 格式的汇编代码时，很多程序员都认为太晦涩了，不过好消息是 _Linux_ 平台上同样可以使用 _Intel_ 格式来编写汇编程序：

```
; Intel 格式
; Hello.asm
section .data           ; 数据段声明
          msg db "Hello World!",0xA   ; 要输出的字符串
          len equ $ -msg              ; 字符串长度
section .text                         ; 代码段声明
global _start                         ; 指定入口函数
_start:                               ; 在屏幕上显示一个字符串
          mov edx, len                ; 参数三：字符串长度
          mov ecx, msg                ; 参数二：要显示的字符串
          mov ebx, 1                  ; 参数一：文件描述符（stdout）
          mov eax, 4                  ; 系统调用号（sys_write）
          int 0x80                    ; 调用内核功能
                                      ; 退出程序
          mov ebx, 0                  ; 参数一：退出代码
          mov eax, 1                  ; 系统调用号（sys_exit）
          int 0x80                    ; 调用内核功能
```

上面两个汇编程序语法虽然不同，但都是通过调用 _Linux_ 内核提供的 _sys_write_ 来显示一个字符串，然后再调用 _sys_exit_ 退出程序。在 _Linux_ 内核源文件 _include/asm-i386/unistd.h_ 中可以找到所有系统调用的定义。

## 四 、Linux 汇编工具
----------------

_Linux_ 平台下的汇编工具种类虽然很多，但同 _DOS/Windows_ 一样，最基本的人仍然是汇编器、链接器和调试器。

1.  **汇编器**

汇编器（_assembler_）的作用是将汇编语言源程序转换成二进制形式的目标代码。_Linux_ 平台的标准汇编器是 _GAS_ ，它是 _GCC_ 所依赖的后台汇编工具，通常包含在 _binutils_ 软件包中。_GAS_ 使用标准的 _AT&T_ 汇编语法，可以用来汇编 _AT&T_ 格式的源代码：

```
$ as -o hello.o hello.s
```

_Linux_ 平台上另一个经常用到的汇编器是 _NASM_ ，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括 _bin_、_a.out_、_coff_、_elf_、_rdf_ 等。_NASM_ 采用的是人工编写的语法分析器，因而执行速度要比 _GAS_ 快很多，更重要的是它使用的是 _Intel_ 的汇编格式：

```
$ nasm -f elf hello.asm
```

**2. 链接器**

汇编器所产生的目标代码是不能够直接在计算机上运行的，它必须经过链接器的处理才能生成可执行文件。链接器通常用来将多个目标代码连接成一个可执行文件，这样可以先将程序分为几个单独的模块来开发，然后将它们组合成一个完整的程序。_Linux_ 使用 _ld_ 作为标准的链接程序，它同样也包含在 _binutils_ 软件包中。汇编源代码在成功通过 _GAS_ 或 _NASM_ 生成目标代码后，就可以使用 _ld_ 将其链接成可执行文件了：

```
$ ld -s -o hello hello.o
```

**3. 调试器**

_“程序不是编出来而是调出来的。”_

_Linux_ 下调试汇编程序既可以用 _GDB_、_DDD_ 这类通用的调试器，也可以使用专门用来调试汇编代码的 _ALD_(Assembly Language Debugger)。

从调试的角度看，使用 _GAS_ 的好处是可以在生成的目标代码中包含符号表（symbol table），这样就可以使用 _GDB_ 和 _DDD_ 来进行源码级的调试了。要在生成的可执行程序中包含符号表，可以采用下面的方式进行编译和链接：

```
$ as --gstabs -o hello.o hello.s
$ ld -o hello hello.o
```

执行 _as_ 命令时带上参数 _--gstabs_ 可以告诉汇编器在生成的目标代码中加上符号表，同时需要注意的是，在用 _ld_ 命令进行链接时不要加上 _-s_ 参数，否则目标代码中的符号表将在链接时被删除。

在 _GDB_ 和 _DDD_ 中调试汇编代码跟调试 _C_ 语言代码一样，你可以通过设置断点来中断程序的运行，查看变量和寄存器的当前值，并可以对代码进行单步跟踪。下图是在 _DDD_ 中调试汇编代码：

![](https://pic2.zhimg.com/v2-7b58f04dc6d9b727e3a04d17686eac61_b.jpg)

汇编程序员通常面对的都是一些比较苛刻的软硬件环境，短小精悍的 _ALD_ 可能更符合实际的需求，下面介绍以下如何用 _ALD_ 来调试汇编程序。首先在终端中执行 _ald_ 命令启动调试器，该命令的参数是将要被调试的可执行程序：

```
$ ald hello
Assembly Language Debugger 0.1.3
Copyright (C) 2000-2002 Patrick Alken
hello: ELF Intel 80386 (32 bit), LSB, Executable, Version 1 (current
Loading debugging symbols...(15 symbols loaded)
ald>
```

当 _ALD_ 的提示符出现之后，用 _disassemble_ 命令对代码段进行反汇编：

```
ald> disassemble -s .text
Disassembling section .text (0x08048074 - 0x08048096)
08048074  BA0F000000                 mov edx, 0xf
08048079  B998900408                 mov ecx, 0x8049098
0804807E  BB01000000                 mov ebx, 0x1
08048083  B804000000                 mov eax, 0x4
08048088  CD80                       int 0x80
0804808A  BB00000000                 mov ebx, 0x0
0804808F  B801000000                 mov eax, 0x1
08048094  CD80                       int 0x80
```

上述输出信息的第一列是指令对应的地址码，利用它可以设置在程序执行时的断点：

```
ald> break 0x08048088
Breakpoint 1 set for 0x08048088
```

断点设置好后，使用 _run_ 命令开始执行程序。_ALD_ 在遇到断点时将自动暂停程序的运行，同时会显示所有寄存器的当前值：

```
ald> run
Starting program: hello
Breakpoint 1 encountered at 0x08048088
eax = 0x00000004 ebx = 0x00000001 ecx = 0x08049098 edx = 0x0000000F
esp = 0xBFFFF6C0 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds  = 0x0000002B es  = 0x0000002B fs  = 0x00000000 gs  = 0x00000000
ss  = 0x0000002B cs  = 0x00000023 eip = 0x08048088 eflags = 0x00000246
Flags: PF ZF IF
08048088  CD80                       int 0x80
```

如果需要对汇编代码进行单步调试，可以使用 _next_ 命令：

```
ald> next
Hello, world!
eax = 0x0000000F ebx = 0x00000000 ecx = 0x08049098 edx = 0x0000000F
esp = 0xBFFFF6C0 ebp = 0x00000000 esi = 0x00000000 edi = 0x00000000
ds  = 0x0000002B es  = 0x0000002B fs  = 0x00000000 gs  = 0x00000000
ss  = 0x0000002B cs  = 0x00000023 eip = 0x0804808F eflags = 0x00000346
Flags: PF ZF TF IF
0804808F  B801000000                 mov eax, 0x1
```

若想获得 _ALD_ 支持的所有调试命令的详细列表，可以使用 _help_ 命令：

```
ald> help
Commands may be abbreviated.
If a blank command is entered, the last command is repeated.
Type `help <command>' for more specific information on <command>.
General commands
attach         clear          continue       detach         disassemble
enter          examine        file           help           load
next           quit           register       run            set
step           unload         window         write
Breakpoint related commands
break          delete         disable        enable         ignore
lbreak         tbreak
```

## 五 、系统调用
----------

即便是最简单的汇编程序，也难免要用到诸如输入、输出以及退出等操作，而要进行这些操作则需要调用操作系统所提供的服务，也就是系统调用。除非你的程序只完成加减乘除等数学运算，否则将很难避免使用系统调用，事实上除了系统调用不同之外，各种操作系统的汇编编程往往都是很类似的。

在 _Linux_ 平台下有两种方式来使用系统调用：利用封装后的 _C_ 库（_libc_）或者通过汇编直接调用。其中通过汇编语言来直接调用系统调用，是最高效地使用 _Linux_ 内核服务的方法，因为最终生成的程序不需要与任何库进行链接，而是直接和内核通信。

和 _DOS_ 一样，_Linux_ 下的系统调用也是通过中断（_int 0x80_）来实现的。在执行 _int 80_ 指令时，寄存器 _eax_ 中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器 _ebx，ecx，edx，esi，edi_ 中，当系统调用完成之后，返回值可以在寄存器 _eax_ 中获得。

所有的系统调用功能号都可以在文件 _/usr/include/bits/syscall.h_ 中找到，为了便于使用，它们是用 _SYS_\<name\>_ 这样的宏来定义的，如 _SYS_write、SYS_exit_ 等。例如，经常用到的 _write_ 函数是如下定义的：

```
ssize_t write(int fd, const void *buf, size_t count);
```

该函数的功能最终是通过 _SYS_write_ 这一系统调用来实现的。根据上面的约定，参数 _fb、buf_ 和 _count_ 分别存在寄存器 _ebx、ecx_ 和 _edx_ 中，而系统调用号 _SYS_write_ 则放在寄存器 _eax_ 中，当 _int 0x80_ 指令执行完毕后，返回值可以从寄存器 _eax_ 中获得。

或许你已经发现，在进行系统调用时至多只有 _5_ 个寄存器能够用来保存参数，难道所有系统调用的参数个数都不超过 _5_ 吗？当然不是，例如 _mmap_ 函数就有 _6_ 个参数，这些参数最后都需要传递给系统调用 _SYS_mmap_：

```
void*  mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
```

当一个系统调用所需的参数个数大于 _5_ 时，执行_int 0x80_ 指令时仍需将系统调用功能号保存在寄存器 _eax_ 中，所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器 _ebx_ 中保存指向该内存区域的指针。系统调用完成之后，返回值仍将保存在寄存器 _eax_ 中。

由于只是需要一块连续的内存区域来保存系统调用的参数，因此完全可以像普通的函数调用一样使用栈 (stack) 来传递系统调用所需的参数。但要注意一点，_Linux_ 采用的是 _C_ 语言的调用模式，这就意味着所有参数必须以相反的顺序进栈，即最后一个参数先入栈，而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数，在执行_int 0x80_ 指令时还应该将栈指针的当前值复制到寄存器 _ebx_中。

## 六 、命令行参数
-----------

在 Linux 操作系统中，当一个可执行程序通过命令行启动时，其所需的参数将被保存到栈中：首先是 argc，然后是指向各个命令行参数的指针数组 argv，最后是指向环境变量的指针数据 envp。在编写汇编语言程序时，很多时候需要对这些参数进行处理，下面的代码示范了如何在汇编代码中进行命令行参数的处理：

```
# args.s
.text
.globl _start
  
_start:
 popl    %ecx        # argc
vnext:
 popl    %ecx        # argv
 test    %ecx, %ecx  # 空指针表明结束
 jz  exit
 movl    %ecx, %ebx
 xorl    %edx, %edx
strlen:
 movb    (%ebx), %al
 inc %edx
 inc %ebx
 test    %al, %al
 jnz strlen
 movb    $10, -1(%ebx)
 movl    $4, %eax        # 系统调用号(sys_write) 
 movl    $1, %ebx        # 文件描述符(stdout) 
 int $0x80
 jmp vnext
exit:
 movl    $1,%eax         # 系统调用号(sys_exit) 
 xorl    %ebx, %ebx      # 退出代码
 int     $0x80
  
 ret
```

## 七 、GCC 内联汇编
--------------

用汇编编写的程序虽然运行速度快，但开发速度非常慢，效率也很低。如果只是想对关键代码段进行优化，或许更好的办法是将汇编指令嵌入到 C 语言程序中，从而充分利用高级语言和汇编语言各自的特点。但一般来讲，在 C 代码中嵌入汇编语句要比 "纯粹" 的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与 C 代码中的变量相结合等问题。

GCC 提供了很好的内联汇编支持，最基本的格式是：

```
__asm__("asm statements");
```

例如：

```
__asm__("nop");
```

如果需要同时执行多条汇编语句，则应该用 "\\n\\t" 将各个语句分隔开，例如：

```
__asm__( "pushl %%eax \\n\\t"
 "movl $0, %%eax \\n\\t"
 "popl %eax");
```

通常嵌入到 C 代码中的汇编语句很难做到与其它部分没有任何关系，因此更多时候需要用到完整的内联汇编格式：

```
__asm__("asm statements" : outputs : inputs : registers-modified);
```

插入到 C 代码中的汇编语句是以 ":" 分隔的四个部分，其中第一部分就是汇编代码本身，通常称为指令部，其格式和在汇编语言中使用的格式基本相同。指令部分是必须的，而其它部分则可以根据实际情况而省略。

在将汇编语句嵌入到 C 代码中时，操作数如何与 C 代码中的变量相结合是个很大的问题。GCC 采用如下方法来解决这个问题：程序员提供具体的指令，而对寄存器的使用则只需给出 "样板" 和约束条件就可以了，具体如何将寄存器与变量结合起来完全由 GCC 和 GAS 来负责。

在 GCC 内联汇编语句的指令部中，加上前缀 '%' 的数字 (如 %0，%1) 表示的就是需要使用寄存器的 "样板" 操作数。指令部中使用了几个样板操作数，就表明有几个变量需要与寄存器相结合，这样 GCC 和 GAS 在编译和汇编时会根据后面给定的约束条件进行恰当的处理。由于样板操作数也使用 '%' 作为前缀，因此在涉及到具体的寄存器时，寄存器名前面应该加上两个 '%' ，以免产生混淆。

紧跟在指令部后面的是输出部，是规定输出变量如何与样板操作数进行结合的条件，每个条件称为一个 "约束"，必要时可以包含多个约束，相互之间用逗号分隔开就可以了。每个输出约束都以 '=' 号开始，然后紧跟一个对操作数类型进行说明的字后，最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身，在执行完嵌入的汇编代码后均不保留执行之前的内容，这是 GCC 在调度寄存器时所使用的依据。

输出部后面是输入部，输入约束的格式和输出约束相似，但不带 '=' 号。如果一个输入约束要求使用寄存器，则 GCC 在预处理时就会为之分配一个寄存器，并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结合的寄存器或操作数本身，在执行完嵌入的汇编代码后也不保留执行之前的内容。

有时在进行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。在 GCC 内联汇编格式中的最后一个部分中，可以对将产生副作用的寄存器进行说明，以便 GCC 能够采用相应的措施。

下面是一个内联汇编的简单例子：

```
/* inline.c */
int main()
{
 int a = 10, b = 0;
 __asm__ __volatile__("movl %1, %%eax;\\n\\r"
 "movl %%eax, %0;"
 :"=r"(b)      /* 输出 */    
 :"r"(a)       /* 输入 */
 :"%eax");     /* 不受影响的寄存器 */
  
 printf("Result: %d, %d\\n", a, b);
}
```

上面的程序完成将变量 a 的值赋予变量 b ，有几点需要说明：

*   变量 b 是输出操作数，通过 %0 来引用，而变量 a 是输入操作数，通过 %1 来引用。
*   输入操作数和输出操作数都使用 r 进行约束，表示将变量 a 和变量 b 存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符 '='。
*   在内联汇编语句中使用寄存器 eax 时，寄存器名前应该加两个 '%'，即 %%eax。内联汇编中使用 %0、%1 等来标识变量，任何只带一个 '%' 的标识符都看成是操作数，而不是寄存器。
*   内联汇编语句的最后一个部分告诉 GCC 它将改变寄存器 eax 中的值，GCC 在处理时不应使用该寄存器来存储任何其它的值。
*   由于变量 b 被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。

在内联汇编中用到的操作数从输出部的第一个约束开始编号，序号从 0 开始，每个约束记数一次，指令部要引用这些操作数时，只需在序号前加上 '%' 作为前缀就可以了。需要注意的是，内联汇编语句的指令部在引用一个操作数时总是将其作为 32 位的长字使用，但实际情况可能需要的是字或字节，因此应该在约束中指明正确的限定符：

```
限定符                      意义
"m"、"v"、"o"	            内存单元
"r"	                    任何寄存器
"q"	                    寄存器eax、ebx、ecx、edx之一
"i"、"h"	            直接操作数
"E"和"F"	            浮点数
"g"	                    任意
"a"、"b"、"c"、"d"	    分别表示寄存器eax、ebx、ecx和edx
"S"和"D"	            寄存器esi、edi
"I"	                    常数（0至31）
```

## 八 、小结
--------

Linux 操作系统是用 C 语言编写的，汇编只在必要的时候才被人们想到，但它却是减少代码尺寸和优化代码性能的一种非常重要的手段，特别是在与硬件直接交互的时候，汇编可以说是最佳的选择。Linux 提供了非常优秀的工具来支持汇编程序的开发，使用 GCC 的内联汇编能够充分地发挥 C 语言和汇编语言各自的优点。
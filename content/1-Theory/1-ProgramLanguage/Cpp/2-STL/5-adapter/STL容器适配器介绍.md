容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。  
  
本章将介绍 3 种容器适配器，分别是 stack、queue、priority_queue：

1. stack\<T\>：是一个封装了 deque\<T\> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack\<T\> 模板定义在头文件 stack 中。
2. queue\<T\>：是一个封装了 deque\<T\> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue\<T\> 模板定义在头文件 queue 中。
3. priority_queue\<T\>：是一个封装了 vector\<T\> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue\<T\> 模板定义在头文件 queue 中。

  
适配器类在基础序列容器的基础上实现了一些自己的操作，显然也可以添加一些自己的操作。它们提供的优势是简化了公共接口，而且提高了代码的可读性。本章我们会详细地探讨这些适配器的应用。

## 理解容器适配器

在详解什么是容器适配器之前，初学者首先要理解适配器的含义。

其实，容器适配器中的 “适配器”，和生活中常见的电源适配器中“适配器” 的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220 V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220 V 的交流电转换成适合电器使用的低压直流电。

从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。

再举一个例子，假设一个代码模块 A，它的构成如下所示：

```
class A{
public:
    void f1(){}
    void f2(){}
    void f3(){}
    void f4(){}
};
```

现在我们需要设计一个模板 B，但发现，其实只需要组合一下模块 A 中的 f1 ()、f2 ()、f3 ()，就可以实现模板 B 需要的功能。其中 f1 () 单独使用即可，而 f2 () 和 f3 () 需要组合起来使用，如下所示：

```
class B{
private:
    A * a;
public:
    void g1(){
        a->f1();
    }
    void g2(){
        a->f2();
        a->f3();
    }
};
```

可以看到，就如同是电源适配器将不适用的交流电变得适用一样，模板 B 将不适合直接拿来用的模板 A 变得适用了，因此我们可以将模板 B 称为 B 适配器。

容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现和模板 A、B 的关系是完全相同的，即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。

> **容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数**。当然，如果必要的话，容器适配器中也可以自创新的成员函数。

需要注意的是，STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。

### STL 容器适配器的种类
------------

STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。其中，各适配器所使用的默认基础容器以及可供用户选择的基础容器，如下表所示。

| 容器适配器          | 基础容器筛选条件                                                                                   | 默认使用的基础容器 |
|----------------|--------------------------------------------------------------------------------------------|-----------|
| stack&nbsp;    | 基础容器需包含以下成员函数：empty () size () back () push_back () pop_back ()满足条件的基础容器有 vector、deque、list。   | deque     |
| queue          | 基础容器需包含以下成员函数：empty () size () front () back () push_back () pop_front ()满足条件的基础容器有 deque、list。 | deque     |
| priority_queue | 基础容器需包含以下成员函数：empty () size () front () push_back () pop_back ()满足条件的基础容器有 vector、deque。       | vector    |

不同场景下，由于不同的序列式容器其底层采用的数据结构不同，因此容器适配器的执行效率也不尽相同。但通常情况下，使用默认的基础容器即可。当然，我们也可以手动修改，具体的修改容器适配器基础容器的方法，后续讲解具体的容器适配器会详细介绍。

## 理解迭代器适配器

通过学习 C++ STL 标准库中的容器我们知道，无论是序列式容器还是关联式容器（包括哈希容器），要想遍历容器中存储的数据，就只能用使用该容器模板类中提供的迭代器。

《C++ STL 迭代器》一节提到，C++ STL 标准库中迭代器大致分为 5 种类型，分别是输入迭代器、输出迭代器、前向迭代器、双向迭代器以及随机访问迭代器。值得一提的是，这 5 种迭代器是 STL 标准库提供的最基础的迭代器，很多场景中遍历容器的需求，它们并不适合。

举个例子，假设有一个 list 容器，现在需要逆序输出该容器中存储的所有元素。要知道，list 容器模板类提供的是双向迭代器，如果使用该类型迭代器实现逆序操作，实现代码如下：

```
#include <iostream>
#include <list>
using namespace std;
int main()
{
    std::list<int> values{1,2,3,4,5};
    //找到遍历的开头位置和结尾位置
    std::list<int>::iterator begin = --values.end();
    std::list<int>::iterator end = --values.begin();
    //开始遍历
    while (begin != end)
    {
        cout << *begin << " ";
        --begin;
    }
    return 0;
}
```

程序执行结果为：
```
5 4 3 2 1
```

相比上面这种实现思路，C++ STL 标准库中还提供有更简单的方法，就是使用迭代器适配器。

所谓**迭代器适配器，其本质也是一个模板类**，比较特殊的是，该模板类是借助以上 5 种基础迭代器实现的。换句话说，迭代器适配器模板类的内部实现，是通过对以上 5 种基础迭代器拥有的成员方法进行整合、修改，甚至为了实现某些功能还会添加一些新的成员方法。由此，将基础迭代器 “改头换面”，就变成了本节要讲的迭代器适配器。

### STL 迭代器适配器种类
----------------

C++ 11 标准中，迭代器适配器供有 4 类，它们各自的名称和功能如下表所示。

| 名称                                                                                                | 功能                                                                                              |
|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| 反向迭代器（reverse_iterator）                                                                           | 又称 “逆向迭代器”，其内部重新定义了递增运算符（++）和递减运算符（--），专门用来实现对容器的逆序遍历。                                          |
| 安插型迭代器（inserter 或者 insert_iterator）                                                               | 通常用于在容器的任何位置添加新的元素，需要注意的是，此类迭代器不能被运用到元素个数固定的容器（比如 array）上。                                      |
| 流迭代器（istream_iterator / ostream_iterator）流缓冲区迭代器（istreambuf_iterator /&nbsp; ostreambuf_iterator） | 输入流迭代器用于从文件或者键盘读取数据；相反，输出流迭代器用于将数据输出到文件或者屏幕上。输入流缓冲区迭代器用于从输入缓冲区中逐个读取数据；输出流缓冲区迭代器用于将数据逐个写入输出流缓冲区。 |
| 移动迭代器（move_iterator）                                                                              | 此类型迭代器是 C++ 11 标准中新添加的，可以将某个范围的类对象移动到目标范围，而不需要通过拷贝去移动。                                          |

> 以上 4 种迭代器的用法，后续章节会做详细介绍。

实际上，前面在学习各种容器的迭代器时，我们经常会使用到反向迭代器。下面样例，演示了用反向迭代器适配器遍历 list 容器的实现过程：

```
#include <iostream>
#include <list>
using namespace std;
int main()
{
    std::list<int> values{ 1,2,3,4,5 };
    //找到遍历的起点和终点，这里无需纠结定义反向迭代器的语法，后续会详细讲解
    std::reverse_iterator<std::list<int>::iterator> begin = values.rbegin();
    std::reverse_iterator<std::list<int>::iterator> end = values.rend();
    while (begin != end) {
        cout << *begin << " ";
        //注意，这里是 ++，因为反向迭代器内部互换了 ++ 和 -- 的含义
        ++begin;
    }
    return 0;
}
```

程序执行结果为：
```
5 4 3 2 1
```
可以看到，程序中通过调用 list 容器模板类提供的 rbegin () 和 rend ()，就可以获得逆序遍历容器所需要的反向迭代器，从而轻松实现逆序输出容器中存储的所有数据。
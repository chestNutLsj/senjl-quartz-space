### `value` 参数设置为 1 错误的原因

当使用 `memset(data, 1, sizeof(data));` 进行内存初始化时，实际得到的结果是每个字节都被设置为 `0x01`，而不是整个 `int` 类型元素都被设置为 `0x00000001`。

这是因为 `memset` 函数按字节（byte）进行初始化，并且 `value` 参数是一个整数（`int` 类型），它的值为 `1`。在内存中，一个 `int` 类型通常占用 4 个字节（32 位系统上），所以 `1` 会被复制到每个字节中。

假设 `int` 类型在你的系统上占用 4 个字节（32 位），`1` 的二进制表示为 `00000000 00000000 00000000 00000001`。当使用 `memset` 将每个字节设置为 `1` 时，内存的结果如下：

```
00000001 00000001 00000001 00000001  // 每个字节都被设置为 0x01 (1)
```

因此，你看到的结果是 `0x01010101`，并不是整个 `int` 类型都被设置为 `0x00000001`。

如果你想将整个 `int` 数组都设置为 `1`，你可以使用循环来实现，或者使用更适合数组初始化的方式，例如：

```cpp
int data[10];
std::fill(data, data + 10, 1); // 使用 std::fill 来将数组元素都设置为 1
```

### `value` 参数设置为-1 正确的原因
当将 `memset(data, -1, sizeof(data));` 中的 `value` 参数改为 `-1` 时，会得到正确的结果。

这是因为在 C/C++ 中，`memset()` 函数的 `value` 参数被强制转换为 `unsigned char` 类型，因此无论 `value` 的值是正数还是负数，它都会被看作是一个 8 位二进制数。

在补码表示中，`-1` 的二进制表示是全为 1 的二进制数。假设 `int` 类型在你的系统上占用 4 个字节（32 位），则 `-1` 的二进制表示为 `11111111 11111111 11111111 11111111`。

当使用 `memset(data, -1, sizeof(data));` 进行内存初始化时，每个字节都被设置为 `0xFF`（十六进制表示），而不是整个 `int` 类型都被设置为 `0xFFFFFFFF`。

```
11111111 11111111 11111111 11111111  // 每个字节都被设置为 0xFF (-1)
```

由于每个字节都被设置为 `-1`，这对于某些特定的用例可能是正确的。但是要注意，这种方法在对整数类型进行内存初始化时可能不总是正确的，因为它可能会受到系统中 `int` 类型的大小和表示方式的影响。通常情况下，`memset()` 更适合对字符数组进行初始化，而不是整数类型。如果你想将整个 `int` 数组都设置为 `-1`，最好使用循环或其他更适合的方法来实现。
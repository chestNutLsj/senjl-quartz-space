
Preprocessor directives are lines included in the code of programs preceded by a hash sign (`#`). These lines are not program statements but directives for the _preprocessor_. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.

These _preprocessor directives_ extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. No semicolon (`;`) is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (`\`).（预处理器指令仅存在于一行，一旦找到换行符该行预处理指令就结束了。预处理器指令末尾不应出现分号 `;`  若要跨行扩展则需要在换行符前添加反斜杠 `\`）

## macro definitions (`#define` , `#undef` )

To define preprocessor macros we can use `#define`. Its syntax is:

`#define identifier replacement`

When the preprocessor encounters this directive, it replaces any occurrence of `identifier` in the rest of the code by `replacement`. This `replacement` can be an expression, a statement, a block or simply anything. The preprocessor does not understand C++ proper, it simply replaces any occurrence of `identifier` by `replacement`.

```
#define TABLE_SIZE 100
int table1[TABLE_SIZE];
int table2[TABLE_SIZE];
```

After the preprocessor has replaced `TABLE_SIZE`, the code becomes equivalent to:

```
int table1[100];
int table2[100];
```

`#define` can work also with parameters to define function macros:

```
#define getmax(a,b) a>b?a:b
```

This would replace any occurrence of `getmax` followed by two arguments by the replacement expression, but also replacing each argument by its identifier, exactly as you would expect if it was a function: （函数宏将用替换表达式在 `getmax` 后跟着两个参数的所有地方进行替换）

```cpp
// function macro
#include <iostream> 
using namespace std;

#define getmax (a, b) ((a)>(b)? (a): (b))

int main ()
{
  int x=5, y;
  y= getmax (x, 2);
  cout << y << endl;
  cout << getmax (7, x) << endl;
  return 0;
}
```

Defined macros are not affected by block structure. A macro lasts until it is undefined with the `#undef` preprocessor directive:（定义的宏不受块结构的影响，宏的作用域一直持续到被 `#undef` 预处理器指令解除定义为止）

```cpp
#define TABLE_SIZE 100
int table1[TABLE_SIZE];
#undef TABLE_SIZE
#define TABLE_SIZE 200
int table2[TABLE_SIZE];
```

This would generate the same code as:

```
int table1[100];
int table2[200];
```

Function macro definitions accept two special operators (`#` and `##`) in the replacement sequence:  （函数宏定义在替换序列中接收两个特殊运算符 `#` 和 `##`）

The operator `#`, followed by a parameter name, is replaced by a string literal that contains the argument passed (as if enclosed between double quotes):  （`#` 运算符后跟参数名称，替换为包含传递的参数的字符串文本，类似双引号之间的字符串）

```
#define str(x) #x
cout << str(test);
```

This would be translated into:  

```cpp
cout << "test";
```

The operator `##` concatenates two arguments leaving no blank spaces between them:

```
#define glue(a,b) a ## b
glue(c,out) << "test";
```

This would also be translated into: 

```cpp
cout << "test";
```

Because preprocessor replacements happen before any C++ syntax check, macro definitions can be a tricky feature. But, be careful: code that relies heavily on complicated macros become less readable, since the syntax expected is on many occasions different from the normal expressions programmers expect in C++.  （由于预处理器替换发生在 Cpp 语法检查之前，因此宏定义可能是一个棘手的功能。并且要小心，严重依赖复杂宏的代码可读性很差，因为预期的语法在许多情况下与程序员期望的 Cpp 中的正常表达式不同）

## Conditional inclusions ( `#ifdef` , `#ifndef` , `#if` , `#endif` , `#else` and `#elif` )

These directives allow to include or discard part of the code of a program if a certain condition is met.

`#ifdef` allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is. For example: （`#ifdef` 仅当指定了作为参数的宏时，才允许编译程序的某个部分，无论具体参数的值是什么）

```
#ifdef TABLE_SIZE
int table[TABLE_SIZE];
#endif
```

In this case, the line of code `int table[TABLE_SIZE];` is only compiled if `TABLE_SIZE` was previously defined with `#define`, independently of its value. If it was not defined, that line will not be included in the program compilation.（只有在前文已经定义了 `#define TABLE_SIZE` 之后，在 `#ifdef` 中才能判断通过，对接下来一行进行编译，不关心 `TABLE_SIZE` 的值具体如何）

`#ifndef` serves for the exact opposite: the code between `#ifndef` and `#endif` directives is only compiled if the specified identifier has not been previously defined. For example:

```
#ifndef TABLE_SIZE
#define TABLE_SIZE 100
#endif
int table[TABLE_SIZE];
```

In this case, if when arriving at this piece of code, the `TABLE_SIZE` macro has not been defined yet, it would be defined to a value of 100. If it already existed it would keep its previous value since the `#define` directive would not be executed.

The `#if`, `#else` and `#elif` (i.e., "else if") directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows `#if` or `#elif` can only evaluate constant expressions, including macro expressions. For example:

```cpp
#if TABLE_SIZE>200
#undef TABLE_SIZE
#define TABLE_SIZE 200
 
#elif TABLE_SIZE<50
#undef TABLE_SIZE
#define TABLE_SIZE 50
 
#else
#undef TABLE_SIZE
#define TABLE_SIZE 100
#endif
 
int table[TABLE_SIZE];
```

Notice how the entire structure of `#if`, `#elif` and `#else` chained directives ends with `#endif`.

The behavior of `#ifdef` and `#ifndef` can also be achieved by using the special operators `defined` and `!defined` respectively in any `#if` or `#elif` directive:

```
#if defined ARRAY_SIZE
#define TABLE_SIZE ARRAY_SIZE
#elif !defined BUFFER_SIZE
#define TABLE_SIZE 128
#else
#define TABLE_SIZE BUFFER_SIZE
#endif
```

## Line control ( `#line` )

When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error. （当编译一个程序并且在编译过程中发生一些错误时，编译器会显示一条错误消息，其中包含对发生错误的文件名和行号的引用，以便更容易找到出现错误的代码）

The `#line` directive allows us to control both things, the line numbers within the code files as well as the file name that we want that appears when an error takes place. （`#line` 指令允许控制代码文件中的行号以及发生错误时想要出现的文件名）

Its format is: `#line number "filename"`

Where `number` is the new line number that will be assigned to the next code line. The line numbers of successive lines will be increased one by one from this point on.（`number` 部分是将要分配给下一个代码行的新行号，从这一行开始连续的行号将逐个增加）

`"filename"` is an optional parameter that allows to redefine the file name that will be shown. （`filename` 是可选参数，可以重新定义显示的文件名）

For example:

```
#line 20 "assigning variable"
int a?;
```

This code will generate an error that will be shown as error in file `"assigning variable"`, line 20.  

## Error directive ( `#error` )

This directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter:（当遇到 `#error` 时中止编译过程，生成可指定为其参数的编译错误）

```
#ifndef __cplusplus
#error A C++ compiler is required!
#endif
```

This example aborts the compilation process if the macro name `__cplusplus` is not defined (this macro name is defined by default in all C++ compilers).  

## Source file inclusion ( `#include` )

This directive has been used assiduously in other sections of this tutorial. When the preprocessor finds an `#include` directive it replaces it by the entire content of the specified header or file. There are two ways to use `#include`:

```
#include <header>
#include "file"
```

In the first case, a _header_ is specified between angle-brackets `<>`. This is used to include headers provided by the implementation, such as the headers that compose the standard library (`iostream`, `string`,...). Whether the headers are actually files or exist in some other form is _implementation-defined_, but in any case they shall be properly included with this directive.（无论头文件是实际存在的文件、还是以某种其他形式存在，都是*已定义的实现*，无论如何都应该正确包含在此指令中）

The syntax used in the second `#include` uses quotes, and includes a _file_. The _file_ is searched for in an _implementation-defined_ manner, which generally includes the current path. In the case that the file is not found, the compiler interprets the directive as a _header_ inclusion, just as if the quotes (`""`) were replaced by angle-brackets (`<>`).（`""` 中包含的文件通常以*预定义实现*的方式进行查找，通常是在当前目录中，如果没有找到，编译器会将 `""` 解释为 `<>` 从而在系统库文件中进行查找）

## Pragma directive ( `#pragma` )

This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use. Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with `#pragma`.（`#pragma` 指令用于为编译器指定各种选项，这些选项特定于使用的平台和编译器，有关可以使用 `#pragma` 定义的可能参数的详细信息，请参阅编译器的手册或参考资料）

If the compiler does not support a specific argument for `#pragma`, it is ignored - no syntax error is generated.

## Predefined macro names

The following macro names are always defined (they all begin and end with two underscore characters, `_`):

| macro           | value                                                                                                                                                                                                                                                                                                                                                                                                                      |
|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `__LINE__`        | Integer value representing the current line in the source code file being compiled.                                                                                                                                                                                                                                                                                                                                        |
| `__FILE__`        | A string literal containing the presumed name of the source file being compiled.                                                                                                                                                                                                                                                                                                                                           |
| `__DATE__`        | A string literal in the form "Mmm dd yyyy" containing the date in which the compilation process began.                                                                                                                                                                                                                                                                                                                     |
| `__TIME__`        | A string literal in the form "hh:mm: ss" containing the time at which the compilation process began.                                                                                                                                                                                                                                                                                                                       |
| `__cplusplus`     | An integer value. All C++ compilers have this constant defined to some value. Its value depends on the version of the standard supported by the compiler: 199711 L: ISO C++ 1998/2003201103 L: ISO C++ 2011 Non conforming compilers define this constant as some value at most five digits long. Note that many compilers are not fully conforming and thus will have this constant defined as neither of the values above. |
| `__STDC_HOSTED__` | 1 if the implementation is a hosted implementation (with all standard headers available) 0 otherwise.                                                                                                                                                                                                                                                                                                                       |

The following macros are optionally defined, generally depending on whether a feature is available:

| macro                            | value                                                                                                                   |
|----------------------------------|-------------------------------------------------------------------------------------------------------------------------|
| `__STDC__`                         | In C: if defined to 1, the implementation conforms to the C standard. In C++: Implementation defined.                    |
| `__STDC_VERSION__`                 | In C: 199401 L: ISO C 1990, Ammendment 1199901 L: ISO C 1999201112 L: ISO C 2011 In C++: Implementation defined.          |
| `__STDC_MB_MIGHT_NEQ_WC__`         | 1 if multibyte encoding might give a character a different value in character literals                                  |
| `__STDC_ISO_10646__`              | A value in the form yyyymmL, specifying the date of the Unicode standard followed by the encoding of wchar_t characters |
| `__STDCPP_STRICT_POINTER_SAFETY__` | 1 if the implementation has strict pointer safety (see get_pointer_safety)                                              |
| `__STDCPP_THREADS__`               | 1 if the program can have more than one thread                                                                          |

Particular implementations may define additional constants.

For example:

```cpp
// standard macro names
#include <iostream> 
using namespace std;

int main ()
{
  cout << "This is the line number " << __LINE__;
  cout << " of file " << __FILE__ << ".\n";
  cout << "Its compilation began " << __DATE__;
  cout << " at " << __TIME__ << ".\n";
  cout << "The compiler gives a __cplusplus value of " << __cplusplus;
  return 0;
}
```

Output is: 

```
This is the line number 10 of file /home/senjl/MyLearning/programming-language/Cpp/official-tutorial/5_others/2_standard_macro.cpp.
Its compilation began Jul 16 2023 at 09:13:43.
The compiler gives a __cplusplus value of 201703

```
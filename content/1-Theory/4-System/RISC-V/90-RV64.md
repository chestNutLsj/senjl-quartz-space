![[90-RV64-I.png]]

![[90-RV64-M-A.png]]

![[90-RV64-F-D.png]]

![[90-RV64-C.png]]

图 9.1 至 9.4 是 RV32G 指令集的 64 位版本 RV64G 指令集的图示。由图可见，要切换到 64 位 ISA，ISA 只添加了少数指令。指令集只添加了 32 位指令对应的字(word)，双字 (doubleword)和长整数(long)版本的指令，并将所有寄存器（包括 PC）扩展为 64 位。因此，RV64I 中的 sub 操作的是两个 64 位数字而不是 RV32I 中的 32 位数字。RV64 很接近 RV32 但实际上又有所不同;它==添加了少量指令同时基础指令做的事情与 RV32 中稍有不同==。

![[90-RV64-asm.png]]
例如，图 9.8 中 RV64I 版本的插入排序与第 2 章第 27 页的图 2.8 中 RV32I 版本的插入排序非常相似。它们指令数量和大小都相同。唯一的变化是加载和存储字指令变为加载并存储双字，地址增量从对应字的 4（4 字节）变为对应双字的 8（8 字节）。图 9.5 列出了图 9.1 到 9.4 中的 RV64GC 指令的操作码。
![[90-RV64-opcode.png]]

尽管 RV64I 有 64 位地址且默认数据大小为 64 位，32 位字仍然是程序中的有效数据类型。因此，RV64I 需要支持字，就像 RV32I 需要支持字节和半字一样。更具体地说，由于寄 存器现在是 64 位宽，RV64I 添加字版本的加法和减法指令：addw，addiw，subw。这些指 令将计算结果截断为 32 位，结果符号扩展后再写入目标寄存器。RV64I 也包括字版本的移 位指令（sllw，slliw，srlw，srliw，sraw，sraiw），以获得 32 位移位结果而不是 64 位移 位结果。要进行 64 位数据传输，RV64 提供了加载和存储双字指令：ld，sd。最后，就像 RV32I 中有无符号版本的加载单字节和加载半字的指令，RV64I 也有一个无符号版本的加载 字：lwu。

出于类似的原因，RV64 需要添加字版本的乘法，除法和取余指令：mulw，divw，divuw， remw，remuw。为了支持对单字及双字的同步操作，RV64A 为其所有的 11 条指令都添加 了双字版本。
![[MMU-MMU-principle.png]]
MMU (Memory Management Unit)，即内存管理单元，是现代 CPU 架构中不可或缺的一部分。

## MMU 的主要功能

* **虚实地址翻译**：在用户访问内存时，将用户访问的虚拟地址翻译为实际的物理地址，以便 CPU 对实际的物理地址进行访问。

* **访问权限控制**：可以对一些虚拟地址进行访问权限控制，以便于对用户程序的访问权限和范围进行管理，如代码段一般设置为只读，如果有用户程序对代码段进行写操作，系统会触发异常。

* **引申的物理内存管理**：对系统的物理内存资源进行管理，为用户程序提供物理内存的申请、释放等操作接口。


## MMU 的优势

* **提升物理内存的利用率**：
	* 物理内存按需申请，如代码段的内存在执行时进行映射和转换，进程 fork 后，通过写时复制 (Copy-On-Write) 进行真正的物理内存分配。
	* 解决内存管理碎片化的问题，即在系统运行一段时间后，频繁的内存申请和释放会导致内存碎片化，无法申请到一块足够大的地址连续的内存。

* **对内存地址的访问进行控制**：如上述代码段只读权限控制，多线程的栈内存之间的空洞页隔离可以防止栈溢出后改写其他线程的栈内存，不同进程之间的地址隔离等等。

* **将进程的地址空间隔离**：
	* 不同进程之间可以使用相同的虚拟内存地址空间，而进程间的物理内存又可以做到隔离，这保证了进程的独立性同时，又简化了地址的访问方式，
	* 如在早期 32 位 CPU 上，为了支持 4G 以上的物理内存，一般物理地址有 36-bit (如 PowerPC-604 系列)，但是用户的虚地址仍然使用 32-bit，做法就是将用户的不同进程的 32-bit 虚地址在 MMU 转换时，转换为 36-bit 的物理地址，这样每个进程仍然能访问 0-3G 虚地址范围，将多个进程的 3G 空间映射到 36-bit 的物理内存空间中去。

## MMU 的由来

* Swap 模式时代

早期计算机在执行程序时，将程序从磁盘加载到内存执行中执行，在多用户系统中，当新的用户程序被执行前，需要先将当前用户的程序从内存 swap 到磁盘，然后从磁盘加载新的程序执行，当前用户退出后，在将前一用户程序从磁盘中加载到内存继续执行，每次用户切换伴随程序的 swap，消耗较大。

![[MMU-swap.png]]

* Page 模式时代

后来人们将内存划分为固定大小的 Page，一般为 4K 或者更小，这样用户程序按需以 Page 的方式加载到内存，不需要将整个程序加载到内存，这样内存可同时容纳更多程序，而无需按照用户切换进行 swap，提升了内存利用率和加载时间 (PageFault 是 Page 时代的产物，而非 MMU 时代独有)。

![[MMU-page.png]]

* 动态地址转换 (DAT - Dynamic Address Translation)

最早可以追溯到 1966 年 IBM 研发的 System/360-Model67，在该计算机的设计中首先引入了动态的地址转换机制，在 Page 模式基础上，为用户程序分配虚地址 (VA)，通过 DAT 转换为物理地址 (PA) 进行访问。通过好处是用户可以使用连续的地址，而不再受制于物理内存大小和 Page 碎片化的限制，原则上用户的程序只受磁盘大小限制，代价是增加虚实地址转换机制。

**实现方式**

> 采用 segment、page、offset 模式，将 24-bit 虚拟地址分为 3 段，0-7bit 保留，8-11bit 索引 segment，一共 16 个 segment，12-19bit 索引 page，每个 segment 最多 256 个 page，20-31bit 为 page offset，每个用户有一个虚实地址映射表，分为 2 级，即 segment 表和 page 表，每个 segment 指向一个 page 表。

**转换过程**

> 当 CPU 访问一个虚地址时，先通过 VA 的 8-11bit 查找 segment 表得到 page 表，再根据 12-19bit 在 page 表中找到 PA 的 page 起始地址，加上 20-31bit 的 page offset 就得到实际的 PA 了。

这就是 MMU 最早的雏形了。

![[MMU-DAT.png]]

## 现代 MMU 的实现

现代 CPU 的 MMU 的地址转换方式一般分为 3 种模式，即实地址模式、块地址转换、页地址转换。

![[MMU-3-kinds.png]]

* 实地址模式

即 CPU 状态位中 MMU 使能位清零，MMU 处于关闭状态，此时 CPU 操作的地址不经过转换 (VA=PA)，直接作为物理地址进行访问，CPU 上电时或者在异常入口时处于该状态，在该状态下可以访问任意物理内存，非常危险，一般操作系统在 CPU 上电后做完必要初始化以后便使能 MMU，或者在异常处理的入口保存好必要信息后使能 MMU。

* 块地址转换

或者成为固定的地址转换或静态配置的地址转换表，这种模式支持配置一些固定的内存地址映射 (VPN->RPN)，比如 Linux Kernel 加载的地址，以 PowerPC604 为例，0xC0000000 这段地址开始的 256M 内存映射使用了该模式的转换，好处是这种配置转换速度快，一般在特定的寄存器中配置，没有页表查找过程，缺点是缺乏灵活性，一次配置永久使用。

* 页地址转换

类似于早期的动态地址转换 DAT，即将 VA 的一部分 bit 用于索引 segment，另外一部分 bit 用于索引 PTE 表，最终得到物理地址的 Page 起始地址，再加上最后 12bit (4K) 的 Page offset 得到真正的物理地址。

相比早期的 DAT，有以下优化：

- 增加了 PTE 表的缓存 TLB (Translation lookaside Buffer)，有些处理器将 ITLB (指令) 和 DTLB (数据) 分开，以减少指令和数据之间的缓存冲突。

* 支持更大的物理地址 (36bit 以上) 或逻辑地址，如在 PowerPC 中，用以应对现代操作系统的多进程管理将 32bit 通过 segment 寄存器扩展为 52bit 的逻辑地址，然后通过 hash 函数得到 key 用来查找 PTE，并最终转换为 36bit 物理地址，逻辑地址的扩展用于减少多进程之间的 PTE 冲突。  
 
* 支持多种 PTE 查找方式，如硬件查找和软件查找。  
 

现在 CPU 的 MMU 地址转换流程如下：

![[MMU-address-convert-flow.png]]

主要分为几个阶段：
* 用户进程访问虚存地址。
* 触发 TLB 查找过程，该部分通过硬件完成（灰色背景），没有软件参与。
* TLB miss 场景下，查找 PTE（粉色背景），该部分在不同 CPU 上实现不同，像 X86 都是硬件查找，PowerPC 有些处理器使用软件查找，即在内核实现一个 TLB miss 的异常处理，可以灵活做到 TLB 查找。
* Do Page Fault，分为几种情况：
	* 新申请内存第一次读写，触发物理内存分配；
	* 进程 fork 后子进程写内存触发 Copy-On-Write；
	* 非法内存读写，错误处理。

## 总结

本文简单的将 MMU 的功能和演进过程做了一个框架性的介绍，以及现代 MMU 的简易处理过程，其中详细的机制后续有机会再做详细介绍，比如多进程的 TLB 缓存处理，PTE 的多级页表查找，NUMA，MMU 虚拟化等，同时随着用户的需求场景不断变化，MMU 的功能也会不断更新升级，比如虚拟机的出现，催熟了 MMU 虚拟化功能，未来异构的硬件和系统中，比如 CPU 和 GPU 配合，GPU 虚拟化等等，MMU 将如何演进？欢迎大家一起探讨。

参考资料:  
[1] [https://en.wikipedia.org/wiki/Memory_management_unit](https://en.wikipedia.org/wiki/Memory_management_unit)  
[2] [https://en.wikipedia.org/wiki/Memory_paging](https://en.wikipedia.org/wiki/Memory_paging)


表单用以提供网站与用户交互——提供文本输入框、单选按钮、复选框、按钮等元素；还可以验证数据，对提交的数据验证合法后再进行操作。

### 0. 依赖
Flask-WTF 是对 WTForms 的封装，WTForms 的功能主要是验证数据和渲染表单 HTML 的标签。
```python
conda install flask-wtf,email_validator
```

## 1. 表单验证
注册帐号时一般要提供邮箱、用户名、密码、确认密码四个字段的数据，因此在 `templates/register.html` 中写入：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>REGISTER</title>
</head>
<body>
<form action="{{ url_for('register') }}" method="POST">
    <table>
        <tr>
            <td>Username:</td>
            <td><label>
                <input type="text" name="username">
            </label></td>
            <td>E-Mail:</td>
            <td><label>
                <input type="email" name="email">
            </label></td>
            <td>Password:</td>
            <td><label>
                <input type="password" name="password">
            </label></td>
            <td>Confirm Password:</td>
            <td><label>
                <input type="password" name="confirm_password">
            </label></td>
            <td></td>
            <td><label>
                <input type="submit" value="submit">
            </label></td>
        </tr>
    </table>
</form>
</body>
</html>
```

form 标签中，使用 `url_for('register')` 将 register 视图函数反转为 URL，在点击提交按钮“Submit”时，会把所有 form 标签下输入框中的内容提交给这个 URL，并且设置提交方法为 POST。

视图函数如下：
```python
@app.route('/register')
def register():
    if request.method == 'GET':
        return render_template("register.html")
    else:
        pass
```

访问效果如图：
![[register.png]]

### 1.1 表单类编写
一般情况下对用户的输入信息是有要求的，如用户名要输入 3 位以上，邮箱要以@+域名结尾，密码最少六位，确认密码要与密码一致。并且用户不一定一次性输入正确，因此在输入错误时要有错误反馈和提示。这个工作前端可以用 JavaScript 完成，服务器端要用 WTForms 实现。

在根路径创建 forms.py：
```python
from wtforms import Form, StringField
from wtforms.validators import length, email, equal_to


class RegisterForm(Form):
    username = StringField(
        validators=[length(min=3, max=20, message="Please enter a username with the correct length!")])
    email = StringField(validators=[email(message="Please enter an email with correct format! Such as lsj@163.com")])
    password = StringField(validators=[length(min=16, max=20, message=(
        "Please enter a password of the correct length! Min is 6 digits and Max is 20 digits"))])
    confirm_password = StringField(
        validators=[equal_to("password", message="The later input password is different with the first one!")])
```
所有表单都必须继承自 Form 基类，RegisterForm 中四个字段都必须与 `register.html` 中的 name 值一致。这四个属性都是字符串属性，因此使用 StringField，除此之外还有：
| 字段类型      | 描述 |
| ------------- | ---- |
| StringField   |      |
| IntegerField  |      |
| FloadField    |      |
| DecimalField  |      |
| BooleanField  |      |
| DateTimeField |      |
| DateField     |      |
| TimeField     |      |
| FileField     |      |

每个字段都传递 validators 参数，这是可以存储多个验证器的集合，不同字段根据需求设置不同的验证器。更多的验证器如下：
| Validator                                   | Description |
| ------------------------------------------- | ----------- |
| length (min, max, message)                  |             |
| email ()                                    |             |
| equal_to (fieldname, message)               |             |
| ip_address (ipv 4, ipv 6, message)          |             |
| mac_address (message)                       |             |
| number_range (min, max, message)            |             |
| optional (strip_whitespace)                 |             |
| input_required (message)                    |             |
| data_required (message)                     |             |
| url (message)                               |             |
| any_of (values, message, values_formatter)  |             |
| none_of (values, message, values_formatter) |             |
| regexp (regex, flags, message)              |             | 


### 1.2 视图函数中使用表单
继续完善 register 视图函数：
```python
from flask import Flask, request, render_template, flash, redirect, url_for  
from forms import RegisterForm

...
app.secret_key = "156324"

@app.route('/register', methods=['GET','POST'])
def register():
    if request.method == 'GET':
        return render_template("register.html")
    else:
        # request.form 是html模板提交上来的表单数据
        form = RegisterForm(request.form)
        # if pass validate
        if form.validate():
            email = form.email.data
            username = form.username.data
            password = form.password.data

            # Commit to database
            print("email: ", email)
            print("username: ", username)
            print("password: ", password)
            return "Register Successfully!"
        else:
            for errors in form.errors.values():
                for err in errors:
                    flash(err)
            return redirect(url_for("register"))
```
第 12 行中先注册了一个 RegisterForm 类的对象，其中 `request.form` 是一个类字典类型，以键值对的形式保存浏览器中传递来的表单数据。调用 `validate()` 方法判断所有字段的验证是否通过，若通过则从对象 form 中提取对应字段，若未通过则使用 `form.errors` 获取错误信息，这也是一个字典类型，key 是字段名称，value 是错误信息的列表。

>[! tip] 不能直接使用 `request.form` 的原因
>不是直接从 `request.form` 提取是因为浏览器中的表单数据都是字符串，而创建对象过程中会对字符串进行整理和转换类型）

表单验证失败时，通过循环 `form.errors.values()` 获取所有错误信息并存储到 flash 中，然后在模板中显示 flash 消息，这里要改动 `register.html`：

```html
...
    <ul>
        {% for message in get_flashed_messages() %}
        <li>{{ message }}</li>
        {% endfor %}
    </ul>
</form>
</body>
</html>
```

> [! warning] 使用 flash 消息的前提
> 需要在 app 上配置 SECRET_KEY，或者直接通过 app. secret_key 设置密钥。

访问效果如图：
![[validator.png]]

### 1.3 自定义验证字段
总有奇奇怪怪的需求需要自定义实现，比如邮箱不能被重复注册，这就需要查询数据库判断是否邮箱已存在。要自定义某个字段的验证逻辑，可以通过表单类中自定义方法 `validate_<字段名>` 实现。改动 forms.py 如下：
```python
from wtforms.validators import ValidationError
...

registered_email = ['aa@gmail.com', 'bb@gmail.com']

class RegisterForm(Form):
	...
	
	def validate_email(self, field):  
		email = field.data  
		if email in registered_email:  
			raise ValidationError("This email has been registered!")  
		return True
```

要注意 `validate_<字段名>` 的格式，不要胡乱名名，因为视图函数中调用 `form.validate()` 会使 RegisterForm 底层调用 validate_email 方法，并传递 field 参数，由于验证的字段是 email，则 field 代表 email 字段，使用 `.data` 可以获取对应的值。

访问效果如下：
![[registered.png]]

## 2. 渲染表单模板
WTForms 能将 Python 表单对象渲染成 HTML 表单模板。在 form.py 中写入：
```python
from flask_wtf import FlaskForm
from wtforms import Form, StringField, BooleanField, SubmitField  
from wtforms.validators import length, email, equal_to, ValidationError
...

class LoginForm(FlaskForm):
    email = StringField(label='E-Mail: ',
                        validators=[email(message="Please enter an email with correct format! Such as lsj@163.com")],
                        render_kw={"placeholder": "Please enter an email"})
    password = StringField(label='Password: ',
                           validators=[length(min=6, max=20, message=(
                               "Please enter a password of the correct length! Min is 6 digits and Max is 20 digits"))],
                           render_kw={"placeholder": "Please enter a password"})
    remember = BooleanField(label="Remember Me: ")
    submit = SubmitField(label="Submit: ")
```
FlaskForm 的父类是 `wtforms.form`，它增加了一些方便的方法，比如不必验证表单数据时手动传入 `request.form`.
label 参数在渲染表单模板时会为除 submit 之外的字段生成一个 label 标签，其中 submit 是一个按钮，其中的 label 参数会被设置为属性 value 的值。表单标签上一些属性，如 placeholder 通过 render_kw 实现。

要在视图函数中使用，应当：
```python
from forms import RegisterForm, LoginForm

...

@app.route('/login', methods=['GET', 'POST'])  
def login():  
	form = LoginForm(meta={"csrf": False})  
	if form.validate_on_submit():  
		email = form.email.data  
		password = form.password.data  
		return redirect('/')
	return render_template("login.html", form=form)
```
`validate_on_submit()` 判断是否通过 POST 请求使表单验证成功，若通过则进入下一步提取信息，否则返回 login 模板界面。
这段代码最后一行，将 form 对象（LoginForm 的实例）传递给 `templates/login.html` 模板，则在 `templates/login.html` 中可以使用 form 对象来渲染表单元素：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LOGIN</title>
</head>
<body>
<form action="" method="POST">
    <table>
        <tbody>
        <tr>
            <td>{{ form.email.label }}</td>
            <td>{{ form.email }}</td>
        </tr>
        {% for error in form.email.errors %}
            <tr>
                <td></td>
                <td>{{ error }}</td>
            </tr>
        {% endfor %}
        <tr>
            <td>{{ form.password.label }}</td>
            <td>{{ form.password }}</td>
        </tr>
        {% for error in form.password.errors %}
            <tr>
                <td></td>
                <td>{{ error }}</td>
            </tr>
        {% endfor %}
        <tr>
            <td>{{ form.remember.label }}</td>
            <td>{{ form.remember() }}</td>
        </tr>
        <tr>
            <td></td>
            <td>{{ form.submit }}</td>
        </tr>
        </tbody>
    </table>
</form>
</body>
</html>
```
这段 HTML 代码中，通过 `form.<字段名>.label` 渲染了 email、password、remember 的 label 标签，然后通过 `form.<字段名>` 渲染对应 input 标签，在每个字段下面使用循环 `form.<字段名>.errors` 进行验证。

访问效果如下：
![[login.png]]

> [! warning] 不推荐使用 WTForms 渲染表单
> 在 Python 类中定义 HTML 标签及样式，会提高代码间的耦合度，造成本应在 HTML 模板中完成的工作，却要在 Python 文件中修改，特别是在前后端开发工程师共同开发项目的情况下，这种项目结构的缺点将十分突出。


## 3. CSRF 攻击
CSRF（Cross Site Request Forgery，跨站请求伪造）攻击原理：
![[csrf.png]]
1.  用户输入账号信息请求登录 A 网站。
2.  A网站验证用户信息，通过验证后返回给用户一个cookie
3.  在未退出网站A之前，在同一浏览器中请求了黑客构造的恶意网站B
4.  B网站收到用户请求后返回攻击性代码，构造访问A网站的语句
5.  浏览器收到攻击性代码后，在用户不知情的情况下携带 cookie 信息请求了 A 网站。此时 A 网站不知道这是由 B 发起的。那么这时黑客就可以进行一些骚操作了！

两个条件：
- 用户访问站点 A 并产生了 cookie
- 用户没有退出 A 同时访问了 B
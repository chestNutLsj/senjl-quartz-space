## 1. 安装 MySQL 及驱动

### 安装 MariaDB
ArchLinux Install MariaDB
[MariaDB - ArchWiki](https://wiki.archlinux.org/title/MariaDB)

```shell
sudo pacman -S mariadb mariadb-libs

sudo mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql

sudo systemctl start mariadb.service
sudo systemctl status mariadb.service
sudo systemctl enable mariadb.service

sudo systemctl stop mariadv.service
sudo mysqld_safe --skip-grant-tables --skip-networking
mariadb -u root
use mysql;
flush privileges;
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password_string';
EXIT;

mariadb -u root -p
```

### 安装驱动
Flask 要操作数据库，必须安装 Python 操作 MySQL 的驱动。如以下驱动包：
- MySQL-python：对 C 语言操作 MySQL 的简单封装，只支持 Python 2；
- mysqlclient：MySQL-python 的分支，支持 python3，执行效率最高；
- pymysql：纯 Python 实现，效率不如 mysqlclient 但兼容性最好；
- mysql-connector-python：MySQL 官方的纯 Python 驱动，执行效率最低；

因此建议如下安装方式：
```shell
conda install -n flask-dev mysqlclient pymysql -c conda-forge -y
```

### 安装 Flask-SQLAlchemy
Flask 中通常使用 SQLAlchemy 提供的 ORM 技术，通过操作 Python 对象实现对数据库的增删改查操作。Flask-SQLAlchemy 是对 SQLAlchemy 的封装，方便在 Flask 中进行操作，安装如下：
```shell
conda install -n flask-dev flask-sqlalchemy -c conda-forge -y
```

SQLAlchemy 文档：[SQLAlchemy - The Database Toolkit for Python](https://www.sqlalchemy.org/)

## 2. 使用 Flask-SQLAlchemy

### 连接 MySQL
在使用 Flask-SQLAlchemy 操作数据库之前，要先创建一个 SQLAlchemy 类的对象。在创建这个类时，需要传入当前的 app，然后在 app.config 中设置 SQLALCHEMY_DATABASE_URI 来配置数据库的连接，其中设置了 MySQL 主机名、端口号、用户名、密码、数据库名：
```python
from flask import Flask  
from flask_sqlalchemy import SQLAlchemy  
from sqlalchemy import text  
  
app = Flask(__name__)  
  
HOSTNAME = 'localhost'  
PORT = 3306  
USERNAME = 'root'  
PASSWORD = '156324lsj'  
DATABASE = 'db_learn'  
  
app.config[  
'SQLALCHEMY_DATABASE_URI'] = f'mariadb+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8'  
  
db = SQLAlchemy(app)  
  
with app.app_context():  
	with db.engine.connect() as conn:  
	rs = conn.execute(text("SELECT 1")) # 使用text将字符串转化为SQL表达式对象，以便execute能够正确接收并操作 
	print(rs.fetchone())
```

在本地 MariaDB 中创建好 db_learn 数据库：
```mysql
create database db_learn;

use db_learn;

# 正确创建并选择数据库后，提示头应改变成这样：
MariaDB [db_learn]> 
```

运行以上程序，应当在 PyCharm 控制台中打印——(1,)：
![[connect-mariadb.png]]
连接成功！

### ORM 模型
ORM（object relationship mapping）是一种可以用 python 面向对象的方式来操作关系型数据库的技术。ORM 技术提供了面向对象与 SQL 交互的桥梁，有以下优势：
1. 开发效率高：只需要纯 Python 语句即可操作数据库；
2. 安全性高：ORM 模型底层代码对一些常见安全问题有优化，如 SQL 注入攻击；
3. 灵活性强：Flask-SQLAlchemy 底层支持 SQLite、MySQL、Oracle 等关系型数据库，并且保持接口一致。

一个 ORM 模型与数据库中的一个表对应，ORM 模型中的每个类属性分别对应表的每个字段；ORM 模型的每个实例对象对应表中的每条记录。

使用 Flask-SQLAlchemy 创建一个 User 模型：
```python
from flask import Flask  
from flask_sqlalchemy import SQLAlchemy  
  
app = Flask(__name__)  
  
HOSTNAME = '127.0.0.1'  
PORT = 3306  
USERNAME = 'root'  
PASSWORD = '156324lsj'  
DATABASE = 'db_learn'  
  
app.config[  
'SQLALCHEMY_DATABASE_URI'] = f'mariadb+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8'  
# 禁止追踪对象的修改，以提高性能  
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  
  
db = SQLAlchemy(app)  
  
  
class User(db.Model):  
__tablename__ = "user"  
id = db.Column(db.Integer, primary_key=True, autoincrement=True)  
username = db.Column(db.String(100))  
password = db.Column(db.String(100))  
  
  
# 创建所有继承自`db.Model`的模型表  
with app.app_context():  
db.create_all()  
  
# 在此之后可以使用`User`模型进行数据库操作
```
所有 ORM 模型必须是 db.Model 的子类，通过 `__tablename__` 属性指定 User 模型映射到数据库中表的名称，然后定义了三个 `db.Column` 类型的类属性，只有这种类属性才会被映射到数据库表中成为字段。
其中 id 字段的类型定义为 `db.Interger`，`primary_key=True` 表示指定 id 作为主键，`autoincrement=True` 表示 id 为自增长。username 和 password 字段的类型定义为 `db.String` 并且长度不超过 100。最后通过 db.create_all ()把 User 模型映射为数据库中的表。

使用 PyCharm 的 database 功能可以查看：
![[create-table.png]]

其他字段类型：
| 类型 | description |
| ---- | ----------- |
| `db.Integer`     | 整型。范围与数据库一致            |

`db.Column` 常用参数：
| params | description                                              |
| ------ | -------------------------------------------------------- |
| name   | 字段在数据库表中的名称。若不设置，则使用属性名作为字段名 |
|        |                                                          |
### CRUD 操作
使用 ORM 进行 CRUD（Create Read Update Delete）操作，需要先将操作添加到会话中，通过 `db.session` 获取会话对象。会话对象存储在内存中，可以通过 `db.session.commit()` 提交到数据库；或者 `db.session.rollback()` 对会话中操作进行回滚。

#### Create
使用 ORM 创建若干数据：
```python
@app.route('/user/add')  
def user_add():  
user1 = User(username="zhang san",password="123456")  
user2 = User(username="zhao si",password="156324")  
user3 = User(username="wang wu",password="123456")  
db.session.add(user1)  
db.session.add(user2)  
db.session.add(user3)  
db.session.commit()  
return "Add Users Successfully!"
```
创建对象时必须通过关键字进行赋值，其中 id 是自增长的主键，可以不用赋值。然后将对象添加到 session 中并提交。

#### Read
ORM 中使用父类 Model 的 query 属性的方法以实现查询操作。查询可以分为提取和过滤两种方法，先看提取方法：
```python
@app.route('/user/fetch')  
def user_fetch():  
# 1. Get all data from User  
users = User.query.all()  
  
# 2. Get the user whose id(primary key) is 2  
user = User.query.get(2)  
  
# 3. Get the first data  
user = User.query.first()  
  
return "Fetch Data Successfully!"
```

提取数据常用方法有：
| Function Name            | Description |
| ------------------------ | ----------- |
| `query.all() `           |             |
| `query.first()`          |             |
| `query.one()`            |             |
| `query.one_or_more()`    |             |
| `query.get(primary_key)` |             |
| `query.exists()`         |             |
| `query.count()`                         |             |

过滤操作常用的方法有 `filter` 和 ` filter_by `，前者用来传递查询条件，后者用来传递关键字参数：
```python
@app.route('/user/filter')  
def user_filter():  
# 1. filter()  
users = User.query.filter(User.username == "zhang san").all()  
  
# 2. filter_by()  
users = User.query.filter_by(username = "zhang san").all()  
  
return "Filter Data Successfully!"
```
除此之外，还有其他过滤方法：
| Function Name             | Description      |
| ------------------------- | ---------------- |
| `query.slice(start,stop)` |                  |
| `query.limit(number)`     |                  |
| `query.offset(offset)`    |                  |
| `query.order_by()`        | 根据给定字段排序 |
| `query.group_by()`        | 根据给定字段分组 |

过滤条件除了 `==` 和 `！=` 关系运算符外，还可以调用 filter 方法实现：
1. like：模糊查询
2. in：判断是否存在于指定数据集
3. not in：
4. is null：
5. is not null：
6. and：
7. or：

#### Update
针对一条数据，可以直接修改对象属性然后 commit：
```python
user = User.query.get(1)
user.username = "张三_被修改的"
db.session.commit()
```

针对多条数据，调用 filter 方法获取 BaseQuery 对象，然后调用 update 方法：
```python
User.query.filter(User.username.like("%张三%")).update({"password":User.password+"_被修改的"},synchronize_session=False)
db.session.commit()
```
由于使用 like 方法作为过滤条件，因此要指定 `synchronize_session` 参数为 False。

#### Delete
删除一条数据，直接调用 `db.session.delete`：
```python
user = User.query.get(1)
db.session.delete(user)
db.session.commit()
```

删除多条数据，需要通过 BaseQuery 的 delete 方法：
```python
User.query.filter(User.username.contains("张三")).delete(synchronize_session=False)
db.session.commit()
```

## 3. 表关系

### 外键

### 一对多关系

### 一对一关系

### 多对多关系

### 级联操作


## 4. ORM 模型迁移
